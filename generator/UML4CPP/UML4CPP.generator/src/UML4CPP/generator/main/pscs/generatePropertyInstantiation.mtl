[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 ****************************************************************************************************************************************************************
 * 
 * module to generate property instantiation code conforming to PSCS instantiation semantics
 * 
 */]
[module generatePropertyInstantiation('http://www.eclipse.org/uml2/5.0.0/UML')]

[import UML4CPP::generator::main::components::generateType /]
[import UML4CPP::generator::main::helpers::nameHelper /]


[**
 * Template for generation of property instatiation (parts & ports) of composite structures
*/]
[template public generateAttributeInstantiation(aProperty : Property)]
//instantiate property '[aProperty.name/]'
[if (aProperty.upper = 1)]
[if (aProperty.canInstantiate())]
[if (aProperty.isComposite())]
m_[aProperty.name/] = [aProperty.type._package.getPackageName()/]::[aProperty.type._package.getPackageName().toUpperFirst()/]Factory::eInstance()->create[aProperty.type.name.toUpperFirst()/]_as_[aProperty.name/]_in_[aProperty.class.name.toUpperFirst()/](m_this[aProperty.class.name.toUpperFirst()/]Ptr);
[else]
m_[aProperty.name/] = [aProperty.type._package.getPackageName()/]::[aProperty.type._package.getPackageName().toUpperFirst()/]Factory::eInstance()->create[aProperty.type.name.toUpperFirst()/]();
[/if]
[/if]
[else]
m_[aProperty.name/].reset(new Bag<[aProperty.type.transformType()/]>());
[if (aProperty.canInstantiate() and aProperty.getUpper() = -1 and aProperty.getLower() > 0)]
for(unsigned int i = 1; i <= [aProperty.getLower()/]; i++)
{
	[if (aProperty.oclIsTypeOf(Port) and aProperty.type.oclIsTypeOf(Interface))]
	[aProperty.generatePortInstantiation()/]
	[else]
	[aProperty.generatePartInstantiation()/]
	[/if]
} 
[/if]
[/if]
[/template]


[**
 * Template for generation of instantiation of a port typed by an interface
*/]
[template private generatePortInstantiation(aProperty : Property) {aPackage : Package = aProperty.ancestors()->filter(Package)->first(); factoryName : String = aPackage.name.toUpperFirst().concat('Factory');}]
	[let interfaceOfPort : Interface = aProperty.type.oclAsType(Interface)]
	[if (aProperty.isComposite)]
	std::shared_ptr<[aProperty.type.transformType()/]> value = [aPackage.name/]::[factoryName/]::eInstance()->create[aPackage.getInterfaceRealizations(interfaceOfPort)->asOrderedSet()->first().owner.oclAsType(Class).name/]_as_[aProperty.name/]_in_[aProperty.class.name.toUpperFirst()/](m_this[aProperty.class.name.toUpperFirst()/]Ptr);
	[else]
	std::shared_ptr<[aProperty.type.transformType()/]> value = [aPackage.name/]::[factoryName/]::eInstance()->create[aPackage.getInterfaceRealizations(interfaceOfPort)->asOrderedSet()->first().owner.oclAsType(Class).name/]();
	[/if]
	[/let]
	m_[aProperty.name/]->add(value);
[/template]


[**
 * Template for generation of instantiation of a part
*/]
[template private generatePartInstantiation(aProperty : Property) {aPackage : Package = aProperty.ancestors()->filter(Package)->first(); factoryName : String = aPackage.name.toUpperFirst().concat('Factory');}]
	[if (aProperty.isComposite)]
	std::shared_ptr<[aProperty.type.transformType()/]> value = [aPackage.name/]::[factoryName/]::eInstance()->create[aProperty.type.name.toUpperFirst()/]_as_[aProperty.name/]_in_[aProperty.class.name.toUpperFirst()/](m_this[aProperty.class.name.toUpperFirst()/]Ptr);
	[else]
	std::shared_ptr<[aProperty.type.transformType()/]> value = [aPackage.name/]::[factoryName/]::eInstance()->create[aProperty.type.name.toUpperFirst()/]();
	m_[aProperty.name/]->add(value);
	[/if]
[/template]


[**
 * generate attribute member initialization for properties with InstanceValue as default value
*/]
[template public generateAttributeDefaultInstantiation(aProperty : Property){instVal : InstanceValue = aProperty.defaultValue.oclAsType(InstanceValue);}]
[let specification : InstanceSpecification = instVal.instance]
//instantiate property '[aProperty.name/]' with default value [if (not specification.name.oclIsUndefined())]'[specification.name/]'[/if]
[if (aProperty.upper <> 1)] [comment *-multiplicity /]
for(unsigned int i = 0; i < [aProperty.lower/]; i++)
{
[for (aSlot : Slot | specification.slot)]
	[aSlot.generateSlotInitialization('m_'.concat(aProperty.name).concat('->at(i)'), 0)/]
[/for]
}
[else] [comment 1-multiplicity /]
[for (aSlot : Slot | specification.slot)]
[aSlot.generateSlotInitialization('m_'.concat(aProperty.name), 0)/]
[/for]
[/if]
[/let]
[/template]

[template private generateSlotInitialization(aSlot : Slot, recursiveString : String, recursionDepth : Integer)]
[if (aSlot.definingFeature.type.isPrimitive())]
[aSlot.generatePrimitiveSlotInitialization(recursiveString)/]
[else]
[aSlot.generateNonPrimitiveSlotInitialization(recursiveString, recursionDepth)/]
[/if]
[/template]

[template private generateNonPrimitiveSlotInitialization(aSlot : Slot, recursiveString : String, recursionDepth : Integer){instValue : InstanceValue = aSlot.value->first().oclAsType(InstanceValue); instSpec : InstanceSpecification = instValue.instance; feature : Property = aSlot.definingFeature.oclAsType(Property)}]
[if (aSlot.definingFeature.getUpper()<>1)]
for(unsigned int i_[recursionDepth/] = 0; i_[recursionDepth/] < [feature.lower/]; i_[recursionDepth/]++)
{
	[for (aNestedSlot : Slot | instSpec.slot)]
	[aNestedSlot.generateSlotInitialization(recursiveString.concat('->get'.concat(feature.name.toUpperFirst()).concat('()->at(i_'.concat(recursionDepth.toString()).concat(')'))), recursionDepth+1) /]
	[/for]
}
[else]
[for (aNestedSlot : Slot | instSpec.slot)]
[aNestedSlot.generateSlotInitialization(recursiveString.concat('->get'.concat(feature.name.toUpperFirst()).concat('()')), recursionDepth) /]
[/for]
[/if]
[/template]

[**
 * generate instantiation of a slot of an instance specification
*/]
[template private generatePrimitiveSlotInitialization(aSlot : Slot, recursiveString : String)]
[if (aSlot.definingFeature.getUpper() <> 1)]
[aSlot.initPrimitiveValueFromMultipleLiteralSpecifications(recursiveString)/]
[else]
[aSlot.initPrimitiveValueFromSingleLiteralSpecification(recursiveString)/]
[/if]
[/template]

[**
 * generate call of attribute setter to set value (upper = 1) as defined by Slot
*/]
[template private initPrimitiveValueFromSingleLiteralSpecification(aSlot : Slot, recursiveString : String)]
[let slotType : String = aSlot.definingFeature.type.name]
[if (slotType = 'Boolean' or slotType = 'EBoolean')][recursiveString/]->set[aSlot.definingFeature.name.toUpperFirst()/]([aSlot.value->first().oclAsType(LiteralBoolean).value/]);
[elseif (slotType = 'UnlimitedNatural')][recursiveString/]->set[aSlot.definingFeature.name.toUpperFirst()/]([aSlot.value->first().oclAsType(LiteralUnlimitedNatural).value/]);
[elseif (slotType = 'Integer' or slotType = 'EInt')][recursiveString/]->set[aSlot.definingFeature.name.toUpperFirst()/]([aSlot.value->first().oclAsType(LiteralInteger).value/]);
[elseif (slotType = 'Real' or slotType = 'EDouble' or slotType = 'EFloat')][recursiveString/]->set[aSlot.definingFeature.name.toUpperFirst()/]([aSlot.value->first().oclAsType(LiteralReal).value/]);
[elseif (aSlot.definingFeature.type.oclIsKindOf(PrimitiveType) and slotType = 'String' or slotType = 'EString')][recursiveString/]->set[aSlot.definingFeature.name.toUpperFirst()/]("[aSlot.value->first().oclAsType(LiteralString).value/]");
[/if]
[/let]
[/template]

[**
 * generate call of attribute setter to set values (upper != 1) as defined by Slot
*/]
[template private initPrimitiveValueFromMultipleLiteralSpecifications(aSlot : Slot, recursiveString : String)]
[let slotType : String = aSlot.definingFeature.type.name]
[for (aValueSpecification : ValueSpecification | aSlot.value)]
[if (slotType = 'Boolean' or slotType = 'EBoolean')][recursiveString/]->get[aSlot.definingFeature.name.toUpperFirst()/]()->add([aValueSpecification.oclAsType(LiteralBoolean).value/]);
[elseif (slotType = 'UnlimitedNatural')][recursiveString/]->get[aSlot.definingFeature.name.toUpperFirst()/]()->add([aValueSpecification.oclAsType(LiteralUnlimitedNatural).value/]);
[elseif (slotType = 'Integer' or slotType = 'EInt')][recursiveString/]->get[aSlot.definingFeature.name.toUpperFirst()/]()->add([ aValueSpecification.oclAsType(LiteralInteger).value/]);
[elseif (slotType = 'Real' or slotType = 'EDouble' or slotType = 'EFloat')][recursiveString/]->get[aSlot.definingFeature.name.toUpperFirst()/]()->add([aValueSpecification.oclAsType(LiteralReal).value/]);
[elseif (aSlot.definingFeature.type.oclIsKindOf(PrimitiveType) and slotType = 'String' or slotType = 'EString')][recursiveString/]->get[aSlot.definingFeature.name.toUpperFirst()/]()->add("[aValueSpecification.oclAsType(LiteralString).value/]");
[/if]
[/for]
[/let]
[/template]




[query public getInterfaceRealizations(aPackage : Package, anInterface : Interface) : Set(InterfaceRealization) = aPackage.allOwnedElements()->selectByType(InterfaceRealization)->reject(not (contract.name = anInterface.name))/]

[query public canInstantiate(aProperty : Property) : Boolean = 
if (aProperty.isComposite()) then
	if(aProperty.oclIsKindOf(TypedElement)) then
		if(aProperty.type.oclIsTypeOf(Class)) then
			not aProperty.type.oclAsType(Class).isAbstract 
		else if (aProperty.type.oclIsTypeOf(Interface)) then
			aProperty.oclIsTypeOf(Port)
			else false
			endif
		endif
	else false
	endif
else false
endif
/]
