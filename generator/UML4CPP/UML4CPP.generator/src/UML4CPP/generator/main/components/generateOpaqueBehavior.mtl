[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 ****************************************************************************************************************************************************************
 * 
 * module for generation of UML Element OpaqueBehavior artefacts
 * 
 */]
[module generateOpaqueBehavior('http://www.eclipse.org/uml2/5.0.0/UML')]

[import UML4CPP::generator::main::components::generateParameter /]
[import UML4CPP::generator::main::components::generateType /]
[import UML4CPP::generator::main::helpers::generalHelper /]
[import UML4CPP::generator::main::helpers::keywords /]
[import UML4CPP::generator::main::helpers::nameHelper /]
[import UML4CPP::generator::main::components::generateStereotype /]

[**
 * Generate creation of metamodel instance for an OpaqueBehavior element
 * 
 * this includes:
 * - creation of OpaqueBehavior
 * - creation of OpaqueBehavior parameter
*/]
[template public generateOpaqueBehaviorCreation(aOpaqueBehavior : OpaqueBehavior)]
[if (aOpaqueBehavior.owner = aOpaqueBehavior._package)]
[aOpaqueBehavior.memberName()/] = factory->create[if(aOpaqueBehavior.oclIsKindOf(FunctionBehavior))]FunctionBehavior[else]OpaqueBehavior[/if]_as_ownedType_in_Package([aOpaqueBehavior._package.memberName()/]);
[else]
[aOpaqueBehavior.memberName()/] = factory->create[if(aOpaqueBehavior.oclIsKindOf(FunctionBehavior))]FunctionBehavior[else]OpaqueBehavior[/if]_as_ownedBehavior_in_BehavioredClassifier([aOpaqueBehavior.owner.oclAsType(NamedElement).memberName()/]);
[/if]
[for (aParameter : Parameter | aOpaqueBehavior.ownedParameter)]
[aParameter.generateParameterCreation()/]
[/for]
[/template]

[**
 * Generate initialization of metamodel instance for an OpaqueBehavior element
 * 
 * this includes:
 * - set OpaqueBehavior name
 * - set OpaqueBehavior context
 * - initialization of OpaqueBehavior parameter
*/]
[template public generateOpaqueBehaviorInitialization(aOpaqueBehavior : OpaqueBehavior)]
[aOpaqueBehavior.memberName()/]->setName("[aOpaqueBehavior.metamodelElementName()/]");
[if (not aOpaqueBehavior._context.oclIsUndefined())]
[aOpaqueBehavior.memberName()/]->setContext([aOpaqueBehavior._context.memberName()/]);
[/if]
[for (aParameter : Parameter | aOpaqueBehavior.ownedParameter)]
[aParameter.generateParameterInitialization()/]
[/for]
[if (not isReflectionModel(aOpaqueBehavior.getRootPackage()))]
[aOpaqueBehavior.memberName()/]->_setID([aOpaqueBehavior.getMemberName().toUpperCase()/]);
[/if]

[aOpaqueBehavior.generateStereotypeApplication()/]
[/template]

[**
 * Generate method declaration from OpaqueBehavior
 */]
[template public generateMethodDeclaration(anOpaqueBehavior : OpaqueBehavior, isImpl: Boolean)
	{
		isFunctionBehavior : Boolean = anOpaqueBehavior.oclIsKindOf(FunctionBehavior);
	}
]
virtual [anOpaqueBehavior.generateCppType()/] [anOpaqueBehavior.name/]([for (passedParameter : Parameter | anOpaqueBehavior.ownedParameter->select(aParameter : Parameter | not (aParameter.direction = ParameterDirectionKind::return))) separator (', ')][if(isFunctionBehavior)]const [/if][passedParameter.generateCppType(true)/] [passedParameter.name/][if (passedParameter.default->notEmpty())] = [passedParameter.genDefault()/][/if][/for])[if (isFunctionBehavior)] const[/if] [abstractSuffix(isImpl)/];
[/template]

[template public generateOpaqueBehaviorImplementation(anOpaqueBehavior : OpaqueBehavior)]
[anOpaqueBehavior.generateOpaqueBehaviorImplementation(true)/]
[/template]

[template public generateOpaqueBehaviorImplementation(anOpaqueBehavior : OpaqueBehavior, impl : Boolean)]
[anOpaqueBehavior.generateCppType()/] [anOpaqueBehavior._context.name.toUpperFirst()/][if(impl)]Impl[/if]::[anOpaqueBehavior.name/]([for (passedParameter : Parameter | anOpaqueBehavior.ownedParameter->select(p :Parameter | not (p.direction = ParameterDirectionKind::return))) separator (',')]
[passedParameter.generateCppType(true)/] [passedParameter.name/][/for])[if (anOpaqueBehavior.oclIsKindOf(FunctionBehavior))] const[/if] 
{
[if (anOpaqueBehavior.ownedParameter->select(p : Parameter | p.direction = ParameterDirectionKind::return)->notEmpty())]
[let returnParameter : Parameter = anOpaqueBehavior.ownedParameter->select(p : Parameter | p.direction = ParameterDirectionKind::return)->first()]
	[anOpaqueBehavior.generateCppType()/] [if(returnParameter.name.oclIsUndefined())][returnParameter.myQualifiedName()/][else][returnParameter.name/][/if][if (returnParameter.upper <> 1)](new Bag<[returnParameter.type.generateCppRawType(true)/]>())[/if][if(returnParameter.type.isPrimitive())] = [returnParameter.genDefault()/][/if];
[/let]
[/if]

	[anOpaqueBehavior.generateMethodImplementationFromOpaqueBehavior()/]

[if (anOpaqueBehavior.ownedParameter->select(p :Parameter | p.direction = ParameterDirectionKind::return)->notEmpty())]
[let returnParameter : Parameter = anOpaqueBehavior.ownedParameter->select(p : Parameter | p.direction = ParameterDirectionKind::return)->first()]
	return [if(returnParameter.name.oclIsUndefined())][returnParameter.myQualifiedName()/][else][returnParameter.name/][/if];
[/let]
[/if]
}
[/template]

[template public generateMethodImplementationFromOpaqueBehavior(anOpaqueBehavior : OpaqueBehavior)]
[if (anOpaqueBehavior.hasLanguage(keyCPP()))]
//Implemented as OpaqueBehaviour [anOpaqueBehavior.name/]
[anOpaqueBehavior.getEntryForLanguage(keyCPP())/]
[else]
//No source code found for behavior '[anOpaqueBehavior.name/]'
//Make sure that '[keyCPP()/]' is contained in the 'language' property of behavior '[anOpaqueBehavior.name/]'
throw std::runtime_error("UnsupportedOperationException: " + std::string(__PRETTY_FUNCTION__));
[/if]
[/template]

[query public hasLanguage(anOpaqueBehavior : OpaqueBehavior, language : String) : Boolean = anOpaqueBehavior.language->includes(language) /]

[query public getEntryForLanguage(anOpaqueBehavior : OpaqueBehavior, language : String) : String = 
	if(anOpaqueBehavior.hasLanguage(language)) then
		if((0 < anOpaqueBehavior.language->indexOf(language)) and (anOpaqueBehavior.language->indexOf(language) <= anOpaqueBehavior._body->size())) then
			anOpaqueBehavior._body->asOrderedSet()->at(anOpaqueBehavior.language->indexOf(language))
		else ''
		endif
	else ''
	endif
/]

[query public getEntriesForLanguageTokenized(anOpaqueBehavior : OpaqueBehavior, language : String) : Sequence(String) = 
	if(anOpaqueBehavior.hasLanguage(language)) then
		anOpaqueBehavior.getEntryForLanguage(language).tokenize(lineSeparator())
	else Sequence{}
	endif
/]

[query public collectOpaqueBehaviorIncludeStrings(anOpaqueBehavior : OpaqueBehavior) : Set(String) = Set(String)
{
	anOpaqueBehavior.ownedParameter.collectParameterIncludeStrings(),
	anOpaqueBehavior.collectOpaqueBehaviorIncludeStringsFromBody()
}->flatten()
/]

[query private collectOpaqueBehaviorIncludeStringsFromBody(anOpaqueBehavior : OpaqueBehavior) : Set(String) = 
	if (anOpaqueBehavior.hasLanguage(keyInclude()))
	then anOpaqueBehavior.getEntriesForLanguageTokenized(keyInclude())->reject(s : String | s = '')->asSet()
	else Set(String){}
	endif
/]