#include "uml/impl/umlFactoryImpl.hpp"

#include <cassert>

#include "abstractDataTypes/SubsetUnion.hpp"
#include "ecore/EClass.hpp"
#include "uml/impl/ElementImpl.hpp"
#include "uml/impl/AbstractionImpl.hpp"
#include "uml/impl/AcceptCallActionImpl.hpp"
#include "uml/impl/AcceptEventActionImpl.hpp"
#include "uml/impl/ActionImpl.hpp"
#include "uml/impl/ActionExecutionSpecificationImpl.hpp"
#include "uml/impl/ActionInputPinImpl.hpp"
#include "uml/impl/ActivityImpl.hpp"
#include "uml/impl/ActivityEdgeImpl.hpp"
#include "uml/impl/ActivityFinalNodeImpl.hpp"
#include "uml/impl/ActivityGroupImpl.hpp"
#include "uml/impl/ActivityNodeImpl.hpp"
#include "uml/impl/ActivityParameterNodeImpl.hpp"
#include "uml/impl/ActivityPartitionImpl.hpp"
#include "uml/impl/ActorImpl.hpp"
#include "uml/impl/AddStructuralFeatureValueActionImpl.hpp"
#include "uml/impl/AddVariableValueActionImpl.hpp"
#include "uml/impl/AnyReceiveEventImpl.hpp"
#include "uml/impl/ArgumentImpl.hpp"
#include "uml/impl/ArtifactImpl.hpp"
#include "uml/impl/AssociationImpl.hpp"
#include "uml/impl/AssociationClassImpl.hpp"
#include "uml/impl/BehaviorImpl.hpp"
#include "uml/impl/BehaviorExecutionSpecificationImpl.hpp"
#include "uml/impl/BehavioralFeatureImpl.hpp"
#include "uml/impl/BehavioredClassifierImpl.hpp"
#include "uml/impl/BroadcastSignalActionImpl.hpp"
#include "uml/impl/CallActionImpl.hpp"
#include "uml/impl/CallBehaviorActionImpl.hpp"
#include "uml/impl/CallEventImpl.hpp"
#include "uml/impl/CallOperationActionImpl.hpp"
#include "uml/impl/CentralBufferNodeImpl.hpp"
#include "uml/impl/ChangeEventImpl.hpp"
#include "uml/impl/ClassImpl.hpp"
#include "uml/impl/ClassifierImpl.hpp"
#include "uml/impl/ClassifierTemplateParameterImpl.hpp"
#include "uml/impl/ClauseImpl.hpp"
#include "uml/impl/ClearAssociationActionImpl.hpp"
#include "uml/impl/ClearStructuralFeatureActionImpl.hpp"
#include "uml/impl/ClearVariableActionImpl.hpp"
#include "uml/impl/CollaborationImpl.hpp"
#include "uml/impl/CollaborationUseImpl.hpp"
#include "uml/impl/CombinedFragmentImpl.hpp"
#include "uml/impl/CommentImpl.hpp"
#include "uml/impl/CommunicationPathImpl.hpp"
#include "uml/impl/ComponentImpl.hpp"
#include "uml/impl/ComponentRealizationImpl.hpp"
#include "uml/impl/ConditionalNodeImpl.hpp"
#include "uml/impl/ConnectableElementImpl.hpp"
#include "uml/impl/ConnectableElementTemplateParameterImpl.hpp"
#include "uml/impl/ConnectionPointReferenceImpl.hpp"
#include "uml/impl/ConnectorImpl.hpp"
#include "uml/impl/ConnectorEndImpl.hpp"
#include "uml/impl/ConsiderIgnoreFragmentImpl.hpp"
#include "uml/impl/ConstraintImpl.hpp"
#include "uml/impl/ContinuationImpl.hpp"
#include "uml/impl/ControlFlowImpl.hpp"
#include "uml/impl/ControlNodeImpl.hpp"
#include "uml/impl/CreateLinkActionImpl.hpp"
#include "uml/impl/CreateLinkObjectActionImpl.hpp"
#include "uml/impl/CreateObjectActionImpl.hpp"
#include "uml/impl/DataStoreNodeImpl.hpp"
#include "uml/impl/DataTypeImpl.hpp"
#include "uml/impl/DecisionNodeImpl.hpp"
#include "uml/impl/DependencyImpl.hpp"
#include "uml/impl/DeployedArtifactImpl.hpp"
#include "uml/impl/DeploymentImpl.hpp"
#include "uml/impl/DeploymentSpecificationImpl.hpp"
#include "uml/impl/DeploymentTargetImpl.hpp"
#include "uml/impl/DestroyLinkActionImpl.hpp"
#include "uml/impl/DestroyObjectActionImpl.hpp"
#include "uml/impl/DestructionOccurrenceSpecificationImpl.hpp"
#include "uml/impl/DeviceImpl.hpp"
#include "uml/impl/DirectedRelationshipImpl.hpp"
#include "uml/impl/DurationImpl.hpp"
#include "uml/impl/DurationConstraintImpl.hpp"
#include "uml/impl/DurationIntervalImpl.hpp"
#include "uml/impl/DurationObservationImpl.hpp"
#include "uml/impl/ElementImpl.hpp"
#include "uml/impl/ElementImportImpl.hpp"
#include "uml/impl/EncapsulatedClassifierImpl.hpp"
#include "uml/impl/EnumerationImpl.hpp"
#include "uml/impl/EnumerationLiteralImpl.hpp"
#include "uml/impl/EventImpl.hpp"
#include "uml/impl/ExceptionHandlerImpl.hpp"
#include "uml/impl/ExecutableNodeImpl.hpp"
#include "uml/impl/ExecutionEnvironmentImpl.hpp"
#include "uml/impl/ExecutionOccurrenceSpecificationImpl.hpp"
#include "uml/impl/ExecutionSpecificationImpl.hpp"
#include "uml/impl/ExpansionNodeImpl.hpp"
#include "uml/impl/ExpansionRegionImpl.hpp"
#include "uml/impl/ExpressionImpl.hpp"
#include "uml/impl/ExtendImpl.hpp"
#include "uml/impl/ExtensionImpl.hpp"
#include "uml/impl/ExtensionEndImpl.hpp"
#include "uml/impl/ExtensionPointImpl.hpp"
#include "uml/impl/FactoryImpl.hpp"
#include "uml/impl/FeatureImpl.hpp"
#include "uml/impl/FinalNodeImpl.hpp"
#include "uml/impl/FinalStateImpl.hpp"
#include "uml/impl/FlowFinalNodeImpl.hpp"
#include "uml/impl/ForkNodeImpl.hpp"
#include "uml/impl/FunctionBehaviorImpl.hpp"
#include "uml/impl/GateImpl.hpp"
#include "uml/impl/GeneralOrderingImpl.hpp"
#include "uml/impl/GeneralizationImpl.hpp"
#include "uml/impl/GeneralizationSetImpl.hpp"
#include "uml/impl/ImageImpl.hpp"
#include "uml/impl/IncludeImpl.hpp"
#include "uml/impl/InformationFlowImpl.hpp"
#include "uml/impl/InformationItemImpl.hpp"
#include "uml/impl/InitialNodeImpl.hpp"
#include "uml/impl/InputPinImpl.hpp"
#include "uml/impl/InstanceSpecificationImpl.hpp"
#include "uml/impl/InstanceValueImpl.hpp"
#include "uml/impl/InteractionImpl.hpp"
#include "uml/impl/InteractionConstraintImpl.hpp"
#include "uml/impl/InteractionFragmentImpl.hpp"
#include "uml/impl/InteractionOperandImpl.hpp"
#include "uml/impl/InteractionUseImpl.hpp"
#include "uml/impl/InterfaceImpl.hpp"
#include "uml/impl/InterfaceRealizationImpl.hpp"
#include "uml/impl/InterruptibleActivityRegionImpl.hpp"
#include "uml/impl/IntervalImpl.hpp"
#include "uml/impl/IntervalConstraintImpl.hpp"
#include "uml/impl/InvocationActionImpl.hpp"
#include "uml/impl/JoinNodeImpl.hpp"
#include "uml/impl/LifelineImpl.hpp"
#include "uml/impl/LinkActionImpl.hpp"
#include "uml/impl/LinkEndCreationDataImpl.hpp"
#include "uml/impl/LinkEndDataImpl.hpp"
#include "uml/impl/LinkEndDestructionDataImpl.hpp"
#include "uml/impl/LiteralBooleanImpl.hpp"
#include "uml/impl/LiteralIntegerImpl.hpp"
#include "uml/impl/LiteralNullImpl.hpp"
#include "uml/impl/LiteralRealImpl.hpp"
#include "uml/impl/LiteralSpecificationImpl.hpp"
#include "uml/impl/LiteralStringImpl.hpp"
#include "uml/impl/LiteralUnlimitedNaturalImpl.hpp"
#include "uml/impl/LoopNodeImpl.hpp"
#include "uml/impl/ManifestationImpl.hpp"
#include "uml/impl/MergeNodeImpl.hpp"
#include "uml/impl/MessageImpl.hpp"
#include "uml/impl/MessageEndImpl.hpp"
#include "uml/impl/MessageEventImpl.hpp"
#include "uml/impl/MessageOccurrenceSpecificationImpl.hpp"
#include "uml/impl/ModelImpl.hpp"
#include "uml/impl/MultiplicityElementImpl.hpp"
#include "uml/impl/NamedElementImpl.hpp"
#include "uml/impl/NamespaceImpl.hpp"
#include "uml/impl/NodeImpl.hpp"
#include "uml/impl/ObjectImpl.hpp"
#include "uml/impl/ObjectFlowImpl.hpp"
#include "uml/impl/ObjectNodeImpl.hpp"
#include "uml/impl/ObservationImpl.hpp"
#include "uml/impl/OccurrenceSpecificationImpl.hpp"
#include "uml/impl/OpaqueActionImpl.hpp"
#include "uml/impl/OpaqueBehaviorImpl.hpp"
#include "uml/impl/OpaqueExpressionImpl.hpp"
#include "uml/impl/OperationImpl.hpp"
#include "uml/impl/OperationTemplateParameterImpl.hpp"
#include "uml/impl/OutputPinImpl.hpp"
#include "uml/impl/PackageImpl.hpp"
#include "uml/impl/PackageImportImpl.hpp"
#include "uml/impl/PackageMergeImpl.hpp"
#include "uml/impl/PackageableElementImpl.hpp"
#include "uml/impl/ParameterImpl.hpp"
#include "uml/impl/ParameterSetImpl.hpp"
#include "uml/impl/ParameterableElementImpl.hpp"
#include "uml/impl/PartDecompositionImpl.hpp"
#include "uml/impl/PinImpl.hpp"
#include "uml/impl/PortImpl.hpp"
#include "uml/impl/PrimitiveTypeImpl.hpp"
#include "uml/impl/ProfileImpl.hpp"
#include "uml/impl/ProfileApplicationImpl.hpp"
#include "uml/impl/PropertyImpl.hpp"
#include "uml/impl/ProtocolConformanceImpl.hpp"
#include "uml/impl/ProtocolStateMachineImpl.hpp"
#include "uml/impl/ProtocolTransitionImpl.hpp"
#include "uml/impl/PseudostateImpl.hpp"
#include "uml/impl/QualifierValueImpl.hpp"
#include "uml/impl/RaiseExceptionActionImpl.hpp"
#include "uml/impl/ReadExtentActionImpl.hpp"
#include "uml/impl/ReadIsClassifiedObjectActionImpl.hpp"
#include "uml/impl/ReadLinkActionImpl.hpp"
#include "uml/impl/ReadLinkObjectEndActionImpl.hpp"
#include "uml/impl/ReadLinkObjectEndQualifierActionImpl.hpp"
#include "uml/impl/ReadSelfActionImpl.hpp"
#include "uml/impl/ReadStructuralFeatureActionImpl.hpp"
#include "uml/impl/ReadVariableActionImpl.hpp"
#include "uml/impl/RealizationImpl.hpp"
#include "uml/impl/ReceptionImpl.hpp"
#include "uml/impl/ReclassifyObjectActionImpl.hpp"
#include "uml/impl/RedefinableElementImpl.hpp"
#include "uml/impl/RedefinableTemplateSignatureImpl.hpp"
#include "uml/impl/ReduceActionImpl.hpp"
#include "uml/impl/RegionImpl.hpp"
#include "uml/impl/RelationshipImpl.hpp"
#include "uml/impl/RemoveStructuralFeatureValueActionImpl.hpp"
#include "uml/impl/RemoveVariableValueActionImpl.hpp"
#include "uml/impl/ReplyActionImpl.hpp"
#include "uml/impl/SendObjectActionImpl.hpp"
#include "uml/impl/SendSignalActionImpl.hpp"
#include "uml/impl/SequenceNodeImpl.hpp"
#include "uml/impl/SignalImpl.hpp"
#include "uml/impl/SignalEventImpl.hpp"
#include "uml/impl/SlotImpl.hpp"
#include "uml/impl/StartClassifierBehaviorActionImpl.hpp"
#include "uml/impl/StartObjectBehaviorActionImpl.hpp"
#include "uml/impl/StateImpl.hpp"
#include "uml/impl/StateInvariantImpl.hpp"
#include "uml/impl/StateMachineImpl.hpp"
#include "uml/impl/StereotypeImpl.hpp"
#include "uml/impl/StringExpressionImpl.hpp"
#include "uml/impl/StructuralFeatureImpl.hpp"
#include "uml/impl/StructuralFeatureActionImpl.hpp"
#include "uml/impl/StructuredActivityNodeImpl.hpp"
#include "uml/impl/StructuredClassifierImpl.hpp"
#include "uml/impl/SubstitutionImpl.hpp"
#include "uml/impl/TemplateBindingImpl.hpp"
#include "uml/impl/TemplateParameterImpl.hpp"
#include "uml/impl/TemplateParameterSubstitutionImpl.hpp"
#include "uml/impl/TemplateSignatureImpl.hpp"
#include "uml/impl/TemplateableElementImpl.hpp"
#include "uml/impl/TestIdentityActionImpl.hpp"
#include "uml/impl/TimeConstraintImpl.hpp"
#include "uml/impl/TimeEventImpl.hpp"
#include "uml/impl/TimeExpressionImpl.hpp"
#include "uml/impl/TimeIntervalImpl.hpp"
#include "uml/impl/TimeObservationImpl.hpp"
#include "uml/impl/TransitionImpl.hpp"
#include "uml/impl/TriggerImpl.hpp"
#include "uml/impl/TypeImpl.hpp"
#include "uml/impl/TypedElementImpl.hpp"
#include "uml/impl/UnmarshallActionImpl.hpp"
#include "uml/impl/UsageImpl.hpp"
#include "uml/impl/UseCaseImpl.hpp"
#include "uml/impl/ValuePinImpl.hpp"
#include "uml/impl/ValueSpecificationImpl.hpp"
#include "uml/impl/ValueSpecificationActionImpl.hpp"
#include "uml/impl/VariableImpl.hpp"
#include "uml/impl/VariableActionImpl.hpp"
#include "uml/impl/VertexImpl.hpp"
#include "uml/impl/WriteLinkActionImpl.hpp"
#include "uml/impl/WriteStructuralFeatureActionImpl.hpp"
#include "uml/impl/WriteVariableActionImpl.hpp"



using namespace uml;

//*********************************
// Constructor / Destructor
//*********************************

umlFactoryImpl::umlFactoryImpl()
{
	m_idMap.insert(std::make_pair("Abstraction", umlPackage::ABSTRACTION_CLASS));
	m_idMap.insert(std::make_pair("AcceptCallAction", umlPackage::ACCEPTCALLACTION_CLASS));
	m_idMap.insert(std::make_pair("AcceptEventAction", umlPackage::ACCEPTEVENTACTION_CLASS));
	m_idMap.insert(std::make_pair("ActionExecutionSpecification", umlPackage::ACTIONEXECUTIONSPECIFICATION_CLASS));
	m_idMap.insert(std::make_pair("ActionInputPin", umlPackage::ACTIONINPUTPIN_CLASS));
	m_idMap.insert(std::make_pair("Activity", umlPackage::ACTIVITY_CLASS));
	m_idMap.insert(std::make_pair("ActivityFinalNode", umlPackage::ACTIVITYFINALNODE_CLASS));
	m_idMap.insert(std::make_pair("ActivityParameterNode", umlPackage::ACTIVITYPARAMETERNODE_CLASS));
	m_idMap.insert(std::make_pair("ActivityPartition", umlPackage::ACTIVITYPARTITION_CLASS));
	m_idMap.insert(std::make_pair("Actor", umlPackage::ACTOR_CLASS));
	m_idMap.insert(std::make_pair("AddStructuralFeatureValueAction", umlPackage::ADDSTRUCTURALFEATUREVALUEACTION_CLASS));
	m_idMap.insert(std::make_pair("AddVariableValueAction", umlPackage::ADDVARIABLEVALUEACTION_CLASS));
	m_idMap.insert(std::make_pair("AnyReceiveEvent", umlPackage::ANYRECEIVEEVENT_CLASS));
	m_idMap.insert(std::make_pair("Argument", umlPackage::ARGUMENT_CLASS));
	m_idMap.insert(std::make_pair("Artifact", umlPackage::ARTIFACT_CLASS));
	m_idMap.insert(std::make_pair("Association", umlPackage::ASSOCIATION_CLASS));
	m_idMap.insert(std::make_pair("AssociationClass", umlPackage::ASSOCIATIONCLASS_CLASS));
	m_idMap.insert(std::make_pair("BehaviorExecutionSpecification", umlPackage::BEHAVIOREXECUTIONSPECIFICATION_CLASS));
	m_idMap.insert(std::make_pair("BroadcastSignalAction", umlPackage::BROADCASTSIGNALACTION_CLASS));
	m_idMap.insert(std::make_pair("CallBehaviorAction", umlPackage::CALLBEHAVIORACTION_CLASS));
	m_idMap.insert(std::make_pair("CallEvent", umlPackage::CALLEVENT_CLASS));
	m_idMap.insert(std::make_pair("CallOperationAction", umlPackage::CALLOPERATIONACTION_CLASS));
	m_idMap.insert(std::make_pair("CentralBufferNode", umlPackage::CENTRALBUFFERNODE_CLASS));
	m_idMap.insert(std::make_pair("ChangeEvent", umlPackage::CHANGEEVENT_CLASS));
	m_idMap.insert(std::make_pair("Class", umlPackage::CLASS_CLASS));
	m_idMap.insert(std::make_pair("ClassifierTemplateParameter", umlPackage::CLASSIFIERTEMPLATEPARAMETER_CLASS));
	m_idMap.insert(std::make_pair("Clause", umlPackage::CLAUSE_CLASS));
	m_idMap.insert(std::make_pair("ClearAssociationAction", umlPackage::CLEARASSOCIATIONACTION_CLASS));
	m_idMap.insert(std::make_pair("ClearStructuralFeatureAction", umlPackage::CLEARSTRUCTURALFEATUREACTION_CLASS));
	m_idMap.insert(std::make_pair("ClearVariableAction", umlPackage::CLEARVARIABLEACTION_CLASS));
	m_idMap.insert(std::make_pair("Collaboration", umlPackage::COLLABORATION_CLASS));
	m_idMap.insert(std::make_pair("CollaborationUse", umlPackage::COLLABORATIONUSE_CLASS));
	m_idMap.insert(std::make_pair("CombinedFragment", umlPackage::COMBINEDFRAGMENT_CLASS));
	m_idMap.insert(std::make_pair("Comment", umlPackage::COMMENT_CLASS));
	m_idMap.insert(std::make_pair("CommunicationPath", umlPackage::COMMUNICATIONPATH_CLASS));
	m_idMap.insert(std::make_pair("Component", umlPackage::COMPONENT_CLASS));
	m_idMap.insert(std::make_pair("ComponentRealization", umlPackage::COMPONENTREALIZATION_CLASS));
	m_idMap.insert(std::make_pair("ConditionalNode", umlPackage::CONDITIONALNODE_CLASS));
	m_idMap.insert(std::make_pair("ConnectableElementTemplateParameter", umlPackage::CONNECTABLEELEMENTTEMPLATEPARAMETER_CLASS));
	m_idMap.insert(std::make_pair("ConnectionPointReference", umlPackage::CONNECTIONPOINTREFERENCE_CLASS));
	m_idMap.insert(std::make_pair("Connector", umlPackage::CONNECTOR_CLASS));
	m_idMap.insert(std::make_pair("ConnectorEnd", umlPackage::CONNECTOREND_CLASS));
	m_idMap.insert(std::make_pair("ConsiderIgnoreFragment", umlPackage::CONSIDERIGNOREFRAGMENT_CLASS));
	m_idMap.insert(std::make_pair("Constraint", umlPackage::CONSTRAINT_CLASS));
	m_idMap.insert(std::make_pair("Continuation", umlPackage::CONTINUATION_CLASS));
	m_idMap.insert(std::make_pair("ControlFlow", umlPackage::CONTROLFLOW_CLASS));
	m_idMap.insert(std::make_pair("CreateLinkAction", umlPackage::CREATELINKACTION_CLASS));
	m_idMap.insert(std::make_pair("CreateLinkObjectAction", umlPackage::CREATELINKOBJECTACTION_CLASS));
	m_idMap.insert(std::make_pair("CreateObjectAction", umlPackage::CREATEOBJECTACTION_CLASS));
	m_idMap.insert(std::make_pair("DataStoreNode", umlPackage::DATASTORENODE_CLASS));
	m_idMap.insert(std::make_pair("DataType", umlPackage::DATATYPE_CLASS));
	m_idMap.insert(std::make_pair("DecisionNode", umlPackage::DECISIONNODE_CLASS));
	m_idMap.insert(std::make_pair("Dependency", umlPackage::DEPENDENCY_CLASS));
	m_idMap.insert(std::make_pair("Deployment", umlPackage::DEPLOYMENT_CLASS));
	m_idMap.insert(std::make_pair("DeploymentSpecification", umlPackage::DEPLOYMENTSPECIFICATION_CLASS));
	m_idMap.insert(std::make_pair("DestroyLinkAction", umlPackage::DESTROYLINKACTION_CLASS));
	m_idMap.insert(std::make_pair("DestroyObjectAction", umlPackage::DESTROYOBJECTACTION_CLASS));
	m_idMap.insert(std::make_pair("DestructionOccurrenceSpecification", umlPackage::DESTRUCTIONOCCURRENCESPECIFICATION_CLASS));
	m_idMap.insert(std::make_pair("Device", umlPackage::DEVICE_CLASS));
	m_idMap.insert(std::make_pair("Duration", umlPackage::DURATION_CLASS));
	m_idMap.insert(std::make_pair("DurationConstraint", umlPackage::DURATIONCONSTRAINT_CLASS));
	m_idMap.insert(std::make_pair("DurationInterval", umlPackage::DURATIONINTERVAL_CLASS));
	m_idMap.insert(std::make_pair("DurationObservation", umlPackage::DURATIONOBSERVATION_CLASS));
	m_idMap.insert(std::make_pair("ElementImport", umlPackage::ELEMENTIMPORT_CLASS));
	m_idMap.insert(std::make_pair("Enumeration", umlPackage::ENUMERATION_CLASS));
	m_idMap.insert(std::make_pair("EnumerationLiteral", umlPackage::ENUMERATIONLITERAL_CLASS));
	m_idMap.insert(std::make_pair("ExceptionHandler", umlPackage::EXCEPTIONHANDLER_CLASS));
	m_idMap.insert(std::make_pair("ExecutionEnvironment", umlPackage::EXECUTIONENVIRONMENT_CLASS));
	m_idMap.insert(std::make_pair("ExecutionOccurrenceSpecification", umlPackage::EXECUTIONOCCURRENCESPECIFICATION_CLASS));
	m_idMap.insert(std::make_pair("ExpansionNode", umlPackage::EXPANSIONNODE_CLASS));
	m_idMap.insert(std::make_pair("ExpansionRegion", umlPackage::EXPANSIONREGION_CLASS));
	m_idMap.insert(std::make_pair("Expression", umlPackage::EXPRESSION_CLASS));
	m_idMap.insert(std::make_pair("Extend", umlPackage::EXTEND_CLASS));
	m_idMap.insert(std::make_pair("Extension", umlPackage::EXTENSION_CLASS));
	m_idMap.insert(std::make_pair("ExtensionEnd", umlPackage::EXTENSIONEND_CLASS));
	m_idMap.insert(std::make_pair("ExtensionPoint", umlPackage::EXTENSIONPOINT_CLASS));
	m_idMap.insert(std::make_pair("Factory", umlPackage::FACTORY_CLASS));
	m_idMap.insert(std::make_pair("FinalState", umlPackage::FINALSTATE_CLASS));
	m_idMap.insert(std::make_pair("FlowFinalNode", umlPackage::FLOWFINALNODE_CLASS));
	m_idMap.insert(std::make_pair("ForkNode", umlPackage::FORKNODE_CLASS));
	m_idMap.insert(std::make_pair("FunctionBehavior", umlPackage::FUNCTIONBEHAVIOR_CLASS));
	m_idMap.insert(std::make_pair("Gate", umlPackage::GATE_CLASS));
	m_idMap.insert(std::make_pair("GeneralOrdering", umlPackage::GENERALORDERING_CLASS));
	m_idMap.insert(std::make_pair("Generalization", umlPackage::GENERALIZATION_CLASS));
	m_idMap.insert(std::make_pair("GeneralizationSet", umlPackage::GENERALIZATIONSET_CLASS));
	m_idMap.insert(std::make_pair("Image", umlPackage::IMAGE_CLASS));
	m_idMap.insert(std::make_pair("Include", umlPackage::INCLUDE_CLASS));
	m_idMap.insert(std::make_pair("InformationFlow", umlPackage::INFORMATIONFLOW_CLASS));
	m_idMap.insert(std::make_pair("InformationItem", umlPackage::INFORMATIONITEM_CLASS));
	m_idMap.insert(std::make_pair("InitialNode", umlPackage::INITIALNODE_CLASS));
	m_idMap.insert(std::make_pair("InputPin", umlPackage::INPUTPIN_CLASS));
	m_idMap.insert(std::make_pair("InstanceSpecification", umlPackage::INSTANCESPECIFICATION_CLASS));
	m_idMap.insert(std::make_pair("InstanceValue", umlPackage::INSTANCEVALUE_CLASS));
	m_idMap.insert(std::make_pair("Interaction", umlPackage::INTERACTION_CLASS));
	m_idMap.insert(std::make_pair("InteractionConstraint", umlPackage::INTERACTIONCONSTRAINT_CLASS));
	m_idMap.insert(std::make_pair("InteractionOperand", umlPackage::INTERACTIONOPERAND_CLASS));
	m_idMap.insert(std::make_pair("InteractionUse", umlPackage::INTERACTIONUSE_CLASS));
	m_idMap.insert(std::make_pair("Interface", umlPackage::INTERFACE_CLASS));
	m_idMap.insert(std::make_pair("InterfaceRealization", umlPackage::INTERFACEREALIZATION_CLASS));
	m_idMap.insert(std::make_pair("InterruptibleActivityRegion", umlPackage::INTERRUPTIBLEACTIVITYREGION_CLASS));
	m_idMap.insert(std::make_pair("Interval", umlPackage::INTERVAL_CLASS));
	m_idMap.insert(std::make_pair("IntervalConstraint", umlPackage::INTERVALCONSTRAINT_CLASS));
	m_idMap.insert(std::make_pair("JoinNode", umlPackage::JOINNODE_CLASS));
	m_idMap.insert(std::make_pair("Lifeline", umlPackage::LIFELINE_CLASS));
	m_idMap.insert(std::make_pair("LinkEndCreationData", umlPackage::LINKENDCREATIONDATA_CLASS));
	m_idMap.insert(std::make_pair("LinkEndData", umlPackage::LINKENDDATA_CLASS));
	m_idMap.insert(std::make_pair("LinkEndDestructionData", umlPackage::LINKENDDESTRUCTIONDATA_CLASS));
	m_idMap.insert(std::make_pair("LiteralBoolean", umlPackage::LITERALBOOLEAN_CLASS));
	m_idMap.insert(std::make_pair("LiteralInteger", umlPackage::LITERALINTEGER_CLASS));
	m_idMap.insert(std::make_pair("LiteralNull", umlPackage::LITERALNULL_CLASS));
	m_idMap.insert(std::make_pair("LiteralReal", umlPackage::LITERALREAL_CLASS));
	m_idMap.insert(std::make_pair("LiteralString", umlPackage::LITERALSTRING_CLASS));
	m_idMap.insert(std::make_pair("LiteralUnlimitedNatural", umlPackage::LITERALUNLIMITEDNATURAL_CLASS));
	m_idMap.insert(std::make_pair("LoopNode", umlPackage::LOOPNODE_CLASS));
	m_idMap.insert(std::make_pair("Manifestation", umlPackage::MANIFESTATION_CLASS));
	m_idMap.insert(std::make_pair("MergeNode", umlPackage::MERGENODE_CLASS));
	m_idMap.insert(std::make_pair("Message", umlPackage::MESSAGE_CLASS));
	m_idMap.insert(std::make_pair("MessageOccurrenceSpecification", umlPackage::MESSAGEOCCURRENCESPECIFICATION_CLASS));
	m_idMap.insert(std::make_pair("Model", umlPackage::MODEL_CLASS));
	m_idMap.insert(std::make_pair("Node", umlPackage::NODE_CLASS));
	m_idMap.insert(std::make_pair("Object", umlPackage::OBJECT_CLASS));
	m_idMap.insert(std::make_pair("ObjectFlow", umlPackage::OBJECTFLOW_CLASS));
	m_idMap.insert(std::make_pair("OccurrenceSpecification", umlPackage::OCCURRENCESPECIFICATION_CLASS));
	m_idMap.insert(std::make_pair("OpaqueAction", umlPackage::OPAQUEACTION_CLASS));
	m_idMap.insert(std::make_pair("OpaqueBehavior", umlPackage::OPAQUEBEHAVIOR_CLASS));
	m_idMap.insert(std::make_pair("OpaqueExpression", umlPackage::OPAQUEEXPRESSION_CLASS));
	m_idMap.insert(std::make_pair("Operation", umlPackage::OPERATION_CLASS));
	m_idMap.insert(std::make_pair("OperationTemplateParameter", umlPackage::OPERATIONTEMPLATEPARAMETER_CLASS));
	m_idMap.insert(std::make_pair("OutputPin", umlPackage::OUTPUTPIN_CLASS));
	m_idMap.insert(std::make_pair("Package", umlPackage::PACKAGE_CLASS));
	m_idMap.insert(std::make_pair("PackageImport", umlPackage::PACKAGEIMPORT_CLASS));
	m_idMap.insert(std::make_pair("PackageMerge", umlPackage::PACKAGEMERGE_CLASS));
	m_idMap.insert(std::make_pair("Parameter", umlPackage::PARAMETER_CLASS));
	m_idMap.insert(std::make_pair("ParameterSet", umlPackage::PARAMETERSET_CLASS));
	m_idMap.insert(std::make_pair("PartDecomposition", umlPackage::PARTDECOMPOSITION_CLASS));
	m_idMap.insert(std::make_pair("Port", umlPackage::PORT_CLASS));
	m_idMap.insert(std::make_pair("PrimitiveType", umlPackage::PRIMITIVETYPE_CLASS));
	m_idMap.insert(std::make_pair("Profile", umlPackage::PROFILE_CLASS));
	m_idMap.insert(std::make_pair("ProfileApplication", umlPackage::PROFILEAPPLICATION_CLASS));
	m_idMap.insert(std::make_pair("Property", umlPackage::PROPERTY_CLASS));
	m_idMap.insert(std::make_pair("ProtocolConformance", umlPackage::PROTOCOLCONFORMANCE_CLASS));
	m_idMap.insert(std::make_pair("ProtocolStateMachine", umlPackage::PROTOCOLSTATEMACHINE_CLASS));
	m_idMap.insert(std::make_pair("ProtocolTransition", umlPackage::PROTOCOLTRANSITION_CLASS));
	m_idMap.insert(std::make_pair("Pseudostate", umlPackage::PSEUDOSTATE_CLASS));
	m_idMap.insert(std::make_pair("QualifierValue", umlPackage::QUALIFIERVALUE_CLASS));
	m_idMap.insert(std::make_pair("RaiseExceptionAction", umlPackage::RAISEEXCEPTIONACTION_CLASS));
	m_idMap.insert(std::make_pair("ReadExtentAction", umlPackage::READEXTENTACTION_CLASS));
	m_idMap.insert(std::make_pair("ReadIsClassifiedObjectAction", umlPackage::READISCLASSIFIEDOBJECTACTION_CLASS));
	m_idMap.insert(std::make_pair("ReadLinkAction", umlPackage::READLINKACTION_CLASS));
	m_idMap.insert(std::make_pair("ReadLinkObjectEndAction", umlPackage::READLINKOBJECTENDACTION_CLASS));
	m_idMap.insert(std::make_pair("ReadLinkObjectEndQualifierAction", umlPackage::READLINKOBJECTENDQUALIFIERACTION_CLASS));
	m_idMap.insert(std::make_pair("ReadSelfAction", umlPackage::READSELFACTION_CLASS));
	m_idMap.insert(std::make_pair("ReadStructuralFeatureAction", umlPackage::READSTRUCTURALFEATUREACTION_CLASS));
	m_idMap.insert(std::make_pair("ReadVariableAction", umlPackage::READVARIABLEACTION_CLASS));
	m_idMap.insert(std::make_pair("Realization", umlPackage::REALIZATION_CLASS));
	m_idMap.insert(std::make_pair("Reception", umlPackage::RECEPTION_CLASS));
	m_idMap.insert(std::make_pair("ReclassifyObjectAction", umlPackage::RECLASSIFYOBJECTACTION_CLASS));
	m_idMap.insert(std::make_pair("RedefinableTemplateSignature", umlPackage::REDEFINABLETEMPLATESIGNATURE_CLASS));
	m_idMap.insert(std::make_pair("ReduceAction", umlPackage::REDUCEACTION_CLASS));
	m_idMap.insert(std::make_pair("Region", umlPackage::REGION_CLASS));
	m_idMap.insert(std::make_pair("RemoveStructuralFeatureValueAction", umlPackage::REMOVESTRUCTURALFEATUREVALUEACTION_CLASS));
	m_idMap.insert(std::make_pair("RemoveVariableValueAction", umlPackage::REMOVEVARIABLEVALUEACTION_CLASS));
	m_idMap.insert(std::make_pair("ReplyAction", umlPackage::REPLYACTION_CLASS));
	m_idMap.insert(std::make_pair("SendObjectAction", umlPackage::SENDOBJECTACTION_CLASS));
	m_idMap.insert(std::make_pair("SendSignalAction", umlPackage::SENDSIGNALACTION_CLASS));
	m_idMap.insert(std::make_pair("SequenceNode", umlPackage::SEQUENCENODE_CLASS));
	m_idMap.insert(std::make_pair("Signal", umlPackage::SIGNAL_CLASS));
	m_idMap.insert(std::make_pair("SignalEvent", umlPackage::SIGNALEVENT_CLASS));
	m_idMap.insert(std::make_pair("Slot", umlPackage::SLOT_CLASS));
	m_idMap.insert(std::make_pair("StartClassifierBehaviorAction", umlPackage::STARTCLASSIFIERBEHAVIORACTION_CLASS));
	m_idMap.insert(std::make_pair("StartObjectBehaviorAction", umlPackage::STARTOBJECTBEHAVIORACTION_CLASS));
	m_idMap.insert(std::make_pair("State", umlPackage::STATE_CLASS));
	m_idMap.insert(std::make_pair("StateInvariant", umlPackage::STATEINVARIANT_CLASS));
	m_idMap.insert(std::make_pair("StateMachine", umlPackage::STATEMACHINE_CLASS));
	m_idMap.insert(std::make_pair("Stereotype", umlPackage::STEREOTYPE_CLASS));
	m_idMap.insert(std::make_pair("StringExpression", umlPackage::STRINGEXPRESSION_CLASS));
	m_idMap.insert(std::make_pair("StructuredActivityNode", umlPackage::STRUCTUREDACTIVITYNODE_CLASS));
	m_idMap.insert(std::make_pair("Substitution", umlPackage::SUBSTITUTION_CLASS));
	m_idMap.insert(std::make_pair("TemplateBinding", umlPackage::TEMPLATEBINDING_CLASS));
	m_idMap.insert(std::make_pair("TemplateParameter", umlPackage::TEMPLATEPARAMETER_CLASS));
	m_idMap.insert(std::make_pair("TemplateParameterSubstitution", umlPackage::TEMPLATEPARAMETERSUBSTITUTION_CLASS));
	m_idMap.insert(std::make_pair("TemplateSignature", umlPackage::TEMPLATESIGNATURE_CLASS));
	m_idMap.insert(std::make_pair("TestIdentityAction", umlPackage::TESTIDENTITYACTION_CLASS));
	m_idMap.insert(std::make_pair("TimeConstraint", umlPackage::TIMECONSTRAINT_CLASS));
	m_idMap.insert(std::make_pair("TimeEvent", umlPackage::TIMEEVENT_CLASS));
	m_idMap.insert(std::make_pair("TimeExpression", umlPackage::TIMEEXPRESSION_CLASS));
	m_idMap.insert(std::make_pair("TimeInterval", umlPackage::TIMEINTERVAL_CLASS));
	m_idMap.insert(std::make_pair("TimeObservation", umlPackage::TIMEOBSERVATION_CLASS));
	m_idMap.insert(std::make_pair("Transition", umlPackage::TRANSITION_CLASS));
	m_idMap.insert(std::make_pair("Trigger", umlPackage::TRIGGER_CLASS));
	m_idMap.insert(std::make_pair("UnmarshallAction", umlPackage::UNMARSHALLACTION_CLASS));
	m_idMap.insert(std::make_pair("Usage", umlPackage::USAGE_CLASS));
	m_idMap.insert(std::make_pair("UseCase", umlPackage::USECASE_CLASS));
	m_idMap.insert(std::make_pair("ValuePin", umlPackage::VALUEPIN_CLASS));
	m_idMap.insert(std::make_pair("ValueSpecificationAction", umlPackage::VALUESPECIFICATIONACTION_CLASS));
	m_idMap.insert(std::make_pair("Variable", umlPackage::VARIABLE_CLASS));
}

umlFactoryImpl::~umlFactoryImpl()
{
}

umlFactory* umlFactoryImpl::create()
{
	return new umlFactoryImpl();
}

//*********************************
// creators
//*********************************

std::shared_ptr<ecore::EObject> umlFactoryImpl::create(const int metaElementID, std::shared_ptr<ecore::EObject> container /*= nullptr*/, const int referenceID/* = -1*/) const
{
	switch(metaElementID)
	{
		case umlPackage::ABSTRACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createAbstraction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Abstraction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createAbstraction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Abstraction has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createAbstraction_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Abstraction has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createAbstraction_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Abstraction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createAbstraction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Abstraction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createAbstraction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Abstraction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createAbstraction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Abstraction has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createAbstraction_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Abstraction has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createAbstraction_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Abstraction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createAbstraction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Abstraction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createAbstraction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Abstraction has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createAbstraction_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Abstraction has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createAbstraction_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Abstraction has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createAbstraction_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Abstraction has roleBinding as a containment
					case  uml::umlPackage::COLLABORATIONUSE_ATTRIBUTE_ROLEBINDING:	
					{
						std::shared_ptr<CollaborationUse> castedContainer = std::dynamic_pointer_cast<CollaborationUse> (container);;
						return this->createAbstraction_as_roleBinding_in_CollaborationUse(castedContainer,metaElementID);
					}
					//Abstraction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createAbstraction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Abstraction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createAbstraction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Abstraction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createAbstraction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Abstraction has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createAbstraction_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::ACCEPTCALLACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createAcceptCallAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//AcceptCallAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createAcceptCallAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//AcceptCallAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createAcceptCallAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//AcceptCallAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createAcceptCallAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//AcceptCallAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createAcceptCallAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//AcceptCallAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createAcceptCallAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//AcceptCallAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createAcceptCallAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//AcceptCallAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createAcceptCallAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//AcceptCallAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createAcceptCallAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//AcceptCallAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createAcceptCallAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//AcceptCallAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createAcceptCallAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//AcceptCallAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createAcceptCallAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//AcceptCallAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createAcceptCallAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//AcceptCallAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createAcceptCallAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//AcceptCallAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createAcceptCallAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//AcceptCallAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createAcceptCallAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//AcceptCallAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createAcceptCallAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//AcceptCallAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createAcceptCallAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//AcceptCallAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createAcceptCallAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::ACCEPTEVENTACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createAcceptEventAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//AcceptEventAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createAcceptEventAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//AcceptEventAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createAcceptEventAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//AcceptEventAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createAcceptEventAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//AcceptEventAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createAcceptEventAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//AcceptEventAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createAcceptEventAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//AcceptEventAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createAcceptEventAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//AcceptEventAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createAcceptEventAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//AcceptEventAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createAcceptEventAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//AcceptEventAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createAcceptEventAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//AcceptEventAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createAcceptEventAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//AcceptEventAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createAcceptEventAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//AcceptEventAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createAcceptEventAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//AcceptEventAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createAcceptEventAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//AcceptEventAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createAcceptEventAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//AcceptEventAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createAcceptEventAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//AcceptEventAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createAcceptEventAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//AcceptEventAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createAcceptEventAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//AcceptEventAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createAcceptEventAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::ACTIONEXECUTIONSPECIFICATION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createActionExecutionSpecification(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ActionExecutionSpecification has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createActionExecutionSpecification_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ActionExecutionSpecification has fragment as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::Interaction> castedContainer = std::dynamic_pointer_cast<uml::Interaction> (container);
						return this->createActionExecutionSpecification_as_fragment_in_Interaction(castedContainer,metaElementID);
					}
					//ActionExecutionSpecification has fragment as a containment
					case  uml::umlPackage::INTERACTIONOPERAND_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::InteractionOperand> castedContainer = std::dynamic_pointer_cast<uml::InteractionOperand> (container);
						return this->createActionExecutionSpecification_as_fragment_in_InteractionOperand(castedContainer,metaElementID);
					}
					//ActionExecutionSpecification has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createActionExecutionSpecification_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ActionExecutionSpecification has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createActionExecutionSpecification_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ActionExecutionSpecification has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createActionExecutionSpecification_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ActionExecutionSpecification has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createActionExecutionSpecification_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ActionExecutionSpecification has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createActionExecutionSpecification_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ActionExecutionSpecification has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createActionExecutionSpecification_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ActionExecutionSpecification has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createActionExecutionSpecification_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ActionExecutionSpecification has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createActionExecutionSpecification_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::ACTIONINPUTPIN_CLASS:
		{
			if (nullptr == container)
			{
				return this->createActionInputPin(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ActionInputPin has argument as a containment
					case  uml::umlPackage::INVOCATIONACTION_ATTRIBUTE_ARGUMENT:	
					{
						std::weak_ptr<uml::InvocationAction> castedContainer = std::dynamic_pointer_cast<uml::InvocationAction> (container);
						return this->createActionInputPin_as_argument_in_InvocationAction(castedContainer,metaElementID);
					}
					//ActionInputPin has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createActionInputPin_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ActionInputPin has collection as a containment
					case  uml::umlPackage::REDUCEACTION_ATTRIBUTE_COLLECTION:	
					{
						std::shared_ptr<ReduceAction> castedContainer = std::dynamic_pointer_cast<ReduceAction> (container);;
						return this->createActionInputPin_as_collection_in_ReduceAction(castedContainer,metaElementID);
					}
					//ActionInputPin has exception as a containment
					case  uml::umlPackage::RAISEEXCEPTIONACTION_ATTRIBUTE_EXCEPTION:	
					{
						std::shared_ptr<RaiseExceptionAction> castedContainer = std::dynamic_pointer_cast<RaiseExceptionAction> (container);;
						return this->createActionInputPin_as_exception_in_RaiseExceptionAction(castedContainer,metaElementID);
					}
					//ActionInputPin has first as a containment
					case  uml::umlPackage::TESTIDENTITYACTION_ATTRIBUTE_FIRST:	
					{
						std::shared_ptr<TestIdentityAction> castedContainer = std::dynamic_pointer_cast<TestIdentityAction> (container);;
						return this->createActionInputPin_as_first_in_TestIdentityAction(castedContainer,metaElementID);
					}
					//ActionInputPin has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createActionInputPin_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ActionInputPin has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createActionInputPin_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ActionInputPin has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createActionInputPin_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ActionInputPin has input as a containment
					case  uml::umlPackage::ACTION_ATTRIBUTE_INPUT:	
					{
						std::weak_ptr<uml::Action> castedContainer = std::dynamic_pointer_cast<uml::Action> (container);
						return this->createActionInputPin_as_input_in_Action(castedContainer,metaElementID);
					}
					//ActionInputPin has inputValue as a containment
					case  uml::umlPackage::LINKACTION_ATTRIBUTE_INPUTVALUE:	
					{
						std::shared_ptr<LinkAction> castedContainer = std::dynamic_pointer_cast<LinkAction> (container);;
						return this->createActionInputPin_as_inputValue_in_LinkAction(castedContainer,metaElementID);
					}
					//ActionInputPin has inputValue as a containment
					case  uml::umlPackage::OPAQUEACTION_ATTRIBUTE_INPUTVALUE:	
					{
						std::shared_ptr<OpaqueAction> castedContainer = std::dynamic_pointer_cast<OpaqueAction> (container);;
						return this->createActionInputPin_as_inputValue_in_OpaqueAction(castedContainer,metaElementID);
					}
					//ActionInputPin has insertAt as a containment
					case  uml::umlPackage::ADDSTRUCTURALFEATUREVALUEACTION_ATTRIBUTE_INSERTAT:	
					{
						std::weak_ptr<uml::AddStructuralFeatureValueAction> castedContainer = std::dynamic_pointer_cast<uml::AddStructuralFeatureValueAction> (container);
						return this->createActionInputPin_as_insertAt_in_AddStructuralFeatureValueAction(castedContainer,metaElementID);
					}
					//ActionInputPin has insertAt as a containment
					case  uml::umlPackage::ADDVARIABLEVALUEACTION_ATTRIBUTE_INSERTAT:	
					{
						std::shared_ptr<AddVariableValueAction> castedContainer = std::dynamic_pointer_cast<AddVariableValueAction> (container);;
						return this->createActionInputPin_as_insertAt_in_AddVariableValueAction(castedContainer,metaElementID);
					}
					//ActionInputPin has loopVariableInput as a containment
					case  uml::umlPackage::LOOPNODE_ATTRIBUTE_LOOPVARIABLEINPUT:	
					{
						std::shared_ptr<LoopNode> castedContainer = std::dynamic_pointer_cast<LoopNode> (container);;
						return this->createActionInputPin_as_loopVariableInput_in_LoopNode(castedContainer,metaElementID);
					}
					//ActionInputPin has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createActionInputPin_as_node_in_Activity(castedContainer,metaElementID);
					}
					//ActionInputPin has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createActionInputPin_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//ActionInputPin has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createActionInputPin_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//ActionInputPin has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createActionInputPin_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//ActionInputPin has object as a containment
					case  uml::umlPackage::STRUCTURALFEATUREACTION_ATTRIBUTE_OBJECT:	
					{
						std::weak_ptr<uml::StructuralFeatureAction> castedContainer = std::dynamic_pointer_cast<uml::StructuralFeatureAction> (container);
						return this->createActionInputPin_as_object_in_StructuralFeatureAction(castedContainer,metaElementID);
					}
					//ActionInputPin has object as a containment
					case  uml::umlPackage::CLEARASSOCIATIONACTION_ATTRIBUTE_OBJECT:	
					{
						std::shared_ptr<ClearAssociationAction> castedContainer = std::dynamic_pointer_cast<ClearAssociationAction> (container);;
						return this->createActionInputPin_as_object_in_ClearAssociationAction(castedContainer,metaElementID);
					}
					//ActionInputPin has object as a containment
					case  uml::umlPackage::READISCLASSIFIEDOBJECTACTION_ATTRIBUTE_OBJECT:	
					{
						std::shared_ptr<ReadIsClassifiedObjectAction> castedContainer = std::dynamic_pointer_cast<ReadIsClassifiedObjectAction> (container);;
						return this->createActionInputPin_as_object_in_ReadIsClassifiedObjectAction(castedContainer,metaElementID);
					}
					//ActionInputPin has object as a containment
					case  uml::umlPackage::READLINKOBJECTENDACTION_ATTRIBUTE_OBJECT:	
					{
						std::shared_ptr<ReadLinkObjectEndAction> castedContainer = std::dynamic_pointer_cast<ReadLinkObjectEndAction> (container);;
						return this->createActionInputPin_as_object_in_ReadLinkObjectEndAction(castedContainer,metaElementID);
					}
					//ActionInputPin has object as a containment
					case  uml::umlPackage::READLINKOBJECTENDQUALIFIERACTION_ATTRIBUTE_OBJECT:	
					{
						std::shared_ptr<ReadLinkObjectEndQualifierAction> castedContainer = std::dynamic_pointer_cast<ReadLinkObjectEndQualifierAction> (container);;
						return this->createActionInputPin_as_object_in_ReadLinkObjectEndQualifierAction(castedContainer,metaElementID);
					}
					//ActionInputPin has object as a containment
					case  uml::umlPackage::RECLASSIFYOBJECTACTION_ATTRIBUTE_OBJECT:	
					{
						std::shared_ptr<ReclassifyObjectAction> castedContainer = std::dynamic_pointer_cast<ReclassifyObjectAction> (container);;
						return this->createActionInputPin_as_object_in_ReclassifyObjectAction(castedContainer,metaElementID);
					}
					//ActionInputPin has object as a containment
					case  uml::umlPackage::STARTCLASSIFIERBEHAVIORACTION_ATTRIBUTE_OBJECT:	
					{
						std::shared_ptr<StartClassifierBehaviorAction> castedContainer = std::dynamic_pointer_cast<StartClassifierBehaviorAction> (container);;
						return this->createActionInputPin_as_object_in_StartClassifierBehaviorAction(castedContainer,metaElementID);
					}
					//ActionInputPin has object as a containment
					case  uml::umlPackage::STARTOBJECTBEHAVIORACTION_ATTRIBUTE_OBJECT:	
					{
						std::shared_ptr<StartObjectBehaviorAction> castedContainer = std::dynamic_pointer_cast<StartObjectBehaviorAction> (container);;
						return this->createActionInputPin_as_object_in_StartObjectBehaviorAction(castedContainer,metaElementID);
					}
					//ActionInputPin has object as a containment
					case  uml::umlPackage::UNMARSHALLACTION_ATTRIBUTE_OBJECT:	
					{
						std::shared_ptr<UnmarshallAction> castedContainer = std::dynamic_pointer_cast<UnmarshallAction> (container);;
						return this->createActionInputPin_as_object_in_UnmarshallAction(castedContainer,metaElementID);
					}
					//ActionInputPin has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createActionInputPin_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ActionInputPin has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createActionInputPin_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ActionInputPin has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createActionInputPin_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//ActionInputPin has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createActionInputPin_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//ActionInputPin has removeAt as a containment
					case  uml::umlPackage::REMOVESTRUCTURALFEATUREVALUEACTION_ATTRIBUTE_REMOVEAT:	
					{
						std::weak_ptr<uml::RemoveStructuralFeatureValueAction> castedContainer = std::dynamic_pointer_cast<uml::RemoveStructuralFeatureValueAction> (container);
						return this->createActionInputPin_as_removeAt_in_RemoveStructuralFeatureValueAction(castedContainer,metaElementID);
					}
					//ActionInputPin has removeAt as a containment
					case  uml::umlPackage::REMOVEVARIABLEVALUEACTION_ATTRIBUTE_REMOVEAT:	
					{
						std::shared_ptr<RemoveVariableValueAction> castedContainer = std::dynamic_pointer_cast<RemoveVariableValueAction> (container);;
						return this->createActionInputPin_as_removeAt_in_RemoveVariableValueAction(castedContainer,metaElementID);
					}
					//ActionInputPin has replyValue as a containment
					case  uml::umlPackage::REPLYACTION_ATTRIBUTE_REPLYVALUE:	
					{
						std::shared_ptr<ReplyAction> castedContainer = std::dynamic_pointer_cast<ReplyAction> (container);;
						return this->createActionInputPin_as_replyValue_in_ReplyAction(castedContainer,metaElementID);
					}
					//ActionInputPin has request as a containment
					case  uml::umlPackage::SENDOBJECTACTION_ATTRIBUTE_REQUEST:	
					{
						std::shared_ptr<SendObjectAction> castedContainer = std::dynamic_pointer_cast<SendObjectAction> (container);;
						return this->createActionInputPin_as_request_in_SendObjectAction(castedContainer,metaElementID);
					}
					//ActionInputPin has returnInformation as a containment
					case  uml::umlPackage::REPLYACTION_ATTRIBUTE_RETURNINFORMATION:	
					{
						std::shared_ptr<ReplyAction> castedContainer = std::dynamic_pointer_cast<ReplyAction> (container);;
						return this->createActionInputPin_as_returnInformation_in_ReplyAction(castedContainer,metaElementID);
					}
					//ActionInputPin has second as a containment
					case  uml::umlPackage::TESTIDENTITYACTION_ATTRIBUTE_SECOND:	
					{
						std::shared_ptr<TestIdentityAction> castedContainer = std::dynamic_pointer_cast<TestIdentityAction> (container);;
						return this->createActionInputPin_as_second_in_TestIdentityAction(castedContainer,metaElementID);
					}
					//ActionInputPin has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createActionInputPin_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ActionInputPin has structuredNodeInput as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_STRUCTUREDNODEINPUT:	
					{
						std::shared_ptr<StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<StructuredActivityNode> (container);;
						return this->createActionInputPin_as_structuredNodeInput_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//ActionInputPin has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createActionInputPin_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ActionInputPin has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createActionInputPin_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ActionInputPin has target as a containment
					case  uml::umlPackage::CALLOPERATIONACTION_ATTRIBUTE_TARGET:	
					{
						std::weak_ptr<uml::CallOperationAction> castedContainer = std::dynamic_pointer_cast<uml::CallOperationAction> (container);
						return this->createActionInputPin_as_target_in_CallOperationAction(castedContainer,metaElementID);
					}
					//ActionInputPin has target as a containment
					case  uml::umlPackage::DESTROYOBJECTACTION_ATTRIBUTE_TARGET:	
					{
						std::weak_ptr<uml::DestroyObjectAction> castedContainer = std::dynamic_pointer_cast<uml::DestroyObjectAction> (container);
						return this->createActionInputPin_as_target_in_DestroyObjectAction(castedContainer,metaElementID);
					}
					//ActionInputPin has target as a containment
					case  uml::umlPackage::SENDOBJECTACTION_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<SendObjectAction> castedContainer = std::dynamic_pointer_cast<SendObjectAction> (container);;
						return this->createActionInputPin_as_target_in_SendObjectAction(castedContainer,metaElementID);
					}
					//ActionInputPin has target as a containment
					case  uml::umlPackage::SENDSIGNALACTION_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<SendSignalAction> castedContainer = std::dynamic_pointer_cast<SendSignalAction> (container);;
						return this->createActionInputPin_as_target_in_SendSignalAction(castedContainer,metaElementID);
					}
					//ActionInputPin has value as a containment
					case  uml::umlPackage::WRITESTRUCTURALFEATUREACTION_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::WriteStructuralFeatureAction> castedContainer = std::dynamic_pointer_cast<uml::WriteStructuralFeatureAction> (container);
						return this->createActionInputPin_as_value_in_WriteStructuralFeatureAction(castedContainer,metaElementID);
					}
					//ActionInputPin has value as a containment
					case  uml::umlPackage::WRITEVARIABLEACTION_ATTRIBUTE_VALUE:	
					{
						std::shared_ptr<WriteVariableAction> castedContainer = std::dynamic_pointer_cast<WriteVariableAction> (container);;
						return this->createActionInputPin_as_value_in_WriteVariableAction(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::ACTIVITY_CLASS:
		{
			if (nullptr == container)
			{
				return this->createActivity(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Activity has activity as a containment
					//Activity has activity as a containment
					//Activity has activityScope as a containment
					//Activity has classifier as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_CLASSIFIER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createActivity_as_classifier_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//Activity has classifierBehavior as a containment
					case  uml::umlPackage::BEHAVIOREDCLASSIFIER_ATTRIBUTE_CLASSIFIERBEHAVIOR:	
					{
						std::shared_ptr<BehavioredClassifier> castedContainer = std::dynamic_pointer_cast<BehavioredClassifier> (container);;
						return this->createActivity_as_classifierBehavior_in_BehavioredClassifier(castedContainer,metaElementID);
					}
					//Activity has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createActivity_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Activity has context as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_CONTEXT:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createActivity_as_context_in_Behavior(castedContainer,metaElementID);
					}
					//Activity has contract as a containment
					case  uml::umlPackage::SUBSTITUTION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<Substitution> castedContainer = std::dynamic_pointer_cast<Substitution> (container);;
						return this->createActivity_as_contract_in_Substitution(castedContainer,metaElementID);
					}
					//Activity has doActivity as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_DOACTIVITY:	
					{
						std::shared_ptr<State> castedContainer = std::dynamic_pointer_cast<State> (container);;
						return this->createActivity_as_doActivity_in_State(castedContainer,metaElementID);
					}
					//Activity has effect as a containment
					case  uml::umlPackage::TRANSITION_ATTRIBUTE_EFFECT:	
					{
						std::shared_ptr<Transition> castedContainer = std::dynamic_pointer_cast<Transition> (container);;
						return this->createActivity_as_effect_in_Transition(castedContainer,metaElementID);
					}
					//Activity has endType as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_ENDTYPE:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createActivity_as_endType_in_Association(castedContainer,metaElementID);
					}
					//Activity has entry as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_ENTRY:	
					{
						std::shared_ptr<State> castedContainer = std::dynamic_pointer_cast<State> (container);;
						return this->createActivity_as_entry_in_State(castedContainer,metaElementID);
					}
					//Activity has exit as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_EXIT:	
					{
						std::shared_ptr<State> castedContainer = std::dynamic_pointer_cast<State> (container);;
						return this->createActivity_as_exit_in_State(castedContainer,metaElementID);
					}
					//Activity has general as a containment
					case  uml::umlPackage::GENERALIZATION_ATTRIBUTE_GENERAL:	
					{
						std::shared_ptr<Generalization> castedContainer = std::dynamic_pointer_cast<Generalization> (container);;
						return this->createActivity_as_general_in_Generalization(castedContainer,metaElementID);
					}
					//Activity has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createActivity_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Activity has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createActivity_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Activity has inActivity as a containment
					//Activity has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createActivity_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Activity has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createActivity_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Activity has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createActivity_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Activity has nestedClassifier as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createActivity_as_nestedClassifier_in_Class(castedContainer,metaElementID);
					}
					//Activity has nestedClassifier as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createActivity_as_nestedClassifier_in_Interface(castedContainer,metaElementID);
					}
					//Activity has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createActivity_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Activity has ownedBehavior as a containment
					case  uml::umlPackage::BEHAVIOREDCLASSIFIER_ATTRIBUTE_OWNEDBEHAVIOR:	
					{
						std::weak_ptr<uml::BehavioredClassifier> castedContainer = std::dynamic_pointer_cast<uml::BehavioredClassifier> (container);
						return this->createActivity_as_ownedBehavior_in_BehavioredClassifier(castedContainer,metaElementID);
					}
					//Activity has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createActivity_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Activity has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createActivity_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Activity has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createActivity_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Activity has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createActivity_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Activity has ownedType as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDTYPE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createActivity_as_ownedType_in_Package(castedContainer,metaElementID);
					}
					//Activity has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createActivity_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Activity has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createActivity_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Activity has realizingClassifier as a containment
					case  uml::umlPackage::COMPONENTREALIZATION_ATTRIBUTE_REALIZINGCLASSIFIER:	
					{
						std::shared_ptr<ComponentRealization> castedContainer = std::dynamic_pointer_cast<ComponentRealization> (container);;
						return this->createActivity_as_realizingClassifier_in_ComponentRealization(castedContainer,metaElementID);
					}
					//Activity has redefinedBehavior as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_REDEFINEDBEHAVIOR:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createActivity_as_redefinedBehavior_in_Behavior(castedContainer,metaElementID);
					}
					//Activity has redefinedClassifier as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REDEFINEDCLASSIFIER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createActivity_as_redefinedClassifier_in_Classifier(castedContainer,metaElementID);
					}
					//Activity has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createActivity_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Activity has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createActivity_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Activity has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createActivity_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Activity has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createActivity_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::ACTIVITYFINALNODE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createActivityFinalNode(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ActivityFinalNode has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createActivityFinalNode_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ActivityFinalNode has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createActivityFinalNode_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ActivityFinalNode has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createActivityFinalNode_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ActivityFinalNode has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createActivityFinalNode_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ActivityFinalNode has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createActivityFinalNode_as_node_in_Activity(castedContainer,metaElementID);
					}
					//ActivityFinalNode has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createActivityFinalNode_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//ActivityFinalNode has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createActivityFinalNode_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//ActivityFinalNode has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createActivityFinalNode_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//ActivityFinalNode has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createActivityFinalNode_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ActivityFinalNode has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createActivityFinalNode_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ActivityFinalNode has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createActivityFinalNode_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//ActivityFinalNode has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createActivityFinalNode_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//ActivityFinalNode has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createActivityFinalNode_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ActivityFinalNode has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createActivityFinalNode_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ActivityFinalNode has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createActivityFinalNode_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::ACTIVITYPARAMETERNODE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createActivityParameterNode(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ActivityParameterNode has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createActivityParameterNode_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ActivityParameterNode has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createActivityParameterNode_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ActivityParameterNode has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createActivityParameterNode_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ActivityParameterNode has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createActivityParameterNode_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ActivityParameterNode has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createActivityParameterNode_as_node_in_Activity(castedContainer,metaElementID);
					}
					//ActivityParameterNode has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createActivityParameterNode_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//ActivityParameterNode has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createActivityParameterNode_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//ActivityParameterNode has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createActivityParameterNode_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//ActivityParameterNode has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createActivityParameterNode_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ActivityParameterNode has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createActivityParameterNode_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ActivityParameterNode has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createActivityParameterNode_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//ActivityParameterNode has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createActivityParameterNode_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//ActivityParameterNode has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createActivityParameterNode_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ActivityParameterNode has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createActivityParameterNode_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ActivityParameterNode has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createActivityParameterNode_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::ACTIVITYPARTITION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createActivityPartition(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ActivityPartition has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createActivityPartition_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ActivityPartition has group as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_GROUP:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createActivityPartition_as_group_in_Activity(castedContainer,metaElementID);
					}
					//ActivityPartition has inPartition as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_INPARTITION:	
					{
						std::shared_ptr<uml::ActivityEdge> castedContainer = std::dynamic_pointer_cast<uml::ActivityEdge> (container);
						return this->createActivityPartition_as_inPartition_in_ActivityEdge(castedContainer,metaElementID);
					}
					//ActivityPartition has inPartition as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_INPARTITION:	
					{
						std::shared_ptr<uml::ActivityNode> castedContainer = std::dynamic_pointer_cast<uml::ActivityNode> (container);
						return this->createActivityPartition_as_inPartition_in_ActivityNode(castedContainer,metaElementID);
					}
					//ActivityPartition has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createActivityPartition_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ActivityPartition has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createActivityPartition_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ActivityPartition has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createActivityPartition_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ActivityPartition has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createActivityPartition_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ActivityPartition has ownedGroup as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDGROUP:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createActivityPartition_as_ownedGroup_in_Activity(castedContainer,metaElementID);
					}
					//ActivityPartition has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createActivityPartition_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ActivityPartition has partition as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_PARTITION:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createActivityPartition_as_partition_in_Activity(castedContainer,metaElementID);
					}
					//ActivityPartition has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createActivityPartition_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ActivityPartition has subgroup as a containment
					case  uml::umlPackage::ACTIVITYGROUP_ATTRIBUTE_SUBGROUP:	
					{
						std::weak_ptr<uml::ActivityGroup> castedContainer = std::dynamic_pointer_cast<uml::ActivityGroup> (container);
						return this->createActivityPartition_as_subgroup_in_ActivityGroup(castedContainer,metaElementID);
					}
					//ActivityPartition has subpartition as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_SUBPARTITION:	
					{
						std::weak_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createActivityPartition_as_subpartition_in_ActivityPartition(castedContainer,metaElementID);
					}
					//ActivityPartition has superPartition as a containment
					//ActivityPartition has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createActivityPartition_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ActivityPartition has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createActivityPartition_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::ACTOR_CLASS:
		{
			if (nullptr == container)
			{
				return this->createActor(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Actor has classifier as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_CLASSIFIER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createActor_as_classifier_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//Actor has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createActor_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Actor has context as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_CONTEXT:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createActor_as_context_in_Behavior(castedContainer,metaElementID);
					}
					//Actor has contract as a containment
					case  uml::umlPackage::SUBSTITUTION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<Substitution> castedContainer = std::dynamic_pointer_cast<Substitution> (container);;
						return this->createActor_as_contract_in_Substitution(castedContainer,metaElementID);
					}
					//Actor has endType as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_ENDTYPE:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createActor_as_endType_in_Association(castedContainer,metaElementID);
					}
					//Actor has general as a containment
					case  uml::umlPackage::GENERALIZATION_ATTRIBUTE_GENERAL:	
					{
						std::shared_ptr<Generalization> castedContainer = std::dynamic_pointer_cast<Generalization> (container);;
						return this->createActor_as_general_in_Generalization(castedContainer,metaElementID);
					}
					//Actor has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createActor_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Actor has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createActor_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Actor has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createActor_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Actor has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createActor_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Actor has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createActor_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Actor has nestedClassifier as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createActor_as_nestedClassifier_in_Class(castedContainer,metaElementID);
					}
					//Actor has nestedClassifier as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createActor_as_nestedClassifier_in_Interface(castedContainer,metaElementID);
					}
					//Actor has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createActor_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Actor has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createActor_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Actor has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createActor_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Actor has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createActor_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Actor has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createActor_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Actor has ownedType as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDTYPE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createActor_as_ownedType_in_Package(castedContainer,metaElementID);
					}
					//Actor has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createActor_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Actor has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createActor_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Actor has realizingClassifier as a containment
					case  uml::umlPackage::COMPONENTREALIZATION_ATTRIBUTE_REALIZINGCLASSIFIER:	
					{
						std::shared_ptr<ComponentRealization> castedContainer = std::dynamic_pointer_cast<ComponentRealization> (container);;
						return this->createActor_as_realizingClassifier_in_ComponentRealization(castedContainer,metaElementID);
					}
					//Actor has redefinedClassifier as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REDEFINEDCLASSIFIER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createActor_as_redefinedClassifier_in_Classifier(castedContainer,metaElementID);
					}
					//Actor has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createActor_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Actor has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createActor_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Actor has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createActor_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Actor has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createActor_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::ADDSTRUCTURALFEATUREVALUEACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createAddStructuralFeatureValueAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//AddStructuralFeatureValueAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createAddStructuralFeatureValueAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//AddStructuralFeatureValueAction has addStructuralFeatureValueAction as a containment
					//AddStructuralFeatureValueAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createAddStructuralFeatureValueAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//AddStructuralFeatureValueAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createAddStructuralFeatureValueAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//AddStructuralFeatureValueAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createAddStructuralFeatureValueAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//AddStructuralFeatureValueAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createAddStructuralFeatureValueAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//AddStructuralFeatureValueAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createAddStructuralFeatureValueAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//AddStructuralFeatureValueAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createAddStructuralFeatureValueAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//AddStructuralFeatureValueAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createAddStructuralFeatureValueAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//AddStructuralFeatureValueAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createAddStructuralFeatureValueAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//AddStructuralFeatureValueAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createAddStructuralFeatureValueAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//AddStructuralFeatureValueAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createAddStructuralFeatureValueAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//AddStructuralFeatureValueAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createAddStructuralFeatureValueAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//AddStructuralFeatureValueAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createAddStructuralFeatureValueAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//AddStructuralFeatureValueAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createAddStructuralFeatureValueAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//AddStructuralFeatureValueAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createAddStructuralFeatureValueAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//AddStructuralFeatureValueAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createAddStructuralFeatureValueAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//AddStructuralFeatureValueAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createAddStructuralFeatureValueAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//AddStructuralFeatureValueAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createAddStructuralFeatureValueAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::ADDVARIABLEVALUEACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createAddVariableValueAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//AddVariableValueAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createAddVariableValueAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//AddVariableValueAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createAddVariableValueAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//AddVariableValueAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createAddVariableValueAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//AddVariableValueAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createAddVariableValueAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//AddVariableValueAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createAddVariableValueAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//AddVariableValueAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createAddVariableValueAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//AddVariableValueAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createAddVariableValueAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//AddVariableValueAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createAddVariableValueAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//AddVariableValueAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createAddVariableValueAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//AddVariableValueAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createAddVariableValueAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//AddVariableValueAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createAddVariableValueAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//AddVariableValueAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createAddVariableValueAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//AddVariableValueAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createAddVariableValueAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//AddVariableValueAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createAddVariableValueAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//AddVariableValueAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createAddVariableValueAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//AddVariableValueAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createAddVariableValueAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//AddVariableValueAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createAddVariableValueAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//AddVariableValueAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createAddVariableValueAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::ANYRECEIVEEVENT_CLASS:
		{
			if (nullptr == container)
			{
				return this->createAnyReceiveEvent(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//AnyReceiveEvent has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createAnyReceiveEvent_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//AnyReceiveEvent has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createAnyReceiveEvent_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//AnyReceiveEvent has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createAnyReceiveEvent_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//AnyReceiveEvent has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createAnyReceiveEvent_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//AnyReceiveEvent has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createAnyReceiveEvent_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//AnyReceiveEvent has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createAnyReceiveEvent_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//AnyReceiveEvent has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createAnyReceiveEvent_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//AnyReceiveEvent has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createAnyReceiveEvent_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//AnyReceiveEvent has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createAnyReceiveEvent_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//AnyReceiveEvent has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createAnyReceiveEvent_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//AnyReceiveEvent has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createAnyReceiveEvent_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//AnyReceiveEvent has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createAnyReceiveEvent_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//AnyReceiveEvent has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createAnyReceiveEvent_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//AnyReceiveEvent has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createAnyReceiveEvent_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//AnyReceiveEvent has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createAnyReceiveEvent_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//AnyReceiveEvent has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createAnyReceiveEvent_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//AnyReceiveEvent has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createAnyReceiveEvent_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::ARGUMENT_CLASS:
		{
				return this->createArgument(metaElementID);
			
			break;
		}
		case umlPackage::ARTIFACT_CLASS:
		{
			if (nullptr == container)
			{
				return this->createArtifact(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Artifact has classifier as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_CLASSIFIER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createArtifact_as_classifier_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//Artifact has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createArtifact_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Artifact has contract as a containment
					case  uml::umlPackage::SUBSTITUTION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<Substitution> castedContainer = std::dynamic_pointer_cast<Substitution> (container);;
						return this->createArtifact_as_contract_in_Substitution(castedContainer,metaElementID);
					}
					//Artifact has deployedArtifact as a containment
					case  uml::umlPackage::DEPLOYMENT_ATTRIBUTE_DEPLOYEDARTIFACT:	
					{
						std::shared_ptr<Deployment> castedContainer = std::dynamic_pointer_cast<Deployment> (container);;
						return this->createArtifact_as_deployedArtifact_in_Deployment(castedContainer,metaElementID);
					}
					//Artifact has endType as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_ENDTYPE:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createArtifact_as_endType_in_Association(castedContainer,metaElementID);
					}
					//Artifact has general as a containment
					case  uml::umlPackage::GENERALIZATION_ATTRIBUTE_GENERAL:	
					{
						std::shared_ptr<Generalization> castedContainer = std::dynamic_pointer_cast<Generalization> (container);;
						return this->createArtifact_as_general_in_Generalization(castedContainer,metaElementID);
					}
					//Artifact has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createArtifact_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Artifact has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createArtifact_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Artifact has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createArtifact_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Artifact has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createArtifact_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Artifact has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createArtifact_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Artifact has nestedArtifact as a containment
					case  uml::umlPackage::ARTIFACT_ATTRIBUTE_NESTEDARTIFACT:	
					{
						std::shared_ptr<Artifact> castedContainer = std::dynamic_pointer_cast<Artifact> (container);;
						return this->createArtifact_as_nestedArtifact_in_Artifact(castedContainer,metaElementID);
					}
					//Artifact has nestedClassifier as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createArtifact_as_nestedClassifier_in_Class(castedContainer,metaElementID);
					}
					//Artifact has nestedClassifier as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createArtifact_as_nestedClassifier_in_Interface(castedContainer,metaElementID);
					}
					//Artifact has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createArtifact_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Artifact has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createArtifact_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Artifact has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createArtifact_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Artifact has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createArtifact_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Artifact has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createArtifact_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Artifact has ownedType as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDTYPE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createArtifact_as_ownedType_in_Package(castedContainer,metaElementID);
					}
					//Artifact has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createArtifact_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Artifact has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createArtifact_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Artifact has realizingClassifier as a containment
					case  uml::umlPackage::COMPONENTREALIZATION_ATTRIBUTE_REALIZINGCLASSIFIER:	
					{
						std::shared_ptr<ComponentRealization> castedContainer = std::dynamic_pointer_cast<ComponentRealization> (container);;
						return this->createArtifact_as_realizingClassifier_in_ComponentRealization(castedContainer,metaElementID);
					}
					//Artifact has redefinedClassifier as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REDEFINEDCLASSIFIER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createArtifact_as_redefinedClassifier_in_Classifier(castedContainer,metaElementID);
					}
					//Artifact has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createArtifact_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Artifact has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createArtifact_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Artifact has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createArtifact_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Artifact has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createArtifact_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::ASSOCIATION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createAssociation(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Association has classifier as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_CLASSIFIER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createAssociation_as_classifier_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//Association has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createAssociation_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Association has contract as a containment
					case  uml::umlPackage::SUBSTITUTION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<Substitution> castedContainer = std::dynamic_pointer_cast<Substitution> (container);;
						return this->createAssociation_as_contract_in_Substitution(castedContainer,metaElementID);
					}
					//Association has endType as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_ENDTYPE:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createAssociation_as_endType_in_Association(castedContainer,metaElementID);
					}
					//Association has general as a containment
					case  uml::umlPackage::GENERALIZATION_ATTRIBUTE_GENERAL:	
					{
						std::shared_ptr<Generalization> castedContainer = std::dynamic_pointer_cast<Generalization> (container);;
						return this->createAssociation_as_general_in_Generalization(castedContainer,metaElementID);
					}
					//Association has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createAssociation_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Association has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createAssociation_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Association has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createAssociation_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Association has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createAssociation_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Association has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createAssociation_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Association has nestedClassifier as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createAssociation_as_nestedClassifier_in_Class(castedContainer,metaElementID);
					}
					//Association has nestedClassifier as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createAssociation_as_nestedClassifier_in_Interface(castedContainer,metaElementID);
					}
					//Association has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createAssociation_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Association has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createAssociation_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Association has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createAssociation_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Association has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createAssociation_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Association has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createAssociation_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Association has ownedType as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDTYPE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createAssociation_as_ownedType_in_Package(castedContainer,metaElementID);
					}
					//Association has owningAssociation as a containment
					//Association has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createAssociation_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Association has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createAssociation_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Association has realizingClassifier as a containment
					case  uml::umlPackage::COMPONENTREALIZATION_ATTRIBUTE_REALIZINGCLASSIFIER:	
					{
						std::shared_ptr<ComponentRealization> castedContainer = std::dynamic_pointer_cast<ComponentRealization> (container);;
						return this->createAssociation_as_realizingClassifier_in_ComponentRealization(castedContainer,metaElementID);
					}
					//Association has redefinedClassifier as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REDEFINEDCLASSIFIER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createAssociation_as_redefinedClassifier_in_Classifier(castedContainer,metaElementID);
					}
					//Association has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createAssociation_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Association has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createAssociation_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Association has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createAssociation_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Association has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createAssociation_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::ASSOCIATIONCLASS_CLASS:
		{
			if (nullptr == container)
			{
				return this->createAssociationClass(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//AssociationClass has classifier as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_CLASSIFIER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createAssociationClass_as_classifier_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//AssociationClass has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createAssociationClass_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//AssociationClass has context as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_CONTEXT:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createAssociationClass_as_context_in_Behavior(castedContainer,metaElementID);
					}
					//AssociationClass has contract as a containment
					case  uml::umlPackage::SUBSTITUTION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<Substitution> castedContainer = std::dynamic_pointer_cast<Substitution> (container);;
						return this->createAssociationClass_as_contract_in_Substitution(castedContainer,metaElementID);
					}
					//AssociationClass has endType as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_ENDTYPE:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createAssociationClass_as_endType_in_Association(castedContainer,metaElementID);
					}
					//AssociationClass has general as a containment
					case  uml::umlPackage::GENERALIZATION_ATTRIBUTE_GENERAL:	
					{
						std::shared_ptr<Generalization> castedContainer = std::dynamic_pointer_cast<Generalization> (container);;
						return this->createAssociationClass_as_general_in_Generalization(castedContainer,metaElementID);
					}
					//AssociationClass has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createAssociationClass_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//AssociationClass has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createAssociationClass_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//AssociationClass has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createAssociationClass_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//AssociationClass has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createAssociationClass_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//AssociationClass has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createAssociationClass_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//AssociationClass has nestedClassifier as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createAssociationClass_as_nestedClassifier_in_Class(castedContainer,metaElementID);
					}
					//AssociationClass has nestedClassifier as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createAssociationClass_as_nestedClassifier_in_Interface(castedContainer,metaElementID);
					}
					//AssociationClass has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createAssociationClass_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//AssociationClass has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createAssociationClass_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//AssociationClass has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createAssociationClass_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//AssociationClass has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createAssociationClass_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//AssociationClass has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createAssociationClass_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//AssociationClass has ownedType as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDTYPE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createAssociationClass_as_ownedType_in_Package(castedContainer,metaElementID);
					}
					//AssociationClass has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createAssociationClass_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//AssociationClass has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createAssociationClass_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//AssociationClass has realizingClassifier as a containment
					case  uml::umlPackage::COMPONENTREALIZATION_ATTRIBUTE_REALIZINGCLASSIFIER:	
					{
						std::shared_ptr<ComponentRealization> castedContainer = std::dynamic_pointer_cast<ComponentRealization> (container);;
						return this->createAssociationClass_as_realizingClassifier_in_ComponentRealization(castedContainer,metaElementID);
					}
					//AssociationClass has redefinedClassifier as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REDEFINEDCLASSIFIER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createAssociationClass_as_redefinedClassifier_in_Classifier(castedContainer,metaElementID);
					}
					//AssociationClass has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createAssociationClass_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//AssociationClass has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createAssociationClass_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//AssociationClass has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createAssociationClass_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//AssociationClass has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createAssociationClass_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::BEHAVIOREXECUTIONSPECIFICATION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createBehaviorExecutionSpecification(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//BehaviorExecutionSpecification has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createBehaviorExecutionSpecification_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//BehaviorExecutionSpecification has fragment as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::Interaction> castedContainer = std::dynamic_pointer_cast<uml::Interaction> (container);
						return this->createBehaviorExecutionSpecification_as_fragment_in_Interaction(castedContainer,metaElementID);
					}
					//BehaviorExecutionSpecification has fragment as a containment
					case  uml::umlPackage::INTERACTIONOPERAND_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::InteractionOperand> castedContainer = std::dynamic_pointer_cast<uml::InteractionOperand> (container);
						return this->createBehaviorExecutionSpecification_as_fragment_in_InteractionOperand(castedContainer,metaElementID);
					}
					//BehaviorExecutionSpecification has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createBehaviorExecutionSpecification_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//BehaviorExecutionSpecification has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createBehaviorExecutionSpecification_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//BehaviorExecutionSpecification has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createBehaviorExecutionSpecification_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//BehaviorExecutionSpecification has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createBehaviorExecutionSpecification_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//BehaviorExecutionSpecification has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createBehaviorExecutionSpecification_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//BehaviorExecutionSpecification has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createBehaviorExecutionSpecification_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//BehaviorExecutionSpecification has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createBehaviorExecutionSpecification_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//BehaviorExecutionSpecification has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createBehaviorExecutionSpecification_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::BROADCASTSIGNALACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createBroadcastSignalAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//BroadcastSignalAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createBroadcastSignalAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//BroadcastSignalAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createBroadcastSignalAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//BroadcastSignalAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createBroadcastSignalAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//BroadcastSignalAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createBroadcastSignalAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//BroadcastSignalAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createBroadcastSignalAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//BroadcastSignalAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createBroadcastSignalAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//BroadcastSignalAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createBroadcastSignalAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//BroadcastSignalAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createBroadcastSignalAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//BroadcastSignalAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createBroadcastSignalAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//BroadcastSignalAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createBroadcastSignalAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//BroadcastSignalAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createBroadcastSignalAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//BroadcastSignalAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createBroadcastSignalAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//BroadcastSignalAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createBroadcastSignalAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//BroadcastSignalAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createBroadcastSignalAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//BroadcastSignalAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createBroadcastSignalAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//BroadcastSignalAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createBroadcastSignalAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//BroadcastSignalAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createBroadcastSignalAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//BroadcastSignalAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createBroadcastSignalAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::CALLBEHAVIORACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createCallBehaviorAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//CallBehaviorAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createCallBehaviorAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//CallBehaviorAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createCallBehaviorAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//CallBehaviorAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createCallBehaviorAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//CallBehaviorAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createCallBehaviorAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//CallBehaviorAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createCallBehaviorAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//CallBehaviorAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createCallBehaviorAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//CallBehaviorAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createCallBehaviorAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//CallBehaviorAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createCallBehaviorAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//CallBehaviorAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createCallBehaviorAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//CallBehaviorAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createCallBehaviorAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//CallBehaviorAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createCallBehaviorAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//CallBehaviorAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createCallBehaviorAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//CallBehaviorAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createCallBehaviorAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//CallBehaviorAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createCallBehaviorAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//CallBehaviorAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createCallBehaviorAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//CallBehaviorAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createCallBehaviorAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//CallBehaviorAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createCallBehaviorAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//CallBehaviorAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createCallBehaviorAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::CALLEVENT_CLASS:
		{
			if (nullptr == container)
			{
				return this->createCallEvent(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//CallEvent has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createCallEvent_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//CallEvent has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createCallEvent_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//CallEvent has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createCallEvent_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//CallEvent has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createCallEvent_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//CallEvent has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createCallEvent_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//CallEvent has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createCallEvent_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//CallEvent has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createCallEvent_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//CallEvent has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createCallEvent_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//CallEvent has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createCallEvent_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//CallEvent has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createCallEvent_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//CallEvent has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createCallEvent_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//CallEvent has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createCallEvent_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//CallEvent has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createCallEvent_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//CallEvent has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createCallEvent_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//CallEvent has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createCallEvent_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//CallEvent has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createCallEvent_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//CallEvent has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createCallEvent_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::CALLOPERATIONACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createCallOperationAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//CallOperationAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createCallOperationAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//CallOperationAction has callOperationAction as a containment
					//CallOperationAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createCallOperationAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//CallOperationAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createCallOperationAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//CallOperationAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createCallOperationAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//CallOperationAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createCallOperationAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//CallOperationAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createCallOperationAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//CallOperationAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createCallOperationAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//CallOperationAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createCallOperationAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//CallOperationAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createCallOperationAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//CallOperationAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createCallOperationAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//CallOperationAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createCallOperationAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//CallOperationAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createCallOperationAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//CallOperationAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createCallOperationAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//CallOperationAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createCallOperationAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//CallOperationAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createCallOperationAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//CallOperationAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createCallOperationAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//CallOperationAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createCallOperationAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//CallOperationAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createCallOperationAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::CENTRALBUFFERNODE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createCentralBufferNode(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//CentralBufferNode has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createCentralBufferNode_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//CentralBufferNode has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createCentralBufferNode_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//CentralBufferNode has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createCentralBufferNode_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//CentralBufferNode has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createCentralBufferNode_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//CentralBufferNode has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createCentralBufferNode_as_node_in_Activity(castedContainer,metaElementID);
					}
					//CentralBufferNode has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createCentralBufferNode_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//CentralBufferNode has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createCentralBufferNode_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//CentralBufferNode has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createCentralBufferNode_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//CentralBufferNode has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createCentralBufferNode_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//CentralBufferNode has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createCentralBufferNode_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//CentralBufferNode has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createCentralBufferNode_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//CentralBufferNode has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createCentralBufferNode_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//CentralBufferNode has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createCentralBufferNode_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//CentralBufferNode has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createCentralBufferNode_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//CentralBufferNode has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createCentralBufferNode_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::CHANGEEVENT_CLASS:
		{
			if (nullptr == container)
			{
				return this->createChangeEvent(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ChangeEvent has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createChangeEvent_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ChangeEvent has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createChangeEvent_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//ChangeEvent has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createChangeEvent_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ChangeEvent has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createChangeEvent_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ChangeEvent has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createChangeEvent_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ChangeEvent has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createChangeEvent_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ChangeEvent has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createChangeEvent_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//ChangeEvent has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createChangeEvent_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//ChangeEvent has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createChangeEvent_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ChangeEvent has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createChangeEvent_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ChangeEvent has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createChangeEvent_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//ChangeEvent has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createChangeEvent_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//ChangeEvent has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createChangeEvent_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//ChangeEvent has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createChangeEvent_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ChangeEvent has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createChangeEvent_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ChangeEvent has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createChangeEvent_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ChangeEvent has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createChangeEvent_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::CLASS_CLASS:
		{
			if (nullptr == container)
			{
				return this->createClass(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Class has class as a containment
					//Class has class as a containment
					//Class has classifier as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_CLASSIFIER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createClass_as_classifier_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//Class has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createClass_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Class has context as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_CONTEXT:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createClass_as_context_in_Behavior(castedContainer,metaElementID);
					}
					//Class has contract as a containment
					case  uml::umlPackage::SUBSTITUTION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<Substitution> castedContainer = std::dynamic_pointer_cast<Substitution> (container);;
						return this->createClass_as_contract_in_Substitution(castedContainer,metaElementID);
					}
					//Class has endType as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_ENDTYPE:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createClass_as_endType_in_Association(castedContainer,metaElementID);
					}
					//Class has general as a containment
					case  uml::umlPackage::GENERALIZATION_ATTRIBUTE_GENERAL:	
					{
						std::shared_ptr<Generalization> castedContainer = std::dynamic_pointer_cast<Generalization> (container);;
						return this->createClass_as_general_in_Generalization(castedContainer,metaElementID);
					}
					//Class has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createClass_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Class has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createClass_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Class has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createClass_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Class has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createClass_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Class has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createClass_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Class has nestedClassifier as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createClass_as_nestedClassifier_in_Class(castedContainer,metaElementID);
					}
					//Class has nestedClassifier as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createClass_as_nestedClassifier_in_Interface(castedContainer,metaElementID);
					}
					//Class has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createClass_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Class has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createClass_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Class has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createClass_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Class has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createClass_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Class has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createClass_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Class has ownedType as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDTYPE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createClass_as_ownedType_in_Package(castedContainer,metaElementID);
					}
					//Class has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createClass_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Class has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createClass_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Class has realizingClassifier as a containment
					case  uml::umlPackage::COMPONENTREALIZATION_ATTRIBUTE_REALIZINGCLASSIFIER:	
					{
						std::shared_ptr<ComponentRealization> castedContainer = std::dynamic_pointer_cast<ComponentRealization> (container);;
						return this->createClass_as_realizingClassifier_in_ComponentRealization(castedContainer,metaElementID);
					}
					//Class has redefinedClassifier as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REDEFINEDCLASSIFIER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createClass_as_redefinedClassifier_in_Classifier(castedContainer,metaElementID);
					}
					//Class has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createClass_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Class has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createClass_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Class has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createClass_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Class has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createClass_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::CLASSIFIERTEMPLATEPARAMETER_CLASS:
		{
			if (nullptr == container)
			{
				return this->createClassifierTemplateParameter(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ClassifierTemplateParameter has inheritedParameter as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_INHERITEDPARAMETER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createClassifierTemplateParameter_as_inheritedParameter_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//ClassifierTemplateParameter has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createClassifierTemplateParameter_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ClassifierTemplateParameter has ownedParameter as a containment
					case  uml::umlPackage::TEMPLATESIGNATURE_ATTRIBUTE_OWNEDPARAMETER:	
					{
						std::weak_ptr<uml::TemplateSignature> castedContainer = std::dynamic_pointer_cast<uml::TemplateSignature> (container);
						return this->createClassifierTemplateParameter_as_ownedParameter_in_TemplateSignature(castedContainer,metaElementID);
					}
					//ClassifierTemplateParameter has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createClassifierTemplateParameter_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ClassifierTemplateParameter has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createClassifierTemplateParameter_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::CLAUSE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createClause(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Clause has clause as a containment
					case  uml::umlPackage::CONDITIONALNODE_ATTRIBUTE_CLAUSE:	
					{
						std::shared_ptr<ConditionalNode> castedContainer = std::dynamic_pointer_cast<ConditionalNode> (container);;
						return this->createClause_as_clause_in_ConditionalNode(castedContainer,metaElementID);
					}
					//Clause has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createClause_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Clause has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createClause_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Clause has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createClause_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::CLEARASSOCIATIONACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createClearAssociationAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ClearAssociationAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createClearAssociationAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//ClearAssociationAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createClearAssociationAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ClearAssociationAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createClearAssociationAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//ClearAssociationAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createClearAssociationAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//ClearAssociationAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createClearAssociationAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ClearAssociationAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createClearAssociationAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ClearAssociationAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createClearAssociationAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ClearAssociationAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createClearAssociationAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//ClearAssociationAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createClearAssociationAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//ClearAssociationAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createClearAssociationAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//ClearAssociationAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createClearAssociationAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//ClearAssociationAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createClearAssociationAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ClearAssociationAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createClearAssociationAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ClearAssociationAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createClearAssociationAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//ClearAssociationAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createClearAssociationAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//ClearAssociationAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createClearAssociationAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ClearAssociationAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createClearAssociationAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ClearAssociationAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createClearAssociationAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::CLEARSTRUCTURALFEATUREACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createClearStructuralFeatureAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ClearStructuralFeatureAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createClearStructuralFeatureAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//ClearStructuralFeatureAction has clearStructuralFeatureAction as a containment
					//ClearStructuralFeatureAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createClearStructuralFeatureAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ClearStructuralFeatureAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createClearStructuralFeatureAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//ClearStructuralFeatureAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createClearStructuralFeatureAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//ClearStructuralFeatureAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createClearStructuralFeatureAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ClearStructuralFeatureAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createClearStructuralFeatureAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ClearStructuralFeatureAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createClearStructuralFeatureAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ClearStructuralFeatureAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createClearStructuralFeatureAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//ClearStructuralFeatureAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createClearStructuralFeatureAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//ClearStructuralFeatureAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createClearStructuralFeatureAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//ClearStructuralFeatureAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createClearStructuralFeatureAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//ClearStructuralFeatureAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createClearStructuralFeatureAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ClearStructuralFeatureAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createClearStructuralFeatureAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ClearStructuralFeatureAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createClearStructuralFeatureAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//ClearStructuralFeatureAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createClearStructuralFeatureAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//ClearStructuralFeatureAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createClearStructuralFeatureAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ClearStructuralFeatureAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createClearStructuralFeatureAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ClearStructuralFeatureAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createClearStructuralFeatureAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::CLEARVARIABLEACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createClearVariableAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ClearVariableAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createClearVariableAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//ClearVariableAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createClearVariableAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ClearVariableAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createClearVariableAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//ClearVariableAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createClearVariableAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//ClearVariableAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createClearVariableAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ClearVariableAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createClearVariableAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ClearVariableAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createClearVariableAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ClearVariableAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createClearVariableAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//ClearVariableAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createClearVariableAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//ClearVariableAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createClearVariableAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//ClearVariableAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createClearVariableAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//ClearVariableAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createClearVariableAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ClearVariableAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createClearVariableAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ClearVariableAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createClearVariableAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//ClearVariableAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createClearVariableAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//ClearVariableAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createClearVariableAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ClearVariableAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createClearVariableAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ClearVariableAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createClearVariableAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::COLLABORATION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createCollaboration(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Collaboration has classifier as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_CLASSIFIER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createCollaboration_as_classifier_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//Collaboration has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createCollaboration_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Collaboration has context as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_CONTEXT:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createCollaboration_as_context_in_Behavior(castedContainer,metaElementID);
					}
					//Collaboration has contract as a containment
					case  uml::umlPackage::SUBSTITUTION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<Substitution> castedContainer = std::dynamic_pointer_cast<Substitution> (container);;
						return this->createCollaboration_as_contract_in_Substitution(castedContainer,metaElementID);
					}
					//Collaboration has endType as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_ENDTYPE:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createCollaboration_as_endType_in_Association(castedContainer,metaElementID);
					}
					//Collaboration has general as a containment
					case  uml::umlPackage::GENERALIZATION_ATTRIBUTE_GENERAL:	
					{
						std::shared_ptr<Generalization> castedContainer = std::dynamic_pointer_cast<Generalization> (container);;
						return this->createCollaboration_as_general_in_Generalization(castedContainer,metaElementID);
					}
					//Collaboration has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createCollaboration_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Collaboration has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createCollaboration_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Collaboration has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createCollaboration_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Collaboration has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createCollaboration_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Collaboration has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createCollaboration_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Collaboration has nestedClassifier as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createCollaboration_as_nestedClassifier_in_Class(castedContainer,metaElementID);
					}
					//Collaboration has nestedClassifier as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createCollaboration_as_nestedClassifier_in_Interface(castedContainer,metaElementID);
					}
					//Collaboration has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createCollaboration_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Collaboration has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createCollaboration_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Collaboration has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createCollaboration_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Collaboration has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createCollaboration_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Collaboration has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createCollaboration_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Collaboration has ownedType as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDTYPE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createCollaboration_as_ownedType_in_Package(castedContainer,metaElementID);
					}
					//Collaboration has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createCollaboration_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Collaboration has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createCollaboration_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Collaboration has realizingClassifier as a containment
					case  uml::umlPackage::COMPONENTREALIZATION_ATTRIBUTE_REALIZINGCLASSIFIER:	
					{
						std::shared_ptr<ComponentRealization> castedContainer = std::dynamic_pointer_cast<ComponentRealization> (container);;
						return this->createCollaboration_as_realizingClassifier_in_ComponentRealization(castedContainer,metaElementID);
					}
					//Collaboration has redefinedClassifier as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REDEFINEDCLASSIFIER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createCollaboration_as_redefinedClassifier_in_Classifier(castedContainer,metaElementID);
					}
					//Collaboration has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createCollaboration_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Collaboration has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createCollaboration_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Collaboration has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createCollaboration_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Collaboration has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createCollaboration_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::COLLABORATIONUSE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createCollaborationUse(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//CollaborationUse has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createCollaborationUse_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//CollaborationUse has collaborationUse as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_COLLABORATIONUSE:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createCollaborationUse_as_collaborationUse_in_Classifier(castedContainer,metaElementID);
					}
					//CollaborationUse has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createCollaborationUse_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//CollaborationUse has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createCollaborationUse_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//CollaborationUse has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createCollaborationUse_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//CollaborationUse has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createCollaborationUse_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//CollaborationUse has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createCollaborationUse_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//CollaborationUse has representation as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REPRESENTATION:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createCollaborationUse_as_representation_in_Classifier(castedContainer,metaElementID);
					}
					//CollaborationUse has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createCollaborationUse_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//CollaborationUse has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createCollaborationUse_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//CollaborationUse has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createCollaborationUse_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::COMBINEDFRAGMENT_CLASS:
		{
			if (nullptr == container)
			{
				return this->createCombinedFragment(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//CombinedFragment has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createCombinedFragment_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//CombinedFragment has fragment as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::Interaction> castedContainer = std::dynamic_pointer_cast<uml::Interaction> (container);
						return this->createCombinedFragment_as_fragment_in_Interaction(castedContainer,metaElementID);
					}
					//CombinedFragment has fragment as a containment
					case  uml::umlPackage::INTERACTIONOPERAND_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::InteractionOperand> castedContainer = std::dynamic_pointer_cast<uml::InteractionOperand> (container);
						return this->createCombinedFragment_as_fragment_in_InteractionOperand(castedContainer,metaElementID);
					}
					//CombinedFragment has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createCombinedFragment_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//CombinedFragment has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createCombinedFragment_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//CombinedFragment has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createCombinedFragment_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//CombinedFragment has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createCombinedFragment_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//CombinedFragment has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createCombinedFragment_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//CombinedFragment has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createCombinedFragment_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//CombinedFragment has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createCombinedFragment_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//CombinedFragment has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createCombinedFragment_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::COMMENT_CLASS:
		{
			if (nullptr == container)
			{
				return this->createComment(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Comment has ownedComment as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDCOMMENT:	
					{
						std::shared_ptr<Element> castedContainer = std::dynamic_pointer_cast<Element> (container);;
						return this->createComment_as_ownedComment_in_Element(castedContainer,metaElementID);
					}
					//Comment has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createComment_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Comment has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createComment_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Comment has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createComment_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::COMMUNICATIONPATH_CLASS:
		{
			if (nullptr == container)
			{
				return this->createCommunicationPath(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//CommunicationPath has classifier as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_CLASSIFIER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createCommunicationPath_as_classifier_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//CommunicationPath has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createCommunicationPath_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//CommunicationPath has contract as a containment
					case  uml::umlPackage::SUBSTITUTION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<Substitution> castedContainer = std::dynamic_pointer_cast<Substitution> (container);;
						return this->createCommunicationPath_as_contract_in_Substitution(castedContainer,metaElementID);
					}
					//CommunicationPath has endType as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_ENDTYPE:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createCommunicationPath_as_endType_in_Association(castedContainer,metaElementID);
					}
					//CommunicationPath has general as a containment
					case  uml::umlPackage::GENERALIZATION_ATTRIBUTE_GENERAL:	
					{
						std::shared_ptr<Generalization> castedContainer = std::dynamic_pointer_cast<Generalization> (container);;
						return this->createCommunicationPath_as_general_in_Generalization(castedContainer,metaElementID);
					}
					//CommunicationPath has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createCommunicationPath_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//CommunicationPath has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createCommunicationPath_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//CommunicationPath has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createCommunicationPath_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//CommunicationPath has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createCommunicationPath_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//CommunicationPath has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createCommunicationPath_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//CommunicationPath has nestedClassifier as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createCommunicationPath_as_nestedClassifier_in_Class(castedContainer,metaElementID);
					}
					//CommunicationPath has nestedClassifier as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createCommunicationPath_as_nestedClassifier_in_Interface(castedContainer,metaElementID);
					}
					//CommunicationPath has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createCommunicationPath_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//CommunicationPath has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createCommunicationPath_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//CommunicationPath has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createCommunicationPath_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//CommunicationPath has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createCommunicationPath_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//CommunicationPath has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createCommunicationPath_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//CommunicationPath has ownedType as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDTYPE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createCommunicationPath_as_ownedType_in_Package(castedContainer,metaElementID);
					}
					//CommunicationPath has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createCommunicationPath_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//CommunicationPath has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createCommunicationPath_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//CommunicationPath has realizingClassifier as a containment
					case  uml::umlPackage::COMPONENTREALIZATION_ATTRIBUTE_REALIZINGCLASSIFIER:	
					{
						std::shared_ptr<ComponentRealization> castedContainer = std::dynamic_pointer_cast<ComponentRealization> (container);;
						return this->createCommunicationPath_as_realizingClassifier_in_ComponentRealization(castedContainer,metaElementID);
					}
					//CommunicationPath has redefinedClassifier as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REDEFINEDCLASSIFIER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createCommunicationPath_as_redefinedClassifier_in_Classifier(castedContainer,metaElementID);
					}
					//CommunicationPath has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createCommunicationPath_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//CommunicationPath has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createCommunicationPath_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//CommunicationPath has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createCommunicationPath_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//CommunicationPath has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createCommunicationPath_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::COMPONENT_CLASS:
		{
			if (nullptr == container)
			{
				return this->createComponent(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Component has abstraction as a containment
					//Component has classifier as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_CLASSIFIER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createComponent_as_classifier_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//Component has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createComponent_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Component has context as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_CONTEXT:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createComponent_as_context_in_Behavior(castedContainer,metaElementID);
					}
					//Component has contract as a containment
					case  uml::umlPackage::SUBSTITUTION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<Substitution> castedContainer = std::dynamic_pointer_cast<Substitution> (container);;
						return this->createComponent_as_contract_in_Substitution(castedContainer,metaElementID);
					}
					//Component has endType as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_ENDTYPE:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createComponent_as_endType_in_Association(castedContainer,metaElementID);
					}
					//Component has general as a containment
					case  uml::umlPackage::GENERALIZATION_ATTRIBUTE_GENERAL:	
					{
						std::shared_ptr<Generalization> castedContainer = std::dynamic_pointer_cast<Generalization> (container);;
						return this->createComponent_as_general_in_Generalization(castedContainer,metaElementID);
					}
					//Component has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createComponent_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Component has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createComponent_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Component has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createComponent_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Component has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createComponent_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Component has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createComponent_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Component has nestedClassifier as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createComponent_as_nestedClassifier_in_Class(castedContainer,metaElementID);
					}
					//Component has nestedClassifier as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createComponent_as_nestedClassifier_in_Interface(castedContainer,metaElementID);
					}
					//Component has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createComponent_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Component has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createComponent_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Component has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createComponent_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Component has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createComponent_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Component has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createComponent_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Component has ownedType as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDTYPE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createComponent_as_ownedType_in_Package(castedContainer,metaElementID);
					}
					//Component has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createComponent_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Component has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createComponent_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Component has realizingClassifier as a containment
					case  uml::umlPackage::COMPONENTREALIZATION_ATTRIBUTE_REALIZINGCLASSIFIER:	
					{
						std::shared_ptr<ComponentRealization> castedContainer = std::dynamic_pointer_cast<ComponentRealization> (container);;
						return this->createComponent_as_realizingClassifier_in_ComponentRealization(castedContainer,metaElementID);
					}
					//Component has redefinedClassifier as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REDEFINEDCLASSIFIER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createComponent_as_redefinedClassifier_in_Classifier(castedContainer,metaElementID);
					}
					//Component has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createComponent_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Component has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createComponent_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Component has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createComponent_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Component has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createComponent_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::COMPONENTREALIZATION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createComponentRealization(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ComponentRealization has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createComponentRealization_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ComponentRealization has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createComponentRealization_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//ComponentRealization has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createComponentRealization_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ComponentRealization has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createComponentRealization_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ComponentRealization has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createComponentRealization_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ComponentRealization has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createComponentRealization_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ComponentRealization has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createComponentRealization_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//ComponentRealization has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createComponentRealization_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//ComponentRealization has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createComponentRealization_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ComponentRealization has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createComponentRealization_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ComponentRealization has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createComponentRealization_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//ComponentRealization has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createComponentRealization_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//ComponentRealization has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createComponentRealization_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//ComponentRealization has realization as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_REALIZATION:	
					{
						std::weak_ptr<uml::Component> castedContainer = std::dynamic_pointer_cast<uml::Component> (container);
						return this->createComponentRealization_as_realization_in_Component(castedContainer,metaElementID);
					}
					//ComponentRealization has roleBinding as a containment
					case  uml::umlPackage::COLLABORATIONUSE_ATTRIBUTE_ROLEBINDING:	
					{
						std::shared_ptr<CollaborationUse> castedContainer = std::dynamic_pointer_cast<CollaborationUse> (container);;
						return this->createComponentRealization_as_roleBinding_in_CollaborationUse(castedContainer,metaElementID);
					}
					//ComponentRealization has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createComponentRealization_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ComponentRealization has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createComponentRealization_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ComponentRealization has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createComponentRealization_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ComponentRealization has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createComponentRealization_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::CONDITIONALNODE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createConditionalNode(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ConditionalNode has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createConditionalNode_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//ConditionalNode has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createConditionalNode_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ConditionalNode has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createConditionalNode_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//ConditionalNode has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createConditionalNode_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//ConditionalNode has group as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_GROUP:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createConditionalNode_as_group_in_Activity(castedContainer,metaElementID);
					}
					//ConditionalNode has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createConditionalNode_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ConditionalNode has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createConditionalNode_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ConditionalNode has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createConditionalNode_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ConditionalNode has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createConditionalNode_as_node_in_Activity(castedContainer,metaElementID);
					}
					//ConditionalNode has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createConditionalNode_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//ConditionalNode has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createConditionalNode_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//ConditionalNode has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createConditionalNode_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//ConditionalNode has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createConditionalNode_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ConditionalNode has ownedGroup as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDGROUP:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createConditionalNode_as_ownedGroup_in_Activity(castedContainer,metaElementID);
					}
					//ConditionalNode has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createConditionalNode_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ConditionalNode has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createConditionalNode_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//ConditionalNode has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createConditionalNode_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//ConditionalNode has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createConditionalNode_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ConditionalNode has structuredNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_STRUCTUREDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createConditionalNode_as_structuredNode_in_Activity(castedContainer,metaElementID);
					}
					//ConditionalNode has subgroup as a containment
					case  uml::umlPackage::ACTIVITYGROUP_ATTRIBUTE_SUBGROUP:	
					{
						std::weak_ptr<uml::ActivityGroup> castedContainer = std::dynamic_pointer_cast<uml::ActivityGroup> (container);
						return this->createConditionalNode_as_subgroup_in_ActivityGroup(castedContainer,metaElementID);
					}
					//ConditionalNode has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createConditionalNode_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ConditionalNode has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createConditionalNode_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::CONNECTABLEELEMENTTEMPLATEPARAMETER_CLASS:
		{
			if (nullptr == container)
			{
				return this->createConnectableElementTemplateParameter(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ConnectableElementTemplateParameter has inheritedParameter as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_INHERITEDPARAMETER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createConnectableElementTemplateParameter_as_inheritedParameter_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//ConnectableElementTemplateParameter has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createConnectableElementTemplateParameter_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ConnectableElementTemplateParameter has ownedParameter as a containment
					case  uml::umlPackage::TEMPLATESIGNATURE_ATTRIBUTE_OWNEDPARAMETER:	
					{
						std::weak_ptr<uml::TemplateSignature> castedContainer = std::dynamic_pointer_cast<uml::TemplateSignature> (container);
						return this->createConnectableElementTemplateParameter_as_ownedParameter_in_TemplateSignature(castedContainer,metaElementID);
					}
					//ConnectableElementTemplateParameter has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createConnectableElementTemplateParameter_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ConnectableElementTemplateParameter has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createConnectableElementTemplateParameter_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::CONNECTIONPOINTREFERENCE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createConnectionPointReference(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ConnectionPointReference has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createConnectionPointReference_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ConnectionPointReference has connection as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_CONNECTION:	
					{
						std::weak_ptr<uml::State> castedContainer = std::dynamic_pointer_cast<uml::State> (container);
						return this->createConnectionPointReference_as_connection_in_State(castedContainer,metaElementID);
					}
					//ConnectionPointReference has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createConnectionPointReference_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ConnectionPointReference has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createConnectionPointReference_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ConnectionPointReference has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createConnectionPointReference_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ConnectionPointReference has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createConnectionPointReference_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ConnectionPointReference has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createConnectionPointReference_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ConnectionPointReference has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createConnectionPointReference_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ConnectionPointReference has subvertex as a containment
					case  uml::umlPackage::REGION_ATTRIBUTE_SUBVERTEX:	
					{
						std::weak_ptr<uml::Region> castedContainer = std::dynamic_pointer_cast<uml::Region> (container);
						return this->createConnectionPointReference_as_subvertex_in_Region(castedContainer,metaElementID);
					}
					//ConnectionPointReference has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createConnectionPointReference_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ConnectionPointReference has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createConnectionPointReference_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::CONNECTOR_CLASS:
		{
			if (nullptr == container)
			{
				return this->createConnector(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Connector has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createConnector_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Connector has feature as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_FEATURE:	
					{
						std::shared_ptr<uml::Classifier> castedContainer = std::dynamic_pointer_cast<uml::Classifier> (container);
						return this->createConnector_as_feature_in_Classifier(castedContainer,metaElementID);
					}
					//Connector has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createConnector_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Connector has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createConnector_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Connector has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createConnector_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Connector has ownedConnector as a containment
					case  uml::umlPackage::STRUCTUREDCLASSIFIER_ATTRIBUTE_OWNEDCONNECTOR:	
					{
						std::weak_ptr<uml::StructuredClassifier> castedContainer = std::dynamic_pointer_cast<uml::StructuredClassifier> (container);
						return this->createConnector_as_ownedConnector_in_StructuredClassifier(castedContainer,metaElementID);
					}
					//Connector has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createConnector_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Connector has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createConnector_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Connector has redefinedConnector as a containment
					case  uml::umlPackage::CONNECTOR_ATTRIBUTE_REDEFINEDCONNECTOR:	
					{
						std::shared_ptr<Connector> castedContainer = std::dynamic_pointer_cast<Connector> (container);;
						return this->createConnector_as_redefinedConnector_in_Connector(castedContainer,metaElementID);
					}
					//Connector has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createConnector_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Connector has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createConnector_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Connector has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createConnector_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::CONNECTOREND_CLASS:
		{
			if (nullptr == container)
			{
				return this->createConnectorEnd(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ConnectorEnd has end as a containment
					case  uml::umlPackage::CONNECTOR_ATTRIBUTE_END:	
					{
						std::weak_ptr<uml::Connector> castedContainer = std::dynamic_pointer_cast<uml::Connector> (container);
						return this->createConnectorEnd_as_end_in_Connector(castedContainer,metaElementID);
					}
					//ConnectorEnd has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createConnectorEnd_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ConnectorEnd has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createConnectorEnd_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ConnectorEnd has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createConnectorEnd_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::CONSIDERIGNOREFRAGMENT_CLASS:
		{
			if (nullptr == container)
			{
				return this->createConsiderIgnoreFragment(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ConsiderIgnoreFragment has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createConsiderIgnoreFragment_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ConsiderIgnoreFragment has fragment as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::Interaction> castedContainer = std::dynamic_pointer_cast<uml::Interaction> (container);
						return this->createConsiderIgnoreFragment_as_fragment_in_Interaction(castedContainer,metaElementID);
					}
					//ConsiderIgnoreFragment has fragment as a containment
					case  uml::umlPackage::INTERACTIONOPERAND_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::InteractionOperand> castedContainer = std::dynamic_pointer_cast<uml::InteractionOperand> (container);
						return this->createConsiderIgnoreFragment_as_fragment_in_InteractionOperand(castedContainer,metaElementID);
					}
					//ConsiderIgnoreFragment has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createConsiderIgnoreFragment_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ConsiderIgnoreFragment has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createConsiderIgnoreFragment_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ConsiderIgnoreFragment has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createConsiderIgnoreFragment_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ConsiderIgnoreFragment has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createConsiderIgnoreFragment_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ConsiderIgnoreFragment has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createConsiderIgnoreFragment_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ConsiderIgnoreFragment has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createConsiderIgnoreFragment_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ConsiderIgnoreFragment has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createConsiderIgnoreFragment_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ConsiderIgnoreFragment has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createConsiderIgnoreFragment_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::CONSTRAINT_CLASS:
		{
			if (nullptr == container)
			{
				return this->createConstraint(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Constraint has bodyCondition as a containment
					case  uml::umlPackage::OPERATION_ATTRIBUTE_BODYCONDITION:	
					{
						std::shared_ptr<Operation> castedContainer = std::dynamic_pointer_cast<Operation> (container);;
						return this->createConstraint_as_bodyCondition_in_Operation(castedContainer,metaElementID);
					}
					//Constraint has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createConstraint_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Constraint has condition as a containment
					case  uml::umlPackage::PARAMETERSET_ATTRIBUTE_CONDITION:	
					{
						std::shared_ptr<ParameterSet> castedContainer = std::dynamic_pointer_cast<ParameterSet> (container);;
						return this->createConstraint_as_condition_in_ParameterSet(castedContainer,metaElementID);
					}
					//Constraint has condition as a containment
					case  uml::umlPackage::EXTEND_ATTRIBUTE_CONDITION:	
					{
						std::shared_ptr<Extend> castedContainer = std::dynamic_pointer_cast<Extend> (container);;
						return this->createConstraint_as_condition_in_Extend(castedContainer,metaElementID);
					}
					//Constraint has guard as a containment
					case  uml::umlPackage::TRANSITION_ATTRIBUTE_GUARD:	
					{
						std::shared_ptr<Transition> castedContainer = std::dynamic_pointer_cast<Transition> (container);;
						return this->createConstraint_as_guard_in_Transition(castedContainer,metaElementID);
					}
					//Constraint has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createConstraint_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Constraint has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createConstraint_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Constraint has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createConstraint_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Constraint has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createConstraint_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Constraint has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createConstraint_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Constraint has invariant as a containment
					case  uml::umlPackage::STATEINVARIANT_ATTRIBUTE_INVARIANT:	
					{
						std::shared_ptr<StateInvariant> castedContainer = std::dynamic_pointer_cast<StateInvariant> (container);;
						return this->createConstraint_as_invariant_in_StateInvariant(castedContainer,metaElementID);
					}
					//Constraint has localPostcondition as a containment
					case  uml::umlPackage::ACTION_ATTRIBUTE_LOCALPOSTCONDITION:	
					{
						std::shared_ptr<Action> castedContainer = std::dynamic_pointer_cast<Action> (container);;
						return this->createConstraint_as_localPostcondition_in_Action(castedContainer,metaElementID);
					}
					//Constraint has localPrecondition as a containment
					case  uml::umlPackage::ACTION_ATTRIBUTE_LOCALPRECONDITION:	
					{
						std::shared_ptr<Action> castedContainer = std::dynamic_pointer_cast<Action> (container);;
						return this->createConstraint_as_localPrecondition_in_Action(castedContainer,metaElementID);
					}
					//Constraint has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createConstraint_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Constraint has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createConstraint_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Constraint has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createConstraint_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Constraint has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createConstraint_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Constraint has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createConstraint_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Constraint has ownedRule as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDRULE:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createConstraint_as_ownedRule_in_Namespace(castedContainer,metaElementID);
					}
					//Constraint has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createConstraint_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Constraint has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createConstraint_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Constraint has postCondition as a containment
					case  uml::umlPackage::PROTOCOLTRANSITION_ATTRIBUTE_POSTCONDITION:	
					{
						std::shared_ptr<ProtocolTransition> castedContainer = std::dynamic_pointer_cast<ProtocolTransition> (container);;
						return this->createConstraint_as_postCondition_in_ProtocolTransition(castedContainer,metaElementID);
					}
					//Constraint has postcondition as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_POSTCONDITION:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createConstraint_as_postcondition_in_Behavior(castedContainer,metaElementID);
					}
					//Constraint has postcondition as a containment
					case  uml::umlPackage::OPERATION_ATTRIBUTE_POSTCONDITION:	
					{
						std::shared_ptr<Operation> castedContainer = std::dynamic_pointer_cast<Operation> (container);;
						return this->createConstraint_as_postcondition_in_Operation(castedContainer,metaElementID);
					}
					//Constraint has preCondition as a containment
					case  uml::umlPackage::PROTOCOLTRANSITION_ATTRIBUTE_PRECONDITION:	
					{
						std::shared_ptr<ProtocolTransition> castedContainer = std::dynamic_pointer_cast<ProtocolTransition> (container);;
						return this->createConstraint_as_preCondition_in_ProtocolTransition(castedContainer,metaElementID);
					}
					//Constraint has precondition as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_PRECONDITION:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createConstraint_as_precondition_in_Behavior(castedContainer,metaElementID);
					}
					//Constraint has precondition as a containment
					case  uml::umlPackage::OPERATION_ATTRIBUTE_PRECONDITION:	
					{
						std::shared_ptr<Operation> castedContainer = std::dynamic_pointer_cast<Operation> (container);;
						return this->createConstraint_as_precondition_in_Operation(castedContainer,metaElementID);
					}
					//Constraint has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createConstraint_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Constraint has stateInvariant as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_STATEINVARIANT:	
					{
						std::shared_ptr<State> castedContainer = std::dynamic_pointer_cast<State> (container);;
						return this->createConstraint_as_stateInvariant_in_State(castedContainer,metaElementID);
					}
					//Constraint has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createConstraint_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Constraint has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createConstraint_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Constraint has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createConstraint_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::CONTINUATION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createContinuation(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Continuation has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createContinuation_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Continuation has fragment as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::Interaction> castedContainer = std::dynamic_pointer_cast<uml::Interaction> (container);
						return this->createContinuation_as_fragment_in_Interaction(castedContainer,metaElementID);
					}
					//Continuation has fragment as a containment
					case  uml::umlPackage::INTERACTIONOPERAND_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::InteractionOperand> castedContainer = std::dynamic_pointer_cast<uml::InteractionOperand> (container);
						return this->createContinuation_as_fragment_in_InteractionOperand(castedContainer,metaElementID);
					}
					//Continuation has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createContinuation_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Continuation has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createContinuation_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Continuation has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createContinuation_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Continuation has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createContinuation_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Continuation has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createContinuation_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Continuation has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createContinuation_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Continuation has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createContinuation_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Continuation has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createContinuation_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::CONTROLFLOW_CLASS:
		{
			if (nullptr == container)
			{
				return this->createControlFlow(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ControlFlow has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createControlFlow_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ControlFlow has edge as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_EDGE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createControlFlow_as_edge_in_Activity(castedContainer,metaElementID);
					}
					//ControlFlow has edge as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_EDGE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createControlFlow_as_edge_in_ActivityPartition(castedContainer,metaElementID);
					}
					//ControlFlow has edge as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_EDGE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createControlFlow_as_edge_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//ControlFlow has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createControlFlow_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ControlFlow has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createControlFlow_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ControlFlow has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createControlFlow_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ControlFlow has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createControlFlow_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ControlFlow has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createControlFlow_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ControlFlow has redefinedEdge as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_REDEFINEDEDGE:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createControlFlow_as_redefinedEdge_in_ActivityEdge(castedContainer,metaElementID);
					}
					//ControlFlow has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createControlFlow_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ControlFlow has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createControlFlow_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ControlFlow has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createControlFlow_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::CREATELINKACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createCreateLinkAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//CreateLinkAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createCreateLinkAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//CreateLinkAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createCreateLinkAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//CreateLinkAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createCreateLinkAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//CreateLinkAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createCreateLinkAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//CreateLinkAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createCreateLinkAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//CreateLinkAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createCreateLinkAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//CreateLinkAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createCreateLinkAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//CreateLinkAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createCreateLinkAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//CreateLinkAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createCreateLinkAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//CreateLinkAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createCreateLinkAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//CreateLinkAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createCreateLinkAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//CreateLinkAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createCreateLinkAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//CreateLinkAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createCreateLinkAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//CreateLinkAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createCreateLinkAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//CreateLinkAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createCreateLinkAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//CreateLinkAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createCreateLinkAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//CreateLinkAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createCreateLinkAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//CreateLinkAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createCreateLinkAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::CREATELINKOBJECTACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createCreateLinkObjectAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//CreateLinkObjectAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createCreateLinkObjectAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//CreateLinkObjectAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createCreateLinkObjectAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//CreateLinkObjectAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createCreateLinkObjectAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//CreateLinkObjectAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createCreateLinkObjectAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//CreateLinkObjectAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createCreateLinkObjectAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//CreateLinkObjectAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createCreateLinkObjectAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//CreateLinkObjectAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createCreateLinkObjectAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//CreateLinkObjectAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createCreateLinkObjectAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//CreateLinkObjectAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createCreateLinkObjectAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//CreateLinkObjectAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createCreateLinkObjectAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//CreateLinkObjectAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createCreateLinkObjectAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//CreateLinkObjectAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createCreateLinkObjectAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//CreateLinkObjectAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createCreateLinkObjectAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//CreateLinkObjectAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createCreateLinkObjectAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//CreateLinkObjectAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createCreateLinkObjectAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//CreateLinkObjectAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createCreateLinkObjectAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//CreateLinkObjectAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createCreateLinkObjectAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//CreateLinkObjectAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createCreateLinkObjectAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::CREATEOBJECTACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createCreateObjectAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//CreateObjectAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createCreateObjectAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//CreateObjectAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createCreateObjectAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//CreateObjectAction has createObjectAction as a containment
					//CreateObjectAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createCreateObjectAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//CreateObjectAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createCreateObjectAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//CreateObjectAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createCreateObjectAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//CreateObjectAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createCreateObjectAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//CreateObjectAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createCreateObjectAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//CreateObjectAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createCreateObjectAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//CreateObjectAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createCreateObjectAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//CreateObjectAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createCreateObjectAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//CreateObjectAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createCreateObjectAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//CreateObjectAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createCreateObjectAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//CreateObjectAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createCreateObjectAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//CreateObjectAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createCreateObjectAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//CreateObjectAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createCreateObjectAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//CreateObjectAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createCreateObjectAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//CreateObjectAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createCreateObjectAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//CreateObjectAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createCreateObjectAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::DATASTORENODE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createDataStoreNode(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//DataStoreNode has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDataStoreNode_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//DataStoreNode has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDataStoreNode_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//DataStoreNode has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDataStoreNode_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//DataStoreNode has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createDataStoreNode_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//DataStoreNode has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createDataStoreNode_as_node_in_Activity(castedContainer,metaElementID);
					}
					//DataStoreNode has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createDataStoreNode_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//DataStoreNode has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createDataStoreNode_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//DataStoreNode has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createDataStoreNode_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//DataStoreNode has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createDataStoreNode_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//DataStoreNode has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createDataStoreNode_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//DataStoreNode has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createDataStoreNode_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//DataStoreNode has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createDataStoreNode_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//DataStoreNode has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDataStoreNode_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//DataStoreNode has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDataStoreNode_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//DataStoreNode has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDataStoreNode_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::DATATYPE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createDataType(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//DataType has classifier as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_CLASSIFIER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createDataType_as_classifier_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//DataType has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDataType_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//DataType has contract as a containment
					case  uml::umlPackage::SUBSTITUTION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<Substitution> castedContainer = std::dynamic_pointer_cast<Substitution> (container);;
						return this->createDataType_as_contract_in_Substitution(castedContainer,metaElementID);
					}
					//DataType has datatype as a containment
					//DataType has datatype as a containment
					//DataType has endType as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_ENDTYPE:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createDataType_as_endType_in_Association(castedContainer,metaElementID);
					}
					//DataType has general as a containment
					case  uml::umlPackage::GENERALIZATION_ATTRIBUTE_GENERAL:	
					{
						std::shared_ptr<Generalization> castedContainer = std::dynamic_pointer_cast<Generalization> (container);;
						return this->createDataType_as_general_in_Generalization(castedContainer,metaElementID);
					}
					//DataType has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createDataType_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//DataType has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createDataType_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//DataType has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDataType_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//DataType has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDataType_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//DataType has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createDataType_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//DataType has nestedClassifier as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createDataType_as_nestedClassifier_in_Class(castedContainer,metaElementID);
					}
					//DataType has nestedClassifier as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createDataType_as_nestedClassifier_in_Interface(castedContainer,metaElementID);
					}
					//DataType has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createDataType_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//DataType has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createDataType_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//DataType has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createDataType_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//DataType has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createDataType_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//DataType has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createDataType_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//DataType has ownedType as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDTYPE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createDataType_as_ownedType_in_Package(castedContainer,metaElementID);
					}
					//DataType has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createDataType_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//DataType has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createDataType_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//DataType has realizingClassifier as a containment
					case  uml::umlPackage::COMPONENTREALIZATION_ATTRIBUTE_REALIZINGCLASSIFIER:	
					{
						std::shared_ptr<ComponentRealization> castedContainer = std::dynamic_pointer_cast<ComponentRealization> (container);;
						return this->createDataType_as_realizingClassifier_in_ComponentRealization(castedContainer,metaElementID);
					}
					//DataType has redefinedClassifier as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REDEFINEDCLASSIFIER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createDataType_as_redefinedClassifier_in_Classifier(castedContainer,metaElementID);
					}
					//DataType has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDataType_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//DataType has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDataType_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//DataType has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDataType_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//DataType has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createDataType_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::DECISIONNODE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createDecisionNode(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//DecisionNode has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDecisionNode_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//DecisionNode has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDecisionNode_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//DecisionNode has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDecisionNode_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//DecisionNode has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createDecisionNode_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//DecisionNode has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createDecisionNode_as_node_in_Activity(castedContainer,metaElementID);
					}
					//DecisionNode has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createDecisionNode_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//DecisionNode has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createDecisionNode_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//DecisionNode has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createDecisionNode_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//DecisionNode has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createDecisionNode_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//DecisionNode has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createDecisionNode_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//DecisionNode has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createDecisionNode_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//DecisionNode has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createDecisionNode_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//DecisionNode has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDecisionNode_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//DecisionNode has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDecisionNode_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//DecisionNode has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDecisionNode_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::DEPENDENCY_CLASS:
		{
			if (nullptr == container)
			{
				return this->createDependency(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Dependency has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDependency_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Dependency has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createDependency_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Dependency has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createDependency_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Dependency has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDependency_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Dependency has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDependency_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Dependency has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createDependency_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Dependency has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createDependency_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Dependency has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createDependency_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Dependency has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createDependency_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Dependency has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createDependency_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Dependency has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createDependency_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Dependency has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createDependency_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Dependency has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createDependency_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Dependency has roleBinding as a containment
					case  uml::umlPackage::COLLABORATIONUSE_ATTRIBUTE_ROLEBINDING:	
					{
						std::shared_ptr<CollaborationUse> castedContainer = std::dynamic_pointer_cast<CollaborationUse> (container);;
						return this->createDependency_as_roleBinding_in_CollaborationUse(castedContainer,metaElementID);
					}
					//Dependency has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDependency_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Dependency has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDependency_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Dependency has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDependency_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Dependency has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createDependency_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::DEPLOYMENT_CLASS:
		{
			if (nullptr == container)
			{
				return this->createDeployment(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Deployment has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDeployment_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Deployment has deployment as a containment
					case  uml::umlPackage::DEPLOYMENTTARGET_ATTRIBUTE_DEPLOYMENT:	
					{
						std::weak_ptr<uml::DeploymentTarget> castedContainer = std::dynamic_pointer_cast<uml::DeploymentTarget> (container);
						return this->createDeployment_as_deployment_in_DeploymentTarget(castedContainer,metaElementID);
					}
					//Deployment has deployment as a containment
					//Deployment has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createDeployment_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Deployment has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createDeployment_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Deployment has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDeployment_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Deployment has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDeployment_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Deployment has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createDeployment_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Deployment has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createDeployment_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Deployment has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createDeployment_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Deployment has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createDeployment_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Deployment has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createDeployment_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Deployment has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createDeployment_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Deployment has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createDeployment_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Deployment has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createDeployment_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Deployment has roleBinding as a containment
					case  uml::umlPackage::COLLABORATIONUSE_ATTRIBUTE_ROLEBINDING:	
					{
						std::shared_ptr<CollaborationUse> castedContainer = std::dynamic_pointer_cast<CollaborationUse> (container);;
						return this->createDeployment_as_roleBinding_in_CollaborationUse(castedContainer,metaElementID);
					}
					//Deployment has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDeployment_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Deployment has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDeployment_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Deployment has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDeployment_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Deployment has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createDeployment_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::DEPLOYMENTSPECIFICATION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createDeploymentSpecification(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//DeploymentSpecification has classifier as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_CLASSIFIER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createDeploymentSpecification_as_classifier_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//DeploymentSpecification has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDeploymentSpecification_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//DeploymentSpecification has configuration as a containment
					case  uml::umlPackage::DEPLOYMENT_ATTRIBUTE_CONFIGURATION:	
					{
						std::weak_ptr<uml::Deployment> castedContainer = std::dynamic_pointer_cast<uml::Deployment> (container);
						return this->createDeploymentSpecification_as_configuration_in_Deployment(castedContainer,metaElementID);
					}
					//DeploymentSpecification has contract as a containment
					case  uml::umlPackage::SUBSTITUTION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<Substitution> castedContainer = std::dynamic_pointer_cast<Substitution> (container);;
						return this->createDeploymentSpecification_as_contract_in_Substitution(castedContainer,metaElementID);
					}
					//DeploymentSpecification has deployedArtifact as a containment
					case  uml::umlPackage::DEPLOYMENT_ATTRIBUTE_DEPLOYEDARTIFACT:	
					{
						std::shared_ptr<Deployment> castedContainer = std::dynamic_pointer_cast<Deployment> (container);;
						return this->createDeploymentSpecification_as_deployedArtifact_in_Deployment(castedContainer,metaElementID);
					}
					//DeploymentSpecification has endType as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_ENDTYPE:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createDeploymentSpecification_as_endType_in_Association(castedContainer,metaElementID);
					}
					//DeploymentSpecification has general as a containment
					case  uml::umlPackage::GENERALIZATION_ATTRIBUTE_GENERAL:	
					{
						std::shared_ptr<Generalization> castedContainer = std::dynamic_pointer_cast<Generalization> (container);;
						return this->createDeploymentSpecification_as_general_in_Generalization(castedContainer,metaElementID);
					}
					//DeploymentSpecification has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createDeploymentSpecification_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//DeploymentSpecification has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createDeploymentSpecification_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//DeploymentSpecification has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDeploymentSpecification_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//DeploymentSpecification has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDeploymentSpecification_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//DeploymentSpecification has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createDeploymentSpecification_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//DeploymentSpecification has nestedArtifact as a containment
					case  uml::umlPackage::ARTIFACT_ATTRIBUTE_NESTEDARTIFACT:	
					{
						std::shared_ptr<Artifact> castedContainer = std::dynamic_pointer_cast<Artifact> (container);;
						return this->createDeploymentSpecification_as_nestedArtifact_in_Artifact(castedContainer,metaElementID);
					}
					//DeploymentSpecification has nestedClassifier as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createDeploymentSpecification_as_nestedClassifier_in_Class(castedContainer,metaElementID);
					}
					//DeploymentSpecification has nestedClassifier as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createDeploymentSpecification_as_nestedClassifier_in_Interface(castedContainer,metaElementID);
					}
					//DeploymentSpecification has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createDeploymentSpecification_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//DeploymentSpecification has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createDeploymentSpecification_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//DeploymentSpecification has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createDeploymentSpecification_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//DeploymentSpecification has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createDeploymentSpecification_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//DeploymentSpecification has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createDeploymentSpecification_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//DeploymentSpecification has ownedType as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDTYPE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createDeploymentSpecification_as_ownedType_in_Package(castedContainer,metaElementID);
					}
					//DeploymentSpecification has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createDeploymentSpecification_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//DeploymentSpecification has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createDeploymentSpecification_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//DeploymentSpecification has realizingClassifier as a containment
					case  uml::umlPackage::COMPONENTREALIZATION_ATTRIBUTE_REALIZINGCLASSIFIER:	
					{
						std::shared_ptr<ComponentRealization> castedContainer = std::dynamic_pointer_cast<ComponentRealization> (container);;
						return this->createDeploymentSpecification_as_realizingClassifier_in_ComponentRealization(castedContainer,metaElementID);
					}
					//DeploymentSpecification has redefinedClassifier as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REDEFINEDCLASSIFIER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createDeploymentSpecification_as_redefinedClassifier_in_Classifier(castedContainer,metaElementID);
					}
					//DeploymentSpecification has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDeploymentSpecification_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//DeploymentSpecification has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDeploymentSpecification_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//DeploymentSpecification has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDeploymentSpecification_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//DeploymentSpecification has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createDeploymentSpecification_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::DESTROYLINKACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createDestroyLinkAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//DestroyLinkAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createDestroyLinkAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//DestroyLinkAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDestroyLinkAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//DestroyLinkAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createDestroyLinkAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//DestroyLinkAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createDestroyLinkAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//DestroyLinkAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDestroyLinkAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//DestroyLinkAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDestroyLinkAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//DestroyLinkAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createDestroyLinkAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//DestroyLinkAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createDestroyLinkAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//DestroyLinkAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createDestroyLinkAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//DestroyLinkAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createDestroyLinkAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//DestroyLinkAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createDestroyLinkAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//DestroyLinkAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createDestroyLinkAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//DestroyLinkAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createDestroyLinkAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//DestroyLinkAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createDestroyLinkAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//DestroyLinkAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createDestroyLinkAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//DestroyLinkAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDestroyLinkAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//DestroyLinkAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDestroyLinkAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//DestroyLinkAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDestroyLinkAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::DESTROYOBJECTACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createDestroyObjectAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//DestroyObjectAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createDestroyObjectAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//DestroyObjectAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDestroyObjectAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//DestroyObjectAction has destroyObjectAction as a containment
					//DestroyObjectAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createDestroyObjectAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//DestroyObjectAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createDestroyObjectAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//DestroyObjectAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDestroyObjectAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//DestroyObjectAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDestroyObjectAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//DestroyObjectAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createDestroyObjectAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//DestroyObjectAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createDestroyObjectAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//DestroyObjectAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createDestroyObjectAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//DestroyObjectAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createDestroyObjectAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//DestroyObjectAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createDestroyObjectAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//DestroyObjectAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createDestroyObjectAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//DestroyObjectAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createDestroyObjectAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//DestroyObjectAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createDestroyObjectAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//DestroyObjectAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createDestroyObjectAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//DestroyObjectAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDestroyObjectAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//DestroyObjectAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDestroyObjectAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//DestroyObjectAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDestroyObjectAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::DESTRUCTIONOCCURRENCESPECIFICATION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createDestructionOccurrenceSpecification(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//DestructionOccurrenceSpecification has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDestructionOccurrenceSpecification_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//DestructionOccurrenceSpecification has fragment as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::Interaction> castedContainer = std::dynamic_pointer_cast<uml::Interaction> (container);
						return this->createDestructionOccurrenceSpecification_as_fragment_in_Interaction(castedContainer,metaElementID);
					}
					//DestructionOccurrenceSpecification has fragment as a containment
					case  uml::umlPackage::INTERACTIONOPERAND_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::InteractionOperand> castedContainer = std::dynamic_pointer_cast<uml::InteractionOperand> (container);
						return this->createDestructionOccurrenceSpecification_as_fragment_in_InteractionOperand(castedContainer,metaElementID);
					}
					//DestructionOccurrenceSpecification has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDestructionOccurrenceSpecification_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//DestructionOccurrenceSpecification has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDestructionOccurrenceSpecification_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//DestructionOccurrenceSpecification has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createDestructionOccurrenceSpecification_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//DestructionOccurrenceSpecification has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createDestructionOccurrenceSpecification_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//DestructionOccurrenceSpecification has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createDestructionOccurrenceSpecification_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//DestructionOccurrenceSpecification has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDestructionOccurrenceSpecification_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//DestructionOccurrenceSpecification has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDestructionOccurrenceSpecification_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//DestructionOccurrenceSpecification has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDestructionOccurrenceSpecification_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::DEVICE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createDevice(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Device has classifier as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_CLASSIFIER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createDevice_as_classifier_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//Device has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDevice_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Device has context as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_CONTEXT:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createDevice_as_context_in_Behavior(castedContainer,metaElementID);
					}
					//Device has contract as a containment
					case  uml::umlPackage::SUBSTITUTION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<Substitution> castedContainer = std::dynamic_pointer_cast<Substitution> (container);;
						return this->createDevice_as_contract_in_Substitution(castedContainer,metaElementID);
					}
					//Device has endType as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_ENDTYPE:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createDevice_as_endType_in_Association(castedContainer,metaElementID);
					}
					//Device has general as a containment
					case  uml::umlPackage::GENERALIZATION_ATTRIBUTE_GENERAL:	
					{
						std::shared_ptr<Generalization> castedContainer = std::dynamic_pointer_cast<Generalization> (container);;
						return this->createDevice_as_general_in_Generalization(castedContainer,metaElementID);
					}
					//Device has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createDevice_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Device has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createDevice_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Device has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDevice_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Device has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDevice_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Device has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createDevice_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Device has nestedClassifier as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createDevice_as_nestedClassifier_in_Class(castedContainer,metaElementID);
					}
					//Device has nestedClassifier as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createDevice_as_nestedClassifier_in_Interface(castedContainer,metaElementID);
					}
					//Device has nestedNode as a containment
					case  uml::umlPackage::NODE_ATTRIBUTE_NESTEDNODE:	
					{
						std::shared_ptr<Node> castedContainer = std::dynamic_pointer_cast<Node> (container);;
						return this->createDevice_as_nestedNode_in_Node(castedContainer,metaElementID);
					}
					//Device has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createDevice_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Device has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createDevice_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Device has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createDevice_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Device has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createDevice_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Device has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createDevice_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Device has ownedType as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDTYPE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createDevice_as_ownedType_in_Package(castedContainer,metaElementID);
					}
					//Device has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createDevice_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Device has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createDevice_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Device has realizingClassifier as a containment
					case  uml::umlPackage::COMPONENTREALIZATION_ATTRIBUTE_REALIZINGCLASSIFIER:	
					{
						std::shared_ptr<ComponentRealization> castedContainer = std::dynamic_pointer_cast<ComponentRealization> (container);;
						return this->createDevice_as_realizingClassifier_in_ComponentRealization(castedContainer,metaElementID);
					}
					//Device has redefinedClassifier as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REDEFINEDCLASSIFIER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createDevice_as_redefinedClassifier_in_Classifier(castedContainer,metaElementID);
					}
					//Device has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDevice_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Device has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDevice_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Device has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDevice_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Device has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createDevice_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::DURATION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createDuration(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Duration has argument as a containment
					case  uml::umlPackage::MESSAGE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<Message> castedContainer = std::dynamic_pointer_cast<Message> (container);;
						return this->createDuration_as_argument_in_Message(castedContainer,metaElementID);
					}
					//Duration has argument as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createDuration_as_argument_in_InteractionUse(castedContainer,metaElementID);
					}
					//Duration has changeExpression as a containment
					case  uml::umlPackage::CHANGEEVENT_ATTRIBUTE_CHANGEEXPRESSION:	
					{
						std::shared_ptr<ChangeEvent> castedContainer = std::dynamic_pointer_cast<ChangeEvent> (container);;
						return this->createDuration_as_changeExpression_in_ChangeEvent(castedContainer,metaElementID);
					}
					//Duration has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDuration_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Duration has defaultValue as a containment
					case  uml::umlPackage::PROPERTY_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Property> castedContainer = std::dynamic_pointer_cast<Property> (container);;
						return this->createDuration_as_defaultValue_in_Property(castedContainer,metaElementID);
					}
					//Duration has defaultValue as a containment
					case  uml::umlPackage::PARAMETER_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Parameter> castedContainer = std::dynamic_pointer_cast<Parameter> (container);;
						return this->createDuration_as_defaultValue_in_Parameter(castedContainer,metaElementID);
					}
					//Duration has expr as a containment
					case  uml::umlPackage::TIMEEXPRESSION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<TimeExpression> castedContainer = std::dynamic_pointer_cast<TimeExpression> (container);;
						return this->createDuration_as_expr_in_TimeExpression(castedContainer,metaElementID);
					}
					//Duration has expr as a containment
					case  uml::umlPackage::DURATION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<Duration> castedContainer = std::dynamic_pointer_cast<Duration> (container);;
						return this->createDuration_as_expr_in_Duration(castedContainer,metaElementID);
					}
					//Duration has guard as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_GUARD:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createDuration_as_guard_in_ActivityEdge(castedContainer,metaElementID);
					}
					//Duration has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createDuration_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Duration has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createDuration_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Duration has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDuration_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Duration has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDuration_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Duration has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createDuration_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Duration has joinSpec as a containment
					case  uml::umlPackage::JOINNODE_ATTRIBUTE_JOINSPEC:	
					{
						std::shared_ptr<JoinNode> castedContainer = std::dynamic_pointer_cast<JoinNode> (container);;
						return this->createDuration_as_joinSpec_in_JoinNode(castedContainer,metaElementID);
					}
					//Duration has lowerValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_LOWERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createDuration_as_lowerValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//Duration has maxint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MAXINT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createDuration_as_maxint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//Duration has minint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MININT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createDuration_as_minint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//Duration has operand as a containment
					case  uml::umlPackage::EXPRESSION_ATTRIBUTE_OPERAND:	
					{
						std::shared_ptr<Expression> castedContainer = std::dynamic_pointer_cast<Expression> (container);;
						return this->createDuration_as_operand_in_Expression(castedContainer,metaElementID);
					}
					//Duration has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createDuration_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Duration has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createDuration_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Duration has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createDuration_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Duration has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createDuration_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Duration has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createDuration_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Duration has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createDuration_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Duration has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createDuration_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Duration has returnValue as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_RETURNVALUE:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createDuration_as_returnValue_in_InteractionUse(castedContainer,metaElementID);
					}
					//Duration has selector as a containment
					case  uml::umlPackage::LIFELINE_ATTRIBUTE_SELECTOR:	
					{
						std::shared_ptr<Lifeline> castedContainer = std::dynamic_pointer_cast<Lifeline> (container);;
						return this->createDuration_as_selector_in_Lifeline(castedContainer,metaElementID);
					}
					//Duration has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDuration_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Duration has specification as a containment
					case  uml::umlPackage::CONSTRAINT_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<Constraint> castedContainer = std::dynamic_pointer_cast<Constraint> (container);;
						return this->createDuration_as_specification_in_Constraint(castedContainer,metaElementID);
					}
					//Duration has specification as a containment
					case  uml::umlPackage::INSTANCESPECIFICATION_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<InstanceSpecification> castedContainer = std::dynamic_pointer_cast<InstanceSpecification> (container);;
						return this->createDuration_as_specification_in_InstanceSpecification(castedContainer,metaElementID);
					}
					//Duration has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDuration_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Duration has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDuration_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Duration has upperBound as a containment
					case  uml::umlPackage::OBJECTNODE_ATTRIBUTE_UPPERBOUND:	
					{
						std::shared_ptr<ObjectNode> castedContainer = std::dynamic_pointer_cast<ObjectNode> (container);;
						return this->createDuration_as_upperBound_in_ObjectNode(castedContainer,metaElementID);
					}
					//Duration has upperValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_UPPERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createDuration_as_upperValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//Duration has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createDuration_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					//Duration has value as a containment
					case  uml::umlPackage::SLOT_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::Slot> castedContainer = std::dynamic_pointer_cast<uml::Slot> (container);
						return this->createDuration_as_value_in_Slot(castedContainer,metaElementID);
					}
					//Duration has value as a containment
					case  uml::umlPackage::VALUESPECIFICATIONACTION_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::ValueSpecificationAction> castedContainer = std::dynamic_pointer_cast<uml::ValueSpecificationAction> (container);
						return this->createDuration_as_value_in_ValueSpecificationAction(castedContainer,metaElementID);
					}
					//Duration has value as a containment
					case  uml::umlPackage::VALUEPIN_ATTRIBUTE_VALUE:	
					{
						std::shared_ptr<ValuePin> castedContainer = std::dynamic_pointer_cast<ValuePin> (container);;
						return this->createDuration_as_value_in_ValuePin(castedContainer,metaElementID);
					}
					//Duration has weight as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_WEIGHT:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createDuration_as_weight_in_ActivityEdge(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::DURATIONCONSTRAINT_CLASS:
		{
			if (nullptr == container)
			{
				return this->createDurationConstraint(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//DurationConstraint has bodyCondition as a containment
					case  uml::umlPackage::OPERATION_ATTRIBUTE_BODYCONDITION:	
					{
						std::shared_ptr<Operation> castedContainer = std::dynamic_pointer_cast<Operation> (container);;
						return this->createDurationConstraint_as_bodyCondition_in_Operation(castedContainer,metaElementID);
					}
					//DurationConstraint has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDurationConstraint_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//DurationConstraint has condition as a containment
					case  uml::umlPackage::PARAMETERSET_ATTRIBUTE_CONDITION:	
					{
						std::shared_ptr<ParameterSet> castedContainer = std::dynamic_pointer_cast<ParameterSet> (container);;
						return this->createDurationConstraint_as_condition_in_ParameterSet(castedContainer,metaElementID);
					}
					//DurationConstraint has condition as a containment
					case  uml::umlPackage::EXTEND_ATTRIBUTE_CONDITION:	
					{
						std::shared_ptr<Extend> castedContainer = std::dynamic_pointer_cast<Extend> (container);;
						return this->createDurationConstraint_as_condition_in_Extend(castedContainer,metaElementID);
					}
					//DurationConstraint has guard as a containment
					case  uml::umlPackage::TRANSITION_ATTRIBUTE_GUARD:	
					{
						std::shared_ptr<Transition> castedContainer = std::dynamic_pointer_cast<Transition> (container);;
						return this->createDurationConstraint_as_guard_in_Transition(castedContainer,metaElementID);
					}
					//DurationConstraint has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createDurationConstraint_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//DurationConstraint has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createDurationConstraint_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//DurationConstraint has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDurationConstraint_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//DurationConstraint has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDurationConstraint_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//DurationConstraint has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createDurationConstraint_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//DurationConstraint has invariant as a containment
					case  uml::umlPackage::STATEINVARIANT_ATTRIBUTE_INVARIANT:	
					{
						std::shared_ptr<StateInvariant> castedContainer = std::dynamic_pointer_cast<StateInvariant> (container);;
						return this->createDurationConstraint_as_invariant_in_StateInvariant(castedContainer,metaElementID);
					}
					//DurationConstraint has localPostcondition as a containment
					case  uml::umlPackage::ACTION_ATTRIBUTE_LOCALPOSTCONDITION:	
					{
						std::shared_ptr<Action> castedContainer = std::dynamic_pointer_cast<Action> (container);;
						return this->createDurationConstraint_as_localPostcondition_in_Action(castedContainer,metaElementID);
					}
					//DurationConstraint has localPrecondition as a containment
					case  uml::umlPackage::ACTION_ATTRIBUTE_LOCALPRECONDITION:	
					{
						std::shared_ptr<Action> castedContainer = std::dynamic_pointer_cast<Action> (container);;
						return this->createDurationConstraint_as_localPrecondition_in_Action(castedContainer,metaElementID);
					}
					//DurationConstraint has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createDurationConstraint_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//DurationConstraint has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createDurationConstraint_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//DurationConstraint has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createDurationConstraint_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//DurationConstraint has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createDurationConstraint_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//DurationConstraint has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createDurationConstraint_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//DurationConstraint has ownedRule as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDRULE:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createDurationConstraint_as_ownedRule_in_Namespace(castedContainer,metaElementID);
					}
					//DurationConstraint has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createDurationConstraint_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//DurationConstraint has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createDurationConstraint_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//DurationConstraint has postCondition as a containment
					case  uml::umlPackage::PROTOCOLTRANSITION_ATTRIBUTE_POSTCONDITION:	
					{
						std::shared_ptr<ProtocolTransition> castedContainer = std::dynamic_pointer_cast<ProtocolTransition> (container);;
						return this->createDurationConstraint_as_postCondition_in_ProtocolTransition(castedContainer,metaElementID);
					}
					//DurationConstraint has postcondition as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_POSTCONDITION:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createDurationConstraint_as_postcondition_in_Behavior(castedContainer,metaElementID);
					}
					//DurationConstraint has postcondition as a containment
					case  uml::umlPackage::OPERATION_ATTRIBUTE_POSTCONDITION:	
					{
						std::shared_ptr<Operation> castedContainer = std::dynamic_pointer_cast<Operation> (container);;
						return this->createDurationConstraint_as_postcondition_in_Operation(castedContainer,metaElementID);
					}
					//DurationConstraint has preCondition as a containment
					case  uml::umlPackage::PROTOCOLTRANSITION_ATTRIBUTE_PRECONDITION:	
					{
						std::shared_ptr<ProtocolTransition> castedContainer = std::dynamic_pointer_cast<ProtocolTransition> (container);;
						return this->createDurationConstraint_as_preCondition_in_ProtocolTransition(castedContainer,metaElementID);
					}
					//DurationConstraint has precondition as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_PRECONDITION:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createDurationConstraint_as_precondition_in_Behavior(castedContainer,metaElementID);
					}
					//DurationConstraint has precondition as a containment
					case  uml::umlPackage::OPERATION_ATTRIBUTE_PRECONDITION:	
					{
						std::shared_ptr<Operation> castedContainer = std::dynamic_pointer_cast<Operation> (container);;
						return this->createDurationConstraint_as_precondition_in_Operation(castedContainer,metaElementID);
					}
					//DurationConstraint has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDurationConstraint_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//DurationConstraint has stateInvariant as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_STATEINVARIANT:	
					{
						std::shared_ptr<State> castedContainer = std::dynamic_pointer_cast<State> (container);;
						return this->createDurationConstraint_as_stateInvariant_in_State(castedContainer,metaElementID);
					}
					//DurationConstraint has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDurationConstraint_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//DurationConstraint has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDurationConstraint_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//DurationConstraint has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createDurationConstraint_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::DURATIONINTERVAL_CLASS:
		{
			if (nullptr == container)
			{
				return this->createDurationInterval(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//DurationInterval has argument as a containment
					case  uml::umlPackage::MESSAGE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<Message> castedContainer = std::dynamic_pointer_cast<Message> (container);;
						return this->createDurationInterval_as_argument_in_Message(castedContainer,metaElementID);
					}
					//DurationInterval has argument as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createDurationInterval_as_argument_in_InteractionUse(castedContainer,metaElementID);
					}
					//DurationInterval has changeExpression as a containment
					case  uml::umlPackage::CHANGEEVENT_ATTRIBUTE_CHANGEEXPRESSION:	
					{
						std::shared_ptr<ChangeEvent> castedContainer = std::dynamic_pointer_cast<ChangeEvent> (container);;
						return this->createDurationInterval_as_changeExpression_in_ChangeEvent(castedContainer,metaElementID);
					}
					//DurationInterval has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDurationInterval_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//DurationInterval has defaultValue as a containment
					case  uml::umlPackage::PROPERTY_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Property> castedContainer = std::dynamic_pointer_cast<Property> (container);;
						return this->createDurationInterval_as_defaultValue_in_Property(castedContainer,metaElementID);
					}
					//DurationInterval has defaultValue as a containment
					case  uml::umlPackage::PARAMETER_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Parameter> castedContainer = std::dynamic_pointer_cast<Parameter> (container);;
						return this->createDurationInterval_as_defaultValue_in_Parameter(castedContainer,metaElementID);
					}
					//DurationInterval has expr as a containment
					case  uml::umlPackage::TIMEEXPRESSION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<TimeExpression> castedContainer = std::dynamic_pointer_cast<TimeExpression> (container);;
						return this->createDurationInterval_as_expr_in_TimeExpression(castedContainer,metaElementID);
					}
					//DurationInterval has expr as a containment
					case  uml::umlPackage::DURATION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<Duration> castedContainer = std::dynamic_pointer_cast<Duration> (container);;
						return this->createDurationInterval_as_expr_in_Duration(castedContainer,metaElementID);
					}
					//DurationInterval has guard as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_GUARD:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createDurationInterval_as_guard_in_ActivityEdge(castedContainer,metaElementID);
					}
					//DurationInterval has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createDurationInterval_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//DurationInterval has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createDurationInterval_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//DurationInterval has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDurationInterval_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//DurationInterval has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDurationInterval_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//DurationInterval has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createDurationInterval_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//DurationInterval has joinSpec as a containment
					case  uml::umlPackage::JOINNODE_ATTRIBUTE_JOINSPEC:	
					{
						std::shared_ptr<JoinNode> castedContainer = std::dynamic_pointer_cast<JoinNode> (container);;
						return this->createDurationInterval_as_joinSpec_in_JoinNode(castedContainer,metaElementID);
					}
					//DurationInterval has lowerValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_LOWERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createDurationInterval_as_lowerValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//DurationInterval has maxint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MAXINT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createDurationInterval_as_maxint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//DurationInterval has minint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MININT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createDurationInterval_as_minint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//DurationInterval has operand as a containment
					case  uml::umlPackage::EXPRESSION_ATTRIBUTE_OPERAND:	
					{
						std::shared_ptr<Expression> castedContainer = std::dynamic_pointer_cast<Expression> (container);;
						return this->createDurationInterval_as_operand_in_Expression(castedContainer,metaElementID);
					}
					//DurationInterval has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createDurationInterval_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//DurationInterval has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createDurationInterval_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//DurationInterval has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createDurationInterval_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//DurationInterval has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createDurationInterval_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//DurationInterval has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createDurationInterval_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//DurationInterval has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createDurationInterval_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//DurationInterval has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createDurationInterval_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//DurationInterval has returnValue as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_RETURNVALUE:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createDurationInterval_as_returnValue_in_InteractionUse(castedContainer,metaElementID);
					}
					//DurationInterval has selector as a containment
					case  uml::umlPackage::LIFELINE_ATTRIBUTE_SELECTOR:	
					{
						std::shared_ptr<Lifeline> castedContainer = std::dynamic_pointer_cast<Lifeline> (container);;
						return this->createDurationInterval_as_selector_in_Lifeline(castedContainer,metaElementID);
					}
					//DurationInterval has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDurationInterval_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//DurationInterval has specification as a containment
					case  uml::umlPackage::CONSTRAINT_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<Constraint> castedContainer = std::dynamic_pointer_cast<Constraint> (container);;
						return this->createDurationInterval_as_specification_in_Constraint(castedContainer,metaElementID);
					}
					//DurationInterval has specification as a containment
					case  uml::umlPackage::INSTANCESPECIFICATION_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<InstanceSpecification> castedContainer = std::dynamic_pointer_cast<InstanceSpecification> (container);;
						return this->createDurationInterval_as_specification_in_InstanceSpecification(castedContainer,metaElementID);
					}
					//DurationInterval has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDurationInterval_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//DurationInterval has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDurationInterval_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//DurationInterval has upperBound as a containment
					case  uml::umlPackage::OBJECTNODE_ATTRIBUTE_UPPERBOUND:	
					{
						std::shared_ptr<ObjectNode> castedContainer = std::dynamic_pointer_cast<ObjectNode> (container);;
						return this->createDurationInterval_as_upperBound_in_ObjectNode(castedContainer,metaElementID);
					}
					//DurationInterval has upperValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_UPPERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createDurationInterval_as_upperValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//DurationInterval has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createDurationInterval_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					//DurationInterval has value as a containment
					case  uml::umlPackage::SLOT_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::Slot> castedContainer = std::dynamic_pointer_cast<uml::Slot> (container);
						return this->createDurationInterval_as_value_in_Slot(castedContainer,metaElementID);
					}
					//DurationInterval has value as a containment
					case  uml::umlPackage::VALUESPECIFICATIONACTION_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::ValueSpecificationAction> castedContainer = std::dynamic_pointer_cast<uml::ValueSpecificationAction> (container);
						return this->createDurationInterval_as_value_in_ValueSpecificationAction(castedContainer,metaElementID);
					}
					//DurationInterval has value as a containment
					case  uml::umlPackage::VALUEPIN_ATTRIBUTE_VALUE:	
					{
						std::shared_ptr<ValuePin> castedContainer = std::dynamic_pointer_cast<ValuePin> (container);;
						return this->createDurationInterval_as_value_in_ValuePin(castedContainer,metaElementID);
					}
					//DurationInterval has weight as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_WEIGHT:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createDurationInterval_as_weight_in_ActivityEdge(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::DURATIONOBSERVATION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createDurationObservation(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//DurationObservation has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDurationObservation_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//DurationObservation has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createDurationObservation_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//DurationObservation has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createDurationObservation_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//DurationObservation has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDurationObservation_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//DurationObservation has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createDurationObservation_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//DurationObservation has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createDurationObservation_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//DurationObservation has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createDurationObservation_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//DurationObservation has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createDurationObservation_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//DurationObservation has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createDurationObservation_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//DurationObservation has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createDurationObservation_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//DurationObservation has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createDurationObservation_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//DurationObservation has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createDurationObservation_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//DurationObservation has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createDurationObservation_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//DurationObservation has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDurationObservation_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//DurationObservation has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createDurationObservation_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//DurationObservation has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createDurationObservation_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//DurationObservation has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createDurationObservation_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::ELEMENTIMPORT_CLASS:
		{
			if (nullptr == container)
			{
				return this->createElementImport(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ElementImport has elementImport as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_ELEMENTIMPORT:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createElementImport_as_elementImport_in_Namespace(castedContainer,metaElementID);
					}
					//ElementImport has metaclassReference as a containment
					case  uml::umlPackage::PROFILE_ATTRIBUTE_METACLASSREFERENCE:	
					{
						std::shared_ptr<Profile> castedContainer = std::dynamic_pointer_cast<Profile> (container);;
						return this->createElementImport_as_metaclassReference_in_Profile(castedContainer,metaElementID);
					}
					//ElementImport has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createElementImport_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ElementImport has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createElementImport_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ElementImport has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createElementImport_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::ENUMERATION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createEnumeration(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Enumeration has classifier as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_CLASSIFIER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createEnumeration_as_classifier_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//Enumeration has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createEnumeration_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Enumeration has contract as a containment
					case  uml::umlPackage::SUBSTITUTION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<Substitution> castedContainer = std::dynamic_pointer_cast<Substitution> (container);;
						return this->createEnumeration_as_contract_in_Substitution(castedContainer,metaElementID);
					}
					//Enumeration has endType as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_ENDTYPE:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createEnumeration_as_endType_in_Association(castedContainer,metaElementID);
					}
					//Enumeration has enumeration as a containment
					//Enumeration has general as a containment
					case  uml::umlPackage::GENERALIZATION_ATTRIBUTE_GENERAL:	
					{
						std::shared_ptr<Generalization> castedContainer = std::dynamic_pointer_cast<Generalization> (container);;
						return this->createEnumeration_as_general_in_Generalization(castedContainer,metaElementID);
					}
					//Enumeration has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createEnumeration_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Enumeration has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createEnumeration_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Enumeration has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createEnumeration_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Enumeration has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createEnumeration_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Enumeration has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createEnumeration_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Enumeration has nestedClassifier as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createEnumeration_as_nestedClassifier_in_Class(castedContainer,metaElementID);
					}
					//Enumeration has nestedClassifier as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createEnumeration_as_nestedClassifier_in_Interface(castedContainer,metaElementID);
					}
					//Enumeration has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createEnumeration_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Enumeration has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createEnumeration_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Enumeration has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createEnumeration_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Enumeration has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createEnumeration_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Enumeration has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createEnumeration_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Enumeration has ownedType as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDTYPE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createEnumeration_as_ownedType_in_Package(castedContainer,metaElementID);
					}
					//Enumeration has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createEnumeration_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Enumeration has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createEnumeration_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Enumeration has realizingClassifier as a containment
					case  uml::umlPackage::COMPONENTREALIZATION_ATTRIBUTE_REALIZINGCLASSIFIER:	
					{
						std::shared_ptr<ComponentRealization> castedContainer = std::dynamic_pointer_cast<ComponentRealization> (container);;
						return this->createEnumeration_as_realizingClassifier_in_ComponentRealization(castedContainer,metaElementID);
					}
					//Enumeration has redefinedClassifier as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REDEFINEDCLASSIFIER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createEnumeration_as_redefinedClassifier_in_Classifier(castedContainer,metaElementID);
					}
					//Enumeration has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createEnumeration_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Enumeration has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createEnumeration_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Enumeration has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createEnumeration_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Enumeration has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createEnumeration_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::ENUMERATIONLITERAL_CLASS:
		{
			if (nullptr == container)
			{
				return this->createEnumerationLiteral(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//EnumerationLiteral has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createEnumerationLiteral_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//EnumerationLiteral has deployedArtifact as a containment
					case  uml::umlPackage::DEPLOYMENT_ATTRIBUTE_DEPLOYEDARTIFACT:	
					{
						std::shared_ptr<Deployment> castedContainer = std::dynamic_pointer_cast<Deployment> (container);;
						return this->createEnumerationLiteral_as_deployedArtifact_in_Deployment(castedContainer,metaElementID);
					}
					//EnumerationLiteral has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createEnumerationLiteral_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//EnumerationLiteral has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createEnumerationLiteral_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//EnumerationLiteral has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createEnumerationLiteral_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//EnumerationLiteral has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createEnumerationLiteral_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//EnumerationLiteral has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createEnumerationLiteral_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//EnumerationLiteral has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createEnumerationLiteral_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//EnumerationLiteral has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createEnumerationLiteral_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//EnumerationLiteral has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createEnumerationLiteral_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//EnumerationLiteral has ownedLiteral as a containment
					case  uml::umlPackage::ENUMERATION_ATTRIBUTE_OWNEDLITERAL:	
					{
						std::weak_ptr<uml::Enumeration> castedContainer = std::dynamic_pointer_cast<uml::Enumeration> (container);
						return this->createEnumerationLiteral_as_ownedLiteral_in_Enumeration(castedContainer,metaElementID);
					}
					//EnumerationLiteral has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createEnumerationLiteral_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//EnumerationLiteral has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createEnumerationLiteral_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//EnumerationLiteral has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createEnumerationLiteral_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//EnumerationLiteral has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createEnumerationLiteral_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//EnumerationLiteral has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createEnumerationLiteral_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//EnumerationLiteral has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createEnumerationLiteral_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//EnumerationLiteral has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createEnumerationLiteral_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//EnumerationLiteral has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createEnumerationLiteral_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::EXCEPTIONHANDLER_CLASS:
		{
			if (nullptr == container)
			{
				return this->createExceptionHandler(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ExceptionHandler has handler as a containment
					case  uml::umlPackage::EXECUTABLENODE_ATTRIBUTE_HANDLER:	
					{
						std::weak_ptr<uml::ExecutableNode> castedContainer = std::dynamic_pointer_cast<uml::ExecutableNode> (container);
						return this->createExceptionHandler_as_handler_in_ExecutableNode(castedContainer,metaElementID);
					}
					//ExceptionHandler has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createExceptionHandler_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ExceptionHandler has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createExceptionHandler_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ExceptionHandler has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createExceptionHandler_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::EXECUTIONENVIRONMENT_CLASS:
		{
			if (nullptr == container)
			{
				return this->createExecutionEnvironment(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ExecutionEnvironment has classifier as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_CLASSIFIER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createExecutionEnvironment_as_classifier_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//ExecutionEnvironment has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createExecutionEnvironment_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ExecutionEnvironment has context as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_CONTEXT:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createExecutionEnvironment_as_context_in_Behavior(castedContainer,metaElementID);
					}
					//ExecutionEnvironment has contract as a containment
					case  uml::umlPackage::SUBSTITUTION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<Substitution> castedContainer = std::dynamic_pointer_cast<Substitution> (container);;
						return this->createExecutionEnvironment_as_contract_in_Substitution(castedContainer,metaElementID);
					}
					//ExecutionEnvironment has endType as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_ENDTYPE:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createExecutionEnvironment_as_endType_in_Association(castedContainer,metaElementID);
					}
					//ExecutionEnvironment has general as a containment
					case  uml::umlPackage::GENERALIZATION_ATTRIBUTE_GENERAL:	
					{
						std::shared_ptr<Generalization> castedContainer = std::dynamic_pointer_cast<Generalization> (container);;
						return this->createExecutionEnvironment_as_general_in_Generalization(castedContainer,metaElementID);
					}
					//ExecutionEnvironment has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createExecutionEnvironment_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//ExecutionEnvironment has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createExecutionEnvironment_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ExecutionEnvironment has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createExecutionEnvironment_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ExecutionEnvironment has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createExecutionEnvironment_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ExecutionEnvironment has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createExecutionEnvironment_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ExecutionEnvironment has nestedClassifier as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createExecutionEnvironment_as_nestedClassifier_in_Class(castedContainer,metaElementID);
					}
					//ExecutionEnvironment has nestedClassifier as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createExecutionEnvironment_as_nestedClassifier_in_Interface(castedContainer,metaElementID);
					}
					//ExecutionEnvironment has nestedNode as a containment
					case  uml::umlPackage::NODE_ATTRIBUTE_NESTEDNODE:	
					{
						std::shared_ptr<Node> castedContainer = std::dynamic_pointer_cast<Node> (container);;
						return this->createExecutionEnvironment_as_nestedNode_in_Node(castedContainer,metaElementID);
					}
					//ExecutionEnvironment has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createExecutionEnvironment_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//ExecutionEnvironment has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createExecutionEnvironment_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//ExecutionEnvironment has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createExecutionEnvironment_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ExecutionEnvironment has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createExecutionEnvironment_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ExecutionEnvironment has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createExecutionEnvironment_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//ExecutionEnvironment has ownedType as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDTYPE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createExecutionEnvironment_as_ownedType_in_Package(castedContainer,metaElementID);
					}
					//ExecutionEnvironment has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createExecutionEnvironment_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//ExecutionEnvironment has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createExecutionEnvironment_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//ExecutionEnvironment has realizingClassifier as a containment
					case  uml::umlPackage::COMPONENTREALIZATION_ATTRIBUTE_REALIZINGCLASSIFIER:	
					{
						std::shared_ptr<ComponentRealization> castedContainer = std::dynamic_pointer_cast<ComponentRealization> (container);;
						return this->createExecutionEnvironment_as_realizingClassifier_in_ComponentRealization(castedContainer,metaElementID);
					}
					//ExecutionEnvironment has redefinedClassifier as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REDEFINEDCLASSIFIER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createExecutionEnvironment_as_redefinedClassifier_in_Classifier(castedContainer,metaElementID);
					}
					//ExecutionEnvironment has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createExecutionEnvironment_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ExecutionEnvironment has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createExecutionEnvironment_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ExecutionEnvironment has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createExecutionEnvironment_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ExecutionEnvironment has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createExecutionEnvironment_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::EXECUTIONOCCURRENCESPECIFICATION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createExecutionOccurrenceSpecification(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ExecutionOccurrenceSpecification has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createExecutionOccurrenceSpecification_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ExecutionOccurrenceSpecification has fragment as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::Interaction> castedContainer = std::dynamic_pointer_cast<uml::Interaction> (container);
						return this->createExecutionOccurrenceSpecification_as_fragment_in_Interaction(castedContainer,metaElementID);
					}
					//ExecutionOccurrenceSpecification has fragment as a containment
					case  uml::umlPackage::INTERACTIONOPERAND_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::InteractionOperand> castedContainer = std::dynamic_pointer_cast<uml::InteractionOperand> (container);
						return this->createExecutionOccurrenceSpecification_as_fragment_in_InteractionOperand(castedContainer,metaElementID);
					}
					//ExecutionOccurrenceSpecification has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createExecutionOccurrenceSpecification_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ExecutionOccurrenceSpecification has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createExecutionOccurrenceSpecification_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ExecutionOccurrenceSpecification has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createExecutionOccurrenceSpecification_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ExecutionOccurrenceSpecification has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createExecutionOccurrenceSpecification_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ExecutionOccurrenceSpecification has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createExecutionOccurrenceSpecification_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ExecutionOccurrenceSpecification has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createExecutionOccurrenceSpecification_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ExecutionOccurrenceSpecification has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createExecutionOccurrenceSpecification_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ExecutionOccurrenceSpecification has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createExecutionOccurrenceSpecification_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::EXPANSIONNODE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createExpansionNode(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ExpansionNode has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createExpansionNode_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ExpansionNode has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createExpansionNode_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ExpansionNode has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createExpansionNode_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ExpansionNode has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createExpansionNode_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ExpansionNode has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createExpansionNode_as_node_in_Activity(castedContainer,metaElementID);
					}
					//ExpansionNode has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createExpansionNode_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//ExpansionNode has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createExpansionNode_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//ExpansionNode has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createExpansionNode_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//ExpansionNode has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createExpansionNode_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ExpansionNode has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createExpansionNode_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ExpansionNode has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createExpansionNode_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//ExpansionNode has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createExpansionNode_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//ExpansionNode has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createExpansionNode_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ExpansionNode has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createExpansionNode_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ExpansionNode has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createExpansionNode_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::EXPANSIONREGION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createExpansionRegion(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ExpansionRegion has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createExpansionRegion_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//ExpansionRegion has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createExpansionRegion_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ExpansionRegion has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createExpansionRegion_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//ExpansionRegion has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createExpansionRegion_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//ExpansionRegion has group as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_GROUP:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createExpansionRegion_as_group_in_Activity(castedContainer,metaElementID);
					}
					//ExpansionRegion has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createExpansionRegion_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ExpansionRegion has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createExpansionRegion_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ExpansionRegion has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createExpansionRegion_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ExpansionRegion has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createExpansionRegion_as_node_in_Activity(castedContainer,metaElementID);
					}
					//ExpansionRegion has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createExpansionRegion_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//ExpansionRegion has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createExpansionRegion_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//ExpansionRegion has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createExpansionRegion_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//ExpansionRegion has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createExpansionRegion_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ExpansionRegion has ownedGroup as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDGROUP:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createExpansionRegion_as_ownedGroup_in_Activity(castedContainer,metaElementID);
					}
					//ExpansionRegion has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createExpansionRegion_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ExpansionRegion has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createExpansionRegion_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//ExpansionRegion has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createExpansionRegion_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//ExpansionRegion has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createExpansionRegion_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ExpansionRegion has structuredNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_STRUCTUREDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createExpansionRegion_as_structuredNode_in_Activity(castedContainer,metaElementID);
					}
					//ExpansionRegion has subgroup as a containment
					case  uml::umlPackage::ACTIVITYGROUP_ATTRIBUTE_SUBGROUP:	
					{
						std::weak_ptr<uml::ActivityGroup> castedContainer = std::dynamic_pointer_cast<uml::ActivityGroup> (container);
						return this->createExpansionRegion_as_subgroup_in_ActivityGroup(castedContainer,metaElementID);
					}
					//ExpansionRegion has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createExpansionRegion_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ExpansionRegion has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createExpansionRegion_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::EXPRESSION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createExpression(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Expression has argument as a containment
					case  uml::umlPackage::MESSAGE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<Message> castedContainer = std::dynamic_pointer_cast<Message> (container);;
						return this->createExpression_as_argument_in_Message(castedContainer,metaElementID);
					}
					//Expression has argument as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createExpression_as_argument_in_InteractionUse(castedContainer,metaElementID);
					}
					//Expression has changeExpression as a containment
					case  uml::umlPackage::CHANGEEVENT_ATTRIBUTE_CHANGEEXPRESSION:	
					{
						std::shared_ptr<ChangeEvent> castedContainer = std::dynamic_pointer_cast<ChangeEvent> (container);;
						return this->createExpression_as_changeExpression_in_ChangeEvent(castedContainer,metaElementID);
					}
					//Expression has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createExpression_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Expression has defaultValue as a containment
					case  uml::umlPackage::PROPERTY_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Property> castedContainer = std::dynamic_pointer_cast<Property> (container);;
						return this->createExpression_as_defaultValue_in_Property(castedContainer,metaElementID);
					}
					//Expression has defaultValue as a containment
					case  uml::umlPackage::PARAMETER_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Parameter> castedContainer = std::dynamic_pointer_cast<Parameter> (container);;
						return this->createExpression_as_defaultValue_in_Parameter(castedContainer,metaElementID);
					}
					//Expression has expr as a containment
					case  uml::umlPackage::TIMEEXPRESSION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<TimeExpression> castedContainer = std::dynamic_pointer_cast<TimeExpression> (container);;
						return this->createExpression_as_expr_in_TimeExpression(castedContainer,metaElementID);
					}
					//Expression has expr as a containment
					case  uml::umlPackage::DURATION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<Duration> castedContainer = std::dynamic_pointer_cast<Duration> (container);;
						return this->createExpression_as_expr_in_Duration(castedContainer,metaElementID);
					}
					//Expression has guard as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_GUARD:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createExpression_as_guard_in_ActivityEdge(castedContainer,metaElementID);
					}
					//Expression has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createExpression_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Expression has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createExpression_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Expression has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createExpression_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Expression has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createExpression_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Expression has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createExpression_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Expression has joinSpec as a containment
					case  uml::umlPackage::JOINNODE_ATTRIBUTE_JOINSPEC:	
					{
						std::shared_ptr<JoinNode> castedContainer = std::dynamic_pointer_cast<JoinNode> (container);;
						return this->createExpression_as_joinSpec_in_JoinNode(castedContainer,metaElementID);
					}
					//Expression has lowerValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_LOWERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createExpression_as_lowerValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//Expression has maxint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MAXINT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createExpression_as_maxint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//Expression has minint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MININT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createExpression_as_minint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//Expression has operand as a containment
					case  uml::umlPackage::EXPRESSION_ATTRIBUTE_OPERAND:	
					{
						std::shared_ptr<Expression> castedContainer = std::dynamic_pointer_cast<Expression> (container);;
						return this->createExpression_as_operand_in_Expression(castedContainer,metaElementID);
					}
					//Expression has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createExpression_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Expression has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createExpression_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Expression has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createExpression_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Expression has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createExpression_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Expression has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createExpression_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Expression has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createExpression_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Expression has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createExpression_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Expression has returnValue as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_RETURNVALUE:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createExpression_as_returnValue_in_InteractionUse(castedContainer,metaElementID);
					}
					//Expression has selector as a containment
					case  uml::umlPackage::LIFELINE_ATTRIBUTE_SELECTOR:	
					{
						std::shared_ptr<Lifeline> castedContainer = std::dynamic_pointer_cast<Lifeline> (container);;
						return this->createExpression_as_selector_in_Lifeline(castedContainer,metaElementID);
					}
					//Expression has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createExpression_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Expression has specification as a containment
					case  uml::umlPackage::CONSTRAINT_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<Constraint> castedContainer = std::dynamic_pointer_cast<Constraint> (container);;
						return this->createExpression_as_specification_in_Constraint(castedContainer,metaElementID);
					}
					//Expression has specification as a containment
					case  uml::umlPackage::INSTANCESPECIFICATION_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<InstanceSpecification> castedContainer = std::dynamic_pointer_cast<InstanceSpecification> (container);;
						return this->createExpression_as_specification_in_InstanceSpecification(castedContainer,metaElementID);
					}
					//Expression has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createExpression_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Expression has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createExpression_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Expression has upperBound as a containment
					case  uml::umlPackage::OBJECTNODE_ATTRIBUTE_UPPERBOUND:	
					{
						std::shared_ptr<ObjectNode> castedContainer = std::dynamic_pointer_cast<ObjectNode> (container);;
						return this->createExpression_as_upperBound_in_ObjectNode(castedContainer,metaElementID);
					}
					//Expression has upperValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_UPPERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createExpression_as_upperValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//Expression has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createExpression_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					//Expression has value as a containment
					case  uml::umlPackage::SLOT_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::Slot> castedContainer = std::dynamic_pointer_cast<uml::Slot> (container);
						return this->createExpression_as_value_in_Slot(castedContainer,metaElementID);
					}
					//Expression has value as a containment
					case  uml::umlPackage::VALUESPECIFICATIONACTION_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::ValueSpecificationAction> castedContainer = std::dynamic_pointer_cast<uml::ValueSpecificationAction> (container);
						return this->createExpression_as_value_in_ValueSpecificationAction(castedContainer,metaElementID);
					}
					//Expression has value as a containment
					case  uml::umlPackage::VALUEPIN_ATTRIBUTE_VALUE:	
					{
						std::shared_ptr<ValuePin> castedContainer = std::dynamic_pointer_cast<ValuePin> (container);;
						return this->createExpression_as_value_in_ValuePin(castedContainer,metaElementID);
					}
					//Expression has weight as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_WEIGHT:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createExpression_as_weight_in_ActivityEdge(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::EXTEND_CLASS:
		{
			if (nullptr == container)
			{
				return this->createExtend(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Extend has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createExtend_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Extend has extend as a containment
					case  uml::umlPackage::USECASE_ATTRIBUTE_EXTEND:	
					{
						std::weak_ptr<uml::UseCase> castedContainer = std::dynamic_pointer_cast<uml::UseCase> (container);
						return this->createExtend_as_extend_in_UseCase(castedContainer,metaElementID);
					}
					//Extend has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createExtend_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Extend has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createExtend_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Extend has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createExtend_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Extend has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createExtend_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Extend has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createExtend_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Extend has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createExtend_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Extend has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createExtend_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Extend has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createExtend_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::EXTENSION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createExtension(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Extension has classifier as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_CLASSIFIER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createExtension_as_classifier_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//Extension has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createExtension_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Extension has contract as a containment
					case  uml::umlPackage::SUBSTITUTION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<Substitution> castedContainer = std::dynamic_pointer_cast<Substitution> (container);;
						return this->createExtension_as_contract_in_Substitution(castedContainer,metaElementID);
					}
					//Extension has endType as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_ENDTYPE:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createExtension_as_endType_in_Association(castedContainer,metaElementID);
					}
					//Extension has general as a containment
					case  uml::umlPackage::GENERALIZATION_ATTRIBUTE_GENERAL:	
					{
						std::shared_ptr<Generalization> castedContainer = std::dynamic_pointer_cast<Generalization> (container);;
						return this->createExtension_as_general_in_Generalization(castedContainer,metaElementID);
					}
					//Extension has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createExtension_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Extension has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createExtension_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Extension has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createExtension_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Extension has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createExtension_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Extension has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createExtension_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Extension has nestedClassifier as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createExtension_as_nestedClassifier_in_Class(castedContainer,metaElementID);
					}
					//Extension has nestedClassifier as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createExtension_as_nestedClassifier_in_Interface(castedContainer,metaElementID);
					}
					//Extension has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createExtension_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Extension has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createExtension_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Extension has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createExtension_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Extension has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createExtension_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Extension has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createExtension_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Extension has ownedType as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDTYPE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createExtension_as_ownedType_in_Package(castedContainer,metaElementID);
					}
					//Extension has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createExtension_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Extension has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createExtension_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Extension has realizingClassifier as a containment
					case  uml::umlPackage::COMPONENTREALIZATION_ATTRIBUTE_REALIZINGCLASSIFIER:	
					{
						std::shared_ptr<ComponentRealization> castedContainer = std::dynamic_pointer_cast<ComponentRealization> (container);;
						return this->createExtension_as_realizingClassifier_in_ComponentRealization(castedContainer,metaElementID);
					}
					//Extension has redefinedClassifier as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REDEFINEDCLASSIFIER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createExtension_as_redefinedClassifier_in_Classifier(castedContainer,metaElementID);
					}
					//Extension has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createExtension_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Extension has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createExtension_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Extension has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createExtension_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Extension has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createExtension_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::EXTENSIONEND_CLASS:
		{
			if (nullptr == container)
			{
				return this->createExtensionEnd(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ExtensionEnd has attribute as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_ATTRIBUTE:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createExtensionEnd_as_attribute_in_Classifier(castedContainer,metaElementID);
					}
					//ExtensionEnd has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createExtensionEnd_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ExtensionEnd has collaborationRole as a containment
					case  uml::umlPackage::COLLABORATION_ATTRIBUTE_COLLABORATIONROLE:	
					{
						std::shared_ptr<Collaboration> castedContainer = std::dynamic_pointer_cast<Collaboration> (container);;
						return this->createExtensionEnd_as_collaborationRole_in_Collaboration(castedContainer,metaElementID);
					}
					//ExtensionEnd has feature as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_FEATURE:	
					{
						std::shared_ptr<uml::Classifier> castedContainer = std::dynamic_pointer_cast<uml::Classifier> (container);
						return this->createExtensionEnd_as_feature_in_Classifier(castedContainer,metaElementID);
					}
					//ExtensionEnd has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createExtensionEnd_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ExtensionEnd has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createExtensionEnd_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ExtensionEnd has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createExtensionEnd_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ExtensionEnd has memberEnd as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_MEMBEREND:	
					{
						std::shared_ptr<uml::Association> castedContainer = std::dynamic_pointer_cast<uml::Association> (container);
						return this->createExtensionEnd_as_memberEnd_in_Association(castedContainer,metaElementID);
					}
					//ExtensionEnd has navigableOwnedEnd as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_NAVIGABLEOWNEDEND:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createExtensionEnd_as_navigableOwnedEnd_in_Association(castedContainer,metaElementID);
					}
					//ExtensionEnd has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createExtensionEnd_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//ExtensionEnd has ownedAttribute as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_OWNEDATTRIBUTE:	
					{
						std::weak_ptr<uml::Class> castedContainer = std::dynamic_pointer_cast<uml::Class> (container);
						return this->createExtensionEnd_as_ownedAttribute_in_Class(castedContainer,metaElementID);
					}
					//ExtensionEnd has ownedAttribute as a containment
					case  uml::umlPackage::ARTIFACT_ATTRIBUTE_OWNEDATTRIBUTE:	
					{
						std::shared_ptr<Artifact> castedContainer = std::dynamic_pointer_cast<Artifact> (container);;
						return this->createExtensionEnd_as_ownedAttribute_in_Artifact(castedContainer,metaElementID);
					}
					//ExtensionEnd has ownedAttribute as a containment
					case  uml::umlPackage::DATATYPE_ATTRIBUTE_OWNEDATTRIBUTE:	
					{
						std::weak_ptr<uml::DataType> castedContainer = std::dynamic_pointer_cast<uml::DataType> (container);
						return this->createExtensionEnd_as_ownedAttribute_in_DataType(castedContainer,metaElementID);
					}
					//ExtensionEnd has ownedAttribute as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_OWNEDATTRIBUTE:	
					{
						std::weak_ptr<uml::Interface> castedContainer = std::dynamic_pointer_cast<uml::Interface> (container);
						return this->createExtensionEnd_as_ownedAttribute_in_Interface(castedContainer,metaElementID);
					}
					//ExtensionEnd has ownedAttribute as a containment
					case  uml::umlPackage::SIGNAL_ATTRIBUTE_OWNEDATTRIBUTE:	
					{
						std::shared_ptr<Signal> castedContainer = std::dynamic_pointer_cast<Signal> (container);;
						return this->createExtensionEnd_as_ownedAttribute_in_Signal(castedContainer,metaElementID);
					}
					//ExtensionEnd has ownedAttribute as a containment
					case  uml::umlPackage::STRUCTUREDCLASSIFIER_ATTRIBUTE_OWNEDATTRIBUTE:	
					{
						std::shared_ptr<StructuredClassifier> castedContainer = std::dynamic_pointer_cast<StructuredClassifier> (container);;
						return this->createExtensionEnd_as_ownedAttribute_in_StructuredClassifier(castedContainer,metaElementID);
					}
					//ExtensionEnd has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createExtensionEnd_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//ExtensionEnd has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createExtensionEnd_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ExtensionEnd has ownedEnd as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_OWNEDEND:	
					{
						std::weak_ptr<uml::Association> castedContainer = std::dynamic_pointer_cast<uml::Association> (container);
						return this->createExtensionEnd_as_ownedEnd_in_Association(castedContainer,metaElementID);
					}
					//ExtensionEnd has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createExtensionEnd_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ExtensionEnd has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createExtensionEnd_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//ExtensionEnd has qualifier as a containment
					case  uml::umlPackage::PROPERTY_ATTRIBUTE_QUALIFIER:	
					{
						std::weak_ptr<uml::Property> castedContainer = std::dynamic_pointer_cast<uml::Property> (container);
						return this->createExtensionEnd_as_qualifier_in_Property(castedContainer,metaElementID);
					}
					//ExtensionEnd has redefinedProperty as a containment
					case  uml::umlPackage::PROPERTY_ATTRIBUTE_REDEFINEDPROPERTY:	
					{
						std::shared_ptr<Property> castedContainer = std::dynamic_pointer_cast<Property> (container);;
						return this->createExtensionEnd_as_redefinedProperty_in_Property(castedContainer,metaElementID);
					}
					//ExtensionEnd has role as a containment
					case  uml::umlPackage::STRUCTUREDCLASSIFIER_ATTRIBUTE_ROLE:	
					{
						std::shared_ptr<StructuredClassifier> castedContainer = std::dynamic_pointer_cast<StructuredClassifier> (container);;
						return this->createExtensionEnd_as_role_in_StructuredClassifier(castedContainer,metaElementID);
					}
					//ExtensionEnd has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createExtensionEnd_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ExtensionEnd has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createExtensionEnd_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ExtensionEnd has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createExtensionEnd_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::EXTENSIONPOINT_CLASS:
		{
			if (nullptr == container)
			{
				return this->createExtensionPoint(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ExtensionPoint has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createExtensionPoint_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ExtensionPoint has extensionPoint as a containment
					case  uml::umlPackage::USECASE_ATTRIBUTE_EXTENSIONPOINT:	
					{
						std::weak_ptr<uml::UseCase> castedContainer = std::dynamic_pointer_cast<uml::UseCase> (container);
						return this->createExtensionPoint_as_extensionPoint_in_UseCase(castedContainer,metaElementID);
					}
					//ExtensionPoint has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createExtensionPoint_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ExtensionPoint has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createExtensionPoint_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ExtensionPoint has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createExtensionPoint_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ExtensionPoint has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createExtensionPoint_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ExtensionPoint has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createExtensionPoint_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ExtensionPoint has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createExtensionPoint_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ExtensionPoint has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createExtensionPoint_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ExtensionPoint has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createExtensionPoint_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::FACTORY_CLASS:
		{
			if (nullptr == container)
			{
				return this->createFactory(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Factory has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createFactory_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Factory has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createFactory_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Factory has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createFactory_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::FINALSTATE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createFinalState(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//FinalState has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createFinalState_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//FinalState has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createFinalState_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//FinalState has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createFinalState_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//FinalState has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createFinalState_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//FinalState has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createFinalState_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//FinalState has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createFinalState_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//FinalState has redefinedState as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_REDEFINEDSTATE:	
					{
						std::shared_ptr<State> castedContainer = std::dynamic_pointer_cast<State> (container);;
						return this->createFinalState_as_redefinedState_in_State(castedContainer,metaElementID);
					}
					//FinalState has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createFinalState_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//FinalState has subvertex as a containment
					case  uml::umlPackage::REGION_ATTRIBUTE_SUBVERTEX:	
					{
						std::weak_ptr<uml::Region> castedContainer = std::dynamic_pointer_cast<uml::Region> (container);
						return this->createFinalState_as_subvertex_in_Region(castedContainer,metaElementID);
					}
					//FinalState has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createFinalState_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//FinalState has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createFinalState_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::FLOWFINALNODE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createFlowFinalNode(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//FlowFinalNode has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createFlowFinalNode_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//FlowFinalNode has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createFlowFinalNode_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//FlowFinalNode has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createFlowFinalNode_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//FlowFinalNode has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createFlowFinalNode_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//FlowFinalNode has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createFlowFinalNode_as_node_in_Activity(castedContainer,metaElementID);
					}
					//FlowFinalNode has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createFlowFinalNode_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//FlowFinalNode has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createFlowFinalNode_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//FlowFinalNode has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createFlowFinalNode_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//FlowFinalNode has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createFlowFinalNode_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//FlowFinalNode has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createFlowFinalNode_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//FlowFinalNode has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createFlowFinalNode_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//FlowFinalNode has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createFlowFinalNode_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//FlowFinalNode has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createFlowFinalNode_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//FlowFinalNode has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createFlowFinalNode_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//FlowFinalNode has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createFlowFinalNode_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::FORKNODE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createForkNode(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ForkNode has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createForkNode_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ForkNode has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createForkNode_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ForkNode has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createForkNode_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ForkNode has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createForkNode_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ForkNode has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createForkNode_as_node_in_Activity(castedContainer,metaElementID);
					}
					//ForkNode has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createForkNode_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//ForkNode has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createForkNode_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//ForkNode has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createForkNode_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//ForkNode has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createForkNode_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ForkNode has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createForkNode_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ForkNode has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createForkNode_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//ForkNode has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createForkNode_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//ForkNode has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createForkNode_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ForkNode has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createForkNode_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ForkNode has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createForkNode_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::FUNCTIONBEHAVIOR_CLASS:
		{
			if (nullptr == container)
			{
				return this->createFunctionBehavior(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//FunctionBehavior has classifier as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_CLASSIFIER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createFunctionBehavior_as_classifier_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//FunctionBehavior has classifierBehavior as a containment
					case  uml::umlPackage::BEHAVIOREDCLASSIFIER_ATTRIBUTE_CLASSIFIERBEHAVIOR:	
					{
						std::shared_ptr<BehavioredClassifier> castedContainer = std::dynamic_pointer_cast<BehavioredClassifier> (container);;
						return this->createFunctionBehavior_as_classifierBehavior_in_BehavioredClassifier(castedContainer,metaElementID);
					}
					//FunctionBehavior has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createFunctionBehavior_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//FunctionBehavior has context as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_CONTEXT:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createFunctionBehavior_as_context_in_Behavior(castedContainer,metaElementID);
					}
					//FunctionBehavior has contract as a containment
					case  uml::umlPackage::SUBSTITUTION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<Substitution> castedContainer = std::dynamic_pointer_cast<Substitution> (container);;
						return this->createFunctionBehavior_as_contract_in_Substitution(castedContainer,metaElementID);
					}
					//FunctionBehavior has doActivity as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_DOACTIVITY:	
					{
						std::shared_ptr<State> castedContainer = std::dynamic_pointer_cast<State> (container);;
						return this->createFunctionBehavior_as_doActivity_in_State(castedContainer,metaElementID);
					}
					//FunctionBehavior has effect as a containment
					case  uml::umlPackage::TRANSITION_ATTRIBUTE_EFFECT:	
					{
						std::shared_ptr<Transition> castedContainer = std::dynamic_pointer_cast<Transition> (container);;
						return this->createFunctionBehavior_as_effect_in_Transition(castedContainer,metaElementID);
					}
					//FunctionBehavior has endType as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_ENDTYPE:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createFunctionBehavior_as_endType_in_Association(castedContainer,metaElementID);
					}
					//FunctionBehavior has entry as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_ENTRY:	
					{
						std::shared_ptr<State> castedContainer = std::dynamic_pointer_cast<State> (container);;
						return this->createFunctionBehavior_as_entry_in_State(castedContainer,metaElementID);
					}
					//FunctionBehavior has exit as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_EXIT:	
					{
						std::shared_ptr<State> castedContainer = std::dynamic_pointer_cast<State> (container);;
						return this->createFunctionBehavior_as_exit_in_State(castedContainer,metaElementID);
					}
					//FunctionBehavior has general as a containment
					case  uml::umlPackage::GENERALIZATION_ATTRIBUTE_GENERAL:	
					{
						std::shared_ptr<Generalization> castedContainer = std::dynamic_pointer_cast<Generalization> (container);;
						return this->createFunctionBehavior_as_general_in_Generalization(castedContainer,metaElementID);
					}
					//FunctionBehavior has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createFunctionBehavior_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//FunctionBehavior has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createFunctionBehavior_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//FunctionBehavior has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createFunctionBehavior_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//FunctionBehavior has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createFunctionBehavior_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//FunctionBehavior has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createFunctionBehavior_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//FunctionBehavior has nestedClassifier as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createFunctionBehavior_as_nestedClassifier_in_Class(castedContainer,metaElementID);
					}
					//FunctionBehavior has nestedClassifier as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createFunctionBehavior_as_nestedClassifier_in_Interface(castedContainer,metaElementID);
					}
					//FunctionBehavior has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createFunctionBehavior_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//FunctionBehavior has ownedBehavior as a containment
					case  uml::umlPackage::BEHAVIOREDCLASSIFIER_ATTRIBUTE_OWNEDBEHAVIOR:	
					{
						std::weak_ptr<uml::BehavioredClassifier> castedContainer = std::dynamic_pointer_cast<uml::BehavioredClassifier> (container);
						return this->createFunctionBehavior_as_ownedBehavior_in_BehavioredClassifier(castedContainer,metaElementID);
					}
					//FunctionBehavior has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createFunctionBehavior_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//FunctionBehavior has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createFunctionBehavior_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//FunctionBehavior has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createFunctionBehavior_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//FunctionBehavior has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createFunctionBehavior_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//FunctionBehavior has ownedType as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDTYPE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createFunctionBehavior_as_ownedType_in_Package(castedContainer,metaElementID);
					}
					//FunctionBehavior has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createFunctionBehavior_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//FunctionBehavior has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createFunctionBehavior_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//FunctionBehavior has realizingClassifier as a containment
					case  uml::umlPackage::COMPONENTREALIZATION_ATTRIBUTE_REALIZINGCLASSIFIER:	
					{
						std::shared_ptr<ComponentRealization> castedContainer = std::dynamic_pointer_cast<ComponentRealization> (container);;
						return this->createFunctionBehavior_as_realizingClassifier_in_ComponentRealization(castedContainer,metaElementID);
					}
					//FunctionBehavior has redefinedBehavior as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_REDEFINEDBEHAVIOR:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createFunctionBehavior_as_redefinedBehavior_in_Behavior(castedContainer,metaElementID);
					}
					//FunctionBehavior has redefinedClassifier as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REDEFINEDCLASSIFIER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createFunctionBehavior_as_redefinedClassifier_in_Classifier(castedContainer,metaElementID);
					}
					//FunctionBehavior has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createFunctionBehavior_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//FunctionBehavior has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createFunctionBehavior_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//FunctionBehavior has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createFunctionBehavior_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//FunctionBehavior has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createFunctionBehavior_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::GATE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createGate(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Gate has actualGate as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_ACTUALGATE:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createGate_as_actualGate_in_InteractionUse(castedContainer,metaElementID);
					}
					//Gate has cfragmentGate as a containment
					case  uml::umlPackage::COMBINEDFRAGMENT_ATTRIBUTE_CFRAGMENTGATE:	
					{
						std::shared_ptr<CombinedFragment> castedContainer = std::dynamic_pointer_cast<CombinedFragment> (container);;
						return this->createGate_as_cfragmentGate_in_CombinedFragment(castedContainer,metaElementID);
					}
					//Gate has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createGate_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Gate has formalGate as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_FORMALGATE:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createGate_as_formalGate_in_Interaction(castedContainer,metaElementID);
					}
					//Gate has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createGate_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Gate has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createGate_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Gate has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createGate_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Gate has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createGate_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Gate has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createGate_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Gate has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createGate_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Gate has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createGate_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Gate has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createGate_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::GENERALORDERING_CLASS:
		{
			if (nullptr == container)
			{
				return this->createGeneralOrdering(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//GeneralOrdering has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createGeneralOrdering_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//GeneralOrdering has generalOrdering as a containment
					case  uml::umlPackage::INTERACTIONFRAGMENT_ATTRIBUTE_GENERALORDERING:	
					{
						std::shared_ptr<InteractionFragment> castedContainer = std::dynamic_pointer_cast<InteractionFragment> (container);;
						return this->createGeneralOrdering_as_generalOrdering_in_InteractionFragment(castedContainer,metaElementID);
					}
					//GeneralOrdering has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createGeneralOrdering_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//GeneralOrdering has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createGeneralOrdering_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//GeneralOrdering has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createGeneralOrdering_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//GeneralOrdering has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createGeneralOrdering_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//GeneralOrdering has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createGeneralOrdering_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//GeneralOrdering has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createGeneralOrdering_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//GeneralOrdering has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createGeneralOrdering_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//GeneralOrdering has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createGeneralOrdering_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::GENERALIZATION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createGeneralization(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Generalization has generalization as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_GENERALIZATION:	
					{
						std::weak_ptr<uml::Classifier> castedContainer = std::dynamic_pointer_cast<uml::Classifier> (container);
						return this->createGeneralization_as_generalization_in_Classifier(castedContainer,metaElementID);
					}
					//Generalization has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createGeneralization_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Generalization has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createGeneralization_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Generalization has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createGeneralization_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::GENERALIZATIONSET_CLASS:
		{
			if (nullptr == container)
			{
				return this->createGeneralizationSet(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//GeneralizationSet has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createGeneralizationSet_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//GeneralizationSet has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createGeneralizationSet_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//GeneralizationSet has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createGeneralizationSet_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//GeneralizationSet has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createGeneralizationSet_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//GeneralizationSet has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createGeneralizationSet_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//GeneralizationSet has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createGeneralizationSet_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//GeneralizationSet has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createGeneralizationSet_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//GeneralizationSet has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createGeneralizationSet_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//GeneralizationSet has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createGeneralizationSet_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//GeneralizationSet has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createGeneralizationSet_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//GeneralizationSet has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createGeneralizationSet_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//GeneralizationSet has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createGeneralizationSet_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//GeneralizationSet has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createGeneralizationSet_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//GeneralizationSet has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createGeneralizationSet_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//GeneralizationSet has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createGeneralizationSet_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//GeneralizationSet has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createGeneralizationSet_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//GeneralizationSet has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createGeneralizationSet_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::IMAGE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createImage(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Image has icon as a containment
					case  uml::umlPackage::STEREOTYPE_ATTRIBUTE_ICON:	
					{
						std::shared_ptr<Stereotype> castedContainer = std::dynamic_pointer_cast<Stereotype> (container);;
						return this->createImage_as_icon_in_Stereotype(castedContainer,metaElementID);
					}
					//Image has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createImage_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Image has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createImage_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Image has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createImage_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::INCLUDE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createInclude(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Include has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInclude_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Include has include as a containment
					case  uml::umlPackage::USECASE_ATTRIBUTE_INCLUDE:	
					{
						std::weak_ptr<uml::UseCase> castedContainer = std::dynamic_pointer_cast<uml::UseCase> (container);
						return this->createInclude_as_include_in_UseCase(castedContainer,metaElementID);
					}
					//Include has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInclude_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Include has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInclude_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Include has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createInclude_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Include has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createInclude_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Include has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createInclude_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Include has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInclude_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Include has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInclude_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Include has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInclude_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::INFORMATIONFLOW_CLASS:
		{
			if (nullptr == container)
			{
				return this->createInformationFlow(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//InformationFlow has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInformationFlow_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//InformationFlow has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createInformationFlow_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//InformationFlow has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createInformationFlow_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//InformationFlow has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInformationFlow_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//InformationFlow has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInformationFlow_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//InformationFlow has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createInformationFlow_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//InformationFlow has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createInformationFlow_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//InformationFlow has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createInformationFlow_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//InformationFlow has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createInformationFlow_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//InformationFlow has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createInformationFlow_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//InformationFlow has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createInformationFlow_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//InformationFlow has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createInformationFlow_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//InformationFlow has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createInformationFlow_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//InformationFlow has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInformationFlow_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//InformationFlow has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInformationFlow_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//InformationFlow has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInformationFlow_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//InformationFlow has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createInformationFlow_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::INFORMATIONITEM_CLASS:
		{
			if (nullptr == container)
			{
				return this->createInformationItem(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//InformationItem has classifier as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_CLASSIFIER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createInformationItem_as_classifier_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//InformationItem has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInformationItem_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//InformationItem has contract as a containment
					case  uml::umlPackage::SUBSTITUTION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<Substitution> castedContainer = std::dynamic_pointer_cast<Substitution> (container);;
						return this->createInformationItem_as_contract_in_Substitution(castedContainer,metaElementID);
					}
					//InformationItem has endType as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_ENDTYPE:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createInformationItem_as_endType_in_Association(castedContainer,metaElementID);
					}
					//InformationItem has general as a containment
					case  uml::umlPackage::GENERALIZATION_ATTRIBUTE_GENERAL:	
					{
						std::shared_ptr<Generalization> castedContainer = std::dynamic_pointer_cast<Generalization> (container);;
						return this->createInformationItem_as_general_in_Generalization(castedContainer,metaElementID);
					}
					//InformationItem has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createInformationItem_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//InformationItem has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createInformationItem_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//InformationItem has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInformationItem_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//InformationItem has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInformationItem_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//InformationItem has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createInformationItem_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//InformationItem has nestedClassifier as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createInformationItem_as_nestedClassifier_in_Class(castedContainer,metaElementID);
					}
					//InformationItem has nestedClassifier as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createInformationItem_as_nestedClassifier_in_Interface(castedContainer,metaElementID);
					}
					//InformationItem has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createInformationItem_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//InformationItem has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createInformationItem_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//InformationItem has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createInformationItem_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//InformationItem has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createInformationItem_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//InformationItem has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createInformationItem_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//InformationItem has ownedType as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDTYPE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createInformationItem_as_ownedType_in_Package(castedContainer,metaElementID);
					}
					//InformationItem has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createInformationItem_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//InformationItem has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createInformationItem_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//InformationItem has realizingClassifier as a containment
					case  uml::umlPackage::COMPONENTREALIZATION_ATTRIBUTE_REALIZINGCLASSIFIER:	
					{
						std::shared_ptr<ComponentRealization> castedContainer = std::dynamic_pointer_cast<ComponentRealization> (container);;
						return this->createInformationItem_as_realizingClassifier_in_ComponentRealization(castedContainer,metaElementID);
					}
					//InformationItem has redefinedClassifier as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REDEFINEDCLASSIFIER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createInformationItem_as_redefinedClassifier_in_Classifier(castedContainer,metaElementID);
					}
					//InformationItem has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInformationItem_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//InformationItem has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInformationItem_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//InformationItem has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInformationItem_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//InformationItem has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createInformationItem_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::INITIALNODE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createInitialNode(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//InitialNode has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInitialNode_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//InitialNode has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInitialNode_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//InitialNode has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInitialNode_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//InitialNode has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createInitialNode_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//InitialNode has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createInitialNode_as_node_in_Activity(castedContainer,metaElementID);
					}
					//InitialNode has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createInitialNode_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//InitialNode has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createInitialNode_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//InitialNode has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createInitialNode_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//InitialNode has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createInitialNode_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//InitialNode has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createInitialNode_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//InitialNode has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createInitialNode_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//InitialNode has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createInitialNode_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//InitialNode has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInitialNode_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//InitialNode has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInitialNode_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//InitialNode has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInitialNode_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::INPUTPIN_CLASS:
		{
			if (nullptr == container)
			{
				return this->createInputPin(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//InputPin has argument as a containment
					case  uml::umlPackage::INVOCATIONACTION_ATTRIBUTE_ARGUMENT:	
					{
						std::weak_ptr<uml::InvocationAction> castedContainer = std::dynamic_pointer_cast<uml::InvocationAction> (container);
						return this->createInputPin_as_argument_in_InvocationAction(castedContainer,metaElementID);
					}
					//InputPin has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInputPin_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//InputPin has collection as a containment
					case  uml::umlPackage::REDUCEACTION_ATTRIBUTE_COLLECTION:	
					{
						std::shared_ptr<ReduceAction> castedContainer = std::dynamic_pointer_cast<ReduceAction> (container);;
						return this->createInputPin_as_collection_in_ReduceAction(castedContainer,metaElementID);
					}
					//InputPin has exception as a containment
					case  uml::umlPackage::RAISEEXCEPTIONACTION_ATTRIBUTE_EXCEPTION:	
					{
						std::shared_ptr<RaiseExceptionAction> castedContainer = std::dynamic_pointer_cast<RaiseExceptionAction> (container);;
						return this->createInputPin_as_exception_in_RaiseExceptionAction(castedContainer,metaElementID);
					}
					//InputPin has first as a containment
					case  uml::umlPackage::TESTIDENTITYACTION_ATTRIBUTE_FIRST:	
					{
						std::shared_ptr<TestIdentityAction> castedContainer = std::dynamic_pointer_cast<TestIdentityAction> (container);;
						return this->createInputPin_as_first_in_TestIdentityAction(castedContainer,metaElementID);
					}
					//InputPin has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInputPin_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//InputPin has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInputPin_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//InputPin has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createInputPin_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//InputPin has input as a containment
					case  uml::umlPackage::ACTION_ATTRIBUTE_INPUT:	
					{
						std::weak_ptr<uml::Action> castedContainer = std::dynamic_pointer_cast<uml::Action> (container);
						return this->createInputPin_as_input_in_Action(castedContainer,metaElementID);
					}
					//InputPin has inputValue as a containment
					case  uml::umlPackage::LINKACTION_ATTRIBUTE_INPUTVALUE:	
					{
						std::shared_ptr<LinkAction> castedContainer = std::dynamic_pointer_cast<LinkAction> (container);;
						return this->createInputPin_as_inputValue_in_LinkAction(castedContainer,metaElementID);
					}
					//InputPin has inputValue as a containment
					case  uml::umlPackage::OPAQUEACTION_ATTRIBUTE_INPUTVALUE:	
					{
						std::shared_ptr<OpaqueAction> castedContainer = std::dynamic_pointer_cast<OpaqueAction> (container);;
						return this->createInputPin_as_inputValue_in_OpaqueAction(castedContainer,metaElementID);
					}
					//InputPin has insertAt as a containment
					case  uml::umlPackage::ADDSTRUCTURALFEATUREVALUEACTION_ATTRIBUTE_INSERTAT:	
					{
						std::weak_ptr<uml::AddStructuralFeatureValueAction> castedContainer = std::dynamic_pointer_cast<uml::AddStructuralFeatureValueAction> (container);
						return this->createInputPin_as_insertAt_in_AddStructuralFeatureValueAction(castedContainer,metaElementID);
					}
					//InputPin has insertAt as a containment
					case  uml::umlPackage::ADDVARIABLEVALUEACTION_ATTRIBUTE_INSERTAT:	
					{
						std::shared_ptr<AddVariableValueAction> castedContainer = std::dynamic_pointer_cast<AddVariableValueAction> (container);;
						return this->createInputPin_as_insertAt_in_AddVariableValueAction(castedContainer,metaElementID);
					}
					//InputPin has loopVariableInput as a containment
					case  uml::umlPackage::LOOPNODE_ATTRIBUTE_LOOPVARIABLEINPUT:	
					{
						std::shared_ptr<LoopNode> castedContainer = std::dynamic_pointer_cast<LoopNode> (container);;
						return this->createInputPin_as_loopVariableInput_in_LoopNode(castedContainer,metaElementID);
					}
					//InputPin has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createInputPin_as_node_in_Activity(castedContainer,metaElementID);
					}
					//InputPin has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createInputPin_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//InputPin has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createInputPin_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//InputPin has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createInputPin_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//InputPin has object as a containment
					case  uml::umlPackage::STRUCTURALFEATUREACTION_ATTRIBUTE_OBJECT:	
					{
						std::weak_ptr<uml::StructuralFeatureAction> castedContainer = std::dynamic_pointer_cast<uml::StructuralFeatureAction> (container);
						return this->createInputPin_as_object_in_StructuralFeatureAction(castedContainer,metaElementID);
					}
					//InputPin has object as a containment
					case  uml::umlPackage::CLEARASSOCIATIONACTION_ATTRIBUTE_OBJECT:	
					{
						std::shared_ptr<ClearAssociationAction> castedContainer = std::dynamic_pointer_cast<ClearAssociationAction> (container);;
						return this->createInputPin_as_object_in_ClearAssociationAction(castedContainer,metaElementID);
					}
					//InputPin has object as a containment
					case  uml::umlPackage::READISCLASSIFIEDOBJECTACTION_ATTRIBUTE_OBJECT:	
					{
						std::shared_ptr<ReadIsClassifiedObjectAction> castedContainer = std::dynamic_pointer_cast<ReadIsClassifiedObjectAction> (container);;
						return this->createInputPin_as_object_in_ReadIsClassifiedObjectAction(castedContainer,metaElementID);
					}
					//InputPin has object as a containment
					case  uml::umlPackage::READLINKOBJECTENDACTION_ATTRIBUTE_OBJECT:	
					{
						std::shared_ptr<ReadLinkObjectEndAction> castedContainer = std::dynamic_pointer_cast<ReadLinkObjectEndAction> (container);;
						return this->createInputPin_as_object_in_ReadLinkObjectEndAction(castedContainer,metaElementID);
					}
					//InputPin has object as a containment
					case  uml::umlPackage::READLINKOBJECTENDQUALIFIERACTION_ATTRIBUTE_OBJECT:	
					{
						std::shared_ptr<ReadLinkObjectEndQualifierAction> castedContainer = std::dynamic_pointer_cast<ReadLinkObjectEndQualifierAction> (container);;
						return this->createInputPin_as_object_in_ReadLinkObjectEndQualifierAction(castedContainer,metaElementID);
					}
					//InputPin has object as a containment
					case  uml::umlPackage::RECLASSIFYOBJECTACTION_ATTRIBUTE_OBJECT:	
					{
						std::shared_ptr<ReclassifyObjectAction> castedContainer = std::dynamic_pointer_cast<ReclassifyObjectAction> (container);;
						return this->createInputPin_as_object_in_ReclassifyObjectAction(castedContainer,metaElementID);
					}
					//InputPin has object as a containment
					case  uml::umlPackage::STARTCLASSIFIERBEHAVIORACTION_ATTRIBUTE_OBJECT:	
					{
						std::shared_ptr<StartClassifierBehaviorAction> castedContainer = std::dynamic_pointer_cast<StartClassifierBehaviorAction> (container);;
						return this->createInputPin_as_object_in_StartClassifierBehaviorAction(castedContainer,metaElementID);
					}
					//InputPin has object as a containment
					case  uml::umlPackage::STARTOBJECTBEHAVIORACTION_ATTRIBUTE_OBJECT:	
					{
						std::shared_ptr<StartObjectBehaviorAction> castedContainer = std::dynamic_pointer_cast<StartObjectBehaviorAction> (container);;
						return this->createInputPin_as_object_in_StartObjectBehaviorAction(castedContainer,metaElementID);
					}
					//InputPin has object as a containment
					case  uml::umlPackage::UNMARSHALLACTION_ATTRIBUTE_OBJECT:	
					{
						std::shared_ptr<UnmarshallAction> castedContainer = std::dynamic_pointer_cast<UnmarshallAction> (container);;
						return this->createInputPin_as_object_in_UnmarshallAction(castedContainer,metaElementID);
					}
					//InputPin has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createInputPin_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//InputPin has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createInputPin_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//InputPin has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createInputPin_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//InputPin has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createInputPin_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//InputPin has removeAt as a containment
					case  uml::umlPackage::REMOVESTRUCTURALFEATUREVALUEACTION_ATTRIBUTE_REMOVEAT:	
					{
						std::weak_ptr<uml::RemoveStructuralFeatureValueAction> castedContainer = std::dynamic_pointer_cast<uml::RemoveStructuralFeatureValueAction> (container);
						return this->createInputPin_as_removeAt_in_RemoveStructuralFeatureValueAction(castedContainer,metaElementID);
					}
					//InputPin has removeAt as a containment
					case  uml::umlPackage::REMOVEVARIABLEVALUEACTION_ATTRIBUTE_REMOVEAT:	
					{
						std::shared_ptr<RemoveVariableValueAction> castedContainer = std::dynamic_pointer_cast<RemoveVariableValueAction> (container);;
						return this->createInputPin_as_removeAt_in_RemoveVariableValueAction(castedContainer,metaElementID);
					}
					//InputPin has replyValue as a containment
					case  uml::umlPackage::REPLYACTION_ATTRIBUTE_REPLYVALUE:	
					{
						std::shared_ptr<ReplyAction> castedContainer = std::dynamic_pointer_cast<ReplyAction> (container);;
						return this->createInputPin_as_replyValue_in_ReplyAction(castedContainer,metaElementID);
					}
					//InputPin has request as a containment
					case  uml::umlPackage::SENDOBJECTACTION_ATTRIBUTE_REQUEST:	
					{
						std::shared_ptr<SendObjectAction> castedContainer = std::dynamic_pointer_cast<SendObjectAction> (container);;
						return this->createInputPin_as_request_in_SendObjectAction(castedContainer,metaElementID);
					}
					//InputPin has returnInformation as a containment
					case  uml::umlPackage::REPLYACTION_ATTRIBUTE_RETURNINFORMATION:	
					{
						std::shared_ptr<ReplyAction> castedContainer = std::dynamic_pointer_cast<ReplyAction> (container);;
						return this->createInputPin_as_returnInformation_in_ReplyAction(castedContainer,metaElementID);
					}
					//InputPin has second as a containment
					case  uml::umlPackage::TESTIDENTITYACTION_ATTRIBUTE_SECOND:	
					{
						std::shared_ptr<TestIdentityAction> castedContainer = std::dynamic_pointer_cast<TestIdentityAction> (container);;
						return this->createInputPin_as_second_in_TestIdentityAction(castedContainer,metaElementID);
					}
					//InputPin has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInputPin_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//InputPin has structuredNodeInput as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_STRUCTUREDNODEINPUT:	
					{
						std::shared_ptr<StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<StructuredActivityNode> (container);;
						return this->createInputPin_as_structuredNodeInput_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//InputPin has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInputPin_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//InputPin has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInputPin_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//InputPin has target as a containment
					case  uml::umlPackage::CALLOPERATIONACTION_ATTRIBUTE_TARGET:	
					{
						std::weak_ptr<uml::CallOperationAction> castedContainer = std::dynamic_pointer_cast<uml::CallOperationAction> (container);
						return this->createInputPin_as_target_in_CallOperationAction(castedContainer,metaElementID);
					}
					//InputPin has target as a containment
					case  uml::umlPackage::DESTROYOBJECTACTION_ATTRIBUTE_TARGET:	
					{
						std::weak_ptr<uml::DestroyObjectAction> castedContainer = std::dynamic_pointer_cast<uml::DestroyObjectAction> (container);
						return this->createInputPin_as_target_in_DestroyObjectAction(castedContainer,metaElementID);
					}
					//InputPin has target as a containment
					case  uml::umlPackage::SENDOBJECTACTION_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<SendObjectAction> castedContainer = std::dynamic_pointer_cast<SendObjectAction> (container);;
						return this->createInputPin_as_target_in_SendObjectAction(castedContainer,metaElementID);
					}
					//InputPin has target as a containment
					case  uml::umlPackage::SENDSIGNALACTION_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<SendSignalAction> castedContainer = std::dynamic_pointer_cast<SendSignalAction> (container);;
						return this->createInputPin_as_target_in_SendSignalAction(castedContainer,metaElementID);
					}
					//InputPin has value as a containment
					case  uml::umlPackage::WRITESTRUCTURALFEATUREACTION_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::WriteStructuralFeatureAction> castedContainer = std::dynamic_pointer_cast<uml::WriteStructuralFeatureAction> (container);
						return this->createInputPin_as_value_in_WriteStructuralFeatureAction(castedContainer,metaElementID);
					}
					//InputPin has value as a containment
					case  uml::umlPackage::WRITEVARIABLEACTION_ATTRIBUTE_VALUE:	
					{
						std::shared_ptr<WriteVariableAction> castedContainer = std::dynamic_pointer_cast<WriteVariableAction> (container);;
						return this->createInputPin_as_value_in_WriteVariableAction(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::INSTANCESPECIFICATION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createInstanceSpecification(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//InstanceSpecification has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInstanceSpecification_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//InstanceSpecification has deployedArtifact as a containment
					case  uml::umlPackage::DEPLOYMENT_ATTRIBUTE_DEPLOYEDARTIFACT:	
					{
						std::shared_ptr<Deployment> castedContainer = std::dynamic_pointer_cast<Deployment> (container);;
						return this->createInstanceSpecification_as_deployedArtifact_in_Deployment(castedContainer,metaElementID);
					}
					//InstanceSpecification has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createInstanceSpecification_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//InstanceSpecification has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createInstanceSpecification_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//InstanceSpecification has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInstanceSpecification_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//InstanceSpecification has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInstanceSpecification_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//InstanceSpecification has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createInstanceSpecification_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//InstanceSpecification has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createInstanceSpecification_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//InstanceSpecification has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createInstanceSpecification_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//InstanceSpecification has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createInstanceSpecification_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//InstanceSpecification has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createInstanceSpecification_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//InstanceSpecification has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createInstanceSpecification_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//InstanceSpecification has owningInstance as a containment
					//InstanceSpecification has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createInstanceSpecification_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//InstanceSpecification has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createInstanceSpecification_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//InstanceSpecification has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInstanceSpecification_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//InstanceSpecification has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInstanceSpecification_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//InstanceSpecification has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInstanceSpecification_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//InstanceSpecification has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createInstanceSpecification_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::INSTANCEVALUE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createInstanceValue(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//InstanceValue has argument as a containment
					case  uml::umlPackage::MESSAGE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<Message> castedContainer = std::dynamic_pointer_cast<Message> (container);;
						return this->createInstanceValue_as_argument_in_Message(castedContainer,metaElementID);
					}
					//InstanceValue has argument as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createInstanceValue_as_argument_in_InteractionUse(castedContainer,metaElementID);
					}
					//InstanceValue has changeExpression as a containment
					case  uml::umlPackage::CHANGEEVENT_ATTRIBUTE_CHANGEEXPRESSION:	
					{
						std::shared_ptr<ChangeEvent> castedContainer = std::dynamic_pointer_cast<ChangeEvent> (container);;
						return this->createInstanceValue_as_changeExpression_in_ChangeEvent(castedContainer,metaElementID);
					}
					//InstanceValue has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInstanceValue_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//InstanceValue has defaultValue as a containment
					case  uml::umlPackage::PROPERTY_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Property> castedContainer = std::dynamic_pointer_cast<Property> (container);;
						return this->createInstanceValue_as_defaultValue_in_Property(castedContainer,metaElementID);
					}
					//InstanceValue has defaultValue as a containment
					case  uml::umlPackage::PARAMETER_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Parameter> castedContainer = std::dynamic_pointer_cast<Parameter> (container);;
						return this->createInstanceValue_as_defaultValue_in_Parameter(castedContainer,metaElementID);
					}
					//InstanceValue has expr as a containment
					case  uml::umlPackage::TIMEEXPRESSION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<TimeExpression> castedContainer = std::dynamic_pointer_cast<TimeExpression> (container);;
						return this->createInstanceValue_as_expr_in_TimeExpression(castedContainer,metaElementID);
					}
					//InstanceValue has expr as a containment
					case  uml::umlPackage::DURATION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<Duration> castedContainer = std::dynamic_pointer_cast<Duration> (container);;
						return this->createInstanceValue_as_expr_in_Duration(castedContainer,metaElementID);
					}
					//InstanceValue has guard as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_GUARD:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createInstanceValue_as_guard_in_ActivityEdge(castedContainer,metaElementID);
					}
					//InstanceValue has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createInstanceValue_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//InstanceValue has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createInstanceValue_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//InstanceValue has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInstanceValue_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//InstanceValue has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInstanceValue_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//InstanceValue has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createInstanceValue_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//InstanceValue has joinSpec as a containment
					case  uml::umlPackage::JOINNODE_ATTRIBUTE_JOINSPEC:	
					{
						std::shared_ptr<JoinNode> castedContainer = std::dynamic_pointer_cast<JoinNode> (container);;
						return this->createInstanceValue_as_joinSpec_in_JoinNode(castedContainer,metaElementID);
					}
					//InstanceValue has lowerValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_LOWERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createInstanceValue_as_lowerValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//InstanceValue has maxint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MAXINT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createInstanceValue_as_maxint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//InstanceValue has minint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MININT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createInstanceValue_as_minint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//InstanceValue has operand as a containment
					case  uml::umlPackage::EXPRESSION_ATTRIBUTE_OPERAND:	
					{
						std::shared_ptr<Expression> castedContainer = std::dynamic_pointer_cast<Expression> (container);;
						return this->createInstanceValue_as_operand_in_Expression(castedContainer,metaElementID);
					}
					//InstanceValue has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createInstanceValue_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//InstanceValue has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createInstanceValue_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//InstanceValue has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createInstanceValue_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//InstanceValue has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createInstanceValue_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//InstanceValue has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createInstanceValue_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//InstanceValue has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createInstanceValue_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//InstanceValue has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createInstanceValue_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//InstanceValue has returnValue as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_RETURNVALUE:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createInstanceValue_as_returnValue_in_InteractionUse(castedContainer,metaElementID);
					}
					//InstanceValue has selector as a containment
					case  uml::umlPackage::LIFELINE_ATTRIBUTE_SELECTOR:	
					{
						std::shared_ptr<Lifeline> castedContainer = std::dynamic_pointer_cast<Lifeline> (container);;
						return this->createInstanceValue_as_selector_in_Lifeline(castedContainer,metaElementID);
					}
					//InstanceValue has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInstanceValue_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//InstanceValue has specification as a containment
					case  uml::umlPackage::CONSTRAINT_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<Constraint> castedContainer = std::dynamic_pointer_cast<Constraint> (container);;
						return this->createInstanceValue_as_specification_in_Constraint(castedContainer,metaElementID);
					}
					//InstanceValue has specification as a containment
					case  uml::umlPackage::INSTANCESPECIFICATION_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<InstanceSpecification> castedContainer = std::dynamic_pointer_cast<InstanceSpecification> (container);;
						return this->createInstanceValue_as_specification_in_InstanceSpecification(castedContainer,metaElementID);
					}
					//InstanceValue has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInstanceValue_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//InstanceValue has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInstanceValue_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//InstanceValue has upperBound as a containment
					case  uml::umlPackage::OBJECTNODE_ATTRIBUTE_UPPERBOUND:	
					{
						std::shared_ptr<ObjectNode> castedContainer = std::dynamic_pointer_cast<ObjectNode> (container);;
						return this->createInstanceValue_as_upperBound_in_ObjectNode(castedContainer,metaElementID);
					}
					//InstanceValue has upperValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_UPPERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createInstanceValue_as_upperValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//InstanceValue has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createInstanceValue_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					//InstanceValue has value as a containment
					case  uml::umlPackage::SLOT_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::Slot> castedContainer = std::dynamic_pointer_cast<uml::Slot> (container);
						return this->createInstanceValue_as_value_in_Slot(castedContainer,metaElementID);
					}
					//InstanceValue has value as a containment
					case  uml::umlPackage::VALUESPECIFICATIONACTION_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::ValueSpecificationAction> castedContainer = std::dynamic_pointer_cast<uml::ValueSpecificationAction> (container);
						return this->createInstanceValue_as_value_in_ValueSpecificationAction(castedContainer,metaElementID);
					}
					//InstanceValue has value as a containment
					case  uml::umlPackage::VALUEPIN_ATTRIBUTE_VALUE:	
					{
						std::shared_ptr<ValuePin> castedContainer = std::dynamic_pointer_cast<ValuePin> (container);;
						return this->createInstanceValue_as_value_in_ValuePin(castedContainer,metaElementID);
					}
					//InstanceValue has weight as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_WEIGHT:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createInstanceValue_as_weight_in_ActivityEdge(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::INTERACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createInteraction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Interaction has classifier as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_CLASSIFIER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createInteraction_as_classifier_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//Interaction has classifierBehavior as a containment
					case  uml::umlPackage::BEHAVIOREDCLASSIFIER_ATTRIBUTE_CLASSIFIERBEHAVIOR:	
					{
						std::shared_ptr<BehavioredClassifier> castedContainer = std::dynamic_pointer_cast<BehavioredClassifier> (container);;
						return this->createInteraction_as_classifierBehavior_in_BehavioredClassifier(castedContainer,metaElementID);
					}
					//Interaction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInteraction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Interaction has context as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_CONTEXT:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createInteraction_as_context_in_Behavior(castedContainer,metaElementID);
					}
					//Interaction has contract as a containment
					case  uml::umlPackage::SUBSTITUTION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<Substitution> castedContainer = std::dynamic_pointer_cast<Substitution> (container);;
						return this->createInteraction_as_contract_in_Substitution(castedContainer,metaElementID);
					}
					//Interaction has doActivity as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_DOACTIVITY:	
					{
						std::shared_ptr<State> castedContainer = std::dynamic_pointer_cast<State> (container);;
						return this->createInteraction_as_doActivity_in_State(castedContainer,metaElementID);
					}
					//Interaction has effect as a containment
					case  uml::umlPackage::TRANSITION_ATTRIBUTE_EFFECT:	
					{
						std::shared_ptr<Transition> castedContainer = std::dynamic_pointer_cast<Transition> (container);;
						return this->createInteraction_as_effect_in_Transition(castedContainer,metaElementID);
					}
					//Interaction has enclosingInteraction as a containment
					//Interaction has endType as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_ENDTYPE:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createInteraction_as_endType_in_Association(castedContainer,metaElementID);
					}
					//Interaction has entry as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_ENTRY:	
					{
						std::shared_ptr<State> castedContainer = std::dynamic_pointer_cast<State> (container);;
						return this->createInteraction_as_entry_in_State(castedContainer,metaElementID);
					}
					//Interaction has exit as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_EXIT:	
					{
						std::shared_ptr<State> castedContainer = std::dynamic_pointer_cast<State> (container);;
						return this->createInteraction_as_exit_in_State(castedContainer,metaElementID);
					}
					//Interaction has fragment as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::Interaction> castedContainer = std::dynamic_pointer_cast<uml::Interaction> (container);
						return this->createInteraction_as_fragment_in_Interaction(castedContainer,metaElementID);
					}
					//Interaction has fragment as a containment
					case  uml::umlPackage::INTERACTIONOPERAND_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::InteractionOperand> castedContainer = std::dynamic_pointer_cast<uml::InteractionOperand> (container);
						return this->createInteraction_as_fragment_in_InteractionOperand(castedContainer,metaElementID);
					}
					//Interaction has general as a containment
					case  uml::umlPackage::GENERALIZATION_ATTRIBUTE_GENERAL:	
					{
						std::shared_ptr<Generalization> castedContainer = std::dynamic_pointer_cast<Generalization> (container);;
						return this->createInteraction_as_general_in_Generalization(castedContainer,metaElementID);
					}
					//Interaction has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createInteraction_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Interaction has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createInteraction_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Interaction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInteraction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Interaction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInteraction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Interaction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createInteraction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Interaction has interaction as a containment
					//Interaction has interaction as a containment
					//Interaction has nestedClassifier as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createInteraction_as_nestedClassifier_in_Class(castedContainer,metaElementID);
					}
					//Interaction has nestedClassifier as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createInteraction_as_nestedClassifier_in_Interface(castedContainer,metaElementID);
					}
					//Interaction has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createInteraction_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Interaction has ownedBehavior as a containment
					case  uml::umlPackage::BEHAVIOREDCLASSIFIER_ATTRIBUTE_OWNEDBEHAVIOR:	
					{
						std::weak_ptr<uml::BehavioredClassifier> castedContainer = std::dynamic_pointer_cast<uml::BehavioredClassifier> (container);
						return this->createInteraction_as_ownedBehavior_in_BehavioredClassifier(castedContainer,metaElementID);
					}
					//Interaction has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createInteraction_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Interaction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createInteraction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Interaction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createInteraction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Interaction has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createInteraction_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Interaction has ownedType as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDTYPE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createInteraction_as_ownedType_in_Package(castedContainer,metaElementID);
					}
					//Interaction has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createInteraction_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Interaction has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createInteraction_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Interaction has realizingClassifier as a containment
					case  uml::umlPackage::COMPONENTREALIZATION_ATTRIBUTE_REALIZINGCLASSIFIER:	
					{
						std::shared_ptr<ComponentRealization> castedContainer = std::dynamic_pointer_cast<ComponentRealization> (container);;
						return this->createInteraction_as_realizingClassifier_in_ComponentRealization(castedContainer,metaElementID);
					}
					//Interaction has redefinedBehavior as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_REDEFINEDBEHAVIOR:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createInteraction_as_redefinedBehavior_in_Behavior(castedContainer,metaElementID);
					}
					//Interaction has redefinedClassifier as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REDEFINEDCLASSIFIER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createInteraction_as_redefinedClassifier_in_Classifier(castedContainer,metaElementID);
					}
					//Interaction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInteraction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Interaction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInteraction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Interaction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInteraction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Interaction has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createInteraction_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::INTERACTIONCONSTRAINT_CLASS:
		{
			if (nullptr == container)
			{
				return this->createInteractionConstraint(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//InteractionConstraint has bodyCondition as a containment
					case  uml::umlPackage::OPERATION_ATTRIBUTE_BODYCONDITION:	
					{
						std::shared_ptr<Operation> castedContainer = std::dynamic_pointer_cast<Operation> (container);;
						return this->createInteractionConstraint_as_bodyCondition_in_Operation(castedContainer,metaElementID);
					}
					//InteractionConstraint has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInteractionConstraint_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//InteractionConstraint has condition as a containment
					case  uml::umlPackage::PARAMETERSET_ATTRIBUTE_CONDITION:	
					{
						std::shared_ptr<ParameterSet> castedContainer = std::dynamic_pointer_cast<ParameterSet> (container);;
						return this->createInteractionConstraint_as_condition_in_ParameterSet(castedContainer,metaElementID);
					}
					//InteractionConstraint has condition as a containment
					case  uml::umlPackage::EXTEND_ATTRIBUTE_CONDITION:	
					{
						std::shared_ptr<Extend> castedContainer = std::dynamic_pointer_cast<Extend> (container);;
						return this->createInteractionConstraint_as_condition_in_Extend(castedContainer,metaElementID);
					}
					//InteractionConstraint has guard as a containment
					case  uml::umlPackage::TRANSITION_ATTRIBUTE_GUARD:	
					{
						std::shared_ptr<Transition> castedContainer = std::dynamic_pointer_cast<Transition> (container);;
						return this->createInteractionConstraint_as_guard_in_Transition(castedContainer,metaElementID);
					}
					//InteractionConstraint has guard as a containment
					case  uml::umlPackage::INTERACTIONOPERAND_ATTRIBUTE_GUARD:	
					{
						std::shared_ptr<InteractionOperand> castedContainer = std::dynamic_pointer_cast<InteractionOperand> (container);;
						return this->createInteractionConstraint_as_guard_in_InteractionOperand(castedContainer,metaElementID);
					}
					//InteractionConstraint has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createInteractionConstraint_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//InteractionConstraint has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createInteractionConstraint_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//InteractionConstraint has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInteractionConstraint_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//InteractionConstraint has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInteractionConstraint_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//InteractionConstraint has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createInteractionConstraint_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//InteractionConstraint has invariant as a containment
					case  uml::umlPackage::STATEINVARIANT_ATTRIBUTE_INVARIANT:	
					{
						std::shared_ptr<StateInvariant> castedContainer = std::dynamic_pointer_cast<StateInvariant> (container);;
						return this->createInteractionConstraint_as_invariant_in_StateInvariant(castedContainer,metaElementID);
					}
					//InteractionConstraint has localPostcondition as a containment
					case  uml::umlPackage::ACTION_ATTRIBUTE_LOCALPOSTCONDITION:	
					{
						std::shared_ptr<Action> castedContainer = std::dynamic_pointer_cast<Action> (container);;
						return this->createInteractionConstraint_as_localPostcondition_in_Action(castedContainer,metaElementID);
					}
					//InteractionConstraint has localPrecondition as a containment
					case  uml::umlPackage::ACTION_ATTRIBUTE_LOCALPRECONDITION:	
					{
						std::shared_ptr<Action> castedContainer = std::dynamic_pointer_cast<Action> (container);;
						return this->createInteractionConstraint_as_localPrecondition_in_Action(castedContainer,metaElementID);
					}
					//InteractionConstraint has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createInteractionConstraint_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//InteractionConstraint has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createInteractionConstraint_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//InteractionConstraint has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createInteractionConstraint_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//InteractionConstraint has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createInteractionConstraint_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//InteractionConstraint has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createInteractionConstraint_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//InteractionConstraint has ownedRule as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDRULE:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createInteractionConstraint_as_ownedRule_in_Namespace(castedContainer,metaElementID);
					}
					//InteractionConstraint has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createInteractionConstraint_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//InteractionConstraint has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createInteractionConstraint_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//InteractionConstraint has postCondition as a containment
					case  uml::umlPackage::PROTOCOLTRANSITION_ATTRIBUTE_POSTCONDITION:	
					{
						std::shared_ptr<ProtocolTransition> castedContainer = std::dynamic_pointer_cast<ProtocolTransition> (container);;
						return this->createInteractionConstraint_as_postCondition_in_ProtocolTransition(castedContainer,metaElementID);
					}
					//InteractionConstraint has postcondition as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_POSTCONDITION:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createInteractionConstraint_as_postcondition_in_Behavior(castedContainer,metaElementID);
					}
					//InteractionConstraint has postcondition as a containment
					case  uml::umlPackage::OPERATION_ATTRIBUTE_POSTCONDITION:	
					{
						std::shared_ptr<Operation> castedContainer = std::dynamic_pointer_cast<Operation> (container);;
						return this->createInteractionConstraint_as_postcondition_in_Operation(castedContainer,metaElementID);
					}
					//InteractionConstraint has preCondition as a containment
					case  uml::umlPackage::PROTOCOLTRANSITION_ATTRIBUTE_PRECONDITION:	
					{
						std::shared_ptr<ProtocolTransition> castedContainer = std::dynamic_pointer_cast<ProtocolTransition> (container);;
						return this->createInteractionConstraint_as_preCondition_in_ProtocolTransition(castedContainer,metaElementID);
					}
					//InteractionConstraint has precondition as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_PRECONDITION:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createInteractionConstraint_as_precondition_in_Behavior(castedContainer,metaElementID);
					}
					//InteractionConstraint has precondition as a containment
					case  uml::umlPackage::OPERATION_ATTRIBUTE_PRECONDITION:	
					{
						std::shared_ptr<Operation> castedContainer = std::dynamic_pointer_cast<Operation> (container);;
						return this->createInteractionConstraint_as_precondition_in_Operation(castedContainer,metaElementID);
					}
					//InteractionConstraint has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInteractionConstraint_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//InteractionConstraint has stateInvariant as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_STATEINVARIANT:	
					{
						std::shared_ptr<State> castedContainer = std::dynamic_pointer_cast<State> (container);;
						return this->createInteractionConstraint_as_stateInvariant_in_State(castedContainer,metaElementID);
					}
					//InteractionConstraint has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInteractionConstraint_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//InteractionConstraint has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInteractionConstraint_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//InteractionConstraint has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createInteractionConstraint_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::INTERACTIONOPERAND_CLASS:
		{
			if (nullptr == container)
			{
				return this->createInteractionOperand(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//InteractionOperand has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInteractionOperand_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//InteractionOperand has enclosingOperand as a containment
					//InteractionOperand has fragment as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::Interaction> castedContainer = std::dynamic_pointer_cast<uml::Interaction> (container);
						return this->createInteractionOperand_as_fragment_in_Interaction(castedContainer,metaElementID);
					}
					//InteractionOperand has fragment as a containment
					case  uml::umlPackage::INTERACTIONOPERAND_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::InteractionOperand> castedContainer = std::dynamic_pointer_cast<uml::InteractionOperand> (container);
						return this->createInteractionOperand_as_fragment_in_InteractionOperand(castedContainer,metaElementID);
					}
					//InteractionOperand has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInteractionOperand_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//InteractionOperand has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInteractionOperand_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//InteractionOperand has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createInteractionOperand_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//InteractionOperand has operand as a containment
					case  uml::umlPackage::COMBINEDFRAGMENT_ATTRIBUTE_OPERAND:	
					{
						std::shared_ptr<CombinedFragment> castedContainer = std::dynamic_pointer_cast<CombinedFragment> (container);;
						return this->createInteractionOperand_as_operand_in_CombinedFragment(castedContainer,metaElementID);
					}
					//InteractionOperand has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createInteractionOperand_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//InteractionOperand has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createInteractionOperand_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//InteractionOperand has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInteractionOperand_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//InteractionOperand has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInteractionOperand_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//InteractionOperand has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInteractionOperand_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::INTERACTIONUSE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createInteractionUse(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//InteractionUse has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInteractionUse_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//InteractionUse has fragment as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::Interaction> castedContainer = std::dynamic_pointer_cast<uml::Interaction> (container);
						return this->createInteractionUse_as_fragment_in_Interaction(castedContainer,metaElementID);
					}
					//InteractionUse has fragment as a containment
					case  uml::umlPackage::INTERACTIONOPERAND_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::InteractionOperand> castedContainer = std::dynamic_pointer_cast<uml::InteractionOperand> (container);
						return this->createInteractionUse_as_fragment_in_InteractionOperand(castedContainer,metaElementID);
					}
					//InteractionUse has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInteractionUse_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//InteractionUse has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInteractionUse_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//InteractionUse has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createInteractionUse_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//InteractionUse has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createInteractionUse_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//InteractionUse has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createInteractionUse_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//InteractionUse has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInteractionUse_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//InteractionUse has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInteractionUse_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//InteractionUse has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInteractionUse_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::INTERFACE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createInterface(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Interface has classifier as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_CLASSIFIER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createInterface_as_classifier_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//Interface has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInterface_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Interface has contract as a containment
					case  uml::umlPackage::SUBSTITUTION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<Substitution> castedContainer = std::dynamic_pointer_cast<Substitution> (container);;
						return this->createInterface_as_contract_in_Substitution(castedContainer,metaElementID);
					}
					//Interface has contract as a containment
					case  uml::umlPackage::INTERFACEREALIZATION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<InterfaceRealization> castedContainer = std::dynamic_pointer_cast<InterfaceRealization> (container);;
						return this->createInterface_as_contract_in_InterfaceRealization(castedContainer,metaElementID);
					}
					//Interface has endType as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_ENDTYPE:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createInterface_as_endType_in_Association(castedContainer,metaElementID);
					}
					//Interface has general as a containment
					case  uml::umlPackage::GENERALIZATION_ATTRIBUTE_GENERAL:	
					{
						std::shared_ptr<Generalization> castedContainer = std::dynamic_pointer_cast<Generalization> (container);;
						return this->createInterface_as_general_in_Generalization(castedContainer,metaElementID);
					}
					//Interface has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createInterface_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Interface has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createInterface_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Interface has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInterface_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Interface has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInterface_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Interface has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createInterface_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Interface has interface as a containment
					//Interface has interface as a containment
					//Interface has nestedClassifier as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createInterface_as_nestedClassifier_in_Class(castedContainer,metaElementID);
					}
					//Interface has nestedClassifier as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createInterface_as_nestedClassifier_in_Interface(castedContainer,metaElementID);
					}
					//Interface has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createInterface_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Interface has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createInterface_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Interface has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createInterface_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Interface has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createInterface_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Interface has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createInterface_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Interface has ownedType as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDTYPE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createInterface_as_ownedType_in_Package(castedContainer,metaElementID);
					}
					//Interface has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createInterface_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Interface has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createInterface_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Interface has realizingClassifier as a containment
					case  uml::umlPackage::COMPONENTREALIZATION_ATTRIBUTE_REALIZINGCLASSIFIER:	
					{
						std::shared_ptr<ComponentRealization> castedContainer = std::dynamic_pointer_cast<ComponentRealization> (container);;
						return this->createInterface_as_realizingClassifier_in_ComponentRealization(castedContainer,metaElementID);
					}
					//Interface has redefinedClassifier as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REDEFINEDCLASSIFIER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createInterface_as_redefinedClassifier_in_Classifier(castedContainer,metaElementID);
					}
					//Interface has redefinedInterface as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_REDEFINEDINTERFACE:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createInterface_as_redefinedInterface_in_Interface(castedContainer,metaElementID);
					}
					//Interface has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInterface_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Interface has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInterface_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Interface has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInterface_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Interface has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createInterface_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::INTERFACEREALIZATION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createInterfaceRealization(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//InterfaceRealization has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInterfaceRealization_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//InterfaceRealization has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createInterfaceRealization_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//InterfaceRealization has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createInterfaceRealization_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//InterfaceRealization has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInterfaceRealization_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//InterfaceRealization has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInterfaceRealization_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//InterfaceRealization has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createInterfaceRealization_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//InterfaceRealization has interfaceRealization as a containment
					case  uml::umlPackage::BEHAVIOREDCLASSIFIER_ATTRIBUTE_INTERFACEREALIZATION:	
					{
						std::weak_ptr<uml::BehavioredClassifier> castedContainer = std::dynamic_pointer_cast<uml::BehavioredClassifier> (container);
						return this->createInterfaceRealization_as_interfaceRealization_in_BehavioredClassifier(castedContainer,metaElementID);
					}
					//InterfaceRealization has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createInterfaceRealization_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//InterfaceRealization has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createInterfaceRealization_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//InterfaceRealization has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createInterfaceRealization_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//InterfaceRealization has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createInterfaceRealization_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//InterfaceRealization has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createInterfaceRealization_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//InterfaceRealization has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createInterfaceRealization_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//InterfaceRealization has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createInterfaceRealization_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//InterfaceRealization has roleBinding as a containment
					case  uml::umlPackage::COLLABORATIONUSE_ATTRIBUTE_ROLEBINDING:	
					{
						std::shared_ptr<CollaborationUse> castedContainer = std::dynamic_pointer_cast<CollaborationUse> (container);;
						return this->createInterfaceRealization_as_roleBinding_in_CollaborationUse(castedContainer,metaElementID);
					}
					//InterfaceRealization has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInterfaceRealization_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//InterfaceRealization has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInterfaceRealization_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//InterfaceRealization has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInterfaceRealization_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//InterfaceRealization has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createInterfaceRealization_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::INTERRUPTIBLEACTIVITYREGION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createInterruptibleActivityRegion(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//InterruptibleActivityRegion has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInterruptibleActivityRegion_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//InterruptibleActivityRegion has group as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_GROUP:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createInterruptibleActivityRegion_as_group_in_Activity(castedContainer,metaElementID);
					}
					//InterruptibleActivityRegion has inInterruptibleRegion as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_ININTERRUPTIBLEREGION:	
					{
						std::shared_ptr<uml::ActivityNode> castedContainer = std::dynamic_pointer_cast<uml::ActivityNode> (container);
						return this->createInterruptibleActivityRegion_as_inInterruptibleRegion_in_ActivityNode(castedContainer,metaElementID);
					}
					//InterruptibleActivityRegion has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInterruptibleActivityRegion_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//InterruptibleActivityRegion has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInterruptibleActivityRegion_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//InterruptibleActivityRegion has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createInterruptibleActivityRegion_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//InterruptibleActivityRegion has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createInterruptibleActivityRegion_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//InterruptibleActivityRegion has ownedGroup as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDGROUP:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createInterruptibleActivityRegion_as_ownedGroup_in_Activity(castedContainer,metaElementID);
					}
					//InterruptibleActivityRegion has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createInterruptibleActivityRegion_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//InterruptibleActivityRegion has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInterruptibleActivityRegion_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//InterruptibleActivityRegion has subgroup as a containment
					case  uml::umlPackage::ACTIVITYGROUP_ATTRIBUTE_SUBGROUP:	
					{
						std::weak_ptr<uml::ActivityGroup> castedContainer = std::dynamic_pointer_cast<uml::ActivityGroup> (container);
						return this->createInterruptibleActivityRegion_as_subgroup_in_ActivityGroup(castedContainer,metaElementID);
					}
					//InterruptibleActivityRegion has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInterruptibleActivityRegion_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//InterruptibleActivityRegion has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInterruptibleActivityRegion_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::INTERVAL_CLASS:
		{
			if (nullptr == container)
			{
				return this->createInterval(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Interval has argument as a containment
					case  uml::umlPackage::MESSAGE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<Message> castedContainer = std::dynamic_pointer_cast<Message> (container);;
						return this->createInterval_as_argument_in_Message(castedContainer,metaElementID);
					}
					//Interval has argument as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createInterval_as_argument_in_InteractionUse(castedContainer,metaElementID);
					}
					//Interval has changeExpression as a containment
					case  uml::umlPackage::CHANGEEVENT_ATTRIBUTE_CHANGEEXPRESSION:	
					{
						std::shared_ptr<ChangeEvent> castedContainer = std::dynamic_pointer_cast<ChangeEvent> (container);;
						return this->createInterval_as_changeExpression_in_ChangeEvent(castedContainer,metaElementID);
					}
					//Interval has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInterval_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Interval has defaultValue as a containment
					case  uml::umlPackage::PROPERTY_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Property> castedContainer = std::dynamic_pointer_cast<Property> (container);;
						return this->createInterval_as_defaultValue_in_Property(castedContainer,metaElementID);
					}
					//Interval has defaultValue as a containment
					case  uml::umlPackage::PARAMETER_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Parameter> castedContainer = std::dynamic_pointer_cast<Parameter> (container);;
						return this->createInterval_as_defaultValue_in_Parameter(castedContainer,metaElementID);
					}
					//Interval has expr as a containment
					case  uml::umlPackage::TIMEEXPRESSION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<TimeExpression> castedContainer = std::dynamic_pointer_cast<TimeExpression> (container);;
						return this->createInterval_as_expr_in_TimeExpression(castedContainer,metaElementID);
					}
					//Interval has expr as a containment
					case  uml::umlPackage::DURATION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<Duration> castedContainer = std::dynamic_pointer_cast<Duration> (container);;
						return this->createInterval_as_expr_in_Duration(castedContainer,metaElementID);
					}
					//Interval has guard as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_GUARD:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createInterval_as_guard_in_ActivityEdge(castedContainer,metaElementID);
					}
					//Interval has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createInterval_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Interval has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createInterval_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Interval has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInterval_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Interval has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createInterval_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Interval has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createInterval_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Interval has joinSpec as a containment
					case  uml::umlPackage::JOINNODE_ATTRIBUTE_JOINSPEC:	
					{
						std::shared_ptr<JoinNode> castedContainer = std::dynamic_pointer_cast<JoinNode> (container);;
						return this->createInterval_as_joinSpec_in_JoinNode(castedContainer,metaElementID);
					}
					//Interval has lowerValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_LOWERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createInterval_as_lowerValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//Interval has maxint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MAXINT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createInterval_as_maxint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//Interval has minint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MININT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createInterval_as_minint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//Interval has operand as a containment
					case  uml::umlPackage::EXPRESSION_ATTRIBUTE_OPERAND:	
					{
						std::shared_ptr<Expression> castedContainer = std::dynamic_pointer_cast<Expression> (container);;
						return this->createInterval_as_operand_in_Expression(castedContainer,metaElementID);
					}
					//Interval has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createInterval_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Interval has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createInterval_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Interval has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createInterval_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Interval has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createInterval_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Interval has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createInterval_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Interval has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createInterval_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Interval has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createInterval_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Interval has returnValue as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_RETURNVALUE:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createInterval_as_returnValue_in_InteractionUse(castedContainer,metaElementID);
					}
					//Interval has selector as a containment
					case  uml::umlPackage::LIFELINE_ATTRIBUTE_SELECTOR:	
					{
						std::shared_ptr<Lifeline> castedContainer = std::dynamic_pointer_cast<Lifeline> (container);;
						return this->createInterval_as_selector_in_Lifeline(castedContainer,metaElementID);
					}
					//Interval has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInterval_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Interval has specification as a containment
					case  uml::umlPackage::CONSTRAINT_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<Constraint> castedContainer = std::dynamic_pointer_cast<Constraint> (container);;
						return this->createInterval_as_specification_in_Constraint(castedContainer,metaElementID);
					}
					//Interval has specification as a containment
					case  uml::umlPackage::INSTANCESPECIFICATION_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<InstanceSpecification> castedContainer = std::dynamic_pointer_cast<InstanceSpecification> (container);;
						return this->createInterval_as_specification_in_InstanceSpecification(castedContainer,metaElementID);
					}
					//Interval has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createInterval_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Interval has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createInterval_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Interval has upperBound as a containment
					case  uml::umlPackage::OBJECTNODE_ATTRIBUTE_UPPERBOUND:	
					{
						std::shared_ptr<ObjectNode> castedContainer = std::dynamic_pointer_cast<ObjectNode> (container);;
						return this->createInterval_as_upperBound_in_ObjectNode(castedContainer,metaElementID);
					}
					//Interval has upperValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_UPPERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createInterval_as_upperValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//Interval has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createInterval_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					//Interval has value as a containment
					case  uml::umlPackage::SLOT_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::Slot> castedContainer = std::dynamic_pointer_cast<uml::Slot> (container);
						return this->createInterval_as_value_in_Slot(castedContainer,metaElementID);
					}
					//Interval has value as a containment
					case  uml::umlPackage::VALUESPECIFICATIONACTION_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::ValueSpecificationAction> castedContainer = std::dynamic_pointer_cast<uml::ValueSpecificationAction> (container);
						return this->createInterval_as_value_in_ValueSpecificationAction(castedContainer,metaElementID);
					}
					//Interval has value as a containment
					case  uml::umlPackage::VALUEPIN_ATTRIBUTE_VALUE:	
					{
						std::shared_ptr<ValuePin> castedContainer = std::dynamic_pointer_cast<ValuePin> (container);;
						return this->createInterval_as_value_in_ValuePin(castedContainer,metaElementID);
					}
					//Interval has weight as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_WEIGHT:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createInterval_as_weight_in_ActivityEdge(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::INTERVALCONSTRAINT_CLASS:
		{
			if (nullptr == container)
			{
				return this->createIntervalConstraint(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//IntervalConstraint has bodyCondition as a containment
					case  uml::umlPackage::OPERATION_ATTRIBUTE_BODYCONDITION:	
					{
						std::shared_ptr<Operation> castedContainer = std::dynamic_pointer_cast<Operation> (container);;
						return this->createIntervalConstraint_as_bodyCondition_in_Operation(castedContainer,metaElementID);
					}
					//IntervalConstraint has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createIntervalConstraint_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//IntervalConstraint has condition as a containment
					case  uml::umlPackage::PARAMETERSET_ATTRIBUTE_CONDITION:	
					{
						std::shared_ptr<ParameterSet> castedContainer = std::dynamic_pointer_cast<ParameterSet> (container);;
						return this->createIntervalConstraint_as_condition_in_ParameterSet(castedContainer,metaElementID);
					}
					//IntervalConstraint has condition as a containment
					case  uml::umlPackage::EXTEND_ATTRIBUTE_CONDITION:	
					{
						std::shared_ptr<Extend> castedContainer = std::dynamic_pointer_cast<Extend> (container);;
						return this->createIntervalConstraint_as_condition_in_Extend(castedContainer,metaElementID);
					}
					//IntervalConstraint has guard as a containment
					case  uml::umlPackage::TRANSITION_ATTRIBUTE_GUARD:	
					{
						std::shared_ptr<Transition> castedContainer = std::dynamic_pointer_cast<Transition> (container);;
						return this->createIntervalConstraint_as_guard_in_Transition(castedContainer,metaElementID);
					}
					//IntervalConstraint has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createIntervalConstraint_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//IntervalConstraint has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createIntervalConstraint_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//IntervalConstraint has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createIntervalConstraint_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//IntervalConstraint has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createIntervalConstraint_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//IntervalConstraint has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createIntervalConstraint_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//IntervalConstraint has invariant as a containment
					case  uml::umlPackage::STATEINVARIANT_ATTRIBUTE_INVARIANT:	
					{
						std::shared_ptr<StateInvariant> castedContainer = std::dynamic_pointer_cast<StateInvariant> (container);;
						return this->createIntervalConstraint_as_invariant_in_StateInvariant(castedContainer,metaElementID);
					}
					//IntervalConstraint has localPostcondition as a containment
					case  uml::umlPackage::ACTION_ATTRIBUTE_LOCALPOSTCONDITION:	
					{
						std::shared_ptr<Action> castedContainer = std::dynamic_pointer_cast<Action> (container);;
						return this->createIntervalConstraint_as_localPostcondition_in_Action(castedContainer,metaElementID);
					}
					//IntervalConstraint has localPrecondition as a containment
					case  uml::umlPackage::ACTION_ATTRIBUTE_LOCALPRECONDITION:	
					{
						std::shared_ptr<Action> castedContainer = std::dynamic_pointer_cast<Action> (container);;
						return this->createIntervalConstraint_as_localPrecondition_in_Action(castedContainer,metaElementID);
					}
					//IntervalConstraint has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createIntervalConstraint_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//IntervalConstraint has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createIntervalConstraint_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//IntervalConstraint has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createIntervalConstraint_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//IntervalConstraint has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createIntervalConstraint_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//IntervalConstraint has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createIntervalConstraint_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//IntervalConstraint has ownedRule as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDRULE:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createIntervalConstraint_as_ownedRule_in_Namespace(castedContainer,metaElementID);
					}
					//IntervalConstraint has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createIntervalConstraint_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//IntervalConstraint has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createIntervalConstraint_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//IntervalConstraint has postCondition as a containment
					case  uml::umlPackage::PROTOCOLTRANSITION_ATTRIBUTE_POSTCONDITION:	
					{
						std::shared_ptr<ProtocolTransition> castedContainer = std::dynamic_pointer_cast<ProtocolTransition> (container);;
						return this->createIntervalConstraint_as_postCondition_in_ProtocolTransition(castedContainer,metaElementID);
					}
					//IntervalConstraint has postcondition as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_POSTCONDITION:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createIntervalConstraint_as_postcondition_in_Behavior(castedContainer,metaElementID);
					}
					//IntervalConstraint has postcondition as a containment
					case  uml::umlPackage::OPERATION_ATTRIBUTE_POSTCONDITION:	
					{
						std::shared_ptr<Operation> castedContainer = std::dynamic_pointer_cast<Operation> (container);;
						return this->createIntervalConstraint_as_postcondition_in_Operation(castedContainer,metaElementID);
					}
					//IntervalConstraint has preCondition as a containment
					case  uml::umlPackage::PROTOCOLTRANSITION_ATTRIBUTE_PRECONDITION:	
					{
						std::shared_ptr<ProtocolTransition> castedContainer = std::dynamic_pointer_cast<ProtocolTransition> (container);;
						return this->createIntervalConstraint_as_preCondition_in_ProtocolTransition(castedContainer,metaElementID);
					}
					//IntervalConstraint has precondition as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_PRECONDITION:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createIntervalConstraint_as_precondition_in_Behavior(castedContainer,metaElementID);
					}
					//IntervalConstraint has precondition as a containment
					case  uml::umlPackage::OPERATION_ATTRIBUTE_PRECONDITION:	
					{
						std::shared_ptr<Operation> castedContainer = std::dynamic_pointer_cast<Operation> (container);;
						return this->createIntervalConstraint_as_precondition_in_Operation(castedContainer,metaElementID);
					}
					//IntervalConstraint has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createIntervalConstraint_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//IntervalConstraint has stateInvariant as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_STATEINVARIANT:	
					{
						std::shared_ptr<State> castedContainer = std::dynamic_pointer_cast<State> (container);;
						return this->createIntervalConstraint_as_stateInvariant_in_State(castedContainer,metaElementID);
					}
					//IntervalConstraint has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createIntervalConstraint_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//IntervalConstraint has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createIntervalConstraint_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//IntervalConstraint has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createIntervalConstraint_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::JOINNODE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createJoinNode(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//JoinNode has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createJoinNode_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//JoinNode has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createJoinNode_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//JoinNode has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createJoinNode_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//JoinNode has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createJoinNode_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//JoinNode has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createJoinNode_as_node_in_Activity(castedContainer,metaElementID);
					}
					//JoinNode has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createJoinNode_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//JoinNode has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createJoinNode_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//JoinNode has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createJoinNode_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//JoinNode has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createJoinNode_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//JoinNode has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createJoinNode_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//JoinNode has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createJoinNode_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//JoinNode has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createJoinNode_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//JoinNode has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createJoinNode_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//JoinNode has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createJoinNode_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//JoinNode has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createJoinNode_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::LIFELINE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createLifeline(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Lifeline has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createLifeline_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Lifeline has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createLifeline_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Lifeline has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createLifeline_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Lifeline has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createLifeline_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Lifeline has lifeline as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_LIFELINE:	
					{
						std::weak_ptr<uml::Interaction> castedContainer = std::dynamic_pointer_cast<uml::Interaction> (container);
						return this->createLifeline_as_lifeline_in_Interaction(castedContainer,metaElementID);
					}
					//Lifeline has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createLifeline_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Lifeline has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createLifeline_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Lifeline has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createLifeline_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Lifeline has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createLifeline_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Lifeline has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createLifeline_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::LINKENDCREATIONDATA_CLASS:
		{
			if (nullptr == container)
			{
				return this->createLinkEndCreationData(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//LinkEndCreationData has endData as a containment
					case  uml::umlPackage::LINKACTION_ATTRIBUTE_ENDDATA:	
					{
						std::shared_ptr<LinkAction> castedContainer = std::dynamic_pointer_cast<LinkAction> (container);;
						return this->createLinkEndCreationData_as_endData_in_LinkAction(castedContainer,metaElementID);
					}
					//LinkEndCreationData has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createLinkEndCreationData_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//LinkEndCreationData has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createLinkEndCreationData_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//LinkEndCreationData has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createLinkEndCreationData_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::LINKENDDATA_CLASS:
		{
			if (nullptr == container)
			{
				return this->createLinkEndData(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//LinkEndData has endData as a containment
					case  uml::umlPackage::LINKACTION_ATTRIBUTE_ENDDATA:	
					{
						std::shared_ptr<LinkAction> castedContainer = std::dynamic_pointer_cast<LinkAction> (container);;
						return this->createLinkEndData_as_endData_in_LinkAction(castedContainer,metaElementID);
					}
					//LinkEndData has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createLinkEndData_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//LinkEndData has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createLinkEndData_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//LinkEndData has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createLinkEndData_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::LINKENDDESTRUCTIONDATA_CLASS:
		{
			if (nullptr == container)
			{
				return this->createLinkEndDestructionData(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//LinkEndDestructionData has endData as a containment
					case  uml::umlPackage::LINKACTION_ATTRIBUTE_ENDDATA:	
					{
						std::shared_ptr<LinkAction> castedContainer = std::dynamic_pointer_cast<LinkAction> (container);;
						return this->createLinkEndDestructionData_as_endData_in_LinkAction(castedContainer,metaElementID);
					}
					//LinkEndDestructionData has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createLinkEndDestructionData_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//LinkEndDestructionData has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createLinkEndDestructionData_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//LinkEndDestructionData has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createLinkEndDestructionData_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::LITERALBOOLEAN_CLASS:
		{
			if (nullptr == container)
			{
				return this->createLiteralBoolean(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//LiteralBoolean has argument as a containment
					case  uml::umlPackage::MESSAGE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<Message> castedContainer = std::dynamic_pointer_cast<Message> (container);;
						return this->createLiteralBoolean_as_argument_in_Message(castedContainer,metaElementID);
					}
					//LiteralBoolean has argument as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createLiteralBoolean_as_argument_in_InteractionUse(castedContainer,metaElementID);
					}
					//LiteralBoolean has changeExpression as a containment
					case  uml::umlPackage::CHANGEEVENT_ATTRIBUTE_CHANGEEXPRESSION:	
					{
						std::shared_ptr<ChangeEvent> castedContainer = std::dynamic_pointer_cast<ChangeEvent> (container);;
						return this->createLiteralBoolean_as_changeExpression_in_ChangeEvent(castedContainer,metaElementID);
					}
					//LiteralBoolean has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createLiteralBoolean_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//LiteralBoolean has defaultValue as a containment
					case  uml::umlPackage::PROPERTY_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Property> castedContainer = std::dynamic_pointer_cast<Property> (container);;
						return this->createLiteralBoolean_as_defaultValue_in_Property(castedContainer,metaElementID);
					}
					//LiteralBoolean has defaultValue as a containment
					case  uml::umlPackage::PARAMETER_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Parameter> castedContainer = std::dynamic_pointer_cast<Parameter> (container);;
						return this->createLiteralBoolean_as_defaultValue_in_Parameter(castedContainer,metaElementID);
					}
					//LiteralBoolean has expr as a containment
					case  uml::umlPackage::TIMEEXPRESSION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<TimeExpression> castedContainer = std::dynamic_pointer_cast<TimeExpression> (container);;
						return this->createLiteralBoolean_as_expr_in_TimeExpression(castedContainer,metaElementID);
					}
					//LiteralBoolean has expr as a containment
					case  uml::umlPackage::DURATION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<Duration> castedContainer = std::dynamic_pointer_cast<Duration> (container);;
						return this->createLiteralBoolean_as_expr_in_Duration(castedContainer,metaElementID);
					}
					//LiteralBoolean has guard as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_GUARD:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createLiteralBoolean_as_guard_in_ActivityEdge(castedContainer,metaElementID);
					}
					//LiteralBoolean has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createLiteralBoolean_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//LiteralBoolean has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createLiteralBoolean_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//LiteralBoolean has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createLiteralBoolean_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//LiteralBoolean has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createLiteralBoolean_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//LiteralBoolean has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createLiteralBoolean_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//LiteralBoolean has joinSpec as a containment
					case  uml::umlPackage::JOINNODE_ATTRIBUTE_JOINSPEC:	
					{
						std::shared_ptr<JoinNode> castedContainer = std::dynamic_pointer_cast<JoinNode> (container);;
						return this->createLiteralBoolean_as_joinSpec_in_JoinNode(castedContainer,metaElementID);
					}
					//LiteralBoolean has lowerValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_LOWERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createLiteralBoolean_as_lowerValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//LiteralBoolean has maxint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MAXINT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createLiteralBoolean_as_maxint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//LiteralBoolean has minint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MININT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createLiteralBoolean_as_minint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//LiteralBoolean has operand as a containment
					case  uml::umlPackage::EXPRESSION_ATTRIBUTE_OPERAND:	
					{
						std::shared_ptr<Expression> castedContainer = std::dynamic_pointer_cast<Expression> (container);;
						return this->createLiteralBoolean_as_operand_in_Expression(castedContainer,metaElementID);
					}
					//LiteralBoolean has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createLiteralBoolean_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//LiteralBoolean has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createLiteralBoolean_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//LiteralBoolean has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createLiteralBoolean_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//LiteralBoolean has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createLiteralBoolean_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//LiteralBoolean has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createLiteralBoolean_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//LiteralBoolean has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createLiteralBoolean_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//LiteralBoolean has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createLiteralBoolean_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//LiteralBoolean has returnValue as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_RETURNVALUE:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createLiteralBoolean_as_returnValue_in_InteractionUse(castedContainer,metaElementID);
					}
					//LiteralBoolean has selector as a containment
					case  uml::umlPackage::LIFELINE_ATTRIBUTE_SELECTOR:	
					{
						std::shared_ptr<Lifeline> castedContainer = std::dynamic_pointer_cast<Lifeline> (container);;
						return this->createLiteralBoolean_as_selector_in_Lifeline(castedContainer,metaElementID);
					}
					//LiteralBoolean has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createLiteralBoolean_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//LiteralBoolean has specification as a containment
					case  uml::umlPackage::CONSTRAINT_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<Constraint> castedContainer = std::dynamic_pointer_cast<Constraint> (container);;
						return this->createLiteralBoolean_as_specification_in_Constraint(castedContainer,metaElementID);
					}
					//LiteralBoolean has specification as a containment
					case  uml::umlPackage::INSTANCESPECIFICATION_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<InstanceSpecification> castedContainer = std::dynamic_pointer_cast<InstanceSpecification> (container);;
						return this->createLiteralBoolean_as_specification_in_InstanceSpecification(castedContainer,metaElementID);
					}
					//LiteralBoolean has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createLiteralBoolean_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//LiteralBoolean has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createLiteralBoolean_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//LiteralBoolean has upperBound as a containment
					case  uml::umlPackage::OBJECTNODE_ATTRIBUTE_UPPERBOUND:	
					{
						std::shared_ptr<ObjectNode> castedContainer = std::dynamic_pointer_cast<ObjectNode> (container);;
						return this->createLiteralBoolean_as_upperBound_in_ObjectNode(castedContainer,metaElementID);
					}
					//LiteralBoolean has upperValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_UPPERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createLiteralBoolean_as_upperValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//LiteralBoolean has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createLiteralBoolean_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					//LiteralBoolean has value as a containment
					case  uml::umlPackage::SLOT_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::Slot> castedContainer = std::dynamic_pointer_cast<uml::Slot> (container);
						return this->createLiteralBoolean_as_value_in_Slot(castedContainer,metaElementID);
					}
					//LiteralBoolean has value as a containment
					case  uml::umlPackage::VALUESPECIFICATIONACTION_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::ValueSpecificationAction> castedContainer = std::dynamic_pointer_cast<uml::ValueSpecificationAction> (container);
						return this->createLiteralBoolean_as_value_in_ValueSpecificationAction(castedContainer,metaElementID);
					}
					//LiteralBoolean has value as a containment
					case  uml::umlPackage::VALUEPIN_ATTRIBUTE_VALUE:	
					{
						std::shared_ptr<ValuePin> castedContainer = std::dynamic_pointer_cast<ValuePin> (container);;
						return this->createLiteralBoolean_as_value_in_ValuePin(castedContainer,metaElementID);
					}
					//LiteralBoolean has weight as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_WEIGHT:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createLiteralBoolean_as_weight_in_ActivityEdge(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::LITERALINTEGER_CLASS:
		{
			if (nullptr == container)
			{
				return this->createLiteralInteger(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//LiteralInteger has argument as a containment
					case  uml::umlPackage::MESSAGE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<Message> castedContainer = std::dynamic_pointer_cast<Message> (container);;
						return this->createLiteralInteger_as_argument_in_Message(castedContainer,metaElementID);
					}
					//LiteralInteger has argument as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createLiteralInteger_as_argument_in_InteractionUse(castedContainer,metaElementID);
					}
					//LiteralInteger has changeExpression as a containment
					case  uml::umlPackage::CHANGEEVENT_ATTRIBUTE_CHANGEEXPRESSION:	
					{
						std::shared_ptr<ChangeEvent> castedContainer = std::dynamic_pointer_cast<ChangeEvent> (container);;
						return this->createLiteralInteger_as_changeExpression_in_ChangeEvent(castedContainer,metaElementID);
					}
					//LiteralInteger has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createLiteralInteger_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//LiteralInteger has defaultValue as a containment
					case  uml::umlPackage::PROPERTY_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Property> castedContainer = std::dynamic_pointer_cast<Property> (container);;
						return this->createLiteralInteger_as_defaultValue_in_Property(castedContainer,metaElementID);
					}
					//LiteralInteger has defaultValue as a containment
					case  uml::umlPackage::PARAMETER_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Parameter> castedContainer = std::dynamic_pointer_cast<Parameter> (container);;
						return this->createLiteralInteger_as_defaultValue_in_Parameter(castedContainer,metaElementID);
					}
					//LiteralInteger has expr as a containment
					case  uml::umlPackage::TIMEEXPRESSION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<TimeExpression> castedContainer = std::dynamic_pointer_cast<TimeExpression> (container);;
						return this->createLiteralInteger_as_expr_in_TimeExpression(castedContainer,metaElementID);
					}
					//LiteralInteger has expr as a containment
					case  uml::umlPackage::DURATION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<Duration> castedContainer = std::dynamic_pointer_cast<Duration> (container);;
						return this->createLiteralInteger_as_expr_in_Duration(castedContainer,metaElementID);
					}
					//LiteralInteger has guard as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_GUARD:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createLiteralInteger_as_guard_in_ActivityEdge(castedContainer,metaElementID);
					}
					//LiteralInteger has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createLiteralInteger_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//LiteralInteger has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createLiteralInteger_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//LiteralInteger has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createLiteralInteger_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//LiteralInteger has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createLiteralInteger_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//LiteralInteger has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createLiteralInteger_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//LiteralInteger has joinSpec as a containment
					case  uml::umlPackage::JOINNODE_ATTRIBUTE_JOINSPEC:	
					{
						std::shared_ptr<JoinNode> castedContainer = std::dynamic_pointer_cast<JoinNode> (container);;
						return this->createLiteralInteger_as_joinSpec_in_JoinNode(castedContainer,metaElementID);
					}
					//LiteralInteger has lowerValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_LOWERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createLiteralInteger_as_lowerValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//LiteralInteger has maxint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MAXINT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createLiteralInteger_as_maxint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//LiteralInteger has minint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MININT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createLiteralInteger_as_minint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//LiteralInteger has operand as a containment
					case  uml::umlPackage::EXPRESSION_ATTRIBUTE_OPERAND:	
					{
						std::shared_ptr<Expression> castedContainer = std::dynamic_pointer_cast<Expression> (container);;
						return this->createLiteralInteger_as_operand_in_Expression(castedContainer,metaElementID);
					}
					//LiteralInteger has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createLiteralInteger_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//LiteralInteger has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createLiteralInteger_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//LiteralInteger has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createLiteralInteger_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//LiteralInteger has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createLiteralInteger_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//LiteralInteger has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createLiteralInteger_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//LiteralInteger has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createLiteralInteger_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//LiteralInteger has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createLiteralInteger_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//LiteralInteger has returnValue as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_RETURNVALUE:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createLiteralInteger_as_returnValue_in_InteractionUse(castedContainer,metaElementID);
					}
					//LiteralInteger has selector as a containment
					case  uml::umlPackage::LIFELINE_ATTRIBUTE_SELECTOR:	
					{
						std::shared_ptr<Lifeline> castedContainer = std::dynamic_pointer_cast<Lifeline> (container);;
						return this->createLiteralInteger_as_selector_in_Lifeline(castedContainer,metaElementID);
					}
					//LiteralInteger has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createLiteralInteger_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//LiteralInteger has specification as a containment
					case  uml::umlPackage::CONSTRAINT_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<Constraint> castedContainer = std::dynamic_pointer_cast<Constraint> (container);;
						return this->createLiteralInteger_as_specification_in_Constraint(castedContainer,metaElementID);
					}
					//LiteralInteger has specification as a containment
					case  uml::umlPackage::INSTANCESPECIFICATION_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<InstanceSpecification> castedContainer = std::dynamic_pointer_cast<InstanceSpecification> (container);;
						return this->createLiteralInteger_as_specification_in_InstanceSpecification(castedContainer,metaElementID);
					}
					//LiteralInteger has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createLiteralInteger_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//LiteralInteger has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createLiteralInteger_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//LiteralInteger has upperBound as a containment
					case  uml::umlPackage::OBJECTNODE_ATTRIBUTE_UPPERBOUND:	
					{
						std::shared_ptr<ObjectNode> castedContainer = std::dynamic_pointer_cast<ObjectNode> (container);;
						return this->createLiteralInteger_as_upperBound_in_ObjectNode(castedContainer,metaElementID);
					}
					//LiteralInteger has upperValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_UPPERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createLiteralInteger_as_upperValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//LiteralInteger has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createLiteralInteger_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					//LiteralInteger has value as a containment
					case  uml::umlPackage::SLOT_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::Slot> castedContainer = std::dynamic_pointer_cast<uml::Slot> (container);
						return this->createLiteralInteger_as_value_in_Slot(castedContainer,metaElementID);
					}
					//LiteralInteger has value as a containment
					case  uml::umlPackage::VALUESPECIFICATIONACTION_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::ValueSpecificationAction> castedContainer = std::dynamic_pointer_cast<uml::ValueSpecificationAction> (container);
						return this->createLiteralInteger_as_value_in_ValueSpecificationAction(castedContainer,metaElementID);
					}
					//LiteralInteger has value as a containment
					case  uml::umlPackage::VALUEPIN_ATTRIBUTE_VALUE:	
					{
						std::shared_ptr<ValuePin> castedContainer = std::dynamic_pointer_cast<ValuePin> (container);;
						return this->createLiteralInteger_as_value_in_ValuePin(castedContainer,metaElementID);
					}
					//LiteralInteger has weight as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_WEIGHT:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createLiteralInteger_as_weight_in_ActivityEdge(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::LITERALNULL_CLASS:
		{
			if (nullptr == container)
			{
				return this->createLiteralNull(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//LiteralNull has argument as a containment
					case  uml::umlPackage::MESSAGE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<Message> castedContainer = std::dynamic_pointer_cast<Message> (container);;
						return this->createLiteralNull_as_argument_in_Message(castedContainer,metaElementID);
					}
					//LiteralNull has argument as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createLiteralNull_as_argument_in_InteractionUse(castedContainer,metaElementID);
					}
					//LiteralNull has changeExpression as a containment
					case  uml::umlPackage::CHANGEEVENT_ATTRIBUTE_CHANGEEXPRESSION:	
					{
						std::shared_ptr<ChangeEvent> castedContainer = std::dynamic_pointer_cast<ChangeEvent> (container);;
						return this->createLiteralNull_as_changeExpression_in_ChangeEvent(castedContainer,metaElementID);
					}
					//LiteralNull has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createLiteralNull_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//LiteralNull has defaultValue as a containment
					case  uml::umlPackage::PROPERTY_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Property> castedContainer = std::dynamic_pointer_cast<Property> (container);;
						return this->createLiteralNull_as_defaultValue_in_Property(castedContainer,metaElementID);
					}
					//LiteralNull has defaultValue as a containment
					case  uml::umlPackage::PARAMETER_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Parameter> castedContainer = std::dynamic_pointer_cast<Parameter> (container);;
						return this->createLiteralNull_as_defaultValue_in_Parameter(castedContainer,metaElementID);
					}
					//LiteralNull has expr as a containment
					case  uml::umlPackage::TIMEEXPRESSION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<TimeExpression> castedContainer = std::dynamic_pointer_cast<TimeExpression> (container);;
						return this->createLiteralNull_as_expr_in_TimeExpression(castedContainer,metaElementID);
					}
					//LiteralNull has expr as a containment
					case  uml::umlPackage::DURATION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<Duration> castedContainer = std::dynamic_pointer_cast<Duration> (container);;
						return this->createLiteralNull_as_expr_in_Duration(castedContainer,metaElementID);
					}
					//LiteralNull has guard as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_GUARD:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createLiteralNull_as_guard_in_ActivityEdge(castedContainer,metaElementID);
					}
					//LiteralNull has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createLiteralNull_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//LiteralNull has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createLiteralNull_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//LiteralNull has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createLiteralNull_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//LiteralNull has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createLiteralNull_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//LiteralNull has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createLiteralNull_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//LiteralNull has joinSpec as a containment
					case  uml::umlPackage::JOINNODE_ATTRIBUTE_JOINSPEC:	
					{
						std::shared_ptr<JoinNode> castedContainer = std::dynamic_pointer_cast<JoinNode> (container);;
						return this->createLiteralNull_as_joinSpec_in_JoinNode(castedContainer,metaElementID);
					}
					//LiteralNull has lowerValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_LOWERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createLiteralNull_as_lowerValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//LiteralNull has maxint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MAXINT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createLiteralNull_as_maxint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//LiteralNull has minint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MININT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createLiteralNull_as_minint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//LiteralNull has operand as a containment
					case  uml::umlPackage::EXPRESSION_ATTRIBUTE_OPERAND:	
					{
						std::shared_ptr<Expression> castedContainer = std::dynamic_pointer_cast<Expression> (container);;
						return this->createLiteralNull_as_operand_in_Expression(castedContainer,metaElementID);
					}
					//LiteralNull has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createLiteralNull_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//LiteralNull has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createLiteralNull_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//LiteralNull has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createLiteralNull_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//LiteralNull has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createLiteralNull_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//LiteralNull has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createLiteralNull_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//LiteralNull has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createLiteralNull_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//LiteralNull has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createLiteralNull_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//LiteralNull has returnValue as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_RETURNVALUE:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createLiteralNull_as_returnValue_in_InteractionUse(castedContainer,metaElementID);
					}
					//LiteralNull has selector as a containment
					case  uml::umlPackage::LIFELINE_ATTRIBUTE_SELECTOR:	
					{
						std::shared_ptr<Lifeline> castedContainer = std::dynamic_pointer_cast<Lifeline> (container);;
						return this->createLiteralNull_as_selector_in_Lifeline(castedContainer,metaElementID);
					}
					//LiteralNull has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createLiteralNull_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//LiteralNull has specification as a containment
					case  uml::umlPackage::CONSTRAINT_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<Constraint> castedContainer = std::dynamic_pointer_cast<Constraint> (container);;
						return this->createLiteralNull_as_specification_in_Constraint(castedContainer,metaElementID);
					}
					//LiteralNull has specification as a containment
					case  uml::umlPackage::INSTANCESPECIFICATION_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<InstanceSpecification> castedContainer = std::dynamic_pointer_cast<InstanceSpecification> (container);;
						return this->createLiteralNull_as_specification_in_InstanceSpecification(castedContainer,metaElementID);
					}
					//LiteralNull has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createLiteralNull_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//LiteralNull has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createLiteralNull_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//LiteralNull has upperBound as a containment
					case  uml::umlPackage::OBJECTNODE_ATTRIBUTE_UPPERBOUND:	
					{
						std::shared_ptr<ObjectNode> castedContainer = std::dynamic_pointer_cast<ObjectNode> (container);;
						return this->createLiteralNull_as_upperBound_in_ObjectNode(castedContainer,metaElementID);
					}
					//LiteralNull has upperValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_UPPERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createLiteralNull_as_upperValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//LiteralNull has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createLiteralNull_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					//LiteralNull has value as a containment
					case  uml::umlPackage::SLOT_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::Slot> castedContainer = std::dynamic_pointer_cast<uml::Slot> (container);
						return this->createLiteralNull_as_value_in_Slot(castedContainer,metaElementID);
					}
					//LiteralNull has value as a containment
					case  uml::umlPackage::VALUESPECIFICATIONACTION_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::ValueSpecificationAction> castedContainer = std::dynamic_pointer_cast<uml::ValueSpecificationAction> (container);
						return this->createLiteralNull_as_value_in_ValueSpecificationAction(castedContainer,metaElementID);
					}
					//LiteralNull has value as a containment
					case  uml::umlPackage::VALUEPIN_ATTRIBUTE_VALUE:	
					{
						std::shared_ptr<ValuePin> castedContainer = std::dynamic_pointer_cast<ValuePin> (container);;
						return this->createLiteralNull_as_value_in_ValuePin(castedContainer,metaElementID);
					}
					//LiteralNull has weight as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_WEIGHT:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createLiteralNull_as_weight_in_ActivityEdge(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::LITERALREAL_CLASS:
		{
			if (nullptr == container)
			{
				return this->createLiteralReal(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//LiteralReal has argument as a containment
					case  uml::umlPackage::MESSAGE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<Message> castedContainer = std::dynamic_pointer_cast<Message> (container);;
						return this->createLiteralReal_as_argument_in_Message(castedContainer,metaElementID);
					}
					//LiteralReal has argument as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createLiteralReal_as_argument_in_InteractionUse(castedContainer,metaElementID);
					}
					//LiteralReal has changeExpression as a containment
					case  uml::umlPackage::CHANGEEVENT_ATTRIBUTE_CHANGEEXPRESSION:	
					{
						std::shared_ptr<ChangeEvent> castedContainer = std::dynamic_pointer_cast<ChangeEvent> (container);;
						return this->createLiteralReal_as_changeExpression_in_ChangeEvent(castedContainer,metaElementID);
					}
					//LiteralReal has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createLiteralReal_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//LiteralReal has defaultValue as a containment
					case  uml::umlPackage::PROPERTY_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Property> castedContainer = std::dynamic_pointer_cast<Property> (container);;
						return this->createLiteralReal_as_defaultValue_in_Property(castedContainer,metaElementID);
					}
					//LiteralReal has defaultValue as a containment
					case  uml::umlPackage::PARAMETER_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Parameter> castedContainer = std::dynamic_pointer_cast<Parameter> (container);;
						return this->createLiteralReal_as_defaultValue_in_Parameter(castedContainer,metaElementID);
					}
					//LiteralReal has expr as a containment
					case  uml::umlPackage::TIMEEXPRESSION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<TimeExpression> castedContainer = std::dynamic_pointer_cast<TimeExpression> (container);;
						return this->createLiteralReal_as_expr_in_TimeExpression(castedContainer,metaElementID);
					}
					//LiteralReal has expr as a containment
					case  uml::umlPackage::DURATION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<Duration> castedContainer = std::dynamic_pointer_cast<Duration> (container);;
						return this->createLiteralReal_as_expr_in_Duration(castedContainer,metaElementID);
					}
					//LiteralReal has guard as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_GUARD:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createLiteralReal_as_guard_in_ActivityEdge(castedContainer,metaElementID);
					}
					//LiteralReal has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createLiteralReal_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//LiteralReal has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createLiteralReal_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//LiteralReal has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createLiteralReal_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//LiteralReal has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createLiteralReal_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//LiteralReal has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createLiteralReal_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//LiteralReal has joinSpec as a containment
					case  uml::umlPackage::JOINNODE_ATTRIBUTE_JOINSPEC:	
					{
						std::shared_ptr<JoinNode> castedContainer = std::dynamic_pointer_cast<JoinNode> (container);;
						return this->createLiteralReal_as_joinSpec_in_JoinNode(castedContainer,metaElementID);
					}
					//LiteralReal has lowerValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_LOWERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createLiteralReal_as_lowerValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//LiteralReal has maxint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MAXINT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createLiteralReal_as_maxint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//LiteralReal has minint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MININT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createLiteralReal_as_minint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//LiteralReal has operand as a containment
					case  uml::umlPackage::EXPRESSION_ATTRIBUTE_OPERAND:	
					{
						std::shared_ptr<Expression> castedContainer = std::dynamic_pointer_cast<Expression> (container);;
						return this->createLiteralReal_as_operand_in_Expression(castedContainer,metaElementID);
					}
					//LiteralReal has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createLiteralReal_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//LiteralReal has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createLiteralReal_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//LiteralReal has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createLiteralReal_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//LiteralReal has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createLiteralReal_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//LiteralReal has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createLiteralReal_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//LiteralReal has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createLiteralReal_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//LiteralReal has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createLiteralReal_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//LiteralReal has returnValue as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_RETURNVALUE:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createLiteralReal_as_returnValue_in_InteractionUse(castedContainer,metaElementID);
					}
					//LiteralReal has selector as a containment
					case  uml::umlPackage::LIFELINE_ATTRIBUTE_SELECTOR:	
					{
						std::shared_ptr<Lifeline> castedContainer = std::dynamic_pointer_cast<Lifeline> (container);;
						return this->createLiteralReal_as_selector_in_Lifeline(castedContainer,metaElementID);
					}
					//LiteralReal has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createLiteralReal_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//LiteralReal has specification as a containment
					case  uml::umlPackage::CONSTRAINT_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<Constraint> castedContainer = std::dynamic_pointer_cast<Constraint> (container);;
						return this->createLiteralReal_as_specification_in_Constraint(castedContainer,metaElementID);
					}
					//LiteralReal has specification as a containment
					case  uml::umlPackage::INSTANCESPECIFICATION_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<InstanceSpecification> castedContainer = std::dynamic_pointer_cast<InstanceSpecification> (container);;
						return this->createLiteralReal_as_specification_in_InstanceSpecification(castedContainer,metaElementID);
					}
					//LiteralReal has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createLiteralReal_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//LiteralReal has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createLiteralReal_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//LiteralReal has upperBound as a containment
					case  uml::umlPackage::OBJECTNODE_ATTRIBUTE_UPPERBOUND:	
					{
						std::shared_ptr<ObjectNode> castedContainer = std::dynamic_pointer_cast<ObjectNode> (container);;
						return this->createLiteralReal_as_upperBound_in_ObjectNode(castedContainer,metaElementID);
					}
					//LiteralReal has upperValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_UPPERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createLiteralReal_as_upperValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//LiteralReal has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createLiteralReal_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					//LiteralReal has value as a containment
					case  uml::umlPackage::SLOT_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::Slot> castedContainer = std::dynamic_pointer_cast<uml::Slot> (container);
						return this->createLiteralReal_as_value_in_Slot(castedContainer,metaElementID);
					}
					//LiteralReal has value as a containment
					case  uml::umlPackage::VALUESPECIFICATIONACTION_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::ValueSpecificationAction> castedContainer = std::dynamic_pointer_cast<uml::ValueSpecificationAction> (container);
						return this->createLiteralReal_as_value_in_ValueSpecificationAction(castedContainer,metaElementID);
					}
					//LiteralReal has value as a containment
					case  uml::umlPackage::VALUEPIN_ATTRIBUTE_VALUE:	
					{
						std::shared_ptr<ValuePin> castedContainer = std::dynamic_pointer_cast<ValuePin> (container);;
						return this->createLiteralReal_as_value_in_ValuePin(castedContainer,metaElementID);
					}
					//LiteralReal has weight as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_WEIGHT:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createLiteralReal_as_weight_in_ActivityEdge(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::LITERALSTRING_CLASS:
		{
			if (nullptr == container)
			{
				return this->createLiteralString(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//LiteralString has argument as a containment
					case  uml::umlPackage::MESSAGE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<Message> castedContainer = std::dynamic_pointer_cast<Message> (container);;
						return this->createLiteralString_as_argument_in_Message(castedContainer,metaElementID);
					}
					//LiteralString has argument as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createLiteralString_as_argument_in_InteractionUse(castedContainer,metaElementID);
					}
					//LiteralString has changeExpression as a containment
					case  uml::umlPackage::CHANGEEVENT_ATTRIBUTE_CHANGEEXPRESSION:	
					{
						std::shared_ptr<ChangeEvent> castedContainer = std::dynamic_pointer_cast<ChangeEvent> (container);;
						return this->createLiteralString_as_changeExpression_in_ChangeEvent(castedContainer,metaElementID);
					}
					//LiteralString has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createLiteralString_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//LiteralString has defaultValue as a containment
					case  uml::umlPackage::PROPERTY_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Property> castedContainer = std::dynamic_pointer_cast<Property> (container);;
						return this->createLiteralString_as_defaultValue_in_Property(castedContainer,metaElementID);
					}
					//LiteralString has defaultValue as a containment
					case  uml::umlPackage::PARAMETER_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Parameter> castedContainer = std::dynamic_pointer_cast<Parameter> (container);;
						return this->createLiteralString_as_defaultValue_in_Parameter(castedContainer,metaElementID);
					}
					//LiteralString has expr as a containment
					case  uml::umlPackage::TIMEEXPRESSION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<TimeExpression> castedContainer = std::dynamic_pointer_cast<TimeExpression> (container);;
						return this->createLiteralString_as_expr_in_TimeExpression(castedContainer,metaElementID);
					}
					//LiteralString has expr as a containment
					case  uml::umlPackage::DURATION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<Duration> castedContainer = std::dynamic_pointer_cast<Duration> (container);;
						return this->createLiteralString_as_expr_in_Duration(castedContainer,metaElementID);
					}
					//LiteralString has guard as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_GUARD:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createLiteralString_as_guard_in_ActivityEdge(castedContainer,metaElementID);
					}
					//LiteralString has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createLiteralString_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//LiteralString has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createLiteralString_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//LiteralString has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createLiteralString_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//LiteralString has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createLiteralString_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//LiteralString has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createLiteralString_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//LiteralString has joinSpec as a containment
					case  uml::umlPackage::JOINNODE_ATTRIBUTE_JOINSPEC:	
					{
						std::shared_ptr<JoinNode> castedContainer = std::dynamic_pointer_cast<JoinNode> (container);;
						return this->createLiteralString_as_joinSpec_in_JoinNode(castedContainer,metaElementID);
					}
					//LiteralString has lowerValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_LOWERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createLiteralString_as_lowerValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//LiteralString has maxint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MAXINT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createLiteralString_as_maxint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//LiteralString has minint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MININT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createLiteralString_as_minint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//LiteralString has operand as a containment
					case  uml::umlPackage::EXPRESSION_ATTRIBUTE_OPERAND:	
					{
						std::shared_ptr<Expression> castedContainer = std::dynamic_pointer_cast<Expression> (container);;
						return this->createLiteralString_as_operand_in_Expression(castedContainer,metaElementID);
					}
					//LiteralString has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createLiteralString_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//LiteralString has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createLiteralString_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//LiteralString has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createLiteralString_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//LiteralString has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createLiteralString_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//LiteralString has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createLiteralString_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//LiteralString has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createLiteralString_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//LiteralString has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createLiteralString_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//LiteralString has returnValue as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_RETURNVALUE:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createLiteralString_as_returnValue_in_InteractionUse(castedContainer,metaElementID);
					}
					//LiteralString has selector as a containment
					case  uml::umlPackage::LIFELINE_ATTRIBUTE_SELECTOR:	
					{
						std::shared_ptr<Lifeline> castedContainer = std::dynamic_pointer_cast<Lifeline> (container);;
						return this->createLiteralString_as_selector_in_Lifeline(castedContainer,metaElementID);
					}
					//LiteralString has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createLiteralString_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//LiteralString has specification as a containment
					case  uml::umlPackage::CONSTRAINT_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<Constraint> castedContainer = std::dynamic_pointer_cast<Constraint> (container);;
						return this->createLiteralString_as_specification_in_Constraint(castedContainer,metaElementID);
					}
					//LiteralString has specification as a containment
					case  uml::umlPackage::INSTANCESPECIFICATION_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<InstanceSpecification> castedContainer = std::dynamic_pointer_cast<InstanceSpecification> (container);;
						return this->createLiteralString_as_specification_in_InstanceSpecification(castedContainer,metaElementID);
					}
					//LiteralString has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createLiteralString_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//LiteralString has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createLiteralString_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//LiteralString has upperBound as a containment
					case  uml::umlPackage::OBJECTNODE_ATTRIBUTE_UPPERBOUND:	
					{
						std::shared_ptr<ObjectNode> castedContainer = std::dynamic_pointer_cast<ObjectNode> (container);;
						return this->createLiteralString_as_upperBound_in_ObjectNode(castedContainer,metaElementID);
					}
					//LiteralString has upperValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_UPPERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createLiteralString_as_upperValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//LiteralString has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createLiteralString_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					//LiteralString has value as a containment
					case  uml::umlPackage::SLOT_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::Slot> castedContainer = std::dynamic_pointer_cast<uml::Slot> (container);
						return this->createLiteralString_as_value_in_Slot(castedContainer,metaElementID);
					}
					//LiteralString has value as a containment
					case  uml::umlPackage::VALUESPECIFICATIONACTION_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::ValueSpecificationAction> castedContainer = std::dynamic_pointer_cast<uml::ValueSpecificationAction> (container);
						return this->createLiteralString_as_value_in_ValueSpecificationAction(castedContainer,metaElementID);
					}
					//LiteralString has value as a containment
					case  uml::umlPackage::VALUEPIN_ATTRIBUTE_VALUE:	
					{
						std::shared_ptr<ValuePin> castedContainer = std::dynamic_pointer_cast<ValuePin> (container);;
						return this->createLiteralString_as_value_in_ValuePin(castedContainer,metaElementID);
					}
					//LiteralString has weight as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_WEIGHT:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createLiteralString_as_weight_in_ActivityEdge(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::LITERALUNLIMITEDNATURAL_CLASS:
		{
			if (nullptr == container)
			{
				return this->createLiteralUnlimitedNatural(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//LiteralUnlimitedNatural has argument as a containment
					case  uml::umlPackage::MESSAGE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<Message> castedContainer = std::dynamic_pointer_cast<Message> (container);;
						return this->createLiteralUnlimitedNatural_as_argument_in_Message(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has argument as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createLiteralUnlimitedNatural_as_argument_in_InteractionUse(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has changeExpression as a containment
					case  uml::umlPackage::CHANGEEVENT_ATTRIBUTE_CHANGEEXPRESSION:	
					{
						std::shared_ptr<ChangeEvent> castedContainer = std::dynamic_pointer_cast<ChangeEvent> (container);;
						return this->createLiteralUnlimitedNatural_as_changeExpression_in_ChangeEvent(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createLiteralUnlimitedNatural_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has defaultValue as a containment
					case  uml::umlPackage::PROPERTY_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Property> castedContainer = std::dynamic_pointer_cast<Property> (container);;
						return this->createLiteralUnlimitedNatural_as_defaultValue_in_Property(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has defaultValue as a containment
					case  uml::umlPackage::PARAMETER_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Parameter> castedContainer = std::dynamic_pointer_cast<Parameter> (container);;
						return this->createLiteralUnlimitedNatural_as_defaultValue_in_Parameter(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has expr as a containment
					case  uml::umlPackage::TIMEEXPRESSION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<TimeExpression> castedContainer = std::dynamic_pointer_cast<TimeExpression> (container);;
						return this->createLiteralUnlimitedNatural_as_expr_in_TimeExpression(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has expr as a containment
					case  uml::umlPackage::DURATION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<Duration> castedContainer = std::dynamic_pointer_cast<Duration> (container);;
						return this->createLiteralUnlimitedNatural_as_expr_in_Duration(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has guard as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_GUARD:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createLiteralUnlimitedNatural_as_guard_in_ActivityEdge(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createLiteralUnlimitedNatural_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createLiteralUnlimitedNatural_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createLiteralUnlimitedNatural_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createLiteralUnlimitedNatural_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createLiteralUnlimitedNatural_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has joinSpec as a containment
					case  uml::umlPackage::JOINNODE_ATTRIBUTE_JOINSPEC:	
					{
						std::shared_ptr<JoinNode> castedContainer = std::dynamic_pointer_cast<JoinNode> (container);;
						return this->createLiteralUnlimitedNatural_as_joinSpec_in_JoinNode(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has lowerValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_LOWERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createLiteralUnlimitedNatural_as_lowerValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has maxint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MAXINT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createLiteralUnlimitedNatural_as_maxint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has minint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MININT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createLiteralUnlimitedNatural_as_minint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has operand as a containment
					case  uml::umlPackage::EXPRESSION_ATTRIBUTE_OPERAND:	
					{
						std::shared_ptr<Expression> castedContainer = std::dynamic_pointer_cast<Expression> (container);;
						return this->createLiteralUnlimitedNatural_as_operand_in_Expression(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createLiteralUnlimitedNatural_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createLiteralUnlimitedNatural_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createLiteralUnlimitedNatural_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createLiteralUnlimitedNatural_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createLiteralUnlimitedNatural_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createLiteralUnlimitedNatural_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createLiteralUnlimitedNatural_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has returnValue as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_RETURNVALUE:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createLiteralUnlimitedNatural_as_returnValue_in_InteractionUse(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has selector as a containment
					case  uml::umlPackage::LIFELINE_ATTRIBUTE_SELECTOR:	
					{
						std::shared_ptr<Lifeline> castedContainer = std::dynamic_pointer_cast<Lifeline> (container);;
						return this->createLiteralUnlimitedNatural_as_selector_in_Lifeline(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createLiteralUnlimitedNatural_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has specification as a containment
					case  uml::umlPackage::CONSTRAINT_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<Constraint> castedContainer = std::dynamic_pointer_cast<Constraint> (container);;
						return this->createLiteralUnlimitedNatural_as_specification_in_Constraint(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has specification as a containment
					case  uml::umlPackage::INSTANCESPECIFICATION_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<InstanceSpecification> castedContainer = std::dynamic_pointer_cast<InstanceSpecification> (container);;
						return this->createLiteralUnlimitedNatural_as_specification_in_InstanceSpecification(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createLiteralUnlimitedNatural_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createLiteralUnlimitedNatural_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has upperBound as a containment
					case  uml::umlPackage::OBJECTNODE_ATTRIBUTE_UPPERBOUND:	
					{
						std::shared_ptr<ObjectNode> castedContainer = std::dynamic_pointer_cast<ObjectNode> (container);;
						return this->createLiteralUnlimitedNatural_as_upperBound_in_ObjectNode(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has upperValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_UPPERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createLiteralUnlimitedNatural_as_upperValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createLiteralUnlimitedNatural_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has value as a containment
					case  uml::umlPackage::SLOT_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::Slot> castedContainer = std::dynamic_pointer_cast<uml::Slot> (container);
						return this->createLiteralUnlimitedNatural_as_value_in_Slot(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has value as a containment
					case  uml::umlPackage::VALUESPECIFICATIONACTION_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::ValueSpecificationAction> castedContainer = std::dynamic_pointer_cast<uml::ValueSpecificationAction> (container);
						return this->createLiteralUnlimitedNatural_as_value_in_ValueSpecificationAction(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has value as a containment
					case  uml::umlPackage::VALUEPIN_ATTRIBUTE_VALUE:	
					{
						std::shared_ptr<ValuePin> castedContainer = std::dynamic_pointer_cast<ValuePin> (container);;
						return this->createLiteralUnlimitedNatural_as_value_in_ValuePin(castedContainer,metaElementID);
					}
					//LiteralUnlimitedNatural has weight as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_WEIGHT:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createLiteralUnlimitedNatural_as_weight_in_ActivityEdge(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::LOOPNODE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createLoopNode(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//LoopNode has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createLoopNode_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//LoopNode has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createLoopNode_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//LoopNode has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createLoopNode_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//LoopNode has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createLoopNode_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//LoopNode has group as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_GROUP:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createLoopNode_as_group_in_Activity(castedContainer,metaElementID);
					}
					//LoopNode has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createLoopNode_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//LoopNode has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createLoopNode_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//LoopNode has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createLoopNode_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//LoopNode has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createLoopNode_as_node_in_Activity(castedContainer,metaElementID);
					}
					//LoopNode has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createLoopNode_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//LoopNode has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createLoopNode_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//LoopNode has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createLoopNode_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//LoopNode has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createLoopNode_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//LoopNode has ownedGroup as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDGROUP:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createLoopNode_as_ownedGroup_in_Activity(castedContainer,metaElementID);
					}
					//LoopNode has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createLoopNode_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//LoopNode has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createLoopNode_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//LoopNode has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createLoopNode_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//LoopNode has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createLoopNode_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//LoopNode has structuredNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_STRUCTUREDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createLoopNode_as_structuredNode_in_Activity(castedContainer,metaElementID);
					}
					//LoopNode has subgroup as a containment
					case  uml::umlPackage::ACTIVITYGROUP_ATTRIBUTE_SUBGROUP:	
					{
						std::weak_ptr<uml::ActivityGroup> castedContainer = std::dynamic_pointer_cast<uml::ActivityGroup> (container);
						return this->createLoopNode_as_subgroup_in_ActivityGroup(castedContainer,metaElementID);
					}
					//LoopNode has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createLoopNode_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//LoopNode has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createLoopNode_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::MANIFESTATION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createManifestation(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Manifestation has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createManifestation_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Manifestation has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createManifestation_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Manifestation has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createManifestation_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Manifestation has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createManifestation_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Manifestation has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createManifestation_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Manifestation has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createManifestation_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Manifestation has manifestation as a containment
					case  uml::umlPackage::ARTIFACT_ATTRIBUTE_MANIFESTATION:	
					{
						std::shared_ptr<Artifact> castedContainer = std::dynamic_pointer_cast<Artifact> (container);;
						return this->createManifestation_as_manifestation_in_Artifact(castedContainer,metaElementID);
					}
					//Manifestation has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createManifestation_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Manifestation has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createManifestation_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Manifestation has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createManifestation_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Manifestation has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createManifestation_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Manifestation has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createManifestation_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Manifestation has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createManifestation_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Manifestation has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createManifestation_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Manifestation has roleBinding as a containment
					case  uml::umlPackage::COLLABORATIONUSE_ATTRIBUTE_ROLEBINDING:	
					{
						std::shared_ptr<CollaborationUse> castedContainer = std::dynamic_pointer_cast<CollaborationUse> (container);;
						return this->createManifestation_as_roleBinding_in_CollaborationUse(castedContainer,metaElementID);
					}
					//Manifestation has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createManifestation_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Manifestation has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createManifestation_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Manifestation has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createManifestation_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Manifestation has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createManifestation_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::MERGENODE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createMergeNode(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//MergeNode has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createMergeNode_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//MergeNode has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createMergeNode_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//MergeNode has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createMergeNode_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//MergeNode has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createMergeNode_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//MergeNode has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createMergeNode_as_node_in_Activity(castedContainer,metaElementID);
					}
					//MergeNode has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createMergeNode_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//MergeNode has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createMergeNode_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//MergeNode has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createMergeNode_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//MergeNode has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createMergeNode_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//MergeNode has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createMergeNode_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//MergeNode has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createMergeNode_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//MergeNode has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createMergeNode_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//MergeNode has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createMergeNode_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//MergeNode has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createMergeNode_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//MergeNode has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createMergeNode_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::MESSAGE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createMessage(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Message has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createMessage_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Message has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createMessage_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Message has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createMessage_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Message has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createMessage_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Message has message as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_MESSAGE:	
					{
						std::weak_ptr<uml::Interaction> castedContainer = std::dynamic_pointer_cast<uml::Interaction> (container);
						return this->createMessage_as_message_in_Interaction(castedContainer,metaElementID);
					}
					//Message has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createMessage_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Message has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createMessage_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Message has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createMessage_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Message has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createMessage_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Message has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createMessage_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::MESSAGEOCCURRENCESPECIFICATION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createMessageOccurrenceSpecification(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//MessageOccurrenceSpecification has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createMessageOccurrenceSpecification_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//MessageOccurrenceSpecification has fragment as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::Interaction> castedContainer = std::dynamic_pointer_cast<uml::Interaction> (container);
						return this->createMessageOccurrenceSpecification_as_fragment_in_Interaction(castedContainer,metaElementID);
					}
					//MessageOccurrenceSpecification has fragment as a containment
					case  uml::umlPackage::INTERACTIONOPERAND_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::InteractionOperand> castedContainer = std::dynamic_pointer_cast<uml::InteractionOperand> (container);
						return this->createMessageOccurrenceSpecification_as_fragment_in_InteractionOperand(castedContainer,metaElementID);
					}
					//MessageOccurrenceSpecification has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createMessageOccurrenceSpecification_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//MessageOccurrenceSpecification has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createMessageOccurrenceSpecification_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//MessageOccurrenceSpecification has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createMessageOccurrenceSpecification_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//MessageOccurrenceSpecification has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createMessageOccurrenceSpecification_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//MessageOccurrenceSpecification has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createMessageOccurrenceSpecification_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//MessageOccurrenceSpecification has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createMessageOccurrenceSpecification_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//MessageOccurrenceSpecification has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createMessageOccurrenceSpecification_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//MessageOccurrenceSpecification has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createMessageOccurrenceSpecification_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::MODEL_CLASS:
		{
			if (nullptr == container)
			{
				return this->createModel(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Model has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createModel_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Model has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createModel_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Model has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createModel_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Model has importedPackage as a containment
					case  uml::umlPackage::PACKAGEIMPORT_ATTRIBUTE_IMPORTEDPACKAGE:	
					{
						std::shared_ptr<PackageImport> castedContainer = std::dynamic_pointer_cast<PackageImport> (container);;
						return this->createModel_as_importedPackage_in_PackageImport(castedContainer,metaElementID);
					}
					//Model has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createModel_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Model has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createModel_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Model has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createModel_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Model has mergedPackage as a containment
					case  uml::umlPackage::PACKAGEMERGE_ATTRIBUTE_MERGEDPACKAGE:	
					{
						std::shared_ptr<PackageMerge> castedContainer = std::dynamic_pointer_cast<PackageMerge> (container);;
						return this->createModel_as_mergedPackage_in_PackageMerge(castedContainer,metaElementID);
					}
					//Model has nestedPackage as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_NESTEDPACKAGE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createModel_as_nestedPackage_in_Package(castedContainer,metaElementID);
					}
					//Model has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createModel_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Model has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createModel_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Model has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createModel_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Model has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createModel_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Model has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createModel_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Model has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createModel_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Model has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createModel_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Model has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createModel_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Model has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createModel_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Model has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createModel_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Model has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createModel_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::NODE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createNode(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Node has classifier as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_CLASSIFIER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createNode_as_classifier_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//Node has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createNode_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Node has context as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_CONTEXT:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createNode_as_context_in_Behavior(castedContainer,metaElementID);
					}
					//Node has contract as a containment
					case  uml::umlPackage::SUBSTITUTION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<Substitution> castedContainer = std::dynamic_pointer_cast<Substitution> (container);;
						return this->createNode_as_contract_in_Substitution(castedContainer,metaElementID);
					}
					//Node has endType as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_ENDTYPE:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createNode_as_endType_in_Association(castedContainer,metaElementID);
					}
					//Node has general as a containment
					case  uml::umlPackage::GENERALIZATION_ATTRIBUTE_GENERAL:	
					{
						std::shared_ptr<Generalization> castedContainer = std::dynamic_pointer_cast<Generalization> (container);;
						return this->createNode_as_general_in_Generalization(castedContainer,metaElementID);
					}
					//Node has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createNode_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Node has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createNode_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Node has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createNode_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Node has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createNode_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Node has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createNode_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Node has nestedClassifier as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createNode_as_nestedClassifier_in_Class(castedContainer,metaElementID);
					}
					//Node has nestedClassifier as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createNode_as_nestedClassifier_in_Interface(castedContainer,metaElementID);
					}
					//Node has nestedNode as a containment
					case  uml::umlPackage::NODE_ATTRIBUTE_NESTEDNODE:	
					{
						std::shared_ptr<Node> castedContainer = std::dynamic_pointer_cast<Node> (container);;
						return this->createNode_as_nestedNode_in_Node(castedContainer,metaElementID);
					}
					//Node has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createNode_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Node has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createNode_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Node has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createNode_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Node has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createNode_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Node has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createNode_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Node has ownedType as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDTYPE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createNode_as_ownedType_in_Package(castedContainer,metaElementID);
					}
					//Node has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createNode_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Node has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createNode_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Node has realizingClassifier as a containment
					case  uml::umlPackage::COMPONENTREALIZATION_ATTRIBUTE_REALIZINGCLASSIFIER:	
					{
						std::shared_ptr<ComponentRealization> castedContainer = std::dynamic_pointer_cast<ComponentRealization> (container);;
						return this->createNode_as_realizingClassifier_in_ComponentRealization(castedContainer,metaElementID);
					}
					//Node has redefinedClassifier as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REDEFINEDCLASSIFIER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createNode_as_redefinedClassifier_in_Classifier(castedContainer,metaElementID);
					}
					//Node has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createNode_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Node has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createNode_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Node has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createNode_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Node has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createNode_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::OBJECT_CLASS:
		{
				return this->createObject(metaElementID);
			
			break;
		}
		case umlPackage::OBJECTFLOW_CLASS:
		{
			if (nullptr == container)
			{
				return this->createObjectFlow(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ObjectFlow has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createObjectFlow_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ObjectFlow has edge as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_EDGE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createObjectFlow_as_edge_in_Activity(castedContainer,metaElementID);
					}
					//ObjectFlow has edge as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_EDGE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createObjectFlow_as_edge_in_ActivityPartition(castedContainer,metaElementID);
					}
					//ObjectFlow has edge as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_EDGE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createObjectFlow_as_edge_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//ObjectFlow has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createObjectFlow_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ObjectFlow has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createObjectFlow_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ObjectFlow has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createObjectFlow_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ObjectFlow has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createObjectFlow_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ObjectFlow has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createObjectFlow_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ObjectFlow has redefinedEdge as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_REDEFINEDEDGE:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createObjectFlow_as_redefinedEdge_in_ActivityEdge(castedContainer,metaElementID);
					}
					//ObjectFlow has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createObjectFlow_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ObjectFlow has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createObjectFlow_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ObjectFlow has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createObjectFlow_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::OCCURRENCESPECIFICATION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createOccurrenceSpecification(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//OccurrenceSpecification has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createOccurrenceSpecification_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//OccurrenceSpecification has fragment as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::Interaction> castedContainer = std::dynamic_pointer_cast<uml::Interaction> (container);
						return this->createOccurrenceSpecification_as_fragment_in_Interaction(castedContainer,metaElementID);
					}
					//OccurrenceSpecification has fragment as a containment
					case  uml::umlPackage::INTERACTIONOPERAND_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::InteractionOperand> castedContainer = std::dynamic_pointer_cast<uml::InteractionOperand> (container);
						return this->createOccurrenceSpecification_as_fragment_in_InteractionOperand(castedContainer,metaElementID);
					}
					//OccurrenceSpecification has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createOccurrenceSpecification_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//OccurrenceSpecification has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createOccurrenceSpecification_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//OccurrenceSpecification has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createOccurrenceSpecification_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//OccurrenceSpecification has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createOccurrenceSpecification_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//OccurrenceSpecification has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createOccurrenceSpecification_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//OccurrenceSpecification has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createOccurrenceSpecification_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//OccurrenceSpecification has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createOccurrenceSpecification_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//OccurrenceSpecification has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createOccurrenceSpecification_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::OPAQUEACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createOpaqueAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//OpaqueAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createOpaqueAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//OpaqueAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createOpaqueAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//OpaqueAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createOpaqueAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//OpaqueAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createOpaqueAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//OpaqueAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createOpaqueAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//OpaqueAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createOpaqueAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//OpaqueAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createOpaqueAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//OpaqueAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createOpaqueAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//OpaqueAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createOpaqueAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//OpaqueAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createOpaqueAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//OpaqueAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createOpaqueAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//OpaqueAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createOpaqueAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//OpaqueAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createOpaqueAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//OpaqueAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createOpaqueAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//OpaqueAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createOpaqueAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//OpaqueAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createOpaqueAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//OpaqueAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createOpaqueAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//OpaqueAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createOpaqueAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::OPAQUEBEHAVIOR_CLASS:
		{
			if (nullptr == container)
			{
				return this->createOpaqueBehavior(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//OpaqueBehavior has classifier as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_CLASSIFIER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createOpaqueBehavior_as_classifier_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//OpaqueBehavior has classifierBehavior as a containment
					case  uml::umlPackage::BEHAVIOREDCLASSIFIER_ATTRIBUTE_CLASSIFIERBEHAVIOR:	
					{
						std::shared_ptr<BehavioredClassifier> castedContainer = std::dynamic_pointer_cast<BehavioredClassifier> (container);;
						return this->createOpaqueBehavior_as_classifierBehavior_in_BehavioredClassifier(castedContainer,metaElementID);
					}
					//OpaqueBehavior has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createOpaqueBehavior_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//OpaqueBehavior has context as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_CONTEXT:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createOpaqueBehavior_as_context_in_Behavior(castedContainer,metaElementID);
					}
					//OpaqueBehavior has contract as a containment
					case  uml::umlPackage::SUBSTITUTION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<Substitution> castedContainer = std::dynamic_pointer_cast<Substitution> (container);;
						return this->createOpaqueBehavior_as_contract_in_Substitution(castedContainer,metaElementID);
					}
					//OpaqueBehavior has doActivity as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_DOACTIVITY:	
					{
						std::shared_ptr<State> castedContainer = std::dynamic_pointer_cast<State> (container);;
						return this->createOpaqueBehavior_as_doActivity_in_State(castedContainer,metaElementID);
					}
					//OpaqueBehavior has effect as a containment
					case  uml::umlPackage::TRANSITION_ATTRIBUTE_EFFECT:	
					{
						std::shared_ptr<Transition> castedContainer = std::dynamic_pointer_cast<Transition> (container);;
						return this->createOpaqueBehavior_as_effect_in_Transition(castedContainer,metaElementID);
					}
					//OpaqueBehavior has endType as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_ENDTYPE:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createOpaqueBehavior_as_endType_in_Association(castedContainer,metaElementID);
					}
					//OpaqueBehavior has entry as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_ENTRY:	
					{
						std::shared_ptr<State> castedContainer = std::dynamic_pointer_cast<State> (container);;
						return this->createOpaqueBehavior_as_entry_in_State(castedContainer,metaElementID);
					}
					//OpaqueBehavior has exit as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_EXIT:	
					{
						std::shared_ptr<State> castedContainer = std::dynamic_pointer_cast<State> (container);;
						return this->createOpaqueBehavior_as_exit_in_State(castedContainer,metaElementID);
					}
					//OpaqueBehavior has general as a containment
					case  uml::umlPackage::GENERALIZATION_ATTRIBUTE_GENERAL:	
					{
						std::shared_ptr<Generalization> castedContainer = std::dynamic_pointer_cast<Generalization> (container);;
						return this->createOpaqueBehavior_as_general_in_Generalization(castedContainer,metaElementID);
					}
					//OpaqueBehavior has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createOpaqueBehavior_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//OpaqueBehavior has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createOpaqueBehavior_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//OpaqueBehavior has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createOpaqueBehavior_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//OpaqueBehavior has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createOpaqueBehavior_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//OpaqueBehavior has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createOpaqueBehavior_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//OpaqueBehavior has nestedClassifier as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createOpaqueBehavior_as_nestedClassifier_in_Class(castedContainer,metaElementID);
					}
					//OpaqueBehavior has nestedClassifier as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createOpaqueBehavior_as_nestedClassifier_in_Interface(castedContainer,metaElementID);
					}
					//OpaqueBehavior has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createOpaqueBehavior_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//OpaqueBehavior has ownedBehavior as a containment
					case  uml::umlPackage::BEHAVIOREDCLASSIFIER_ATTRIBUTE_OWNEDBEHAVIOR:	
					{
						std::weak_ptr<uml::BehavioredClassifier> castedContainer = std::dynamic_pointer_cast<uml::BehavioredClassifier> (container);
						return this->createOpaqueBehavior_as_ownedBehavior_in_BehavioredClassifier(castedContainer,metaElementID);
					}
					//OpaqueBehavior has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createOpaqueBehavior_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//OpaqueBehavior has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createOpaqueBehavior_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//OpaqueBehavior has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createOpaqueBehavior_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//OpaqueBehavior has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createOpaqueBehavior_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//OpaqueBehavior has ownedType as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDTYPE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createOpaqueBehavior_as_ownedType_in_Package(castedContainer,metaElementID);
					}
					//OpaqueBehavior has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createOpaqueBehavior_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//OpaqueBehavior has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createOpaqueBehavior_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//OpaqueBehavior has realizingClassifier as a containment
					case  uml::umlPackage::COMPONENTREALIZATION_ATTRIBUTE_REALIZINGCLASSIFIER:	
					{
						std::shared_ptr<ComponentRealization> castedContainer = std::dynamic_pointer_cast<ComponentRealization> (container);;
						return this->createOpaqueBehavior_as_realizingClassifier_in_ComponentRealization(castedContainer,metaElementID);
					}
					//OpaqueBehavior has redefinedBehavior as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_REDEFINEDBEHAVIOR:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createOpaqueBehavior_as_redefinedBehavior_in_Behavior(castedContainer,metaElementID);
					}
					//OpaqueBehavior has redefinedClassifier as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REDEFINEDCLASSIFIER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createOpaqueBehavior_as_redefinedClassifier_in_Classifier(castedContainer,metaElementID);
					}
					//OpaqueBehavior has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createOpaqueBehavior_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//OpaqueBehavior has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createOpaqueBehavior_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//OpaqueBehavior has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createOpaqueBehavior_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//OpaqueBehavior has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createOpaqueBehavior_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::OPAQUEEXPRESSION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createOpaqueExpression(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//OpaqueExpression has argument as a containment
					case  uml::umlPackage::MESSAGE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<Message> castedContainer = std::dynamic_pointer_cast<Message> (container);;
						return this->createOpaqueExpression_as_argument_in_Message(castedContainer,metaElementID);
					}
					//OpaqueExpression has argument as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createOpaqueExpression_as_argument_in_InteractionUse(castedContainer,metaElementID);
					}
					//OpaqueExpression has changeExpression as a containment
					case  uml::umlPackage::CHANGEEVENT_ATTRIBUTE_CHANGEEXPRESSION:	
					{
						std::shared_ptr<ChangeEvent> castedContainer = std::dynamic_pointer_cast<ChangeEvent> (container);;
						return this->createOpaqueExpression_as_changeExpression_in_ChangeEvent(castedContainer,metaElementID);
					}
					//OpaqueExpression has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createOpaqueExpression_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//OpaqueExpression has defaultValue as a containment
					case  uml::umlPackage::PROPERTY_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Property> castedContainer = std::dynamic_pointer_cast<Property> (container);;
						return this->createOpaqueExpression_as_defaultValue_in_Property(castedContainer,metaElementID);
					}
					//OpaqueExpression has defaultValue as a containment
					case  uml::umlPackage::PARAMETER_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Parameter> castedContainer = std::dynamic_pointer_cast<Parameter> (container);;
						return this->createOpaqueExpression_as_defaultValue_in_Parameter(castedContainer,metaElementID);
					}
					//OpaqueExpression has expr as a containment
					case  uml::umlPackage::TIMEEXPRESSION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<TimeExpression> castedContainer = std::dynamic_pointer_cast<TimeExpression> (container);;
						return this->createOpaqueExpression_as_expr_in_TimeExpression(castedContainer,metaElementID);
					}
					//OpaqueExpression has expr as a containment
					case  uml::umlPackage::DURATION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<Duration> castedContainer = std::dynamic_pointer_cast<Duration> (container);;
						return this->createOpaqueExpression_as_expr_in_Duration(castedContainer,metaElementID);
					}
					//OpaqueExpression has guard as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_GUARD:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createOpaqueExpression_as_guard_in_ActivityEdge(castedContainer,metaElementID);
					}
					//OpaqueExpression has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createOpaqueExpression_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//OpaqueExpression has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createOpaqueExpression_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//OpaqueExpression has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createOpaqueExpression_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//OpaqueExpression has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createOpaqueExpression_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//OpaqueExpression has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createOpaqueExpression_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//OpaqueExpression has joinSpec as a containment
					case  uml::umlPackage::JOINNODE_ATTRIBUTE_JOINSPEC:	
					{
						std::shared_ptr<JoinNode> castedContainer = std::dynamic_pointer_cast<JoinNode> (container);;
						return this->createOpaqueExpression_as_joinSpec_in_JoinNode(castedContainer,metaElementID);
					}
					//OpaqueExpression has lowerValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_LOWERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createOpaqueExpression_as_lowerValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//OpaqueExpression has mapping as a containment
					case  uml::umlPackage::ABSTRACTION_ATTRIBUTE_MAPPING:	
					{
						std::shared_ptr<Abstraction> castedContainer = std::dynamic_pointer_cast<Abstraction> (container);;
						return this->createOpaqueExpression_as_mapping_in_Abstraction(castedContainer,metaElementID);
					}
					//OpaqueExpression has maxint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MAXINT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createOpaqueExpression_as_maxint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//OpaqueExpression has minint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MININT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createOpaqueExpression_as_minint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//OpaqueExpression has operand as a containment
					case  uml::umlPackage::EXPRESSION_ATTRIBUTE_OPERAND:	
					{
						std::shared_ptr<Expression> castedContainer = std::dynamic_pointer_cast<Expression> (container);;
						return this->createOpaqueExpression_as_operand_in_Expression(castedContainer,metaElementID);
					}
					//OpaqueExpression has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createOpaqueExpression_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//OpaqueExpression has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createOpaqueExpression_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//OpaqueExpression has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createOpaqueExpression_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//OpaqueExpression has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createOpaqueExpression_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//OpaqueExpression has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createOpaqueExpression_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//OpaqueExpression has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createOpaqueExpression_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//OpaqueExpression has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createOpaqueExpression_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//OpaqueExpression has returnValue as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_RETURNVALUE:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createOpaqueExpression_as_returnValue_in_InteractionUse(castedContainer,metaElementID);
					}
					//OpaqueExpression has selector as a containment
					case  uml::umlPackage::LIFELINE_ATTRIBUTE_SELECTOR:	
					{
						std::shared_ptr<Lifeline> castedContainer = std::dynamic_pointer_cast<Lifeline> (container);;
						return this->createOpaqueExpression_as_selector_in_Lifeline(castedContainer,metaElementID);
					}
					//OpaqueExpression has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createOpaqueExpression_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//OpaqueExpression has specification as a containment
					case  uml::umlPackage::CONSTRAINT_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<Constraint> castedContainer = std::dynamic_pointer_cast<Constraint> (container);;
						return this->createOpaqueExpression_as_specification_in_Constraint(castedContainer,metaElementID);
					}
					//OpaqueExpression has specification as a containment
					case  uml::umlPackage::INSTANCESPECIFICATION_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<InstanceSpecification> castedContainer = std::dynamic_pointer_cast<InstanceSpecification> (container);;
						return this->createOpaqueExpression_as_specification_in_InstanceSpecification(castedContainer,metaElementID);
					}
					//OpaqueExpression has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createOpaqueExpression_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//OpaqueExpression has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createOpaqueExpression_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//OpaqueExpression has upperBound as a containment
					case  uml::umlPackage::OBJECTNODE_ATTRIBUTE_UPPERBOUND:	
					{
						std::shared_ptr<ObjectNode> castedContainer = std::dynamic_pointer_cast<ObjectNode> (container);;
						return this->createOpaqueExpression_as_upperBound_in_ObjectNode(castedContainer,metaElementID);
					}
					//OpaqueExpression has upperValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_UPPERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createOpaqueExpression_as_upperValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//OpaqueExpression has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createOpaqueExpression_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					//OpaqueExpression has value as a containment
					case  uml::umlPackage::SLOT_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::Slot> castedContainer = std::dynamic_pointer_cast<uml::Slot> (container);
						return this->createOpaqueExpression_as_value_in_Slot(castedContainer,metaElementID);
					}
					//OpaqueExpression has value as a containment
					case  uml::umlPackage::VALUESPECIFICATIONACTION_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::ValueSpecificationAction> castedContainer = std::dynamic_pointer_cast<uml::ValueSpecificationAction> (container);
						return this->createOpaqueExpression_as_value_in_ValueSpecificationAction(castedContainer,metaElementID);
					}
					//OpaqueExpression has value as a containment
					case  uml::umlPackage::VALUEPIN_ATTRIBUTE_VALUE:	
					{
						std::shared_ptr<ValuePin> castedContainer = std::dynamic_pointer_cast<ValuePin> (container);;
						return this->createOpaqueExpression_as_value_in_ValuePin(castedContainer,metaElementID);
					}
					//OpaqueExpression has weight as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_WEIGHT:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createOpaqueExpression_as_weight_in_ActivityEdge(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::OPERATION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createOperation(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Operation has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createOperation_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Operation has feature as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_FEATURE:	
					{
						std::shared_ptr<uml::Classifier> castedContainer = std::dynamic_pointer_cast<uml::Classifier> (container);
						return this->createOperation_as_feature_in_Classifier(castedContainer,metaElementID);
					}
					//Operation has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createOperation_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Operation has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createOperation_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Operation has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createOperation_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Operation has operation as a containment
					//Operation has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createOperation_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Operation has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createOperation_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Operation has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createOperation_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Operation has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createOperation_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Operation has ownedOperation as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_OWNEDOPERATION:	
					{
						std::weak_ptr<uml::Class> castedContainer = std::dynamic_pointer_cast<uml::Class> (container);
						return this->createOperation_as_ownedOperation_in_Class(castedContainer,metaElementID);
					}
					//Operation has ownedOperation as a containment
					case  uml::umlPackage::ARTIFACT_ATTRIBUTE_OWNEDOPERATION:	
					{
						std::shared_ptr<Artifact> castedContainer = std::dynamic_pointer_cast<Artifact> (container);;
						return this->createOperation_as_ownedOperation_in_Artifact(castedContainer,metaElementID);
					}
					//Operation has ownedOperation as a containment
					case  uml::umlPackage::DATATYPE_ATTRIBUTE_OWNEDOPERATION:	
					{
						std::weak_ptr<uml::DataType> castedContainer = std::dynamic_pointer_cast<uml::DataType> (container);
						return this->createOperation_as_ownedOperation_in_DataType(castedContainer,metaElementID);
					}
					//Operation has ownedOperation as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_OWNEDOPERATION:	
					{
						std::weak_ptr<uml::Interface> castedContainer = std::dynamic_pointer_cast<uml::Interface> (container);
						return this->createOperation_as_ownedOperation_in_Interface(castedContainer,metaElementID);
					}
					//Operation has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createOperation_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Operation has redefinedOperation as a containment
					case  uml::umlPackage::OPERATION_ATTRIBUTE_REDEFINEDOPERATION:	
					{
						std::shared_ptr<Operation> castedContainer = std::dynamic_pointer_cast<Operation> (container);;
						return this->createOperation_as_redefinedOperation_in_Operation(castedContainer,metaElementID);
					}
					//Operation has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createOperation_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Operation has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createOperation_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Operation has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createOperation_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::OPERATIONTEMPLATEPARAMETER_CLASS:
		{
			if (nullptr == container)
			{
				return this->createOperationTemplateParameter(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//OperationTemplateParameter has inheritedParameter as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_INHERITEDPARAMETER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createOperationTemplateParameter_as_inheritedParameter_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//OperationTemplateParameter has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createOperationTemplateParameter_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//OperationTemplateParameter has ownedParameter as a containment
					case  uml::umlPackage::TEMPLATESIGNATURE_ATTRIBUTE_OWNEDPARAMETER:	
					{
						std::weak_ptr<uml::TemplateSignature> castedContainer = std::dynamic_pointer_cast<uml::TemplateSignature> (container);
						return this->createOperationTemplateParameter_as_ownedParameter_in_TemplateSignature(castedContainer,metaElementID);
					}
					//OperationTemplateParameter has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createOperationTemplateParameter_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//OperationTemplateParameter has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createOperationTemplateParameter_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::OUTPUTPIN_CLASS:
		{
			if (nullptr == container)
			{
				return this->createOutputPin(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//OutputPin has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createOutputPin_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//OutputPin has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createOutputPin_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//OutputPin has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createOutputPin_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//OutputPin has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createOutputPin_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//OutputPin has loopVariable as a containment
					case  uml::umlPackage::LOOPNODE_ATTRIBUTE_LOOPVARIABLE:	
					{
						std::shared_ptr<LoopNode> castedContainer = std::dynamic_pointer_cast<LoopNode> (container);;
						return this->createOutputPin_as_loopVariable_in_LoopNode(castedContainer,metaElementID);
					}
					//OutputPin has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createOutputPin_as_node_in_Activity(castedContainer,metaElementID);
					}
					//OutputPin has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createOutputPin_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//OutputPin has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createOutputPin_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//OutputPin has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createOutputPin_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//OutputPin has output as a containment
					case  uml::umlPackage::ACTION_ATTRIBUTE_OUTPUT:	
					{
						std::weak_ptr<uml::Action> castedContainer = std::dynamic_pointer_cast<uml::Action> (container);
						return this->createOutputPin_as_output_in_Action(castedContainer,metaElementID);
					}
					//OutputPin has outputValue as a containment
					case  uml::umlPackage::OPAQUEACTION_ATTRIBUTE_OUTPUTVALUE:	
					{
						std::shared_ptr<OpaqueAction> castedContainer = std::dynamic_pointer_cast<OpaqueAction> (container);;
						return this->createOutputPin_as_outputValue_in_OpaqueAction(castedContainer,metaElementID);
					}
					//OutputPin has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createOutputPin_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//OutputPin has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createOutputPin_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//OutputPin has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createOutputPin_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//OutputPin has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createOutputPin_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//OutputPin has result as a containment
					case  uml::umlPackage::VALUESPECIFICATIONACTION_ATTRIBUTE_RESULT:	
					{
						std::weak_ptr<uml::ValueSpecificationAction> castedContainer = std::dynamic_pointer_cast<uml::ValueSpecificationAction> (container);
						return this->createOutputPin_as_result_in_ValueSpecificationAction(castedContainer,metaElementID);
					}
					//OutputPin has result as a containment
					case  uml::umlPackage::WRITESTRUCTURALFEATUREACTION_ATTRIBUTE_RESULT:	
					{
						std::weak_ptr<uml::WriteStructuralFeatureAction> castedContainer = std::dynamic_pointer_cast<uml::WriteStructuralFeatureAction> (container);
						return this->createOutputPin_as_result_in_WriteStructuralFeatureAction(castedContainer,metaElementID);
					}
					//OutputPin has result as a containment
					case  uml::umlPackage::ACCEPTEVENTACTION_ATTRIBUTE_RESULT:	
					{
						std::shared_ptr<AcceptEventAction> castedContainer = std::dynamic_pointer_cast<AcceptEventAction> (container);;
						return this->createOutputPin_as_result_in_AcceptEventAction(castedContainer,metaElementID);
					}
					//OutputPin has result as a containment
					case  uml::umlPackage::CALLACTION_ATTRIBUTE_RESULT:	
					{
						std::weak_ptr<uml::CallAction> castedContainer = std::dynamic_pointer_cast<uml::CallAction> (container);
						return this->createOutputPin_as_result_in_CallAction(castedContainer,metaElementID);
					}
					//OutputPin has result as a containment
					case  uml::umlPackage::CLEARSTRUCTURALFEATUREACTION_ATTRIBUTE_RESULT:	
					{
						std::weak_ptr<uml::ClearStructuralFeatureAction> castedContainer = std::dynamic_pointer_cast<uml::ClearStructuralFeatureAction> (container);
						return this->createOutputPin_as_result_in_ClearStructuralFeatureAction(castedContainer,metaElementID);
					}
					//OutputPin has result as a containment
					case  uml::umlPackage::CONDITIONALNODE_ATTRIBUTE_RESULT:	
					{
						std::shared_ptr<ConditionalNode> castedContainer = std::dynamic_pointer_cast<ConditionalNode> (container);;
						return this->createOutputPin_as_result_in_ConditionalNode(castedContainer,metaElementID);
					}
					//OutputPin has result as a containment
					case  uml::umlPackage::CREATELINKOBJECTACTION_ATTRIBUTE_RESULT:	
					{
						std::shared_ptr<CreateLinkObjectAction> castedContainer = std::dynamic_pointer_cast<CreateLinkObjectAction> (container);;
						return this->createOutputPin_as_result_in_CreateLinkObjectAction(castedContainer,metaElementID);
					}
					//OutputPin has result as a containment
					case  uml::umlPackage::CREATEOBJECTACTION_ATTRIBUTE_RESULT:	
					{
						std::weak_ptr<uml::CreateObjectAction> castedContainer = std::dynamic_pointer_cast<uml::CreateObjectAction> (container);
						return this->createOutputPin_as_result_in_CreateObjectAction(castedContainer,metaElementID);
					}
					//OutputPin has result as a containment
					case  uml::umlPackage::LOOPNODE_ATTRIBUTE_RESULT:	
					{
						std::shared_ptr<LoopNode> castedContainer = std::dynamic_pointer_cast<LoopNode> (container);;
						return this->createOutputPin_as_result_in_LoopNode(castedContainer,metaElementID);
					}
					//OutputPin has result as a containment
					case  uml::umlPackage::READEXTENTACTION_ATTRIBUTE_RESULT:	
					{
						std::shared_ptr<ReadExtentAction> castedContainer = std::dynamic_pointer_cast<ReadExtentAction> (container);;
						return this->createOutputPin_as_result_in_ReadExtentAction(castedContainer,metaElementID);
					}
					//OutputPin has result as a containment
					case  uml::umlPackage::READISCLASSIFIEDOBJECTACTION_ATTRIBUTE_RESULT:	
					{
						std::shared_ptr<ReadIsClassifiedObjectAction> castedContainer = std::dynamic_pointer_cast<ReadIsClassifiedObjectAction> (container);;
						return this->createOutputPin_as_result_in_ReadIsClassifiedObjectAction(castedContainer,metaElementID);
					}
					//OutputPin has result as a containment
					case  uml::umlPackage::READLINKACTION_ATTRIBUTE_RESULT:	
					{
						std::shared_ptr<ReadLinkAction> castedContainer = std::dynamic_pointer_cast<ReadLinkAction> (container);;
						return this->createOutputPin_as_result_in_ReadLinkAction(castedContainer,metaElementID);
					}
					//OutputPin has result as a containment
					case  uml::umlPackage::READLINKOBJECTENDACTION_ATTRIBUTE_RESULT:	
					{
						std::shared_ptr<ReadLinkObjectEndAction> castedContainer = std::dynamic_pointer_cast<ReadLinkObjectEndAction> (container);;
						return this->createOutputPin_as_result_in_ReadLinkObjectEndAction(castedContainer,metaElementID);
					}
					//OutputPin has result as a containment
					case  uml::umlPackage::READLINKOBJECTENDQUALIFIERACTION_ATTRIBUTE_RESULT:	
					{
						std::shared_ptr<ReadLinkObjectEndQualifierAction> castedContainer = std::dynamic_pointer_cast<ReadLinkObjectEndQualifierAction> (container);;
						return this->createOutputPin_as_result_in_ReadLinkObjectEndQualifierAction(castedContainer,metaElementID);
					}
					//OutputPin has result as a containment
					case  uml::umlPackage::READSELFACTION_ATTRIBUTE_RESULT:	
					{
						std::weak_ptr<uml::ReadSelfAction> castedContainer = std::dynamic_pointer_cast<uml::ReadSelfAction> (container);
						return this->createOutputPin_as_result_in_ReadSelfAction(castedContainer,metaElementID);
					}
					//OutputPin has result as a containment
					case  uml::umlPackage::READSTRUCTURALFEATUREACTION_ATTRIBUTE_RESULT:	
					{
						std::weak_ptr<uml::ReadStructuralFeatureAction> castedContainer = std::dynamic_pointer_cast<uml::ReadStructuralFeatureAction> (container);
						return this->createOutputPin_as_result_in_ReadStructuralFeatureAction(castedContainer,metaElementID);
					}
					//OutputPin has result as a containment
					case  uml::umlPackage::READVARIABLEACTION_ATTRIBUTE_RESULT:	
					{
						std::shared_ptr<ReadVariableAction> castedContainer = std::dynamic_pointer_cast<ReadVariableAction> (container);;
						return this->createOutputPin_as_result_in_ReadVariableAction(castedContainer,metaElementID);
					}
					//OutputPin has result as a containment
					case  uml::umlPackage::REDUCEACTION_ATTRIBUTE_RESULT:	
					{
						std::shared_ptr<ReduceAction> castedContainer = std::dynamic_pointer_cast<ReduceAction> (container);;
						return this->createOutputPin_as_result_in_ReduceAction(castedContainer,metaElementID);
					}
					//OutputPin has result as a containment
					case  uml::umlPackage::TESTIDENTITYACTION_ATTRIBUTE_RESULT:	
					{
						std::shared_ptr<TestIdentityAction> castedContainer = std::dynamic_pointer_cast<TestIdentityAction> (container);;
						return this->createOutputPin_as_result_in_TestIdentityAction(castedContainer,metaElementID);
					}
					//OutputPin has result as a containment
					case  uml::umlPackage::UNMARSHALLACTION_ATTRIBUTE_RESULT:	
					{
						std::shared_ptr<UnmarshallAction> castedContainer = std::dynamic_pointer_cast<UnmarshallAction> (container);;
						return this->createOutputPin_as_result_in_UnmarshallAction(castedContainer,metaElementID);
					}
					//OutputPin has returnInformation as a containment
					case  uml::umlPackage::ACCEPTCALLACTION_ATTRIBUTE_RETURNINFORMATION:	
					{
						std::shared_ptr<AcceptCallAction> castedContainer = std::dynamic_pointer_cast<AcceptCallAction> (container);;
						return this->createOutputPin_as_returnInformation_in_AcceptCallAction(castedContainer,metaElementID);
					}
					//OutputPin has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createOutputPin_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//OutputPin has structuredNodeOutput as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_STRUCTUREDNODEOUTPUT:	
					{
						std::shared_ptr<StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<StructuredActivityNode> (container);;
						return this->createOutputPin_as_structuredNodeOutput_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//OutputPin has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createOutputPin_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//OutputPin has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createOutputPin_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::PACKAGE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createPackage(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Package has applyingPackage as a containment
					//Package has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createPackage_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Package has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createPackage_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Package has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createPackage_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Package has importedPackage as a containment
					case  uml::umlPackage::PACKAGEIMPORT_ATTRIBUTE_IMPORTEDPACKAGE:	
					{
						std::shared_ptr<PackageImport> castedContainer = std::dynamic_pointer_cast<PackageImport> (container);;
						return this->createPackage_as_importedPackage_in_PackageImport(castedContainer,metaElementID);
					}
					//Package has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createPackage_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Package has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createPackage_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Package has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createPackage_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Package has mergedPackage as a containment
					case  uml::umlPackage::PACKAGEMERGE_ATTRIBUTE_MERGEDPACKAGE:	
					{
						std::shared_ptr<PackageMerge> castedContainer = std::dynamic_pointer_cast<PackageMerge> (container);;
						return this->createPackage_as_mergedPackage_in_PackageMerge(castedContainer,metaElementID);
					}
					//Package has nestedPackage as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_NESTEDPACKAGE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createPackage_as_nestedPackage_in_Package(castedContainer,metaElementID);
					}
					//Package has nestingPackage as a containment
					//Package has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createPackage_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Package has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createPackage_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Package has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createPackage_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Package has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createPackage_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Package has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createPackage_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Package has owningPackage as a containment
					//Package has package as a containment
					//Package has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createPackage_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Package has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createPackage_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Package has receivingPackage as a containment
					//Package has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createPackage_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Package has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createPackage_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Package has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createPackage_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Package has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createPackage_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::PACKAGEIMPORT_CLASS:
		{
			if (nullptr == container)
			{
				return this->createPackageImport(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//PackageImport has metamodelReference as a containment
					case  uml::umlPackage::PROFILE_ATTRIBUTE_METAMODELREFERENCE:	
					{
						std::shared_ptr<Profile> castedContainer = std::dynamic_pointer_cast<Profile> (container);;
						return this->createPackageImport_as_metamodelReference_in_Profile(castedContainer,metaElementID);
					}
					//PackageImport has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createPackageImport_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//PackageImport has packageImport as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_PACKAGEIMPORT:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createPackageImport_as_packageImport_in_Namespace(castedContainer,metaElementID);
					}
					//PackageImport has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createPackageImport_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//PackageImport has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createPackageImport_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::PACKAGEMERGE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createPackageMerge(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//PackageMerge has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createPackageMerge_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//PackageMerge has packageMerge as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEMERGE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createPackageMerge_as_packageMerge_in_Package(castedContainer,metaElementID);
					}
					//PackageMerge has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createPackageMerge_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//PackageMerge has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createPackageMerge_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::PARAMETER_CLASS:
		{
			if (nullptr == container)
			{
				return this->createParameter(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Parameter has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createParameter_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Parameter has collaborationRole as a containment
					case  uml::umlPackage::COLLABORATION_ATTRIBUTE_COLLABORATIONROLE:	
					{
						std::shared_ptr<Collaboration> castedContainer = std::dynamic_pointer_cast<Collaboration> (container);;
						return this->createParameter_as_collaborationRole_in_Collaboration(castedContainer,metaElementID);
					}
					//Parameter has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createParameter_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Parameter has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createParameter_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Parameter has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createParameter_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Parameter has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createParameter_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Parameter has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createParameter_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Parameter has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createParameter_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Parameter has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createParameter_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Parameter has ownedParameter as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_OWNEDPARAMETER:	
					{
						std::weak_ptr<uml::Behavior> castedContainer = std::dynamic_pointer_cast<uml::Behavior> (container);
						return this->createParameter_as_ownedParameter_in_Behavior(castedContainer,metaElementID);
					}
					//Parameter has ownedParameter as a containment
					case  uml::umlPackage::OPERATION_ATTRIBUTE_OWNEDPARAMETER:	
					{
						std::weak_ptr<uml::Operation> castedContainer = std::dynamic_pointer_cast<uml::Operation> (container);
						return this->createParameter_as_ownedParameter_in_Operation(castedContainer,metaElementID);
					}
					//Parameter has ownedParameter as a containment
					case  uml::umlPackage::BEHAVIORALFEATURE_ATTRIBUTE_OWNEDPARAMETER:	
					{
						std::shared_ptr<BehavioralFeature> castedContainer = std::dynamic_pointer_cast<BehavioralFeature> (container);;
						return this->createParameter_as_ownedParameter_in_BehavioralFeature(castedContainer,metaElementID);
					}
					//Parameter has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createParameter_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Parameter has role as a containment
					case  uml::umlPackage::STRUCTUREDCLASSIFIER_ATTRIBUTE_ROLE:	
					{
						std::shared_ptr<StructuredClassifier> castedContainer = std::dynamic_pointer_cast<StructuredClassifier> (container);;
						return this->createParameter_as_role_in_StructuredClassifier(castedContainer,metaElementID);
					}
					//Parameter has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createParameter_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Parameter has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createParameter_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Parameter has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createParameter_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::PARAMETERSET_CLASS:
		{
			if (nullptr == container)
			{
				return this->createParameterSet(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ParameterSet has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createParameterSet_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ParameterSet has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createParameterSet_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ParameterSet has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createParameterSet_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ParameterSet has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createParameterSet_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ParameterSet has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createParameterSet_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ParameterSet has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createParameterSet_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ParameterSet has ownedParameterSet as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_OWNEDPARAMETERSET:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createParameterSet_as_ownedParameterSet_in_Behavior(castedContainer,metaElementID);
					}
					//ParameterSet has ownedParameterSet as a containment
					case  uml::umlPackage::BEHAVIORALFEATURE_ATTRIBUTE_OWNEDPARAMETERSET:	
					{
						std::shared_ptr<BehavioralFeature> castedContainer = std::dynamic_pointer_cast<BehavioralFeature> (container);;
						return this->createParameterSet_as_ownedParameterSet_in_BehavioralFeature(castedContainer,metaElementID);
					}
					//ParameterSet has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createParameterSet_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ParameterSet has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createParameterSet_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ParameterSet has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createParameterSet_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::PARTDECOMPOSITION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createPartDecomposition(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//PartDecomposition has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createPartDecomposition_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//PartDecomposition has fragment as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::Interaction> castedContainer = std::dynamic_pointer_cast<uml::Interaction> (container);
						return this->createPartDecomposition_as_fragment_in_Interaction(castedContainer,metaElementID);
					}
					//PartDecomposition has fragment as a containment
					case  uml::umlPackage::INTERACTIONOPERAND_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::InteractionOperand> castedContainer = std::dynamic_pointer_cast<uml::InteractionOperand> (container);
						return this->createPartDecomposition_as_fragment_in_InteractionOperand(castedContainer,metaElementID);
					}
					//PartDecomposition has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createPartDecomposition_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//PartDecomposition has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createPartDecomposition_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//PartDecomposition has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createPartDecomposition_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//PartDecomposition has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createPartDecomposition_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//PartDecomposition has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createPartDecomposition_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//PartDecomposition has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createPartDecomposition_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//PartDecomposition has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createPartDecomposition_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//PartDecomposition has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createPartDecomposition_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::PORT_CLASS:
		{
			if (nullptr == container)
			{
				return this->createPort(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Port has attribute as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_ATTRIBUTE:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createPort_as_attribute_in_Classifier(castedContainer,metaElementID);
					}
					//Port has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createPort_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Port has collaborationRole as a containment
					case  uml::umlPackage::COLLABORATION_ATTRIBUTE_COLLABORATIONROLE:	
					{
						std::shared_ptr<Collaboration> castedContainer = std::dynamic_pointer_cast<Collaboration> (container);;
						return this->createPort_as_collaborationRole_in_Collaboration(castedContainer,metaElementID);
					}
					//Port has feature as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_FEATURE:	
					{
						std::shared_ptr<uml::Classifier> castedContainer = std::dynamic_pointer_cast<uml::Classifier> (container);
						return this->createPort_as_feature_in_Classifier(castedContainer,metaElementID);
					}
					//Port has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createPort_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Port has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createPort_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Port has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createPort_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Port has memberEnd as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_MEMBEREND:	
					{
						std::shared_ptr<uml::Association> castedContainer = std::dynamic_pointer_cast<uml::Association> (container);
						return this->createPort_as_memberEnd_in_Association(castedContainer,metaElementID);
					}
					//Port has navigableOwnedEnd as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_NAVIGABLEOWNEDEND:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createPort_as_navigableOwnedEnd_in_Association(castedContainer,metaElementID);
					}
					//Port has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createPort_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Port has ownedAttribute as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_OWNEDATTRIBUTE:	
					{
						std::weak_ptr<uml::Class> castedContainer = std::dynamic_pointer_cast<uml::Class> (container);
						return this->createPort_as_ownedAttribute_in_Class(castedContainer,metaElementID);
					}
					//Port has ownedAttribute as a containment
					case  uml::umlPackage::ARTIFACT_ATTRIBUTE_OWNEDATTRIBUTE:	
					{
						std::shared_ptr<Artifact> castedContainer = std::dynamic_pointer_cast<Artifact> (container);;
						return this->createPort_as_ownedAttribute_in_Artifact(castedContainer,metaElementID);
					}
					//Port has ownedAttribute as a containment
					case  uml::umlPackage::DATATYPE_ATTRIBUTE_OWNEDATTRIBUTE:	
					{
						std::weak_ptr<uml::DataType> castedContainer = std::dynamic_pointer_cast<uml::DataType> (container);
						return this->createPort_as_ownedAttribute_in_DataType(castedContainer,metaElementID);
					}
					//Port has ownedAttribute as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_OWNEDATTRIBUTE:	
					{
						std::weak_ptr<uml::Interface> castedContainer = std::dynamic_pointer_cast<uml::Interface> (container);
						return this->createPort_as_ownedAttribute_in_Interface(castedContainer,metaElementID);
					}
					//Port has ownedAttribute as a containment
					case  uml::umlPackage::SIGNAL_ATTRIBUTE_OWNEDATTRIBUTE:	
					{
						std::shared_ptr<Signal> castedContainer = std::dynamic_pointer_cast<Signal> (container);;
						return this->createPort_as_ownedAttribute_in_Signal(castedContainer,metaElementID);
					}
					//Port has ownedAttribute as a containment
					case  uml::umlPackage::STRUCTUREDCLASSIFIER_ATTRIBUTE_OWNEDATTRIBUTE:	
					{
						std::shared_ptr<StructuredClassifier> castedContainer = std::dynamic_pointer_cast<StructuredClassifier> (container);;
						return this->createPort_as_ownedAttribute_in_StructuredClassifier(castedContainer,metaElementID);
					}
					//Port has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createPort_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Port has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createPort_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Port has ownedEnd as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_OWNEDEND:	
					{
						std::weak_ptr<uml::Association> castedContainer = std::dynamic_pointer_cast<uml::Association> (container);
						return this->createPort_as_ownedEnd_in_Association(castedContainer,metaElementID);
					}
					//Port has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createPort_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Port has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createPort_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Port has ownedPort as a containment
					case  uml::umlPackage::ENCAPSULATEDCLASSIFIER_ATTRIBUTE_OWNEDPORT:	
					{
						std::shared_ptr<EncapsulatedClassifier> castedContainer = std::dynamic_pointer_cast<EncapsulatedClassifier> (container);;
						return this->createPort_as_ownedPort_in_EncapsulatedClassifier(castedContainer,metaElementID);
					}
					//Port has qualifier as a containment
					case  uml::umlPackage::PROPERTY_ATTRIBUTE_QUALIFIER:	
					{
						std::weak_ptr<uml::Property> castedContainer = std::dynamic_pointer_cast<uml::Property> (container);
						return this->createPort_as_qualifier_in_Property(castedContainer,metaElementID);
					}
					//Port has redefinedPort as a containment
					case  uml::umlPackage::PORT_ATTRIBUTE_REDEFINEDPORT:	
					{
						std::shared_ptr<Port> castedContainer = std::dynamic_pointer_cast<Port> (container);;
						return this->createPort_as_redefinedPort_in_Port(castedContainer,metaElementID);
					}
					//Port has redefinedProperty as a containment
					case  uml::umlPackage::PROPERTY_ATTRIBUTE_REDEFINEDPROPERTY:	
					{
						std::shared_ptr<Property> castedContainer = std::dynamic_pointer_cast<Property> (container);;
						return this->createPort_as_redefinedProperty_in_Property(castedContainer,metaElementID);
					}
					//Port has role as a containment
					case  uml::umlPackage::STRUCTUREDCLASSIFIER_ATTRIBUTE_ROLE:	
					{
						std::shared_ptr<StructuredClassifier> castedContainer = std::dynamic_pointer_cast<StructuredClassifier> (container);;
						return this->createPort_as_role_in_StructuredClassifier(castedContainer,metaElementID);
					}
					//Port has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createPort_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Port has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createPort_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Port has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createPort_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::PRIMITIVETYPE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createPrimitiveType(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//PrimitiveType has classifier as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_CLASSIFIER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createPrimitiveType_as_classifier_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//PrimitiveType has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createPrimitiveType_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//PrimitiveType has contract as a containment
					case  uml::umlPackage::SUBSTITUTION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<Substitution> castedContainer = std::dynamic_pointer_cast<Substitution> (container);;
						return this->createPrimitiveType_as_contract_in_Substitution(castedContainer,metaElementID);
					}
					//PrimitiveType has endType as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_ENDTYPE:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createPrimitiveType_as_endType_in_Association(castedContainer,metaElementID);
					}
					//PrimitiveType has general as a containment
					case  uml::umlPackage::GENERALIZATION_ATTRIBUTE_GENERAL:	
					{
						std::shared_ptr<Generalization> castedContainer = std::dynamic_pointer_cast<Generalization> (container);;
						return this->createPrimitiveType_as_general_in_Generalization(castedContainer,metaElementID);
					}
					//PrimitiveType has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createPrimitiveType_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//PrimitiveType has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createPrimitiveType_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//PrimitiveType has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createPrimitiveType_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//PrimitiveType has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createPrimitiveType_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//PrimitiveType has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createPrimitiveType_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//PrimitiveType has nestedClassifier as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createPrimitiveType_as_nestedClassifier_in_Class(castedContainer,metaElementID);
					}
					//PrimitiveType has nestedClassifier as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createPrimitiveType_as_nestedClassifier_in_Interface(castedContainer,metaElementID);
					}
					//PrimitiveType has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createPrimitiveType_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//PrimitiveType has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createPrimitiveType_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//PrimitiveType has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createPrimitiveType_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//PrimitiveType has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createPrimitiveType_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//PrimitiveType has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createPrimitiveType_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//PrimitiveType has ownedType as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDTYPE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createPrimitiveType_as_ownedType_in_Package(castedContainer,metaElementID);
					}
					//PrimitiveType has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createPrimitiveType_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//PrimitiveType has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createPrimitiveType_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//PrimitiveType has realizingClassifier as a containment
					case  uml::umlPackage::COMPONENTREALIZATION_ATTRIBUTE_REALIZINGCLASSIFIER:	
					{
						std::shared_ptr<ComponentRealization> castedContainer = std::dynamic_pointer_cast<ComponentRealization> (container);;
						return this->createPrimitiveType_as_realizingClassifier_in_ComponentRealization(castedContainer,metaElementID);
					}
					//PrimitiveType has redefinedClassifier as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REDEFINEDCLASSIFIER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createPrimitiveType_as_redefinedClassifier_in_Classifier(castedContainer,metaElementID);
					}
					//PrimitiveType has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createPrimitiveType_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//PrimitiveType has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createPrimitiveType_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//PrimitiveType has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createPrimitiveType_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//PrimitiveType has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createPrimitiveType_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::PROFILE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createProfile(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Profile has appliedProfile as a containment
					case  uml::umlPackage::PROFILEAPPLICATION_ATTRIBUTE_APPLIEDPROFILE:	
					{
						std::shared_ptr<ProfileApplication> castedContainer = std::dynamic_pointer_cast<ProfileApplication> (container);;
						return this->createProfile_as_appliedProfile_in_ProfileApplication(castedContainer,metaElementID);
					}
					//Profile has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createProfile_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Profile has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createProfile_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Profile has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createProfile_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Profile has importedPackage as a containment
					case  uml::umlPackage::PACKAGEIMPORT_ATTRIBUTE_IMPORTEDPACKAGE:	
					{
						std::shared_ptr<PackageImport> castedContainer = std::dynamic_pointer_cast<PackageImport> (container);;
						return this->createProfile_as_importedPackage_in_PackageImport(castedContainer,metaElementID);
					}
					//Profile has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createProfile_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Profile has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createProfile_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Profile has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createProfile_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Profile has mergedPackage as a containment
					case  uml::umlPackage::PACKAGEMERGE_ATTRIBUTE_MERGEDPACKAGE:	
					{
						std::shared_ptr<PackageMerge> castedContainer = std::dynamic_pointer_cast<PackageMerge> (container);;
						return this->createProfile_as_mergedPackage_in_PackageMerge(castedContainer,metaElementID);
					}
					//Profile has nestedPackage as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_NESTEDPACKAGE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createProfile_as_nestedPackage_in_Package(castedContainer,metaElementID);
					}
					//Profile has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createProfile_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Profile has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createProfile_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Profile has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createProfile_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Profile has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createProfile_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Profile has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createProfile_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Profile has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createProfile_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Profile has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createProfile_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Profile has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createProfile_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Profile has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createProfile_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Profile has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createProfile_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Profile has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createProfile_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::PROFILEAPPLICATION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createProfileApplication(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ProfileApplication has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createProfileApplication_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ProfileApplication has profileApplication as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PROFILEAPPLICATION:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createProfileApplication_as_profileApplication_in_Package(castedContainer,metaElementID);
					}
					//ProfileApplication has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createProfileApplication_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ProfileApplication has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createProfileApplication_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::PROPERTY_CLASS:
		{
			if (nullptr == container)
			{
				return this->createProperty(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Property has associationEnd as a containment
					//Property has attribute as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_ATTRIBUTE:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createProperty_as_attribute_in_Classifier(castedContainer,metaElementID);
					}
					//Property has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createProperty_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Property has collaborationRole as a containment
					case  uml::umlPackage::COLLABORATION_ATTRIBUTE_COLLABORATIONROLE:	
					{
						std::shared_ptr<Collaboration> castedContainer = std::dynamic_pointer_cast<Collaboration> (container);;
						return this->createProperty_as_collaborationRole_in_Collaboration(castedContainer,metaElementID);
					}
					//Property has feature as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_FEATURE:	
					{
						std::shared_ptr<uml::Classifier> castedContainer = std::dynamic_pointer_cast<uml::Classifier> (container);
						return this->createProperty_as_feature_in_Classifier(castedContainer,metaElementID);
					}
					//Property has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createProperty_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Property has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createProperty_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Property has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createProperty_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Property has memberEnd as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_MEMBEREND:	
					{
						std::shared_ptr<uml::Association> castedContainer = std::dynamic_pointer_cast<uml::Association> (container);
						return this->createProperty_as_memberEnd_in_Association(castedContainer,metaElementID);
					}
					//Property has navigableOwnedEnd as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_NAVIGABLEOWNEDEND:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createProperty_as_navigableOwnedEnd_in_Association(castedContainer,metaElementID);
					}
					//Property has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createProperty_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Property has ownedAttribute as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_OWNEDATTRIBUTE:	
					{
						std::weak_ptr<uml::Class> castedContainer = std::dynamic_pointer_cast<uml::Class> (container);
						return this->createProperty_as_ownedAttribute_in_Class(castedContainer,metaElementID);
					}
					//Property has ownedAttribute as a containment
					case  uml::umlPackage::ARTIFACT_ATTRIBUTE_OWNEDATTRIBUTE:	
					{
						std::shared_ptr<Artifact> castedContainer = std::dynamic_pointer_cast<Artifact> (container);;
						return this->createProperty_as_ownedAttribute_in_Artifact(castedContainer,metaElementID);
					}
					//Property has ownedAttribute as a containment
					case  uml::umlPackage::DATATYPE_ATTRIBUTE_OWNEDATTRIBUTE:	
					{
						std::weak_ptr<uml::DataType> castedContainer = std::dynamic_pointer_cast<uml::DataType> (container);
						return this->createProperty_as_ownedAttribute_in_DataType(castedContainer,metaElementID);
					}
					//Property has ownedAttribute as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_OWNEDATTRIBUTE:	
					{
						std::weak_ptr<uml::Interface> castedContainer = std::dynamic_pointer_cast<uml::Interface> (container);
						return this->createProperty_as_ownedAttribute_in_Interface(castedContainer,metaElementID);
					}
					//Property has ownedAttribute as a containment
					case  uml::umlPackage::SIGNAL_ATTRIBUTE_OWNEDATTRIBUTE:	
					{
						std::shared_ptr<Signal> castedContainer = std::dynamic_pointer_cast<Signal> (container);;
						return this->createProperty_as_ownedAttribute_in_Signal(castedContainer,metaElementID);
					}
					//Property has ownedAttribute as a containment
					case  uml::umlPackage::STRUCTUREDCLASSIFIER_ATTRIBUTE_OWNEDATTRIBUTE:	
					{
						std::shared_ptr<StructuredClassifier> castedContainer = std::dynamic_pointer_cast<StructuredClassifier> (container);;
						return this->createProperty_as_ownedAttribute_in_StructuredClassifier(castedContainer,metaElementID);
					}
					//Property has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createProperty_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Property has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createProperty_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Property has ownedEnd as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_OWNEDEND:	
					{
						std::weak_ptr<uml::Association> castedContainer = std::dynamic_pointer_cast<uml::Association> (container);
						return this->createProperty_as_ownedEnd_in_Association(castedContainer,metaElementID);
					}
					//Property has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createProperty_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Property has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createProperty_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Property has qualifier as a containment
					case  uml::umlPackage::PROPERTY_ATTRIBUTE_QUALIFIER:	
					{
						std::weak_ptr<uml::Property> castedContainer = std::dynamic_pointer_cast<uml::Property> (container);
						return this->createProperty_as_qualifier_in_Property(castedContainer,metaElementID);
					}
					//Property has redefinedProperty as a containment
					case  uml::umlPackage::PROPERTY_ATTRIBUTE_REDEFINEDPROPERTY:	
					{
						std::shared_ptr<Property> castedContainer = std::dynamic_pointer_cast<Property> (container);;
						return this->createProperty_as_redefinedProperty_in_Property(castedContainer,metaElementID);
					}
					//Property has role as a containment
					case  uml::umlPackage::STRUCTUREDCLASSIFIER_ATTRIBUTE_ROLE:	
					{
						std::shared_ptr<StructuredClassifier> castedContainer = std::dynamic_pointer_cast<StructuredClassifier> (container);;
						return this->createProperty_as_role_in_StructuredClassifier(castedContainer,metaElementID);
					}
					//Property has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createProperty_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Property has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createProperty_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Property has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createProperty_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::PROTOCOLCONFORMANCE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createProtocolConformance(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ProtocolConformance has conformance as a containment
					case  uml::umlPackage::PROTOCOLSTATEMACHINE_ATTRIBUTE_CONFORMANCE:	
					{
						std::weak_ptr<uml::ProtocolStateMachine> castedContainer = std::dynamic_pointer_cast<uml::ProtocolStateMachine> (container);
						return this->createProtocolConformance_as_conformance_in_ProtocolStateMachine(castedContainer,metaElementID);
					}
					//ProtocolConformance has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createProtocolConformance_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ProtocolConformance has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createProtocolConformance_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ProtocolConformance has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createProtocolConformance_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::PROTOCOLSTATEMACHINE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createProtocolStateMachine(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ProtocolStateMachine has classifier as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_CLASSIFIER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createProtocolStateMachine_as_classifier_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has classifierBehavior as a containment
					case  uml::umlPackage::BEHAVIOREDCLASSIFIER_ATTRIBUTE_CLASSIFIERBEHAVIOR:	
					{
						std::shared_ptr<BehavioredClassifier> castedContainer = std::dynamic_pointer_cast<BehavioredClassifier> (container);;
						return this->createProtocolStateMachine_as_classifierBehavior_in_BehavioredClassifier(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createProtocolStateMachine_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has context as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_CONTEXT:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createProtocolStateMachine_as_context_in_Behavior(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has contract as a containment
					case  uml::umlPackage::SUBSTITUTION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<Substitution> castedContainer = std::dynamic_pointer_cast<Substitution> (container);;
						return this->createProtocolStateMachine_as_contract_in_Substitution(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has doActivity as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_DOACTIVITY:	
					{
						std::shared_ptr<State> castedContainer = std::dynamic_pointer_cast<State> (container);;
						return this->createProtocolStateMachine_as_doActivity_in_State(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has effect as a containment
					case  uml::umlPackage::TRANSITION_ATTRIBUTE_EFFECT:	
					{
						std::shared_ptr<Transition> castedContainer = std::dynamic_pointer_cast<Transition> (container);;
						return this->createProtocolStateMachine_as_effect_in_Transition(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has endType as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_ENDTYPE:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createProtocolStateMachine_as_endType_in_Association(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has entry as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_ENTRY:	
					{
						std::shared_ptr<State> castedContainer = std::dynamic_pointer_cast<State> (container);;
						return this->createProtocolStateMachine_as_entry_in_State(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has exit as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_EXIT:	
					{
						std::shared_ptr<State> castedContainer = std::dynamic_pointer_cast<State> (container);;
						return this->createProtocolStateMachine_as_exit_in_State(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has general as a containment
					case  uml::umlPackage::GENERALIZATION_ATTRIBUTE_GENERAL:	
					{
						std::shared_ptr<Generalization> castedContainer = std::dynamic_pointer_cast<Generalization> (container);;
						return this->createProtocolStateMachine_as_general_in_Generalization(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has generalMachine as a containment
					case  uml::umlPackage::PROTOCOLCONFORMANCE_ATTRIBUTE_GENERALMACHINE:	
					{
						std::shared_ptr<ProtocolConformance> castedContainer = std::dynamic_pointer_cast<ProtocolConformance> (container);;
						return this->createProtocolStateMachine_as_generalMachine_in_ProtocolConformance(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createProtocolStateMachine_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createProtocolStateMachine_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createProtocolStateMachine_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createProtocolStateMachine_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createProtocolStateMachine_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has nestedClassifier as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createProtocolStateMachine_as_nestedClassifier_in_Class(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has nestedClassifier as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createProtocolStateMachine_as_nestedClassifier_in_Interface(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createProtocolStateMachine_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has ownedBehavior as a containment
					case  uml::umlPackage::BEHAVIOREDCLASSIFIER_ATTRIBUTE_OWNEDBEHAVIOR:	
					{
						std::weak_ptr<uml::BehavioredClassifier> castedContainer = std::dynamic_pointer_cast<uml::BehavioredClassifier> (container);
						return this->createProtocolStateMachine_as_ownedBehavior_in_BehavioredClassifier(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createProtocolStateMachine_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createProtocolStateMachine_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createProtocolStateMachine_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createProtocolStateMachine_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has ownedType as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDTYPE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createProtocolStateMachine_as_ownedType_in_Package(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createProtocolStateMachine_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createProtocolStateMachine_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has protocol as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_PROTOCOL:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createProtocolStateMachine_as_protocol_in_Interface(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has realizingClassifier as a containment
					case  uml::umlPackage::COMPONENTREALIZATION_ATTRIBUTE_REALIZINGCLASSIFIER:	
					{
						std::shared_ptr<ComponentRealization> castedContainer = std::dynamic_pointer_cast<ComponentRealization> (container);;
						return this->createProtocolStateMachine_as_realizingClassifier_in_ComponentRealization(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has redefinedBehavior as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_REDEFINEDBEHAVIOR:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createProtocolStateMachine_as_redefinedBehavior_in_Behavior(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has redefinedClassifier as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REDEFINEDCLASSIFIER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createProtocolStateMachine_as_redefinedClassifier_in_Classifier(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createProtocolStateMachine_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has specificMachine as a containment
					//ProtocolStateMachine has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createProtocolStateMachine_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createProtocolStateMachine_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ProtocolStateMachine has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createProtocolStateMachine_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::PROTOCOLTRANSITION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createProtocolTransition(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ProtocolTransition has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createProtocolTransition_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ProtocolTransition has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createProtocolTransition_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ProtocolTransition has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createProtocolTransition_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ProtocolTransition has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createProtocolTransition_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ProtocolTransition has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createProtocolTransition_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ProtocolTransition has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createProtocolTransition_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ProtocolTransition has redefinedTransition as a containment
					case  uml::umlPackage::TRANSITION_ATTRIBUTE_REDEFINEDTRANSITION:	
					{
						std::shared_ptr<Transition> castedContainer = std::dynamic_pointer_cast<Transition> (container);;
						return this->createProtocolTransition_as_redefinedTransition_in_Transition(castedContainer,metaElementID);
					}
					//ProtocolTransition has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createProtocolTransition_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ProtocolTransition has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createProtocolTransition_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ProtocolTransition has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createProtocolTransition_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ProtocolTransition has transition as a containment
					case  uml::umlPackage::REGION_ATTRIBUTE_TRANSITION:	
					{
						std::weak_ptr<uml::Region> castedContainer = std::dynamic_pointer_cast<uml::Region> (container);
						return this->createProtocolTransition_as_transition_in_Region(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::PSEUDOSTATE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createPseudostate(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Pseudostate has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createPseudostate_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Pseudostate has connectionPoint as a containment
					case  uml::umlPackage::STATEMACHINE_ATTRIBUTE_CONNECTIONPOINT:	
					{
						std::weak_ptr<uml::StateMachine> castedContainer = std::dynamic_pointer_cast<uml::StateMachine> (container);
						return this->createPseudostate_as_connectionPoint_in_StateMachine(castedContainer,metaElementID);
					}
					//Pseudostate has connectionPoint as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_CONNECTIONPOINT:	
					{
						std::weak_ptr<uml::State> castedContainer = std::dynamic_pointer_cast<uml::State> (container);
						return this->createPseudostate_as_connectionPoint_in_State(castedContainer,metaElementID);
					}
					//Pseudostate has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createPseudostate_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Pseudostate has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createPseudostate_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Pseudostate has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createPseudostate_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Pseudostate has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createPseudostate_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Pseudostate has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createPseudostate_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Pseudostate has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createPseudostate_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Pseudostate has subvertex as a containment
					case  uml::umlPackage::REGION_ATTRIBUTE_SUBVERTEX:	
					{
						std::weak_ptr<uml::Region> castedContainer = std::dynamic_pointer_cast<uml::Region> (container);
						return this->createPseudostate_as_subvertex_in_Region(castedContainer,metaElementID);
					}
					//Pseudostate has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createPseudostate_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Pseudostate has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createPseudostate_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::QUALIFIERVALUE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createQualifierValue(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//QualifierValue has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createQualifierValue_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//QualifierValue has qualifier as a containment
					case  uml::umlPackage::LINKENDDATA_ATTRIBUTE_QUALIFIER:	
					{
						std::shared_ptr<LinkEndData> castedContainer = std::dynamic_pointer_cast<LinkEndData> (container);;
						return this->createQualifierValue_as_qualifier_in_LinkEndData(castedContainer,metaElementID);
					}
					//QualifierValue has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createQualifierValue_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//QualifierValue has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createQualifierValue_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::RAISEEXCEPTIONACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createRaiseExceptionAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//RaiseExceptionAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createRaiseExceptionAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//RaiseExceptionAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createRaiseExceptionAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//RaiseExceptionAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createRaiseExceptionAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//RaiseExceptionAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createRaiseExceptionAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//RaiseExceptionAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createRaiseExceptionAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//RaiseExceptionAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createRaiseExceptionAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//RaiseExceptionAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createRaiseExceptionAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//RaiseExceptionAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createRaiseExceptionAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//RaiseExceptionAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createRaiseExceptionAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//RaiseExceptionAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createRaiseExceptionAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//RaiseExceptionAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createRaiseExceptionAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//RaiseExceptionAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createRaiseExceptionAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//RaiseExceptionAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createRaiseExceptionAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//RaiseExceptionAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createRaiseExceptionAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//RaiseExceptionAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createRaiseExceptionAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//RaiseExceptionAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createRaiseExceptionAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//RaiseExceptionAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createRaiseExceptionAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//RaiseExceptionAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createRaiseExceptionAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::READEXTENTACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createReadExtentAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ReadExtentAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createReadExtentAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//ReadExtentAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createReadExtentAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ReadExtentAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createReadExtentAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//ReadExtentAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createReadExtentAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//ReadExtentAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createReadExtentAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ReadExtentAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createReadExtentAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ReadExtentAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createReadExtentAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ReadExtentAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createReadExtentAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//ReadExtentAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createReadExtentAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//ReadExtentAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createReadExtentAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//ReadExtentAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createReadExtentAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//ReadExtentAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createReadExtentAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ReadExtentAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createReadExtentAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ReadExtentAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createReadExtentAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//ReadExtentAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createReadExtentAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//ReadExtentAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createReadExtentAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ReadExtentAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createReadExtentAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ReadExtentAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createReadExtentAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::READISCLASSIFIEDOBJECTACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createReadIsClassifiedObjectAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ReadIsClassifiedObjectAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createReadIsClassifiedObjectAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//ReadIsClassifiedObjectAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createReadIsClassifiedObjectAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ReadIsClassifiedObjectAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createReadIsClassifiedObjectAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//ReadIsClassifiedObjectAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createReadIsClassifiedObjectAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//ReadIsClassifiedObjectAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createReadIsClassifiedObjectAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ReadIsClassifiedObjectAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createReadIsClassifiedObjectAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ReadIsClassifiedObjectAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createReadIsClassifiedObjectAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ReadIsClassifiedObjectAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createReadIsClassifiedObjectAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//ReadIsClassifiedObjectAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createReadIsClassifiedObjectAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//ReadIsClassifiedObjectAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createReadIsClassifiedObjectAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//ReadIsClassifiedObjectAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createReadIsClassifiedObjectAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//ReadIsClassifiedObjectAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createReadIsClassifiedObjectAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ReadIsClassifiedObjectAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createReadIsClassifiedObjectAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ReadIsClassifiedObjectAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createReadIsClassifiedObjectAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//ReadIsClassifiedObjectAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createReadIsClassifiedObjectAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//ReadIsClassifiedObjectAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createReadIsClassifiedObjectAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ReadIsClassifiedObjectAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createReadIsClassifiedObjectAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ReadIsClassifiedObjectAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createReadIsClassifiedObjectAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::READLINKACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createReadLinkAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ReadLinkAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createReadLinkAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//ReadLinkAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createReadLinkAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ReadLinkAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createReadLinkAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//ReadLinkAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createReadLinkAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//ReadLinkAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createReadLinkAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ReadLinkAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createReadLinkAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ReadLinkAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createReadLinkAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ReadLinkAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createReadLinkAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//ReadLinkAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createReadLinkAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//ReadLinkAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createReadLinkAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//ReadLinkAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createReadLinkAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//ReadLinkAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createReadLinkAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ReadLinkAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createReadLinkAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ReadLinkAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createReadLinkAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//ReadLinkAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createReadLinkAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//ReadLinkAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createReadLinkAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ReadLinkAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createReadLinkAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ReadLinkAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createReadLinkAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::READLINKOBJECTENDACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createReadLinkObjectEndAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ReadLinkObjectEndAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createReadLinkObjectEndAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createReadLinkObjectEndAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createReadLinkObjectEndAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createReadLinkObjectEndAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createReadLinkObjectEndAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createReadLinkObjectEndAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createReadLinkObjectEndAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createReadLinkObjectEndAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createReadLinkObjectEndAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createReadLinkObjectEndAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createReadLinkObjectEndAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createReadLinkObjectEndAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createReadLinkObjectEndAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createReadLinkObjectEndAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createReadLinkObjectEndAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createReadLinkObjectEndAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createReadLinkObjectEndAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createReadLinkObjectEndAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::READLINKOBJECTENDQUALIFIERACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createReadLinkObjectEndQualifierAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ReadLinkObjectEndQualifierAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createReadLinkObjectEndQualifierAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndQualifierAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createReadLinkObjectEndQualifierAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndQualifierAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createReadLinkObjectEndQualifierAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndQualifierAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createReadLinkObjectEndQualifierAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndQualifierAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createReadLinkObjectEndQualifierAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndQualifierAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createReadLinkObjectEndQualifierAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndQualifierAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createReadLinkObjectEndQualifierAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndQualifierAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createReadLinkObjectEndQualifierAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndQualifierAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createReadLinkObjectEndQualifierAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndQualifierAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createReadLinkObjectEndQualifierAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndQualifierAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createReadLinkObjectEndQualifierAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndQualifierAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createReadLinkObjectEndQualifierAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndQualifierAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createReadLinkObjectEndQualifierAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndQualifierAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createReadLinkObjectEndQualifierAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndQualifierAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createReadLinkObjectEndQualifierAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndQualifierAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createReadLinkObjectEndQualifierAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndQualifierAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createReadLinkObjectEndQualifierAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ReadLinkObjectEndQualifierAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createReadLinkObjectEndQualifierAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::READSELFACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createReadSelfAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ReadSelfAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createReadSelfAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//ReadSelfAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createReadSelfAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ReadSelfAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createReadSelfAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//ReadSelfAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createReadSelfAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//ReadSelfAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createReadSelfAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ReadSelfAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createReadSelfAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ReadSelfAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createReadSelfAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ReadSelfAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createReadSelfAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//ReadSelfAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createReadSelfAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//ReadSelfAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createReadSelfAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//ReadSelfAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createReadSelfAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//ReadSelfAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createReadSelfAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ReadSelfAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createReadSelfAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ReadSelfAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createReadSelfAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//ReadSelfAction has readSelfAction as a containment
					//ReadSelfAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createReadSelfAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//ReadSelfAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createReadSelfAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ReadSelfAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createReadSelfAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ReadSelfAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createReadSelfAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::READSTRUCTURALFEATUREACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createReadStructuralFeatureAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ReadStructuralFeatureAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createReadStructuralFeatureAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//ReadStructuralFeatureAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createReadStructuralFeatureAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ReadStructuralFeatureAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createReadStructuralFeatureAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//ReadStructuralFeatureAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createReadStructuralFeatureAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//ReadStructuralFeatureAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createReadStructuralFeatureAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ReadStructuralFeatureAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createReadStructuralFeatureAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ReadStructuralFeatureAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createReadStructuralFeatureAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ReadStructuralFeatureAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createReadStructuralFeatureAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//ReadStructuralFeatureAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createReadStructuralFeatureAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//ReadStructuralFeatureAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createReadStructuralFeatureAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//ReadStructuralFeatureAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createReadStructuralFeatureAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//ReadStructuralFeatureAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createReadStructuralFeatureAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ReadStructuralFeatureAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createReadStructuralFeatureAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ReadStructuralFeatureAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createReadStructuralFeatureAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//ReadStructuralFeatureAction has readStructuralFeatureAction as a containment
					//ReadStructuralFeatureAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createReadStructuralFeatureAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//ReadStructuralFeatureAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createReadStructuralFeatureAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ReadStructuralFeatureAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createReadStructuralFeatureAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ReadStructuralFeatureAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createReadStructuralFeatureAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::READVARIABLEACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createReadVariableAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ReadVariableAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createReadVariableAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//ReadVariableAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createReadVariableAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ReadVariableAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createReadVariableAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//ReadVariableAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createReadVariableAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//ReadVariableAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createReadVariableAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ReadVariableAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createReadVariableAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ReadVariableAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createReadVariableAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ReadVariableAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createReadVariableAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//ReadVariableAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createReadVariableAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//ReadVariableAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createReadVariableAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//ReadVariableAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createReadVariableAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//ReadVariableAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createReadVariableAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ReadVariableAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createReadVariableAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ReadVariableAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createReadVariableAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//ReadVariableAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createReadVariableAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//ReadVariableAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createReadVariableAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ReadVariableAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createReadVariableAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ReadVariableAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createReadVariableAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::REALIZATION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createRealization(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Realization has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createRealization_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Realization has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createRealization_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Realization has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createRealization_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Realization has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createRealization_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Realization has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createRealization_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Realization has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createRealization_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Realization has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createRealization_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Realization has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createRealization_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Realization has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createRealization_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Realization has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createRealization_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Realization has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createRealization_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Realization has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createRealization_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Realization has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createRealization_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Realization has roleBinding as a containment
					case  uml::umlPackage::COLLABORATIONUSE_ATTRIBUTE_ROLEBINDING:	
					{
						std::shared_ptr<CollaborationUse> castedContainer = std::dynamic_pointer_cast<CollaborationUse> (container);;
						return this->createRealization_as_roleBinding_in_CollaborationUse(castedContainer,metaElementID);
					}
					//Realization has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createRealization_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Realization has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createRealization_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Realization has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createRealization_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Realization has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createRealization_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::RECEPTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createReception(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Reception has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createReception_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Reception has feature as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_FEATURE:	
					{
						std::shared_ptr<uml::Classifier> castedContainer = std::dynamic_pointer_cast<uml::Classifier> (container);
						return this->createReception_as_feature_in_Classifier(castedContainer,metaElementID);
					}
					//Reception has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createReception_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Reception has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createReception_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Reception has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createReception_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Reception has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createReception_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Reception has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createReception_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Reception has ownedReception as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_OWNEDRECEPTION:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createReception_as_ownedReception_in_Class(castedContainer,metaElementID);
					}
					//Reception has ownedReception as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_OWNEDRECEPTION:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createReception_as_ownedReception_in_Interface(castedContainer,metaElementID);
					}
					//Reception has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createReception_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Reception has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createReception_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Reception has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createReception_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::RECLASSIFYOBJECTACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createReclassifyObjectAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ReclassifyObjectAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createReclassifyObjectAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//ReclassifyObjectAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createReclassifyObjectAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ReclassifyObjectAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createReclassifyObjectAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//ReclassifyObjectAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createReclassifyObjectAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//ReclassifyObjectAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createReclassifyObjectAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ReclassifyObjectAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createReclassifyObjectAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ReclassifyObjectAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createReclassifyObjectAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ReclassifyObjectAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createReclassifyObjectAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//ReclassifyObjectAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createReclassifyObjectAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//ReclassifyObjectAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createReclassifyObjectAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//ReclassifyObjectAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createReclassifyObjectAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//ReclassifyObjectAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createReclassifyObjectAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ReclassifyObjectAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createReclassifyObjectAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ReclassifyObjectAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createReclassifyObjectAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//ReclassifyObjectAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createReclassifyObjectAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//ReclassifyObjectAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createReclassifyObjectAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ReclassifyObjectAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createReclassifyObjectAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ReclassifyObjectAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createReclassifyObjectAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::REDEFINABLETEMPLATESIGNATURE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createRedefinableTemplateSignature(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//RedefinableTemplateSignature has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createRedefinableTemplateSignature_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//RedefinableTemplateSignature has extendedSignature as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_EXTENDEDSIGNATURE:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createRedefinableTemplateSignature_as_extendedSignature_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//RedefinableTemplateSignature has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createRedefinableTemplateSignature_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//RedefinableTemplateSignature has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createRedefinableTemplateSignature_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//RedefinableTemplateSignature has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createRedefinableTemplateSignature_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//RedefinableTemplateSignature has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createRedefinableTemplateSignature_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//RedefinableTemplateSignature has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createRedefinableTemplateSignature_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//RedefinableTemplateSignature has ownedTemplateSignature as a containment
					case  uml::umlPackage::TEMPLATEABLEELEMENT_ATTRIBUTE_OWNEDTEMPLATESIGNATURE:	
					{
						std::weak_ptr<uml::TemplateableElement> castedContainer = std::dynamic_pointer_cast<uml::TemplateableElement> (container);
						return this->createRedefinableTemplateSignature_as_ownedTemplateSignature_in_TemplateableElement(castedContainer,metaElementID);
					}
					//RedefinableTemplateSignature has signature as a containment
					case  uml::umlPackage::TEMPLATEBINDING_ATTRIBUTE_SIGNATURE:	
					{
						std::shared_ptr<TemplateBinding> castedContainer = std::dynamic_pointer_cast<TemplateBinding> (container);;
						return this->createRedefinableTemplateSignature_as_signature_in_TemplateBinding(castedContainer,metaElementID);
					}
					//RedefinableTemplateSignature has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createRedefinableTemplateSignature_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//RedefinableTemplateSignature has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createRedefinableTemplateSignature_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//RedefinableTemplateSignature has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createRedefinableTemplateSignature_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::REDUCEACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createReduceAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ReduceAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createReduceAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//ReduceAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createReduceAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ReduceAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createReduceAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//ReduceAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createReduceAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//ReduceAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createReduceAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ReduceAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createReduceAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ReduceAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createReduceAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ReduceAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createReduceAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//ReduceAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createReduceAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//ReduceAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createReduceAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//ReduceAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createReduceAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//ReduceAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createReduceAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ReduceAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createReduceAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ReduceAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createReduceAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//ReduceAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createReduceAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//ReduceAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createReduceAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ReduceAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createReduceAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ReduceAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createReduceAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::REGION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createRegion(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Region has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createRegion_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Region has container as a containment
					//Region has container as a containment
					//Region has extendedRegion as a containment
					case  uml::umlPackage::REGION_ATTRIBUTE_EXTENDEDREGION:	
					{
						std::shared_ptr<Region> castedContainer = std::dynamic_pointer_cast<Region> (container);;
						return this->createRegion_as_extendedRegion_in_Region(castedContainer,metaElementID);
					}
					//Region has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createRegion_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Region has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createRegion_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Region has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createRegion_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Region has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createRegion_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Region has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createRegion_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Region has region as a containment
					case  uml::umlPackage::STATEMACHINE_ATTRIBUTE_REGION:	
					{
						std::weak_ptr<uml::StateMachine> castedContainer = std::dynamic_pointer_cast<uml::StateMachine> (container);
						return this->createRegion_as_region_in_StateMachine(castedContainer,metaElementID);
					}
					//Region has region as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_REGION:	
					{
						std::weak_ptr<uml::State> castedContainer = std::dynamic_pointer_cast<uml::State> (container);
						return this->createRegion_as_region_in_State(castedContainer,metaElementID);
					}
					//Region has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createRegion_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Region has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createRegion_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Region has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createRegion_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::REMOVESTRUCTURALFEATUREVALUEACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createRemoveStructuralFeatureValueAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//RemoveStructuralFeatureValueAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createRemoveStructuralFeatureValueAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//RemoveStructuralFeatureValueAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createRemoveStructuralFeatureValueAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//RemoveStructuralFeatureValueAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createRemoveStructuralFeatureValueAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//RemoveStructuralFeatureValueAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createRemoveStructuralFeatureValueAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//RemoveStructuralFeatureValueAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createRemoveStructuralFeatureValueAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//RemoveStructuralFeatureValueAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createRemoveStructuralFeatureValueAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//RemoveStructuralFeatureValueAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createRemoveStructuralFeatureValueAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//RemoveStructuralFeatureValueAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createRemoveStructuralFeatureValueAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//RemoveStructuralFeatureValueAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createRemoveStructuralFeatureValueAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//RemoveStructuralFeatureValueAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createRemoveStructuralFeatureValueAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//RemoveStructuralFeatureValueAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createRemoveStructuralFeatureValueAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//RemoveStructuralFeatureValueAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createRemoveStructuralFeatureValueAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//RemoveStructuralFeatureValueAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createRemoveStructuralFeatureValueAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//RemoveStructuralFeatureValueAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createRemoveStructuralFeatureValueAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//RemoveStructuralFeatureValueAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createRemoveStructuralFeatureValueAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//RemoveStructuralFeatureValueAction has removeStructuralFeatureValueAction as a containment
					//RemoveStructuralFeatureValueAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createRemoveStructuralFeatureValueAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//RemoveStructuralFeatureValueAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createRemoveStructuralFeatureValueAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//RemoveStructuralFeatureValueAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createRemoveStructuralFeatureValueAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::REMOVEVARIABLEVALUEACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createRemoveVariableValueAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//RemoveVariableValueAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createRemoveVariableValueAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//RemoveVariableValueAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createRemoveVariableValueAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//RemoveVariableValueAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createRemoveVariableValueAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//RemoveVariableValueAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createRemoveVariableValueAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//RemoveVariableValueAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createRemoveVariableValueAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//RemoveVariableValueAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createRemoveVariableValueAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//RemoveVariableValueAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createRemoveVariableValueAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//RemoveVariableValueAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createRemoveVariableValueAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//RemoveVariableValueAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createRemoveVariableValueAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//RemoveVariableValueAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createRemoveVariableValueAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//RemoveVariableValueAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createRemoveVariableValueAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//RemoveVariableValueAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createRemoveVariableValueAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//RemoveVariableValueAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createRemoveVariableValueAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//RemoveVariableValueAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createRemoveVariableValueAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//RemoveVariableValueAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createRemoveVariableValueAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//RemoveVariableValueAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createRemoveVariableValueAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//RemoveVariableValueAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createRemoveVariableValueAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//RemoveVariableValueAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createRemoveVariableValueAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::REPLYACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createReplyAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ReplyAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createReplyAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//ReplyAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createReplyAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ReplyAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createReplyAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//ReplyAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createReplyAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//ReplyAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createReplyAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ReplyAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createReplyAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ReplyAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createReplyAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ReplyAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createReplyAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//ReplyAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createReplyAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//ReplyAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createReplyAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//ReplyAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createReplyAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//ReplyAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createReplyAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ReplyAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createReplyAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ReplyAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createReplyAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//ReplyAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createReplyAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//ReplyAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createReplyAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ReplyAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createReplyAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ReplyAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createReplyAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::SENDOBJECTACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createSendObjectAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//SendObjectAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createSendObjectAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//SendObjectAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createSendObjectAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//SendObjectAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createSendObjectAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//SendObjectAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createSendObjectAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//SendObjectAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createSendObjectAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//SendObjectAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createSendObjectAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//SendObjectAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createSendObjectAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//SendObjectAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createSendObjectAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//SendObjectAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createSendObjectAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//SendObjectAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createSendObjectAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//SendObjectAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createSendObjectAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//SendObjectAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createSendObjectAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//SendObjectAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createSendObjectAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//SendObjectAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createSendObjectAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//SendObjectAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createSendObjectAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//SendObjectAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createSendObjectAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//SendObjectAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createSendObjectAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//SendObjectAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createSendObjectAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::SENDSIGNALACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createSendSignalAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//SendSignalAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createSendSignalAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//SendSignalAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createSendSignalAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//SendSignalAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createSendSignalAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//SendSignalAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createSendSignalAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//SendSignalAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createSendSignalAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//SendSignalAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createSendSignalAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//SendSignalAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createSendSignalAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//SendSignalAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createSendSignalAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//SendSignalAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createSendSignalAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//SendSignalAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createSendSignalAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//SendSignalAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createSendSignalAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//SendSignalAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createSendSignalAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//SendSignalAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createSendSignalAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//SendSignalAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createSendSignalAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//SendSignalAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createSendSignalAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//SendSignalAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createSendSignalAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//SendSignalAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createSendSignalAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//SendSignalAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createSendSignalAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::SEQUENCENODE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createSequenceNode(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//SequenceNode has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createSequenceNode_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//SequenceNode has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createSequenceNode_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//SequenceNode has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createSequenceNode_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//SequenceNode has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createSequenceNode_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//SequenceNode has group as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_GROUP:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createSequenceNode_as_group_in_Activity(castedContainer,metaElementID);
					}
					//SequenceNode has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createSequenceNode_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//SequenceNode has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createSequenceNode_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//SequenceNode has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createSequenceNode_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//SequenceNode has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createSequenceNode_as_node_in_Activity(castedContainer,metaElementID);
					}
					//SequenceNode has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createSequenceNode_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//SequenceNode has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createSequenceNode_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//SequenceNode has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createSequenceNode_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//SequenceNode has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createSequenceNode_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//SequenceNode has ownedGroup as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDGROUP:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createSequenceNode_as_ownedGroup_in_Activity(castedContainer,metaElementID);
					}
					//SequenceNode has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createSequenceNode_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//SequenceNode has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createSequenceNode_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//SequenceNode has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createSequenceNode_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//SequenceNode has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createSequenceNode_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//SequenceNode has structuredNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_STRUCTUREDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createSequenceNode_as_structuredNode_in_Activity(castedContainer,metaElementID);
					}
					//SequenceNode has subgroup as a containment
					case  uml::umlPackage::ACTIVITYGROUP_ATTRIBUTE_SUBGROUP:	
					{
						std::weak_ptr<uml::ActivityGroup> castedContainer = std::dynamic_pointer_cast<uml::ActivityGroup> (container);
						return this->createSequenceNode_as_subgroup_in_ActivityGroup(castedContainer,metaElementID);
					}
					//SequenceNode has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createSequenceNode_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//SequenceNode has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createSequenceNode_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::SIGNAL_CLASS:
		{
			if (nullptr == container)
			{
				return this->createSignal(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Signal has classifier as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_CLASSIFIER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createSignal_as_classifier_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//Signal has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createSignal_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Signal has contract as a containment
					case  uml::umlPackage::SUBSTITUTION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<Substitution> castedContainer = std::dynamic_pointer_cast<Substitution> (container);;
						return this->createSignal_as_contract_in_Substitution(castedContainer,metaElementID);
					}
					//Signal has endType as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_ENDTYPE:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createSignal_as_endType_in_Association(castedContainer,metaElementID);
					}
					//Signal has general as a containment
					case  uml::umlPackage::GENERALIZATION_ATTRIBUTE_GENERAL:	
					{
						std::shared_ptr<Generalization> castedContainer = std::dynamic_pointer_cast<Generalization> (container);;
						return this->createSignal_as_general_in_Generalization(castedContainer,metaElementID);
					}
					//Signal has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createSignal_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Signal has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createSignal_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Signal has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createSignal_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Signal has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createSignal_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Signal has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createSignal_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Signal has nestedClassifier as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createSignal_as_nestedClassifier_in_Class(castedContainer,metaElementID);
					}
					//Signal has nestedClassifier as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createSignal_as_nestedClassifier_in_Interface(castedContainer,metaElementID);
					}
					//Signal has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createSignal_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Signal has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createSignal_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Signal has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createSignal_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Signal has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createSignal_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Signal has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createSignal_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Signal has ownedType as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDTYPE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createSignal_as_ownedType_in_Package(castedContainer,metaElementID);
					}
					//Signal has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createSignal_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Signal has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createSignal_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Signal has realizingClassifier as a containment
					case  uml::umlPackage::COMPONENTREALIZATION_ATTRIBUTE_REALIZINGCLASSIFIER:	
					{
						std::shared_ptr<ComponentRealization> castedContainer = std::dynamic_pointer_cast<ComponentRealization> (container);;
						return this->createSignal_as_realizingClassifier_in_ComponentRealization(castedContainer,metaElementID);
					}
					//Signal has redefinedClassifier as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REDEFINEDCLASSIFIER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createSignal_as_redefinedClassifier_in_Classifier(castedContainer,metaElementID);
					}
					//Signal has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createSignal_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Signal has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createSignal_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Signal has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createSignal_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Signal has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createSignal_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::SIGNALEVENT_CLASS:
		{
			if (nullptr == container)
			{
				return this->createSignalEvent(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//SignalEvent has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createSignalEvent_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//SignalEvent has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createSignalEvent_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//SignalEvent has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createSignalEvent_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//SignalEvent has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createSignalEvent_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//SignalEvent has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createSignalEvent_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//SignalEvent has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createSignalEvent_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//SignalEvent has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createSignalEvent_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//SignalEvent has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createSignalEvent_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//SignalEvent has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createSignalEvent_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//SignalEvent has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createSignalEvent_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//SignalEvent has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createSignalEvent_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//SignalEvent has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createSignalEvent_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//SignalEvent has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createSignalEvent_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//SignalEvent has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createSignalEvent_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//SignalEvent has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createSignalEvent_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//SignalEvent has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createSignalEvent_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//SignalEvent has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createSignalEvent_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::SLOT_CLASS:
		{
			if (nullptr == container)
			{
				return this->createSlot(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Slot has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createSlot_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Slot has owningSlot as a containment
					//Slot has slot as a containment
					case  uml::umlPackage::INSTANCESPECIFICATION_ATTRIBUTE_SLOT:	
					{
						std::weak_ptr<uml::InstanceSpecification> castedContainer = std::dynamic_pointer_cast<uml::InstanceSpecification> (container);
						return this->createSlot_as_slot_in_InstanceSpecification(castedContainer,metaElementID);
					}
					//Slot has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createSlot_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Slot has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createSlot_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::STARTCLASSIFIERBEHAVIORACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createStartClassifierBehaviorAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//StartClassifierBehaviorAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createStartClassifierBehaviorAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//StartClassifierBehaviorAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createStartClassifierBehaviorAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//StartClassifierBehaviorAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createStartClassifierBehaviorAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//StartClassifierBehaviorAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createStartClassifierBehaviorAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//StartClassifierBehaviorAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createStartClassifierBehaviorAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//StartClassifierBehaviorAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createStartClassifierBehaviorAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//StartClassifierBehaviorAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createStartClassifierBehaviorAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//StartClassifierBehaviorAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createStartClassifierBehaviorAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//StartClassifierBehaviorAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createStartClassifierBehaviorAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//StartClassifierBehaviorAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createStartClassifierBehaviorAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//StartClassifierBehaviorAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createStartClassifierBehaviorAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//StartClassifierBehaviorAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createStartClassifierBehaviorAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//StartClassifierBehaviorAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createStartClassifierBehaviorAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//StartClassifierBehaviorAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createStartClassifierBehaviorAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//StartClassifierBehaviorAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createStartClassifierBehaviorAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//StartClassifierBehaviorAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createStartClassifierBehaviorAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//StartClassifierBehaviorAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createStartClassifierBehaviorAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//StartClassifierBehaviorAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createStartClassifierBehaviorAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::STARTOBJECTBEHAVIORACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createStartObjectBehaviorAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//StartObjectBehaviorAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createStartObjectBehaviorAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//StartObjectBehaviorAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createStartObjectBehaviorAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//StartObjectBehaviorAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createStartObjectBehaviorAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//StartObjectBehaviorAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createStartObjectBehaviorAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//StartObjectBehaviorAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createStartObjectBehaviorAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//StartObjectBehaviorAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createStartObjectBehaviorAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//StartObjectBehaviorAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createStartObjectBehaviorAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//StartObjectBehaviorAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createStartObjectBehaviorAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//StartObjectBehaviorAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createStartObjectBehaviorAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//StartObjectBehaviorAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createStartObjectBehaviorAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//StartObjectBehaviorAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createStartObjectBehaviorAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//StartObjectBehaviorAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createStartObjectBehaviorAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//StartObjectBehaviorAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createStartObjectBehaviorAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//StartObjectBehaviorAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createStartObjectBehaviorAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//StartObjectBehaviorAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createStartObjectBehaviorAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//StartObjectBehaviorAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createStartObjectBehaviorAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//StartObjectBehaviorAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createStartObjectBehaviorAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//StartObjectBehaviorAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createStartObjectBehaviorAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::STATE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createState(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//State has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createState_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//State has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createState_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//State has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createState_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//State has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createState_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//State has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createState_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//State has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createState_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//State has redefinedState as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_REDEFINEDSTATE:	
					{
						std::shared_ptr<State> castedContainer = std::dynamic_pointer_cast<State> (container);;
						return this->createState_as_redefinedState_in_State(castedContainer,metaElementID);
					}
					//State has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createState_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//State has state as a containment
					//State has state as a containment
					//State has state as a containment
					//State has subvertex as a containment
					case  uml::umlPackage::REGION_ATTRIBUTE_SUBVERTEX:	
					{
						std::weak_ptr<uml::Region> castedContainer = std::dynamic_pointer_cast<uml::Region> (container);
						return this->createState_as_subvertex_in_Region(castedContainer,metaElementID);
					}
					//State has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createState_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//State has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createState_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::STATEINVARIANT_CLASS:
		{
			if (nullptr == container)
			{
				return this->createStateInvariant(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//StateInvariant has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createStateInvariant_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//StateInvariant has fragment as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::Interaction> castedContainer = std::dynamic_pointer_cast<uml::Interaction> (container);
						return this->createStateInvariant_as_fragment_in_Interaction(castedContainer,metaElementID);
					}
					//StateInvariant has fragment as a containment
					case  uml::umlPackage::INTERACTIONOPERAND_ATTRIBUTE_FRAGMENT:	
					{
						std::weak_ptr<uml::InteractionOperand> castedContainer = std::dynamic_pointer_cast<uml::InteractionOperand> (container);
						return this->createStateInvariant_as_fragment_in_InteractionOperand(castedContainer,metaElementID);
					}
					//StateInvariant has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createStateInvariant_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//StateInvariant has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createStateInvariant_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//StateInvariant has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createStateInvariant_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//StateInvariant has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createStateInvariant_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//StateInvariant has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createStateInvariant_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//StateInvariant has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createStateInvariant_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//StateInvariant has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createStateInvariant_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//StateInvariant has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createStateInvariant_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::STATEMACHINE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createStateMachine(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//StateMachine has classifier as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_CLASSIFIER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createStateMachine_as_classifier_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//StateMachine has classifierBehavior as a containment
					case  uml::umlPackage::BEHAVIOREDCLASSIFIER_ATTRIBUTE_CLASSIFIERBEHAVIOR:	
					{
						std::shared_ptr<BehavioredClassifier> castedContainer = std::dynamic_pointer_cast<BehavioredClassifier> (container);;
						return this->createStateMachine_as_classifierBehavior_in_BehavioredClassifier(castedContainer,metaElementID);
					}
					//StateMachine has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createStateMachine_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//StateMachine has context as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_CONTEXT:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createStateMachine_as_context_in_Behavior(castedContainer,metaElementID);
					}
					//StateMachine has contract as a containment
					case  uml::umlPackage::SUBSTITUTION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<Substitution> castedContainer = std::dynamic_pointer_cast<Substitution> (container);;
						return this->createStateMachine_as_contract_in_Substitution(castedContainer,metaElementID);
					}
					//StateMachine has doActivity as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_DOACTIVITY:	
					{
						std::shared_ptr<State> castedContainer = std::dynamic_pointer_cast<State> (container);;
						return this->createStateMachine_as_doActivity_in_State(castedContainer,metaElementID);
					}
					//StateMachine has effect as a containment
					case  uml::umlPackage::TRANSITION_ATTRIBUTE_EFFECT:	
					{
						std::shared_ptr<Transition> castedContainer = std::dynamic_pointer_cast<Transition> (container);;
						return this->createStateMachine_as_effect_in_Transition(castedContainer,metaElementID);
					}
					//StateMachine has endType as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_ENDTYPE:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createStateMachine_as_endType_in_Association(castedContainer,metaElementID);
					}
					//StateMachine has entry as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_ENTRY:	
					{
						std::shared_ptr<State> castedContainer = std::dynamic_pointer_cast<State> (container);;
						return this->createStateMachine_as_entry_in_State(castedContainer,metaElementID);
					}
					//StateMachine has exit as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_EXIT:	
					{
						std::shared_ptr<State> castedContainer = std::dynamic_pointer_cast<State> (container);;
						return this->createStateMachine_as_exit_in_State(castedContainer,metaElementID);
					}
					//StateMachine has general as a containment
					case  uml::umlPackage::GENERALIZATION_ATTRIBUTE_GENERAL:	
					{
						std::shared_ptr<Generalization> castedContainer = std::dynamic_pointer_cast<Generalization> (container);;
						return this->createStateMachine_as_general_in_Generalization(castedContainer,metaElementID);
					}
					//StateMachine has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createStateMachine_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//StateMachine has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createStateMachine_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//StateMachine has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createStateMachine_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//StateMachine has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createStateMachine_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//StateMachine has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createStateMachine_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//StateMachine has nestedClassifier as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createStateMachine_as_nestedClassifier_in_Class(castedContainer,metaElementID);
					}
					//StateMachine has nestedClassifier as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createStateMachine_as_nestedClassifier_in_Interface(castedContainer,metaElementID);
					}
					//StateMachine has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createStateMachine_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//StateMachine has ownedBehavior as a containment
					case  uml::umlPackage::BEHAVIOREDCLASSIFIER_ATTRIBUTE_OWNEDBEHAVIOR:	
					{
						std::weak_ptr<uml::BehavioredClassifier> castedContainer = std::dynamic_pointer_cast<uml::BehavioredClassifier> (container);
						return this->createStateMachine_as_ownedBehavior_in_BehavioredClassifier(castedContainer,metaElementID);
					}
					//StateMachine has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createStateMachine_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//StateMachine has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createStateMachine_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//StateMachine has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createStateMachine_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//StateMachine has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createStateMachine_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//StateMachine has ownedType as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDTYPE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createStateMachine_as_ownedType_in_Package(castedContainer,metaElementID);
					}
					//StateMachine has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createStateMachine_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//StateMachine has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createStateMachine_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//StateMachine has realizingClassifier as a containment
					case  uml::umlPackage::COMPONENTREALIZATION_ATTRIBUTE_REALIZINGCLASSIFIER:	
					{
						std::shared_ptr<ComponentRealization> castedContainer = std::dynamic_pointer_cast<ComponentRealization> (container);;
						return this->createStateMachine_as_realizingClassifier_in_ComponentRealization(castedContainer,metaElementID);
					}
					//StateMachine has redefinedBehavior as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_REDEFINEDBEHAVIOR:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createStateMachine_as_redefinedBehavior_in_Behavior(castedContainer,metaElementID);
					}
					//StateMachine has redefinedClassifier as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REDEFINEDCLASSIFIER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createStateMachine_as_redefinedClassifier_in_Classifier(castedContainer,metaElementID);
					}
					//StateMachine has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createStateMachine_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//StateMachine has stateMachine as a containment
					//StateMachine has stateMachine as a containment
					//StateMachine has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createStateMachine_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//StateMachine has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createStateMachine_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//StateMachine has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createStateMachine_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::STEREOTYPE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createStereotype(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Stereotype has classifier as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_CLASSIFIER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createStereotype_as_classifier_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//Stereotype has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createStereotype_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Stereotype has context as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_CONTEXT:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createStereotype_as_context_in_Behavior(castedContainer,metaElementID);
					}
					//Stereotype has contract as a containment
					case  uml::umlPackage::SUBSTITUTION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<Substitution> castedContainer = std::dynamic_pointer_cast<Substitution> (container);;
						return this->createStereotype_as_contract_in_Substitution(castedContainer,metaElementID);
					}
					//Stereotype has endType as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_ENDTYPE:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createStereotype_as_endType_in_Association(castedContainer,metaElementID);
					}
					//Stereotype has general as a containment
					case  uml::umlPackage::GENERALIZATION_ATTRIBUTE_GENERAL:	
					{
						std::shared_ptr<Generalization> castedContainer = std::dynamic_pointer_cast<Generalization> (container);;
						return this->createStereotype_as_general_in_Generalization(castedContainer,metaElementID);
					}
					//Stereotype has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createStereotype_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Stereotype has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createStereotype_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Stereotype has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createStereotype_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Stereotype has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createStereotype_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Stereotype has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createStereotype_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Stereotype has nestedClassifier as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createStereotype_as_nestedClassifier_in_Class(castedContainer,metaElementID);
					}
					//Stereotype has nestedClassifier as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createStereotype_as_nestedClassifier_in_Interface(castedContainer,metaElementID);
					}
					//Stereotype has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createStereotype_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Stereotype has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createStereotype_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Stereotype has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createStereotype_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Stereotype has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createStereotype_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Stereotype has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createStereotype_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Stereotype has ownedStereotype as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDSTEREOTYPE:	
					{
						std::shared_ptr<Package> castedContainer = std::dynamic_pointer_cast<Package> (container);;
						return this->createStereotype_as_ownedStereotype_in_Package(castedContainer,metaElementID);
					}
					//Stereotype has ownedType as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDTYPE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createStereotype_as_ownedType_in_Package(castedContainer,metaElementID);
					}
					//Stereotype has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createStereotype_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Stereotype has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createStereotype_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Stereotype has realizingClassifier as a containment
					case  uml::umlPackage::COMPONENTREALIZATION_ATTRIBUTE_REALIZINGCLASSIFIER:	
					{
						std::shared_ptr<ComponentRealization> castedContainer = std::dynamic_pointer_cast<ComponentRealization> (container);;
						return this->createStereotype_as_realizingClassifier_in_ComponentRealization(castedContainer,metaElementID);
					}
					//Stereotype has redefinedClassifier as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REDEFINEDCLASSIFIER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createStereotype_as_redefinedClassifier_in_Classifier(castedContainer,metaElementID);
					}
					//Stereotype has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createStereotype_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Stereotype has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createStereotype_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Stereotype has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createStereotype_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Stereotype has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createStereotype_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::STRINGEXPRESSION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createStringExpression(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//StringExpression has argument as a containment
					case  uml::umlPackage::MESSAGE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<Message> castedContainer = std::dynamic_pointer_cast<Message> (container);;
						return this->createStringExpression_as_argument_in_Message(castedContainer,metaElementID);
					}
					//StringExpression has argument as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createStringExpression_as_argument_in_InteractionUse(castedContainer,metaElementID);
					}
					//StringExpression has changeExpression as a containment
					case  uml::umlPackage::CHANGEEVENT_ATTRIBUTE_CHANGEEXPRESSION:	
					{
						std::shared_ptr<ChangeEvent> castedContainer = std::dynamic_pointer_cast<ChangeEvent> (container);;
						return this->createStringExpression_as_changeExpression_in_ChangeEvent(castedContainer,metaElementID);
					}
					//StringExpression has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createStringExpression_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//StringExpression has defaultValue as a containment
					case  uml::umlPackage::PROPERTY_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Property> castedContainer = std::dynamic_pointer_cast<Property> (container);;
						return this->createStringExpression_as_defaultValue_in_Property(castedContainer,metaElementID);
					}
					//StringExpression has defaultValue as a containment
					case  uml::umlPackage::PARAMETER_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Parameter> castedContainer = std::dynamic_pointer_cast<Parameter> (container);;
						return this->createStringExpression_as_defaultValue_in_Parameter(castedContainer,metaElementID);
					}
					//StringExpression has expr as a containment
					case  uml::umlPackage::TIMEEXPRESSION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<TimeExpression> castedContainer = std::dynamic_pointer_cast<TimeExpression> (container);;
						return this->createStringExpression_as_expr_in_TimeExpression(castedContainer,metaElementID);
					}
					//StringExpression has expr as a containment
					case  uml::umlPackage::DURATION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<Duration> castedContainer = std::dynamic_pointer_cast<Duration> (container);;
						return this->createStringExpression_as_expr_in_Duration(castedContainer,metaElementID);
					}
					//StringExpression has guard as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_GUARD:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createStringExpression_as_guard_in_ActivityEdge(castedContainer,metaElementID);
					}
					//StringExpression has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createStringExpression_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//StringExpression has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createStringExpression_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//StringExpression has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createStringExpression_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//StringExpression has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createStringExpression_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//StringExpression has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createStringExpression_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//StringExpression has joinSpec as a containment
					case  uml::umlPackage::JOINNODE_ATTRIBUTE_JOINSPEC:	
					{
						std::shared_ptr<JoinNode> castedContainer = std::dynamic_pointer_cast<JoinNode> (container);;
						return this->createStringExpression_as_joinSpec_in_JoinNode(castedContainer,metaElementID);
					}
					//StringExpression has lowerValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_LOWERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createStringExpression_as_lowerValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//StringExpression has maxint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MAXINT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createStringExpression_as_maxint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//StringExpression has minint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MININT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createStringExpression_as_minint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//StringExpression has nameExpression as a containment
					case  uml::umlPackage::NAMEDELEMENT_ATTRIBUTE_NAMEEXPRESSION:	
					{
						std::shared_ptr<NamedElement> castedContainer = std::dynamic_pointer_cast<NamedElement> (container);;
						return this->createStringExpression_as_nameExpression_in_NamedElement(castedContainer,metaElementID);
					}
					//StringExpression has operand as a containment
					case  uml::umlPackage::EXPRESSION_ATTRIBUTE_OPERAND:	
					{
						std::shared_ptr<Expression> castedContainer = std::dynamic_pointer_cast<Expression> (container);;
						return this->createStringExpression_as_operand_in_Expression(castedContainer,metaElementID);
					}
					//StringExpression has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createStringExpression_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//StringExpression has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createStringExpression_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//StringExpression has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createStringExpression_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//StringExpression has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createStringExpression_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//StringExpression has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createStringExpression_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//StringExpression has owningExpression as a containment
					//StringExpression has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createStringExpression_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//StringExpression has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createStringExpression_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//StringExpression has returnValue as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_RETURNVALUE:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createStringExpression_as_returnValue_in_InteractionUse(castedContainer,metaElementID);
					}
					//StringExpression has selector as a containment
					case  uml::umlPackage::LIFELINE_ATTRIBUTE_SELECTOR:	
					{
						std::shared_ptr<Lifeline> castedContainer = std::dynamic_pointer_cast<Lifeline> (container);;
						return this->createStringExpression_as_selector_in_Lifeline(castedContainer,metaElementID);
					}
					//StringExpression has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createStringExpression_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//StringExpression has specification as a containment
					case  uml::umlPackage::CONSTRAINT_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<Constraint> castedContainer = std::dynamic_pointer_cast<Constraint> (container);;
						return this->createStringExpression_as_specification_in_Constraint(castedContainer,metaElementID);
					}
					//StringExpression has specification as a containment
					case  uml::umlPackage::INSTANCESPECIFICATION_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<InstanceSpecification> castedContainer = std::dynamic_pointer_cast<InstanceSpecification> (container);;
						return this->createStringExpression_as_specification_in_InstanceSpecification(castedContainer,metaElementID);
					}
					//StringExpression has subExpression as a containment
					case  uml::umlPackage::STRINGEXPRESSION_ATTRIBUTE_SUBEXPRESSION:	
					{
						std::weak_ptr<uml::StringExpression> castedContainer = std::dynamic_pointer_cast<uml::StringExpression> (container);
						return this->createStringExpression_as_subExpression_in_StringExpression(castedContainer,metaElementID);
					}
					//StringExpression has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createStringExpression_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//StringExpression has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createStringExpression_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//StringExpression has upperBound as a containment
					case  uml::umlPackage::OBJECTNODE_ATTRIBUTE_UPPERBOUND:	
					{
						std::shared_ptr<ObjectNode> castedContainer = std::dynamic_pointer_cast<ObjectNode> (container);;
						return this->createStringExpression_as_upperBound_in_ObjectNode(castedContainer,metaElementID);
					}
					//StringExpression has upperValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_UPPERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createStringExpression_as_upperValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//StringExpression has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createStringExpression_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					//StringExpression has value as a containment
					case  uml::umlPackage::SLOT_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::Slot> castedContainer = std::dynamic_pointer_cast<uml::Slot> (container);
						return this->createStringExpression_as_value_in_Slot(castedContainer,metaElementID);
					}
					//StringExpression has value as a containment
					case  uml::umlPackage::VALUESPECIFICATIONACTION_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::ValueSpecificationAction> castedContainer = std::dynamic_pointer_cast<uml::ValueSpecificationAction> (container);
						return this->createStringExpression_as_value_in_ValueSpecificationAction(castedContainer,metaElementID);
					}
					//StringExpression has value as a containment
					case  uml::umlPackage::VALUEPIN_ATTRIBUTE_VALUE:	
					{
						std::shared_ptr<ValuePin> castedContainer = std::dynamic_pointer_cast<ValuePin> (container);;
						return this->createStringExpression_as_value_in_ValuePin(castedContainer,metaElementID);
					}
					//StringExpression has weight as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_WEIGHT:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createStringExpression_as_weight_in_ActivityEdge(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::STRUCTUREDACTIVITYNODE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createStructuredActivityNode(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//StructuredActivityNode has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createStructuredActivityNode_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//StructuredActivityNode has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createStructuredActivityNode_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//StructuredActivityNode has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createStructuredActivityNode_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//StructuredActivityNode has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createStructuredActivityNode_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//StructuredActivityNode has group as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_GROUP:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createStructuredActivityNode_as_group_in_Activity(castedContainer,metaElementID);
					}
					//StructuredActivityNode has inStructuredNode as a containment
					//StructuredActivityNode has inStructuredNode as a containment
					//StructuredActivityNode has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createStructuredActivityNode_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//StructuredActivityNode has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createStructuredActivityNode_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//StructuredActivityNode has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createStructuredActivityNode_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//StructuredActivityNode has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createStructuredActivityNode_as_node_in_Activity(castedContainer,metaElementID);
					}
					//StructuredActivityNode has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createStructuredActivityNode_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//StructuredActivityNode has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createStructuredActivityNode_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//StructuredActivityNode has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createStructuredActivityNode_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//StructuredActivityNode has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createStructuredActivityNode_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//StructuredActivityNode has ownedGroup as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDGROUP:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createStructuredActivityNode_as_ownedGroup_in_Activity(castedContainer,metaElementID);
					}
					//StructuredActivityNode has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createStructuredActivityNode_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//StructuredActivityNode has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createStructuredActivityNode_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//StructuredActivityNode has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createStructuredActivityNode_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//StructuredActivityNode has scope as a containment
					//StructuredActivityNode has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createStructuredActivityNode_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//StructuredActivityNode has structuredNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_STRUCTUREDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createStructuredActivityNode_as_structuredNode_in_Activity(castedContainer,metaElementID);
					}
					//StructuredActivityNode has subgroup as a containment
					case  uml::umlPackage::ACTIVITYGROUP_ATTRIBUTE_SUBGROUP:	
					{
						std::weak_ptr<uml::ActivityGroup> castedContainer = std::dynamic_pointer_cast<uml::ActivityGroup> (container);
						return this->createStructuredActivityNode_as_subgroup_in_ActivityGroup(castedContainer,metaElementID);
					}
					//StructuredActivityNode has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createStructuredActivityNode_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//StructuredActivityNode has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createStructuredActivityNode_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::SUBSTITUTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createSubstitution(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Substitution has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createSubstitution_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Substitution has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createSubstitution_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Substitution has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createSubstitution_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Substitution has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createSubstitution_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Substitution has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createSubstitution_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Substitution has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createSubstitution_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Substitution has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createSubstitution_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Substitution has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createSubstitution_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Substitution has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createSubstitution_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Substitution has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createSubstitution_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Substitution has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createSubstitution_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Substitution has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createSubstitution_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Substitution has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createSubstitution_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Substitution has roleBinding as a containment
					case  uml::umlPackage::COLLABORATIONUSE_ATTRIBUTE_ROLEBINDING:	
					{
						std::shared_ptr<CollaborationUse> castedContainer = std::dynamic_pointer_cast<CollaborationUse> (container);;
						return this->createSubstitution_as_roleBinding_in_CollaborationUse(castedContainer,metaElementID);
					}
					//Substitution has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createSubstitution_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Substitution has substitution as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_SUBSTITUTION:	
					{
						std::weak_ptr<uml::Classifier> castedContainer = std::dynamic_pointer_cast<uml::Classifier> (container);
						return this->createSubstitution_as_substitution_in_Classifier(castedContainer,metaElementID);
					}
					//Substitution has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createSubstitution_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Substitution has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createSubstitution_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Substitution has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createSubstitution_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::TEMPLATEBINDING_CLASS:
		{
			if (nullptr == container)
			{
				return this->createTemplateBinding(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//TemplateBinding has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createTemplateBinding_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//TemplateBinding has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createTemplateBinding_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//TemplateBinding has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createTemplateBinding_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//TemplateBinding has templateBinding as a containment
					case  uml::umlPackage::TEMPLATEABLEELEMENT_ATTRIBUTE_TEMPLATEBINDING:	
					{
						std::weak_ptr<uml::TemplateableElement> castedContainer = std::dynamic_pointer_cast<uml::TemplateableElement> (container);
						return this->createTemplateBinding_as_templateBinding_in_TemplateableElement(castedContainer,metaElementID);
					}
					//TemplateBinding has templateBinding as a containment
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::TEMPLATEPARAMETER_CLASS:
		{
			if (nullptr == container)
			{
				return this->createTemplateParameter(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//TemplateParameter has inheritedParameter as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_INHERITEDPARAMETER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createTemplateParameter_as_inheritedParameter_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//TemplateParameter has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createTemplateParameter_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//TemplateParameter has ownedParameter as a containment
					case  uml::umlPackage::TEMPLATESIGNATURE_ATTRIBUTE_OWNEDPARAMETER:	
					{
						std::weak_ptr<uml::TemplateSignature> castedContainer = std::dynamic_pointer_cast<uml::TemplateSignature> (container);
						return this->createTemplateParameter_as_ownedParameter_in_TemplateSignature(castedContainer,metaElementID);
					}
					//TemplateParameter has owningTemplateParameter as a containment
					//TemplateParameter has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createTemplateParameter_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//TemplateParameter has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createTemplateParameter_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::TEMPLATEPARAMETERSUBSTITUTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createTemplateParameterSubstitution(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//TemplateParameterSubstitution has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createTemplateParameterSubstitution_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//TemplateParameterSubstitution has parameterSubstitution as a containment
					case  uml::umlPackage::TEMPLATEBINDING_ATTRIBUTE_PARAMETERSUBSTITUTION:	
					{
						std::weak_ptr<uml::TemplateBinding> castedContainer = std::dynamic_pointer_cast<uml::TemplateBinding> (container);
						return this->createTemplateParameterSubstitution_as_parameterSubstitution_in_TemplateBinding(castedContainer,metaElementID);
					}
					//TemplateParameterSubstitution has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createTemplateParameterSubstitution_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//TemplateParameterSubstitution has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createTemplateParameterSubstitution_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::TEMPLATESIGNATURE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createTemplateSignature(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//TemplateSignature has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createTemplateSignature_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//TemplateSignature has ownedTemplateSignature as a containment
					case  uml::umlPackage::TEMPLATEABLEELEMENT_ATTRIBUTE_OWNEDTEMPLATESIGNATURE:	
					{
						std::weak_ptr<uml::TemplateableElement> castedContainer = std::dynamic_pointer_cast<uml::TemplateableElement> (container);
						return this->createTemplateSignature_as_ownedTemplateSignature_in_TemplateableElement(castedContainer,metaElementID);
					}
					//TemplateSignature has signature as a containment
					//TemplateSignature has signature as a containment
					case  uml::umlPackage::TEMPLATEBINDING_ATTRIBUTE_SIGNATURE:	
					{
						std::shared_ptr<TemplateBinding> castedContainer = std::dynamic_pointer_cast<TemplateBinding> (container);;
						return this->createTemplateSignature_as_signature_in_TemplateBinding(castedContainer,metaElementID);
					}
					//TemplateSignature has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createTemplateSignature_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//TemplateSignature has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createTemplateSignature_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::TESTIDENTITYACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createTestIdentityAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//TestIdentityAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createTestIdentityAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//TestIdentityAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createTestIdentityAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//TestIdentityAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createTestIdentityAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//TestIdentityAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createTestIdentityAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//TestIdentityAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createTestIdentityAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//TestIdentityAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createTestIdentityAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//TestIdentityAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createTestIdentityAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//TestIdentityAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createTestIdentityAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//TestIdentityAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createTestIdentityAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//TestIdentityAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createTestIdentityAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//TestIdentityAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createTestIdentityAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//TestIdentityAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createTestIdentityAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//TestIdentityAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createTestIdentityAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//TestIdentityAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createTestIdentityAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//TestIdentityAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createTestIdentityAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//TestIdentityAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createTestIdentityAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//TestIdentityAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createTestIdentityAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//TestIdentityAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createTestIdentityAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::TIMECONSTRAINT_CLASS:
		{
			if (nullptr == container)
			{
				return this->createTimeConstraint(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//TimeConstraint has bodyCondition as a containment
					case  uml::umlPackage::OPERATION_ATTRIBUTE_BODYCONDITION:	
					{
						std::shared_ptr<Operation> castedContainer = std::dynamic_pointer_cast<Operation> (container);;
						return this->createTimeConstraint_as_bodyCondition_in_Operation(castedContainer,metaElementID);
					}
					//TimeConstraint has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createTimeConstraint_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//TimeConstraint has condition as a containment
					case  uml::umlPackage::PARAMETERSET_ATTRIBUTE_CONDITION:	
					{
						std::shared_ptr<ParameterSet> castedContainer = std::dynamic_pointer_cast<ParameterSet> (container);;
						return this->createTimeConstraint_as_condition_in_ParameterSet(castedContainer,metaElementID);
					}
					//TimeConstraint has condition as a containment
					case  uml::umlPackage::EXTEND_ATTRIBUTE_CONDITION:	
					{
						std::shared_ptr<Extend> castedContainer = std::dynamic_pointer_cast<Extend> (container);;
						return this->createTimeConstraint_as_condition_in_Extend(castedContainer,metaElementID);
					}
					//TimeConstraint has guard as a containment
					case  uml::umlPackage::TRANSITION_ATTRIBUTE_GUARD:	
					{
						std::shared_ptr<Transition> castedContainer = std::dynamic_pointer_cast<Transition> (container);;
						return this->createTimeConstraint_as_guard_in_Transition(castedContainer,metaElementID);
					}
					//TimeConstraint has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createTimeConstraint_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//TimeConstraint has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createTimeConstraint_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//TimeConstraint has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createTimeConstraint_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//TimeConstraint has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createTimeConstraint_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//TimeConstraint has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createTimeConstraint_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//TimeConstraint has invariant as a containment
					case  uml::umlPackage::STATEINVARIANT_ATTRIBUTE_INVARIANT:	
					{
						std::shared_ptr<StateInvariant> castedContainer = std::dynamic_pointer_cast<StateInvariant> (container);;
						return this->createTimeConstraint_as_invariant_in_StateInvariant(castedContainer,metaElementID);
					}
					//TimeConstraint has localPostcondition as a containment
					case  uml::umlPackage::ACTION_ATTRIBUTE_LOCALPOSTCONDITION:	
					{
						std::shared_ptr<Action> castedContainer = std::dynamic_pointer_cast<Action> (container);;
						return this->createTimeConstraint_as_localPostcondition_in_Action(castedContainer,metaElementID);
					}
					//TimeConstraint has localPrecondition as a containment
					case  uml::umlPackage::ACTION_ATTRIBUTE_LOCALPRECONDITION:	
					{
						std::shared_ptr<Action> castedContainer = std::dynamic_pointer_cast<Action> (container);;
						return this->createTimeConstraint_as_localPrecondition_in_Action(castedContainer,metaElementID);
					}
					//TimeConstraint has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createTimeConstraint_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//TimeConstraint has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createTimeConstraint_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//TimeConstraint has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createTimeConstraint_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//TimeConstraint has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createTimeConstraint_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//TimeConstraint has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createTimeConstraint_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//TimeConstraint has ownedRule as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDRULE:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createTimeConstraint_as_ownedRule_in_Namespace(castedContainer,metaElementID);
					}
					//TimeConstraint has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createTimeConstraint_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//TimeConstraint has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createTimeConstraint_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//TimeConstraint has postCondition as a containment
					case  uml::umlPackage::PROTOCOLTRANSITION_ATTRIBUTE_POSTCONDITION:	
					{
						std::shared_ptr<ProtocolTransition> castedContainer = std::dynamic_pointer_cast<ProtocolTransition> (container);;
						return this->createTimeConstraint_as_postCondition_in_ProtocolTransition(castedContainer,metaElementID);
					}
					//TimeConstraint has postcondition as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_POSTCONDITION:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createTimeConstraint_as_postcondition_in_Behavior(castedContainer,metaElementID);
					}
					//TimeConstraint has postcondition as a containment
					case  uml::umlPackage::OPERATION_ATTRIBUTE_POSTCONDITION:	
					{
						std::shared_ptr<Operation> castedContainer = std::dynamic_pointer_cast<Operation> (container);;
						return this->createTimeConstraint_as_postcondition_in_Operation(castedContainer,metaElementID);
					}
					//TimeConstraint has preCondition as a containment
					case  uml::umlPackage::PROTOCOLTRANSITION_ATTRIBUTE_PRECONDITION:	
					{
						std::shared_ptr<ProtocolTransition> castedContainer = std::dynamic_pointer_cast<ProtocolTransition> (container);;
						return this->createTimeConstraint_as_preCondition_in_ProtocolTransition(castedContainer,metaElementID);
					}
					//TimeConstraint has precondition as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_PRECONDITION:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createTimeConstraint_as_precondition_in_Behavior(castedContainer,metaElementID);
					}
					//TimeConstraint has precondition as a containment
					case  uml::umlPackage::OPERATION_ATTRIBUTE_PRECONDITION:	
					{
						std::shared_ptr<Operation> castedContainer = std::dynamic_pointer_cast<Operation> (container);;
						return this->createTimeConstraint_as_precondition_in_Operation(castedContainer,metaElementID);
					}
					//TimeConstraint has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createTimeConstraint_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//TimeConstraint has stateInvariant as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_STATEINVARIANT:	
					{
						std::shared_ptr<State> castedContainer = std::dynamic_pointer_cast<State> (container);;
						return this->createTimeConstraint_as_stateInvariant_in_State(castedContainer,metaElementID);
					}
					//TimeConstraint has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createTimeConstraint_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//TimeConstraint has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createTimeConstraint_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//TimeConstraint has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createTimeConstraint_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::TIMEEVENT_CLASS:
		{
			if (nullptr == container)
			{
				return this->createTimeEvent(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//TimeEvent has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createTimeEvent_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//TimeEvent has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createTimeEvent_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//TimeEvent has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createTimeEvent_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//TimeEvent has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createTimeEvent_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//TimeEvent has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createTimeEvent_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//TimeEvent has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createTimeEvent_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//TimeEvent has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createTimeEvent_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//TimeEvent has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createTimeEvent_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//TimeEvent has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createTimeEvent_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//TimeEvent has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createTimeEvent_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//TimeEvent has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createTimeEvent_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//TimeEvent has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createTimeEvent_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//TimeEvent has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createTimeEvent_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//TimeEvent has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createTimeEvent_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//TimeEvent has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createTimeEvent_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//TimeEvent has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createTimeEvent_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//TimeEvent has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createTimeEvent_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::TIMEEXPRESSION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createTimeExpression(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//TimeExpression has argument as a containment
					case  uml::umlPackage::MESSAGE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<Message> castedContainer = std::dynamic_pointer_cast<Message> (container);;
						return this->createTimeExpression_as_argument_in_Message(castedContainer,metaElementID);
					}
					//TimeExpression has argument as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createTimeExpression_as_argument_in_InteractionUse(castedContainer,metaElementID);
					}
					//TimeExpression has changeExpression as a containment
					case  uml::umlPackage::CHANGEEVENT_ATTRIBUTE_CHANGEEXPRESSION:	
					{
						std::shared_ptr<ChangeEvent> castedContainer = std::dynamic_pointer_cast<ChangeEvent> (container);;
						return this->createTimeExpression_as_changeExpression_in_ChangeEvent(castedContainer,metaElementID);
					}
					//TimeExpression has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createTimeExpression_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//TimeExpression has defaultValue as a containment
					case  uml::umlPackage::PROPERTY_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Property> castedContainer = std::dynamic_pointer_cast<Property> (container);;
						return this->createTimeExpression_as_defaultValue_in_Property(castedContainer,metaElementID);
					}
					//TimeExpression has defaultValue as a containment
					case  uml::umlPackage::PARAMETER_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Parameter> castedContainer = std::dynamic_pointer_cast<Parameter> (container);;
						return this->createTimeExpression_as_defaultValue_in_Parameter(castedContainer,metaElementID);
					}
					//TimeExpression has expr as a containment
					case  uml::umlPackage::TIMEEXPRESSION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<TimeExpression> castedContainer = std::dynamic_pointer_cast<TimeExpression> (container);;
						return this->createTimeExpression_as_expr_in_TimeExpression(castedContainer,metaElementID);
					}
					//TimeExpression has expr as a containment
					case  uml::umlPackage::DURATION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<Duration> castedContainer = std::dynamic_pointer_cast<Duration> (container);;
						return this->createTimeExpression_as_expr_in_Duration(castedContainer,metaElementID);
					}
					//TimeExpression has guard as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_GUARD:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createTimeExpression_as_guard_in_ActivityEdge(castedContainer,metaElementID);
					}
					//TimeExpression has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createTimeExpression_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//TimeExpression has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createTimeExpression_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//TimeExpression has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createTimeExpression_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//TimeExpression has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createTimeExpression_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//TimeExpression has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createTimeExpression_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//TimeExpression has joinSpec as a containment
					case  uml::umlPackage::JOINNODE_ATTRIBUTE_JOINSPEC:	
					{
						std::shared_ptr<JoinNode> castedContainer = std::dynamic_pointer_cast<JoinNode> (container);;
						return this->createTimeExpression_as_joinSpec_in_JoinNode(castedContainer,metaElementID);
					}
					//TimeExpression has lowerValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_LOWERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createTimeExpression_as_lowerValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//TimeExpression has maxint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MAXINT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createTimeExpression_as_maxint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//TimeExpression has minint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MININT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createTimeExpression_as_minint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//TimeExpression has operand as a containment
					case  uml::umlPackage::EXPRESSION_ATTRIBUTE_OPERAND:	
					{
						std::shared_ptr<Expression> castedContainer = std::dynamic_pointer_cast<Expression> (container);;
						return this->createTimeExpression_as_operand_in_Expression(castedContainer,metaElementID);
					}
					//TimeExpression has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createTimeExpression_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//TimeExpression has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createTimeExpression_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//TimeExpression has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createTimeExpression_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//TimeExpression has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createTimeExpression_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//TimeExpression has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createTimeExpression_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//TimeExpression has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createTimeExpression_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//TimeExpression has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createTimeExpression_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//TimeExpression has returnValue as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_RETURNVALUE:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createTimeExpression_as_returnValue_in_InteractionUse(castedContainer,metaElementID);
					}
					//TimeExpression has selector as a containment
					case  uml::umlPackage::LIFELINE_ATTRIBUTE_SELECTOR:	
					{
						std::shared_ptr<Lifeline> castedContainer = std::dynamic_pointer_cast<Lifeline> (container);;
						return this->createTimeExpression_as_selector_in_Lifeline(castedContainer,metaElementID);
					}
					//TimeExpression has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createTimeExpression_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//TimeExpression has specification as a containment
					case  uml::umlPackage::CONSTRAINT_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<Constraint> castedContainer = std::dynamic_pointer_cast<Constraint> (container);;
						return this->createTimeExpression_as_specification_in_Constraint(castedContainer,metaElementID);
					}
					//TimeExpression has specification as a containment
					case  uml::umlPackage::INSTANCESPECIFICATION_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<InstanceSpecification> castedContainer = std::dynamic_pointer_cast<InstanceSpecification> (container);;
						return this->createTimeExpression_as_specification_in_InstanceSpecification(castedContainer,metaElementID);
					}
					//TimeExpression has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createTimeExpression_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//TimeExpression has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createTimeExpression_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//TimeExpression has upperBound as a containment
					case  uml::umlPackage::OBJECTNODE_ATTRIBUTE_UPPERBOUND:	
					{
						std::shared_ptr<ObjectNode> castedContainer = std::dynamic_pointer_cast<ObjectNode> (container);;
						return this->createTimeExpression_as_upperBound_in_ObjectNode(castedContainer,metaElementID);
					}
					//TimeExpression has upperValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_UPPERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createTimeExpression_as_upperValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//TimeExpression has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createTimeExpression_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					//TimeExpression has value as a containment
					case  uml::umlPackage::SLOT_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::Slot> castedContainer = std::dynamic_pointer_cast<uml::Slot> (container);
						return this->createTimeExpression_as_value_in_Slot(castedContainer,metaElementID);
					}
					//TimeExpression has value as a containment
					case  uml::umlPackage::VALUESPECIFICATIONACTION_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::ValueSpecificationAction> castedContainer = std::dynamic_pointer_cast<uml::ValueSpecificationAction> (container);
						return this->createTimeExpression_as_value_in_ValueSpecificationAction(castedContainer,metaElementID);
					}
					//TimeExpression has value as a containment
					case  uml::umlPackage::VALUEPIN_ATTRIBUTE_VALUE:	
					{
						std::shared_ptr<ValuePin> castedContainer = std::dynamic_pointer_cast<ValuePin> (container);;
						return this->createTimeExpression_as_value_in_ValuePin(castedContainer,metaElementID);
					}
					//TimeExpression has weight as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_WEIGHT:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createTimeExpression_as_weight_in_ActivityEdge(castedContainer,metaElementID);
					}
					//TimeExpression has when as a containment
					case  uml::umlPackage::TIMEEVENT_ATTRIBUTE_WHEN:	
					{
						std::shared_ptr<TimeEvent> castedContainer = std::dynamic_pointer_cast<TimeEvent> (container);;
						return this->createTimeExpression_as_when_in_TimeEvent(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::TIMEINTERVAL_CLASS:
		{
			if (nullptr == container)
			{
				return this->createTimeInterval(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//TimeInterval has argument as a containment
					case  uml::umlPackage::MESSAGE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<Message> castedContainer = std::dynamic_pointer_cast<Message> (container);;
						return this->createTimeInterval_as_argument_in_Message(castedContainer,metaElementID);
					}
					//TimeInterval has argument as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_ARGUMENT:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createTimeInterval_as_argument_in_InteractionUse(castedContainer,metaElementID);
					}
					//TimeInterval has changeExpression as a containment
					case  uml::umlPackage::CHANGEEVENT_ATTRIBUTE_CHANGEEXPRESSION:	
					{
						std::shared_ptr<ChangeEvent> castedContainer = std::dynamic_pointer_cast<ChangeEvent> (container);;
						return this->createTimeInterval_as_changeExpression_in_ChangeEvent(castedContainer,metaElementID);
					}
					//TimeInterval has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createTimeInterval_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//TimeInterval has defaultValue as a containment
					case  uml::umlPackage::PROPERTY_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Property> castedContainer = std::dynamic_pointer_cast<Property> (container);;
						return this->createTimeInterval_as_defaultValue_in_Property(castedContainer,metaElementID);
					}
					//TimeInterval has defaultValue as a containment
					case  uml::umlPackage::PARAMETER_ATTRIBUTE_DEFAULTVALUE:	
					{
						std::shared_ptr<Parameter> castedContainer = std::dynamic_pointer_cast<Parameter> (container);;
						return this->createTimeInterval_as_defaultValue_in_Parameter(castedContainer,metaElementID);
					}
					//TimeInterval has expr as a containment
					case  uml::umlPackage::TIMEEXPRESSION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<TimeExpression> castedContainer = std::dynamic_pointer_cast<TimeExpression> (container);;
						return this->createTimeInterval_as_expr_in_TimeExpression(castedContainer,metaElementID);
					}
					//TimeInterval has expr as a containment
					case  uml::umlPackage::DURATION_ATTRIBUTE_EXPR:	
					{
						std::shared_ptr<Duration> castedContainer = std::dynamic_pointer_cast<Duration> (container);;
						return this->createTimeInterval_as_expr_in_Duration(castedContainer,metaElementID);
					}
					//TimeInterval has guard as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_GUARD:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createTimeInterval_as_guard_in_ActivityEdge(castedContainer,metaElementID);
					}
					//TimeInterval has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createTimeInterval_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//TimeInterval has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createTimeInterval_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//TimeInterval has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createTimeInterval_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//TimeInterval has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createTimeInterval_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//TimeInterval has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createTimeInterval_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//TimeInterval has joinSpec as a containment
					case  uml::umlPackage::JOINNODE_ATTRIBUTE_JOINSPEC:	
					{
						std::shared_ptr<JoinNode> castedContainer = std::dynamic_pointer_cast<JoinNode> (container);;
						return this->createTimeInterval_as_joinSpec_in_JoinNode(castedContainer,metaElementID);
					}
					//TimeInterval has lowerValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_LOWERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createTimeInterval_as_lowerValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//TimeInterval has maxint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MAXINT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createTimeInterval_as_maxint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//TimeInterval has minint as a containment
					case  uml::umlPackage::INTERACTIONCONSTRAINT_ATTRIBUTE_MININT:	
					{
						std::shared_ptr<InteractionConstraint> castedContainer = std::dynamic_pointer_cast<InteractionConstraint> (container);;
						return this->createTimeInterval_as_minint_in_InteractionConstraint(castedContainer,metaElementID);
					}
					//TimeInterval has operand as a containment
					case  uml::umlPackage::EXPRESSION_ATTRIBUTE_OPERAND:	
					{
						std::shared_ptr<Expression> castedContainer = std::dynamic_pointer_cast<Expression> (container);;
						return this->createTimeInterval_as_operand_in_Expression(castedContainer,metaElementID);
					}
					//TimeInterval has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createTimeInterval_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//TimeInterval has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createTimeInterval_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//TimeInterval has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createTimeInterval_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//TimeInterval has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createTimeInterval_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//TimeInterval has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createTimeInterval_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//TimeInterval has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createTimeInterval_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//TimeInterval has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createTimeInterval_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//TimeInterval has returnValue as a containment
					case  uml::umlPackage::INTERACTIONUSE_ATTRIBUTE_RETURNVALUE:	
					{
						std::shared_ptr<InteractionUse> castedContainer = std::dynamic_pointer_cast<InteractionUse> (container);;
						return this->createTimeInterval_as_returnValue_in_InteractionUse(castedContainer,metaElementID);
					}
					//TimeInterval has selector as a containment
					case  uml::umlPackage::LIFELINE_ATTRIBUTE_SELECTOR:	
					{
						std::shared_ptr<Lifeline> castedContainer = std::dynamic_pointer_cast<Lifeline> (container);;
						return this->createTimeInterval_as_selector_in_Lifeline(castedContainer,metaElementID);
					}
					//TimeInterval has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createTimeInterval_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//TimeInterval has specification as a containment
					case  uml::umlPackage::CONSTRAINT_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<Constraint> castedContainer = std::dynamic_pointer_cast<Constraint> (container);;
						return this->createTimeInterval_as_specification_in_Constraint(castedContainer,metaElementID);
					}
					//TimeInterval has specification as a containment
					case  uml::umlPackage::INSTANCESPECIFICATION_ATTRIBUTE_SPECIFICATION:	
					{
						std::shared_ptr<InstanceSpecification> castedContainer = std::dynamic_pointer_cast<InstanceSpecification> (container);;
						return this->createTimeInterval_as_specification_in_InstanceSpecification(castedContainer,metaElementID);
					}
					//TimeInterval has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createTimeInterval_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//TimeInterval has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createTimeInterval_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//TimeInterval has upperBound as a containment
					case  uml::umlPackage::OBJECTNODE_ATTRIBUTE_UPPERBOUND:	
					{
						std::shared_ptr<ObjectNode> castedContainer = std::dynamic_pointer_cast<ObjectNode> (container);;
						return this->createTimeInterval_as_upperBound_in_ObjectNode(castedContainer,metaElementID);
					}
					//TimeInterval has upperValue as a containment
					case  uml::umlPackage::MULTIPLICITYELEMENT_ATTRIBUTE_UPPERVALUE:	
					{
						std::shared_ptr<MultiplicityElement> castedContainer = std::dynamic_pointer_cast<MultiplicityElement> (container);;
						return this->createTimeInterval_as_upperValue_in_MultiplicityElement(castedContainer,metaElementID);
					}
					//TimeInterval has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createTimeInterval_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					//TimeInterval has value as a containment
					case  uml::umlPackage::SLOT_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::Slot> castedContainer = std::dynamic_pointer_cast<uml::Slot> (container);
						return this->createTimeInterval_as_value_in_Slot(castedContainer,metaElementID);
					}
					//TimeInterval has value as a containment
					case  uml::umlPackage::VALUESPECIFICATIONACTION_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::ValueSpecificationAction> castedContainer = std::dynamic_pointer_cast<uml::ValueSpecificationAction> (container);
						return this->createTimeInterval_as_value_in_ValueSpecificationAction(castedContainer,metaElementID);
					}
					//TimeInterval has value as a containment
					case  uml::umlPackage::VALUEPIN_ATTRIBUTE_VALUE:	
					{
						std::shared_ptr<ValuePin> castedContainer = std::dynamic_pointer_cast<ValuePin> (container);;
						return this->createTimeInterval_as_value_in_ValuePin(castedContainer,metaElementID);
					}
					//TimeInterval has weight as a containment
					case  uml::umlPackage::ACTIVITYEDGE_ATTRIBUTE_WEIGHT:	
					{
						std::shared_ptr<ActivityEdge> castedContainer = std::dynamic_pointer_cast<ActivityEdge> (container);;
						return this->createTimeInterval_as_weight_in_ActivityEdge(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::TIMEOBSERVATION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createTimeObservation(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//TimeObservation has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createTimeObservation_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//TimeObservation has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createTimeObservation_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//TimeObservation has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createTimeObservation_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//TimeObservation has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createTimeObservation_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//TimeObservation has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createTimeObservation_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//TimeObservation has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createTimeObservation_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//TimeObservation has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createTimeObservation_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//TimeObservation has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createTimeObservation_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//TimeObservation has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createTimeObservation_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//TimeObservation has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createTimeObservation_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//TimeObservation has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createTimeObservation_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//TimeObservation has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createTimeObservation_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//TimeObservation has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createTimeObservation_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//TimeObservation has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createTimeObservation_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//TimeObservation has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createTimeObservation_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//TimeObservation has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createTimeObservation_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//TimeObservation has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createTimeObservation_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::TRANSITION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createTransition(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Transition has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createTransition_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Transition has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createTransition_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Transition has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createTransition_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Transition has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createTransition_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Transition has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createTransition_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Transition has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createTransition_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Transition has redefinedTransition as a containment
					case  uml::umlPackage::TRANSITION_ATTRIBUTE_REDEFINEDTRANSITION:	
					{
						std::shared_ptr<Transition> castedContainer = std::dynamic_pointer_cast<Transition> (container);;
						return this->createTransition_as_redefinedTransition_in_Transition(castedContainer,metaElementID);
					}
					//Transition has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createTransition_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Transition has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createTransition_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Transition has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createTransition_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Transition has transition as a containment
					case  uml::umlPackage::REGION_ATTRIBUTE_TRANSITION:	
					{
						std::weak_ptr<uml::Region> castedContainer = std::dynamic_pointer_cast<uml::Region> (container);
						return this->createTransition_as_transition_in_Region(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::TRIGGER_CLASS:
		{
			if (nullptr == container)
			{
				return this->createTrigger(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Trigger has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createTrigger_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Trigger has deferrableTrigger as a containment
					case  uml::umlPackage::STATE_ATTRIBUTE_DEFERRABLETRIGGER:	
					{
						std::shared_ptr<State> castedContainer = std::dynamic_pointer_cast<State> (container);;
						return this->createTrigger_as_deferrableTrigger_in_State(castedContainer,metaElementID);
					}
					//Trigger has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createTrigger_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Trigger has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createTrigger_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Trigger has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createTrigger_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Trigger has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createTrigger_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Trigger has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createTrigger_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Trigger has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createTrigger_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Trigger has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createTrigger_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Trigger has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createTrigger_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Trigger has trigger as a containment
					case  uml::umlPackage::TRANSITION_ATTRIBUTE_TRIGGER:	
					{
						std::shared_ptr<Transition> castedContainer = std::dynamic_pointer_cast<Transition> (container);;
						return this->createTrigger_as_trigger_in_Transition(castedContainer,metaElementID);
					}
					//Trigger has trigger as a containment
					case  uml::umlPackage::ACCEPTEVENTACTION_ATTRIBUTE_TRIGGER:	
					{
						std::shared_ptr<AcceptEventAction> castedContainer = std::dynamic_pointer_cast<AcceptEventAction> (container);;
						return this->createTrigger_as_trigger_in_AcceptEventAction(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::UNMARSHALLACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createUnmarshallAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//UnmarshallAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createUnmarshallAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//UnmarshallAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createUnmarshallAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//UnmarshallAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createUnmarshallAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//UnmarshallAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createUnmarshallAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//UnmarshallAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createUnmarshallAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//UnmarshallAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createUnmarshallAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//UnmarshallAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createUnmarshallAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//UnmarshallAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createUnmarshallAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//UnmarshallAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createUnmarshallAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//UnmarshallAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createUnmarshallAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//UnmarshallAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createUnmarshallAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//UnmarshallAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createUnmarshallAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//UnmarshallAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createUnmarshallAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//UnmarshallAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createUnmarshallAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//UnmarshallAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createUnmarshallAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//UnmarshallAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createUnmarshallAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//UnmarshallAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createUnmarshallAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//UnmarshallAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createUnmarshallAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::USAGE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createUsage(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Usage has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createUsage_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Usage has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createUsage_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//Usage has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createUsage_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Usage has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createUsage_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Usage has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createUsage_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Usage has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createUsage_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Usage has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createUsage_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Usage has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createUsage_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Usage has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createUsage_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Usage has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createUsage_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Usage has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createUsage_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Usage has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createUsage_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//Usage has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createUsage_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//Usage has roleBinding as a containment
					case  uml::umlPackage::COLLABORATIONUSE_ATTRIBUTE_ROLEBINDING:	
					{
						std::shared_ptr<CollaborationUse> castedContainer = std::dynamic_pointer_cast<CollaborationUse> (container);;
						return this->createUsage_as_roleBinding_in_CollaborationUse(castedContainer,metaElementID);
					}
					//Usage has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createUsage_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Usage has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createUsage_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Usage has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createUsage_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Usage has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createUsage_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::USECASE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createUseCase(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//UseCase has addition as a containment
					case  uml::umlPackage::INCLUDE_ATTRIBUTE_ADDITION:	
					{
						std::shared_ptr<Include> castedContainer = std::dynamic_pointer_cast<Include> (container);;
						return this->createUseCase_as_addition_in_Include(castedContainer,metaElementID);
					}
					//UseCase has classifier as a containment
					case  uml::umlPackage::REDEFINABLETEMPLATESIGNATURE_ATTRIBUTE_CLASSIFIER:	
					{
						std::shared_ptr<RedefinableTemplateSignature> castedContainer = std::dynamic_pointer_cast<RedefinableTemplateSignature> (container);;
						return this->createUseCase_as_classifier_in_RedefinableTemplateSignature(castedContainer,metaElementID);
					}
					//UseCase has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createUseCase_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//UseCase has context as a containment
					case  uml::umlPackage::BEHAVIOR_ATTRIBUTE_CONTEXT:	
					{
						std::shared_ptr<Behavior> castedContainer = std::dynamic_pointer_cast<Behavior> (container);;
						return this->createUseCase_as_context_in_Behavior(castedContainer,metaElementID);
					}
					//UseCase has contract as a containment
					case  uml::umlPackage::SUBSTITUTION_ATTRIBUTE_CONTRACT:	
					{
						std::shared_ptr<Substitution> castedContainer = std::dynamic_pointer_cast<Substitution> (container);;
						return this->createUseCase_as_contract_in_Substitution(castedContainer,metaElementID);
					}
					//UseCase has endType as a containment
					case  uml::umlPackage::ASSOCIATION_ATTRIBUTE_ENDTYPE:	
					{
						std::shared_ptr<Association> castedContainer = std::dynamic_pointer_cast<Association> (container);;
						return this->createUseCase_as_endType_in_Association(castedContainer,metaElementID);
					}
					//UseCase has extendedCase as a containment
					case  uml::umlPackage::EXTEND_ATTRIBUTE_EXTENDEDCASE:	
					{
						std::shared_ptr<Extend> castedContainer = std::dynamic_pointer_cast<Extend> (container);;
						return this->createUseCase_as_extendedCase_in_Extend(castedContainer,metaElementID);
					}
					//UseCase has extension as a containment
					//UseCase has general as a containment
					case  uml::umlPackage::GENERALIZATION_ATTRIBUTE_GENERAL:	
					{
						std::shared_ptr<Generalization> castedContainer = std::dynamic_pointer_cast<Generalization> (container);;
						return this->createUseCase_as_general_in_Generalization(castedContainer,metaElementID);
					}
					//UseCase has importedElement as a containment
					case  uml::umlPackage::ELEMENTIMPORT_ATTRIBUTE_IMPORTEDELEMENT:	
					{
						std::shared_ptr<ElementImport> castedContainer = std::dynamic_pointer_cast<ElementImport> (container);;
						return this->createUseCase_as_importedElement_in_ElementImport(castedContainer,metaElementID);
					}
					//UseCase has importedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_IMPORTEDMEMBER:	
					{
						std::shared_ptr<Namespace> castedContainer = std::dynamic_pointer_cast<Namespace> (container);;
						return this->createUseCase_as_importedMember_in_Namespace(castedContainer,metaElementID);
					}
					//UseCase has includingCase as a containment
					//UseCase has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createUseCase_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//UseCase has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createUseCase_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//UseCase has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createUseCase_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//UseCase has nestedClassifier as a containment
					case  uml::umlPackage::CLASS_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Class> castedContainer = std::dynamic_pointer_cast<Class> (container);;
						return this->createUseCase_as_nestedClassifier_in_Class(castedContainer,metaElementID);
					}
					//UseCase has nestedClassifier as a containment
					case  uml::umlPackage::INTERFACE_ATTRIBUTE_NESTEDCLASSIFIER:	
					{
						std::shared_ptr<Interface> castedContainer = std::dynamic_pointer_cast<Interface> (container);;
						return this->createUseCase_as_nestedClassifier_in_Interface(castedContainer,metaElementID);
					}
					//UseCase has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createUseCase_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//UseCase has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createUseCase_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//UseCase has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createUseCase_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//UseCase has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createUseCase_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//UseCase has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createUseCase_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//UseCase has ownedType as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_OWNEDTYPE:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createUseCase_as_ownedType_in_Package(castedContainer,metaElementID);
					}
					//UseCase has ownedUseCase as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_OWNEDUSECASE:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createUseCase_as_ownedUseCase_in_Classifier(castedContainer,metaElementID);
					}
					//UseCase has packagedElement as a containment
					case  uml::umlPackage::PACKAGE_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::weak_ptr<uml::Package> castedContainer = std::dynamic_pointer_cast<uml::Package> (container);
						return this->createUseCase_as_packagedElement_in_Package(castedContainer,metaElementID);
					}
					//UseCase has packagedElement as a containment
					case  uml::umlPackage::COMPONENT_ATTRIBUTE_PACKAGEDELEMENT:	
					{
						std::shared_ptr<Component> castedContainer = std::dynamic_pointer_cast<Component> (container);;
						return this->createUseCase_as_packagedElement_in_Component(castedContainer,metaElementID);
					}
					//UseCase has realizingClassifier as a containment
					case  uml::umlPackage::COMPONENTREALIZATION_ATTRIBUTE_REALIZINGCLASSIFIER:	
					{
						std::shared_ptr<ComponentRealization> castedContainer = std::dynamic_pointer_cast<ComponentRealization> (container);;
						return this->createUseCase_as_realizingClassifier_in_ComponentRealization(castedContainer,metaElementID);
					}
					//UseCase has redefinedClassifier as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_REDEFINEDCLASSIFIER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createUseCase_as_redefinedClassifier_in_Classifier(castedContainer,metaElementID);
					}
					//UseCase has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createUseCase_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//UseCase has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createUseCase_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//UseCase has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createUseCase_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//UseCase has useCase as a containment
					//UseCase has utilizedElement as a containment
					case  uml::umlPackage::MANIFESTATION_ATTRIBUTE_UTILIZEDELEMENT:	
					{
						std::shared_ptr<Manifestation> castedContainer = std::dynamic_pointer_cast<Manifestation> (container);;
						return this->createUseCase_as_utilizedElement_in_Manifestation(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::VALUEPIN_CLASS:
		{
			if (nullptr == container)
			{
				return this->createValuePin(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ValuePin has argument as a containment
					case  uml::umlPackage::INVOCATIONACTION_ATTRIBUTE_ARGUMENT:	
					{
						std::weak_ptr<uml::InvocationAction> castedContainer = std::dynamic_pointer_cast<uml::InvocationAction> (container);
						return this->createValuePin_as_argument_in_InvocationAction(castedContainer,metaElementID);
					}
					//ValuePin has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createValuePin_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ValuePin has collection as a containment
					case  uml::umlPackage::REDUCEACTION_ATTRIBUTE_COLLECTION:	
					{
						std::shared_ptr<ReduceAction> castedContainer = std::dynamic_pointer_cast<ReduceAction> (container);;
						return this->createValuePin_as_collection_in_ReduceAction(castedContainer,metaElementID);
					}
					//ValuePin has exception as a containment
					case  uml::umlPackage::RAISEEXCEPTIONACTION_ATTRIBUTE_EXCEPTION:	
					{
						std::shared_ptr<RaiseExceptionAction> castedContainer = std::dynamic_pointer_cast<RaiseExceptionAction> (container);;
						return this->createValuePin_as_exception_in_RaiseExceptionAction(castedContainer,metaElementID);
					}
					//ValuePin has first as a containment
					case  uml::umlPackage::TESTIDENTITYACTION_ATTRIBUTE_FIRST:	
					{
						std::shared_ptr<TestIdentityAction> castedContainer = std::dynamic_pointer_cast<TestIdentityAction> (container);;
						return this->createValuePin_as_first_in_TestIdentityAction(castedContainer,metaElementID);
					}
					//ValuePin has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createValuePin_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ValuePin has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createValuePin_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ValuePin has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createValuePin_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ValuePin has input as a containment
					case  uml::umlPackage::ACTION_ATTRIBUTE_INPUT:	
					{
						std::weak_ptr<uml::Action> castedContainer = std::dynamic_pointer_cast<uml::Action> (container);
						return this->createValuePin_as_input_in_Action(castedContainer,metaElementID);
					}
					//ValuePin has inputValue as a containment
					case  uml::umlPackage::LINKACTION_ATTRIBUTE_INPUTVALUE:	
					{
						std::shared_ptr<LinkAction> castedContainer = std::dynamic_pointer_cast<LinkAction> (container);;
						return this->createValuePin_as_inputValue_in_LinkAction(castedContainer,metaElementID);
					}
					//ValuePin has inputValue as a containment
					case  uml::umlPackage::OPAQUEACTION_ATTRIBUTE_INPUTVALUE:	
					{
						std::shared_ptr<OpaqueAction> castedContainer = std::dynamic_pointer_cast<OpaqueAction> (container);;
						return this->createValuePin_as_inputValue_in_OpaqueAction(castedContainer,metaElementID);
					}
					//ValuePin has insertAt as a containment
					case  uml::umlPackage::ADDSTRUCTURALFEATUREVALUEACTION_ATTRIBUTE_INSERTAT:	
					{
						std::weak_ptr<uml::AddStructuralFeatureValueAction> castedContainer = std::dynamic_pointer_cast<uml::AddStructuralFeatureValueAction> (container);
						return this->createValuePin_as_insertAt_in_AddStructuralFeatureValueAction(castedContainer,metaElementID);
					}
					//ValuePin has insertAt as a containment
					case  uml::umlPackage::ADDVARIABLEVALUEACTION_ATTRIBUTE_INSERTAT:	
					{
						std::shared_ptr<AddVariableValueAction> castedContainer = std::dynamic_pointer_cast<AddVariableValueAction> (container);;
						return this->createValuePin_as_insertAt_in_AddVariableValueAction(castedContainer,metaElementID);
					}
					//ValuePin has loopVariableInput as a containment
					case  uml::umlPackage::LOOPNODE_ATTRIBUTE_LOOPVARIABLEINPUT:	
					{
						std::shared_ptr<LoopNode> castedContainer = std::dynamic_pointer_cast<LoopNode> (container);;
						return this->createValuePin_as_loopVariableInput_in_LoopNode(castedContainer,metaElementID);
					}
					//ValuePin has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createValuePin_as_node_in_Activity(castedContainer,metaElementID);
					}
					//ValuePin has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createValuePin_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//ValuePin has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createValuePin_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//ValuePin has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createValuePin_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//ValuePin has object as a containment
					case  uml::umlPackage::STRUCTURALFEATUREACTION_ATTRIBUTE_OBJECT:	
					{
						std::weak_ptr<uml::StructuralFeatureAction> castedContainer = std::dynamic_pointer_cast<uml::StructuralFeatureAction> (container);
						return this->createValuePin_as_object_in_StructuralFeatureAction(castedContainer,metaElementID);
					}
					//ValuePin has object as a containment
					case  uml::umlPackage::CLEARASSOCIATIONACTION_ATTRIBUTE_OBJECT:	
					{
						std::shared_ptr<ClearAssociationAction> castedContainer = std::dynamic_pointer_cast<ClearAssociationAction> (container);;
						return this->createValuePin_as_object_in_ClearAssociationAction(castedContainer,metaElementID);
					}
					//ValuePin has object as a containment
					case  uml::umlPackage::READISCLASSIFIEDOBJECTACTION_ATTRIBUTE_OBJECT:	
					{
						std::shared_ptr<ReadIsClassifiedObjectAction> castedContainer = std::dynamic_pointer_cast<ReadIsClassifiedObjectAction> (container);;
						return this->createValuePin_as_object_in_ReadIsClassifiedObjectAction(castedContainer,metaElementID);
					}
					//ValuePin has object as a containment
					case  uml::umlPackage::READLINKOBJECTENDACTION_ATTRIBUTE_OBJECT:	
					{
						std::shared_ptr<ReadLinkObjectEndAction> castedContainer = std::dynamic_pointer_cast<ReadLinkObjectEndAction> (container);;
						return this->createValuePin_as_object_in_ReadLinkObjectEndAction(castedContainer,metaElementID);
					}
					//ValuePin has object as a containment
					case  uml::umlPackage::READLINKOBJECTENDQUALIFIERACTION_ATTRIBUTE_OBJECT:	
					{
						std::shared_ptr<ReadLinkObjectEndQualifierAction> castedContainer = std::dynamic_pointer_cast<ReadLinkObjectEndQualifierAction> (container);;
						return this->createValuePin_as_object_in_ReadLinkObjectEndQualifierAction(castedContainer,metaElementID);
					}
					//ValuePin has object as a containment
					case  uml::umlPackage::RECLASSIFYOBJECTACTION_ATTRIBUTE_OBJECT:	
					{
						std::shared_ptr<ReclassifyObjectAction> castedContainer = std::dynamic_pointer_cast<ReclassifyObjectAction> (container);;
						return this->createValuePin_as_object_in_ReclassifyObjectAction(castedContainer,metaElementID);
					}
					//ValuePin has object as a containment
					case  uml::umlPackage::STARTCLASSIFIERBEHAVIORACTION_ATTRIBUTE_OBJECT:	
					{
						std::shared_ptr<StartClassifierBehaviorAction> castedContainer = std::dynamic_pointer_cast<StartClassifierBehaviorAction> (container);;
						return this->createValuePin_as_object_in_StartClassifierBehaviorAction(castedContainer,metaElementID);
					}
					//ValuePin has object as a containment
					case  uml::umlPackage::STARTOBJECTBEHAVIORACTION_ATTRIBUTE_OBJECT:	
					{
						std::shared_ptr<StartObjectBehaviorAction> castedContainer = std::dynamic_pointer_cast<StartObjectBehaviorAction> (container);;
						return this->createValuePin_as_object_in_StartObjectBehaviorAction(castedContainer,metaElementID);
					}
					//ValuePin has object as a containment
					case  uml::umlPackage::UNMARSHALLACTION_ATTRIBUTE_OBJECT:	
					{
						std::shared_ptr<UnmarshallAction> castedContainer = std::dynamic_pointer_cast<UnmarshallAction> (container);;
						return this->createValuePin_as_object_in_UnmarshallAction(castedContainer,metaElementID);
					}
					//ValuePin has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createValuePin_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ValuePin has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createValuePin_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ValuePin has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createValuePin_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//ValuePin has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createValuePin_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//ValuePin has removeAt as a containment
					case  uml::umlPackage::REMOVESTRUCTURALFEATUREVALUEACTION_ATTRIBUTE_REMOVEAT:	
					{
						std::weak_ptr<uml::RemoveStructuralFeatureValueAction> castedContainer = std::dynamic_pointer_cast<uml::RemoveStructuralFeatureValueAction> (container);
						return this->createValuePin_as_removeAt_in_RemoveStructuralFeatureValueAction(castedContainer,metaElementID);
					}
					//ValuePin has removeAt as a containment
					case  uml::umlPackage::REMOVEVARIABLEVALUEACTION_ATTRIBUTE_REMOVEAT:	
					{
						std::shared_ptr<RemoveVariableValueAction> castedContainer = std::dynamic_pointer_cast<RemoveVariableValueAction> (container);;
						return this->createValuePin_as_removeAt_in_RemoveVariableValueAction(castedContainer,metaElementID);
					}
					//ValuePin has replyValue as a containment
					case  uml::umlPackage::REPLYACTION_ATTRIBUTE_REPLYVALUE:	
					{
						std::shared_ptr<ReplyAction> castedContainer = std::dynamic_pointer_cast<ReplyAction> (container);;
						return this->createValuePin_as_replyValue_in_ReplyAction(castedContainer,metaElementID);
					}
					//ValuePin has request as a containment
					case  uml::umlPackage::SENDOBJECTACTION_ATTRIBUTE_REQUEST:	
					{
						std::shared_ptr<SendObjectAction> castedContainer = std::dynamic_pointer_cast<SendObjectAction> (container);;
						return this->createValuePin_as_request_in_SendObjectAction(castedContainer,metaElementID);
					}
					//ValuePin has returnInformation as a containment
					case  uml::umlPackage::REPLYACTION_ATTRIBUTE_RETURNINFORMATION:	
					{
						std::shared_ptr<ReplyAction> castedContainer = std::dynamic_pointer_cast<ReplyAction> (container);;
						return this->createValuePin_as_returnInformation_in_ReplyAction(castedContainer,metaElementID);
					}
					//ValuePin has second as a containment
					case  uml::umlPackage::TESTIDENTITYACTION_ATTRIBUTE_SECOND:	
					{
						std::shared_ptr<TestIdentityAction> castedContainer = std::dynamic_pointer_cast<TestIdentityAction> (container);;
						return this->createValuePin_as_second_in_TestIdentityAction(castedContainer,metaElementID);
					}
					//ValuePin has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createValuePin_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ValuePin has structuredNodeInput as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_STRUCTUREDNODEINPUT:	
					{
						std::shared_ptr<StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<StructuredActivityNode> (container);;
						return this->createValuePin_as_structuredNodeInput_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//ValuePin has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createValuePin_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ValuePin has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createValuePin_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ValuePin has target as a containment
					case  uml::umlPackage::CALLOPERATIONACTION_ATTRIBUTE_TARGET:	
					{
						std::weak_ptr<uml::CallOperationAction> castedContainer = std::dynamic_pointer_cast<uml::CallOperationAction> (container);
						return this->createValuePin_as_target_in_CallOperationAction(castedContainer,metaElementID);
					}
					//ValuePin has target as a containment
					case  uml::umlPackage::DESTROYOBJECTACTION_ATTRIBUTE_TARGET:	
					{
						std::weak_ptr<uml::DestroyObjectAction> castedContainer = std::dynamic_pointer_cast<uml::DestroyObjectAction> (container);
						return this->createValuePin_as_target_in_DestroyObjectAction(castedContainer,metaElementID);
					}
					//ValuePin has target as a containment
					case  uml::umlPackage::SENDOBJECTACTION_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<SendObjectAction> castedContainer = std::dynamic_pointer_cast<SendObjectAction> (container);;
						return this->createValuePin_as_target_in_SendObjectAction(castedContainer,metaElementID);
					}
					//ValuePin has target as a containment
					case  uml::umlPackage::SENDSIGNALACTION_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<SendSignalAction> castedContainer = std::dynamic_pointer_cast<SendSignalAction> (container);;
						return this->createValuePin_as_target_in_SendSignalAction(castedContainer,metaElementID);
					}
					//ValuePin has value as a containment
					case  uml::umlPackage::WRITESTRUCTURALFEATUREACTION_ATTRIBUTE_VALUE:	
					{
						std::weak_ptr<uml::WriteStructuralFeatureAction> castedContainer = std::dynamic_pointer_cast<uml::WriteStructuralFeatureAction> (container);
						return this->createValuePin_as_value_in_WriteStructuralFeatureAction(castedContainer,metaElementID);
					}
					//ValuePin has value as a containment
					case  uml::umlPackage::WRITEVARIABLEACTION_ATTRIBUTE_VALUE:	
					{
						std::shared_ptr<WriteVariableAction> castedContainer = std::dynamic_pointer_cast<WriteVariableAction> (container);;
						return this->createValuePin_as_value_in_WriteVariableAction(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::VALUESPECIFICATIONACTION_CLASS:
		{
			if (nullptr == container)
			{
				return this->createValueSpecificationAction(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//ValueSpecificationAction has action as a containment
					case  uml::umlPackage::INTERACTION_ATTRIBUTE_ACTION:	
					{
						std::shared_ptr<Interaction> castedContainer = std::dynamic_pointer_cast<Interaction> (container);;
						return this->createValueSpecificationAction_as_action_in_Interaction(castedContainer,metaElementID);
					}
					//ValueSpecificationAction has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createValueSpecificationAction_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//ValueSpecificationAction has executableNode as a containment
					case  uml::umlPackage::SEQUENCENODE_ATTRIBUTE_EXECUTABLENODE:	
					{
						std::shared_ptr<SequenceNode> castedContainer = std::dynamic_pointer_cast<SequenceNode> (container);;
						return this->createValueSpecificationAction_as_executableNode_in_SequenceNode(castedContainer,metaElementID);
					}
					//ValueSpecificationAction has fromAction as a containment
					case  uml::umlPackage::ACTIONINPUTPIN_ATTRIBUTE_FROMACTION:	
					{
						std::shared_ptr<ActionInputPin> castedContainer = std::dynamic_pointer_cast<ActionInputPin> (container);;
						return this->createValueSpecificationAction_as_fromAction_in_ActionInputPin(castedContainer,metaElementID);
					}
					//ValueSpecificationAction has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createValueSpecificationAction_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//ValueSpecificationAction has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createValueSpecificationAction_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//ValueSpecificationAction has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createValueSpecificationAction_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//ValueSpecificationAction has node as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createValueSpecificationAction_as_node_in_Activity(castedContainer,metaElementID);
					}
					//ValueSpecificationAction has node as a containment
					case  uml::umlPackage::ACTIVITYPARTITION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::ActivityPartition> castedContainer = std::dynamic_pointer_cast<uml::ActivityPartition> (container);
						return this->createValueSpecificationAction_as_node_in_ActivityPartition(castedContainer,metaElementID);
					}
					//ValueSpecificationAction has node as a containment
					case  uml::umlPackage::INTERRUPTIBLEACTIVITYREGION_ATTRIBUTE_NODE:	
					{
						std::shared_ptr<uml::InterruptibleActivityRegion> castedContainer = std::dynamic_pointer_cast<uml::InterruptibleActivityRegion> (container);
						return this->createValueSpecificationAction_as_node_in_InterruptibleActivityRegion(castedContainer,metaElementID);
					}
					//ValueSpecificationAction has node as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_NODE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createValueSpecificationAction_as_node_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					//ValueSpecificationAction has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createValueSpecificationAction_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//ValueSpecificationAction has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createValueSpecificationAction_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//ValueSpecificationAction has ownedNode as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_OWNEDNODE:	
					{
						std::shared_ptr<Activity> castedContainer = std::dynamic_pointer_cast<Activity> (container);;
						return this->createValueSpecificationAction_as_ownedNode_in_Activity(castedContainer,metaElementID);
					}
					//ValueSpecificationAction has redefinedNode as a containment
					case  uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_REDEFINEDNODE:	
					{
						std::shared_ptr<ActivityNode> castedContainer = std::dynamic_pointer_cast<ActivityNode> (container);;
						return this->createValueSpecificationAction_as_redefinedNode_in_ActivityNode(castedContainer,metaElementID);
					}
					//ValueSpecificationAction has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createValueSpecificationAction_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ValueSpecificationAction has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createValueSpecificationAction_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//ValueSpecificationAction has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createValueSpecificationAction_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//ValueSpecificationAction has valueSpecificationAction as a containment
					//ValueSpecificationAction has valueSpecificationAction as a containment
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
		case umlPackage::VARIABLE_CLASS:
		{
			if (nullptr == container)
			{
				return this->createVariable(metaElementID);
			}
			else
			{
				switch(referenceID)
				{
					//Variable has client as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_CLIENT:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createVariable_as_client_in_Dependency(castedContainer,metaElementID);
					}
					//Variable has collaborationRole as a containment
					case  uml::umlPackage::COLLABORATION_ATTRIBUTE_COLLABORATIONROLE:	
					{
						std::shared_ptr<Collaboration> castedContainer = std::dynamic_pointer_cast<Collaboration> (container);;
						return this->createVariable_as_collaborationRole_in_Collaboration(castedContainer,metaElementID);
					}
					//Variable has informationSource as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONSOURCE:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createVariable_as_informationSource_in_InformationFlow(castedContainer,metaElementID);
					}
					//Variable has informationTarget as a containment
					case  uml::umlPackage::INFORMATIONFLOW_ATTRIBUTE_INFORMATIONTARGET:	
					{
						std::shared_ptr<InformationFlow> castedContainer = std::dynamic_pointer_cast<InformationFlow> (container);;
						return this->createVariable_as_informationTarget_in_InformationFlow(castedContainer,metaElementID);
					}
					//Variable has inheritedMember as a containment
					case  uml::umlPackage::CLASSIFIER_ATTRIBUTE_INHERITEDMEMBER:	
					{
						std::shared_ptr<Classifier> castedContainer = std::dynamic_pointer_cast<Classifier> (container);;
						return this->createVariable_as_inheritedMember_in_Classifier(castedContainer,metaElementID);
					}
					//Variable has ownedActual as a containment
					case  uml::umlPackage::TEMPLATEPARAMETERSUBSTITUTION_ATTRIBUTE_OWNEDACTUAL:	
					{
						std::shared_ptr<TemplateParameterSubstitution> castedContainer = std::dynamic_pointer_cast<TemplateParameterSubstitution> (container);;
						return this->createVariable_as_ownedActual_in_TemplateParameterSubstitution(castedContainer,metaElementID);
					}
					//Variable has ownedDefault as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDDEFAULT:	
					{
						std::shared_ptr<TemplateParameter> castedContainer = std::dynamic_pointer_cast<TemplateParameter> (container);;
						return this->createVariable_as_ownedDefault_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Variable has ownedElement as a containment
					case  uml::umlPackage::ELEMENT_ATTRIBUTE_OWNEDELEMENT:	
					{
						std::weak_ptr<uml::Element> castedContainer = std::dynamic_pointer_cast<uml::Element> (container);
						return this->createVariable_as_ownedElement_in_Element(castedContainer,metaElementID);
					}
					//Variable has ownedMember as a containment
					case  uml::umlPackage::NAMESPACE_ATTRIBUTE_OWNEDMEMBER:	
					{
						std::weak_ptr<uml::Namespace> castedContainer = std::dynamic_pointer_cast<uml::Namespace> (container);
						return this->createVariable_as_ownedMember_in_Namespace(castedContainer,metaElementID);
					}
					//Variable has ownedParameteredElement as a containment
					case  uml::umlPackage::TEMPLATEPARAMETER_ATTRIBUTE_OWNEDPARAMETEREDELEMENT:	
					{
						std::weak_ptr<uml::TemplateParameter> castedContainer = std::dynamic_pointer_cast<uml::TemplateParameter> (container);
						return this->createVariable_as_ownedParameteredElement_in_TemplateParameter(castedContainer,metaElementID);
					}
					//Variable has role as a containment
					case  uml::umlPackage::STRUCTUREDCLASSIFIER_ATTRIBUTE_ROLE:	
					{
						std::shared_ptr<StructuredClassifier> castedContainer = std::dynamic_pointer_cast<StructuredClassifier> (container);;
						return this->createVariable_as_role_in_StructuredClassifier(castedContainer,metaElementID);
					}
					//Variable has source as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_SOURCE:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createVariable_as_source_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Variable has supplier as a containment
					case  uml::umlPackage::DEPENDENCY_ATTRIBUTE_SUPPLIER:	
					{
						std::shared_ptr<Dependency> castedContainer = std::dynamic_pointer_cast<Dependency> (container);;
						return this->createVariable_as_supplier_in_Dependency(castedContainer,metaElementID);
					}
					//Variable has target as a containment
					case  uml::umlPackage::DIRECTEDRELATIONSHIP_ATTRIBUTE_TARGET:	
					{
						std::shared_ptr<DirectedRelationship> castedContainer = std::dynamic_pointer_cast<DirectedRelationship> (container);;
						return this->createVariable_as_target_in_DirectedRelationship(castedContainer,metaElementID);
					}
					//Variable has variable as a containment
					case  uml::umlPackage::ACTIVITY_ATTRIBUTE_VARIABLE:	
					{
						std::weak_ptr<uml::Activity> castedContainer = std::dynamic_pointer_cast<uml::Activity> (container);
						return this->createVariable_as_variable_in_Activity(castedContainer,metaElementID);
					}
					//Variable has variable as a containment
					case  uml::umlPackage::STRUCTUREDACTIVITYNODE_ATTRIBUTE_VARIABLE:	
					{
						std::weak_ptr<uml::StructuredActivityNode> castedContainer = std::dynamic_pointer_cast<uml::StructuredActivityNode> (container);
						return this->createVariable_as_variable_in_StructuredActivityNode(castedContainer,metaElementID);
					}
					default:
						std::cerr << __PRETTY_FUNCTION__ << "ERROR: Reference type not found." << std::endl;
				}	
			}
			break;
		}
	default:
	   	    std::cerr << __PRETTY_FUNCTION__ << " ID " << metaElementID <<" not found" << std::endl;
	}
	return nullptr;
}

std::shared_ptr<ecore::EObject> umlFactoryImpl::create(std::shared_ptr<ecore::EClass> _class, std::shared_ptr<ecore::EObject> container /*= nullptr*/, const int referenceID/* = -1*/) const
{
	if(_class->isAbstract())
    {
    	return nullptr;
   	}
	int _elementID = _class->getMetaElementID();
	return create(_elementID, container, referenceID);
}

std::shared_ptr<ecore::EObject> umlFactoryImpl::create(std::string _className, std::shared_ptr<ecore::EObject> container /*= nullptr*/, const int referenceID/* = -1*/) const
{
	auto iter = m_idMap.find(_className);
	if(iter != m_idMap.end())
    {
		//get the ID
        int id = iter->second;
		return create(id,container,referenceID);
    }
    return nullptr;
}

std::shared_ptr<Abstraction> umlFactoryImpl::createAbstraction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<AbstractionImpl> element(new AbstractionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisAbstractionPtr(element);
	return element;
}
std::shared_ptr<Abstraction> umlFactoryImpl::createAbstraction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<AbstractionImpl> element(new AbstractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisAbstractionPtr(element);
	return element;
	
}
std::shared_ptr<Abstraction> umlFactoryImpl::createAbstraction_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<AbstractionImpl> element(new AbstractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisAbstractionPtr(element);
	return element;
	
}
std::shared_ptr<Abstraction> umlFactoryImpl::createAbstraction_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<AbstractionImpl> element(new AbstractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisAbstractionPtr(element);
	return element;
	
}
std::shared_ptr<Abstraction> umlFactoryImpl::createAbstraction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<AbstractionImpl> element(new AbstractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisAbstractionPtr(element);
	return element;
	
}
std::shared_ptr<Abstraction> umlFactoryImpl::createAbstraction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<AbstractionImpl> element(new AbstractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisAbstractionPtr(element);
	return element;
	
}
std::shared_ptr<Abstraction> umlFactoryImpl::createAbstraction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<AbstractionImpl> element(new AbstractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisAbstractionPtr(element);
	return element;
	
}
std::shared_ptr<Abstraction> umlFactoryImpl::createAbstraction_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<AbstractionImpl> element(new AbstractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisAbstractionPtr(element);
	return element;
	
}
std::shared_ptr<Abstraction> umlFactoryImpl::createAbstraction_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<AbstractionImpl> element(new AbstractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisAbstractionPtr(element);
	return element;
	
}
std::shared_ptr<Abstraction> umlFactoryImpl::createAbstraction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<AbstractionImpl> element(new AbstractionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisAbstractionPtr(element);
	return element;
	
}
std::shared_ptr<Abstraction> umlFactoryImpl::createAbstraction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<AbstractionImpl> element(new AbstractionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisAbstractionPtr(element);
	return element;
	
}
std::shared_ptr<Abstraction> umlFactoryImpl::createAbstraction_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<AbstractionImpl> element(new AbstractionImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisAbstractionPtr(element);
	return element;
	
}
std::shared_ptr<Abstraction> umlFactoryImpl::createAbstraction_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<AbstractionImpl> element(new AbstractionImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisAbstractionPtr(element);
	return element;
	
}
std::shared_ptr<Abstraction> umlFactoryImpl::createAbstraction_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<AbstractionImpl> element(new AbstractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisAbstractionPtr(element);
	return element;
	
}
std::shared_ptr<Abstraction> umlFactoryImpl::createAbstraction_as_roleBinding_in_CollaborationUse(std::shared_ptr<CollaborationUse> par_CollaborationUse, const int metaElementID) const
{
	std::shared_ptr<AbstractionImpl> element(new AbstractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_CollaborationUse)
	{
		par_CollaborationUse->getRoleBinding()->push_back(element);
	}
	
	element->setThisAbstractionPtr(element);
	return element;
	
}
std::shared_ptr<Abstraction> umlFactoryImpl::createAbstraction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<AbstractionImpl> element(new AbstractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisAbstractionPtr(element);
	return element;
	
}
std::shared_ptr<Abstraction> umlFactoryImpl::createAbstraction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<AbstractionImpl> element(new AbstractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisAbstractionPtr(element);
	return element;
	
}
std::shared_ptr<Abstraction> umlFactoryImpl::createAbstraction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<AbstractionImpl> element(new AbstractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisAbstractionPtr(element);
	return element;
	
}
std::shared_ptr<Abstraction> umlFactoryImpl::createAbstraction_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<AbstractionImpl> element(new AbstractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisAbstractionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptCallAction> umlFactoryImpl::createAcceptCallAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<AcceptCallActionImpl> element(new AcceptCallActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisAcceptCallActionPtr(element);
	return element;
}
std::shared_ptr<AcceptCallAction> umlFactoryImpl::createAcceptCallAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<AcceptCallActionImpl> element(new AcceptCallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisAcceptCallActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptCallAction> umlFactoryImpl::createAcceptCallAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<AcceptCallActionImpl> element(new AcceptCallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisAcceptCallActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptCallAction> umlFactoryImpl::createAcceptCallAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<AcceptCallActionImpl> element(new AcceptCallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisAcceptCallActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptCallAction> umlFactoryImpl::createAcceptCallAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<AcceptCallActionImpl> element(new AcceptCallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisAcceptCallActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptCallAction> umlFactoryImpl::createAcceptCallAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<AcceptCallActionImpl> element(new AcceptCallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisAcceptCallActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptCallAction> umlFactoryImpl::createAcceptCallAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<AcceptCallActionImpl> element(new AcceptCallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisAcceptCallActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptCallAction> umlFactoryImpl::createAcceptCallAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<AcceptCallActionImpl> element(new AcceptCallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisAcceptCallActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptCallAction> umlFactoryImpl::createAcceptCallAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<AcceptCallActionImpl> element(new AcceptCallActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisAcceptCallActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptCallAction> umlFactoryImpl::createAcceptCallAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<AcceptCallActionImpl> element(new AcceptCallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisAcceptCallActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptCallAction> umlFactoryImpl::createAcceptCallAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<AcceptCallActionImpl> element(new AcceptCallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisAcceptCallActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptCallAction> umlFactoryImpl::createAcceptCallAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<AcceptCallActionImpl> element(new AcceptCallActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisAcceptCallActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptCallAction> umlFactoryImpl::createAcceptCallAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<AcceptCallActionImpl> element(new AcceptCallActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisAcceptCallActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptCallAction> umlFactoryImpl::createAcceptCallAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<AcceptCallActionImpl> element(new AcceptCallActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisAcceptCallActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptCallAction> umlFactoryImpl::createAcceptCallAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<AcceptCallActionImpl> element(new AcceptCallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisAcceptCallActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptCallAction> umlFactoryImpl::createAcceptCallAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<AcceptCallActionImpl> element(new AcceptCallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisAcceptCallActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptCallAction> umlFactoryImpl::createAcceptCallAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<AcceptCallActionImpl> element(new AcceptCallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisAcceptCallActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptCallAction> umlFactoryImpl::createAcceptCallAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<AcceptCallActionImpl> element(new AcceptCallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisAcceptCallActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptCallAction> umlFactoryImpl::createAcceptCallAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<AcceptCallActionImpl> element(new AcceptCallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisAcceptCallActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptEventAction> umlFactoryImpl::createAcceptEventAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<AcceptEventActionImpl> element(new AcceptEventActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisAcceptEventActionPtr(element);
	return element;
}
std::shared_ptr<AcceptEventAction> umlFactoryImpl::createAcceptEventAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<AcceptEventActionImpl> element(new AcceptEventActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisAcceptEventActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptEventAction> umlFactoryImpl::createAcceptEventAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<AcceptEventActionImpl> element(new AcceptEventActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisAcceptEventActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptEventAction> umlFactoryImpl::createAcceptEventAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<AcceptEventActionImpl> element(new AcceptEventActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisAcceptEventActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptEventAction> umlFactoryImpl::createAcceptEventAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<AcceptEventActionImpl> element(new AcceptEventActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisAcceptEventActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptEventAction> umlFactoryImpl::createAcceptEventAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<AcceptEventActionImpl> element(new AcceptEventActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisAcceptEventActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptEventAction> umlFactoryImpl::createAcceptEventAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<AcceptEventActionImpl> element(new AcceptEventActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisAcceptEventActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptEventAction> umlFactoryImpl::createAcceptEventAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<AcceptEventActionImpl> element(new AcceptEventActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisAcceptEventActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptEventAction> umlFactoryImpl::createAcceptEventAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<AcceptEventActionImpl> element(new AcceptEventActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisAcceptEventActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptEventAction> umlFactoryImpl::createAcceptEventAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<AcceptEventActionImpl> element(new AcceptEventActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisAcceptEventActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptEventAction> umlFactoryImpl::createAcceptEventAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<AcceptEventActionImpl> element(new AcceptEventActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisAcceptEventActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptEventAction> umlFactoryImpl::createAcceptEventAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<AcceptEventActionImpl> element(new AcceptEventActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisAcceptEventActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptEventAction> umlFactoryImpl::createAcceptEventAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<AcceptEventActionImpl> element(new AcceptEventActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisAcceptEventActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptEventAction> umlFactoryImpl::createAcceptEventAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<AcceptEventActionImpl> element(new AcceptEventActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisAcceptEventActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptEventAction> umlFactoryImpl::createAcceptEventAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<AcceptEventActionImpl> element(new AcceptEventActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisAcceptEventActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptEventAction> umlFactoryImpl::createAcceptEventAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<AcceptEventActionImpl> element(new AcceptEventActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisAcceptEventActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptEventAction> umlFactoryImpl::createAcceptEventAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<AcceptEventActionImpl> element(new AcceptEventActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisAcceptEventActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptEventAction> umlFactoryImpl::createAcceptEventAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<AcceptEventActionImpl> element(new AcceptEventActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisAcceptEventActionPtr(element);
	return element;
	
}
std::shared_ptr<AcceptEventAction> umlFactoryImpl::createAcceptEventAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<AcceptEventActionImpl> element(new AcceptEventActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisAcceptEventActionPtr(element);
	return element;
	
}
std::shared_ptr<ActionExecutionSpecification> umlFactoryImpl::createActionExecutionSpecification(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ActionExecutionSpecificationImpl> element(new ActionExecutionSpecificationImpl());
	element->setMetaElementID(metaElementID);
	element->setThisActionExecutionSpecificationPtr(element);
	return element;
}
std::shared_ptr<ActionExecutionSpecification> umlFactoryImpl::createActionExecutionSpecification_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ActionExecutionSpecificationImpl> element(new ActionExecutionSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisActionExecutionSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<ActionExecutionSpecification> umlFactoryImpl::createActionExecutionSpecification_as_fragment_in_Interaction(std::weak_ptr<uml::Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<ActionExecutionSpecificationImpl> element(new ActionExecutionSpecificationImpl(par_Interaction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Interaction.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisActionExecutionSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<ActionExecutionSpecification> umlFactoryImpl::createActionExecutionSpecification_as_fragment_in_InteractionOperand(std::weak_ptr<uml::InteractionOperand> par_InteractionOperand, const int metaElementID) const
{
	std::shared_ptr<ActionExecutionSpecificationImpl> element(new ActionExecutionSpecificationImpl(par_InteractionOperand));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_InteractionOperand.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisActionExecutionSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<ActionExecutionSpecification> umlFactoryImpl::createActionExecutionSpecification_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ActionExecutionSpecificationImpl> element(new ActionExecutionSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisActionExecutionSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<ActionExecutionSpecification> umlFactoryImpl::createActionExecutionSpecification_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ActionExecutionSpecificationImpl> element(new ActionExecutionSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisActionExecutionSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<ActionExecutionSpecification> umlFactoryImpl::createActionExecutionSpecification_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ActionExecutionSpecificationImpl> element(new ActionExecutionSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisActionExecutionSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<ActionExecutionSpecification> umlFactoryImpl::createActionExecutionSpecification_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ActionExecutionSpecificationImpl> element(new ActionExecutionSpecificationImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisActionExecutionSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<ActionExecutionSpecification> umlFactoryImpl::createActionExecutionSpecification_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ActionExecutionSpecificationImpl> element(new ActionExecutionSpecificationImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisActionExecutionSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<ActionExecutionSpecification> umlFactoryImpl::createActionExecutionSpecification_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ActionExecutionSpecificationImpl> element(new ActionExecutionSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisActionExecutionSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<ActionExecutionSpecification> umlFactoryImpl::createActionExecutionSpecification_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ActionExecutionSpecificationImpl> element(new ActionExecutionSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisActionExecutionSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<ActionExecutionSpecification> umlFactoryImpl::createActionExecutionSpecification_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ActionExecutionSpecificationImpl> element(new ActionExecutionSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisActionExecutionSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	element->setThisActionInputPinPtr(element);
	return element;
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_argument_in_InvocationAction(std::weak_ptr<uml::InvocationAction> par_InvocationAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl(par_InvocationAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_InvocationAction.lock())
	{
		wp->getArgument()->push_back(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_collection_in_ReduceAction(std::shared_ptr<ReduceAction> par_ReduceAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReduceAction)
	{
		par_ReduceAction->setCollection(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_exception_in_RaiseExceptionAction(std::shared_ptr<RaiseExceptionAction> par_RaiseExceptionAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RaiseExceptionAction)
	{
		par_RaiseExceptionAction->setException(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_first_in_TestIdentityAction(std::shared_ptr<TestIdentityAction> par_TestIdentityAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TestIdentityAction)
	{
		par_TestIdentityAction->setFirst(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_input_in_Action(std::weak_ptr<uml::Action> par_Action, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl(par_Action));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Action.lock())
	{
		wp->getInput()->push_back(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_inputValue_in_LinkAction(std::shared_ptr<LinkAction> par_LinkAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_LinkAction)
	{
		par_LinkAction->getInputValue()->push_back(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_inputValue_in_OpaqueAction(std::shared_ptr<OpaqueAction> par_OpaqueAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_OpaqueAction)
	{
		par_OpaqueAction->getInputValue()->push_back(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_insertAt_in_AddStructuralFeatureValueAction(std::weak_ptr<uml::AddStructuralFeatureValueAction> par_AddStructuralFeatureValueAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl(par_AddStructuralFeatureValueAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_AddStructuralFeatureValueAction.lock())
	{
		wp->setInsertAt(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_insertAt_in_AddVariableValueAction(std::shared_ptr<AddVariableValueAction> par_AddVariableValueAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_AddVariableValueAction)
	{
		par_AddVariableValueAction->setInsertAt(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_loopVariableInput_in_LoopNode(std::shared_ptr<LoopNode> par_LoopNode, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_LoopNode)
	{
		par_LoopNode->getLoopVariableInput()->push_back(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_object_in_StructuralFeatureAction(std::weak_ptr<uml::StructuralFeatureAction> par_StructuralFeatureAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl(par_StructuralFeatureAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuralFeatureAction.lock())
	{
		wp->setObject(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_object_in_ClearAssociationAction(std::shared_ptr<ClearAssociationAction> par_ClearAssociationAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ClearAssociationAction)
	{
		par_ClearAssociationAction->setObject(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_object_in_ReadIsClassifiedObjectAction(std::shared_ptr<ReadIsClassifiedObjectAction> par_ReadIsClassifiedObjectAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReadIsClassifiedObjectAction)
	{
		par_ReadIsClassifiedObjectAction->setObject(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_object_in_ReadLinkObjectEndAction(std::shared_ptr<ReadLinkObjectEndAction> par_ReadLinkObjectEndAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReadLinkObjectEndAction)
	{
		par_ReadLinkObjectEndAction->setObject(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_object_in_ReadLinkObjectEndQualifierAction(std::shared_ptr<ReadLinkObjectEndQualifierAction> par_ReadLinkObjectEndQualifierAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReadLinkObjectEndQualifierAction)
	{
		par_ReadLinkObjectEndQualifierAction->setObject(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_object_in_ReclassifyObjectAction(std::shared_ptr<ReclassifyObjectAction> par_ReclassifyObjectAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReclassifyObjectAction)
	{
		par_ReclassifyObjectAction->setObject(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_object_in_StartClassifierBehaviorAction(std::shared_ptr<StartClassifierBehaviorAction> par_StartClassifierBehaviorAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_StartClassifierBehaviorAction)
	{
		par_StartClassifierBehaviorAction->setObject(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_object_in_StartObjectBehaviorAction(std::shared_ptr<StartObjectBehaviorAction> par_StartObjectBehaviorAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_StartObjectBehaviorAction)
	{
		par_StartObjectBehaviorAction->setObject(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_object_in_UnmarshallAction(std::shared_ptr<UnmarshallAction> par_UnmarshallAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_UnmarshallAction)
	{
		par_UnmarshallAction->setObject(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_removeAt_in_RemoveStructuralFeatureValueAction(std::weak_ptr<uml::RemoveStructuralFeatureValueAction> par_RemoveStructuralFeatureValueAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl(par_RemoveStructuralFeatureValueAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_RemoveStructuralFeatureValueAction.lock())
	{
		wp->setRemoveAt(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_removeAt_in_RemoveVariableValueAction(std::shared_ptr<RemoveVariableValueAction> par_RemoveVariableValueAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RemoveVariableValueAction)
	{
		par_RemoveVariableValueAction->setRemoveAt(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_replyValue_in_ReplyAction(std::shared_ptr<ReplyAction> par_ReplyAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReplyAction)
	{
		par_ReplyAction->getReplyValue()->push_back(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_request_in_SendObjectAction(std::shared_ptr<SendObjectAction> par_SendObjectAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SendObjectAction)
	{
		par_SendObjectAction->setRequest(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_returnInformation_in_ReplyAction(std::shared_ptr<ReplyAction> par_ReplyAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReplyAction)
	{
		par_ReplyAction->setReturnInformation(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_second_in_TestIdentityAction(std::shared_ptr<TestIdentityAction> par_TestIdentityAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TestIdentityAction)
	{
		par_TestIdentityAction->setSecond(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_structuredNodeInput_in_StructuredActivityNode(std::shared_ptr<StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_StructuredActivityNode)
	{
		par_StructuredActivityNode->getStructuredNodeInput()->push_back(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_target_in_CallOperationAction(std::weak_ptr<uml::CallOperationAction> par_CallOperationAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl(par_CallOperationAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_CallOperationAction.lock())
	{
		wp->setTarget(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_target_in_DestroyObjectAction(std::weak_ptr<uml::DestroyObjectAction> par_DestroyObjectAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl(par_DestroyObjectAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_DestroyObjectAction.lock())
	{
		wp->setTarget(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_target_in_SendObjectAction(std::shared_ptr<SendObjectAction> par_SendObjectAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SendObjectAction)
	{
		par_SendObjectAction->setTarget(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_target_in_SendSignalAction(std::shared_ptr<SendSignalAction> par_SendSignalAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SendSignalAction)
	{
		par_SendSignalAction->setTarget(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_value_in_WriteStructuralFeatureAction(std::weak_ptr<uml::WriteStructuralFeatureAction> par_WriteStructuralFeatureAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl(par_WriteStructuralFeatureAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_WriteStructuralFeatureAction.lock())
	{
		wp->setValue(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<ActionInputPin> umlFactoryImpl::createActionInputPin_as_value_in_WriteVariableAction(std::shared_ptr<WriteVariableAction> par_WriteVariableAction, const int metaElementID) const
{
	std::shared_ptr<ActionInputPinImpl> element(new ActionInputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_WriteVariableAction)
	{
		par_WriteVariableAction->setValue(element);
	}
	
	element->setThisActionInputPinPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	element->setThisActivityPtr(element);
	return element;
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_classifier_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->setClassifier(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_classifierBehavior_in_BehavioredClassifier(std::shared_ptr<BehavioredClassifier> par_BehavioredClassifier, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_BehavioredClassifier)
	{
		par_BehavioredClassifier->setClassifierBehavior(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_context_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->setContext(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_contract_in_Substitution(std::shared_ptr<Substitution> par_Substitution, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Substitution)
	{
		par_Substitution->setContract(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_doActivity_in_State(std::shared_ptr<State> par_State, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_State)
	{
		par_State->setDoActivity(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_effect_in_Transition(std::shared_ptr<Transition> par_Transition, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Transition)
	{
		par_Transition->setEffect(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_endType_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getEndType()->push_back(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_entry_in_State(std::shared_ptr<State> par_State, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_State)
	{
		par_State->setEntry(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_exit_in_State(std::shared_ptr<State> par_State, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_State)
	{
		par_State->setExit(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_general_in_Generalization(std::shared_ptr<Generalization> par_Generalization, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Generalization)
	{
		par_Generalization->setGeneral(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_nestedClassifier_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getNestedClassifier()->push_back(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_nestedClassifier_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getNestedClassifier()->push_back(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_ownedBehavior_in_BehavioredClassifier(std::weak_ptr<uml::BehavioredClassifier> par_BehavioredClassifier, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl(par_BehavioredClassifier));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_BehavioredClassifier.lock())
	{
		wp->getOwnedBehavior()->push_back(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_ownedType_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl(par_Package, uml::umlPackage::TYPE_ATTRIBUTE_PACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getOwnedType()->push_back(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_realizingClassifier_in_ComponentRealization(std::shared_ptr<ComponentRealization> par_ComponentRealization, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ComponentRealization)
	{
		par_ComponentRealization->getRealizingClassifier()->push_back(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_redefinedBehavior_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->getRedefinedBehavior()->push_back(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_redefinedClassifier_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getRedefinedClassifier()->push_back(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<Activity> umlFactoryImpl::createActivity_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<ActivityImpl> element(new ActivityImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisActivityPtr(element);
	return element;
	
}
std::shared_ptr<ActivityFinalNode> umlFactoryImpl::createActivityFinalNode(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ActivityFinalNodeImpl> element(new ActivityFinalNodeImpl());
	element->setMetaElementID(metaElementID);
	element->setThisActivityFinalNodePtr(element);
	return element;
}
std::shared_ptr<ActivityFinalNode> umlFactoryImpl::createActivityFinalNode_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ActivityFinalNodeImpl> element(new ActivityFinalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisActivityFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityFinalNode> umlFactoryImpl::createActivityFinalNode_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ActivityFinalNodeImpl> element(new ActivityFinalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisActivityFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityFinalNode> umlFactoryImpl::createActivityFinalNode_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ActivityFinalNodeImpl> element(new ActivityFinalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisActivityFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityFinalNode> umlFactoryImpl::createActivityFinalNode_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ActivityFinalNodeImpl> element(new ActivityFinalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisActivityFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityFinalNode> umlFactoryImpl::createActivityFinalNode_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ActivityFinalNodeImpl> element(new ActivityFinalNodeImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisActivityFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityFinalNode> umlFactoryImpl::createActivityFinalNode_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<ActivityFinalNodeImpl> element(new ActivityFinalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisActivityFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityFinalNode> umlFactoryImpl::createActivityFinalNode_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<ActivityFinalNodeImpl> element(new ActivityFinalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisActivityFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityFinalNode> umlFactoryImpl::createActivityFinalNode_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<ActivityFinalNodeImpl> element(new ActivityFinalNodeImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisActivityFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityFinalNode> umlFactoryImpl::createActivityFinalNode_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ActivityFinalNodeImpl> element(new ActivityFinalNodeImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisActivityFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityFinalNode> umlFactoryImpl::createActivityFinalNode_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ActivityFinalNodeImpl> element(new ActivityFinalNodeImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisActivityFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityFinalNode> umlFactoryImpl::createActivityFinalNode_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ActivityFinalNodeImpl> element(new ActivityFinalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisActivityFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityFinalNode> umlFactoryImpl::createActivityFinalNode_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<ActivityFinalNodeImpl> element(new ActivityFinalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisActivityFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityFinalNode> umlFactoryImpl::createActivityFinalNode_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ActivityFinalNodeImpl> element(new ActivityFinalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisActivityFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityFinalNode> umlFactoryImpl::createActivityFinalNode_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ActivityFinalNodeImpl> element(new ActivityFinalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisActivityFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityFinalNode> umlFactoryImpl::createActivityFinalNode_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ActivityFinalNodeImpl> element(new ActivityFinalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisActivityFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityParameterNode> umlFactoryImpl::createActivityParameterNode(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ActivityParameterNodeImpl> element(new ActivityParameterNodeImpl());
	element->setMetaElementID(metaElementID);
	element->setThisActivityParameterNodePtr(element);
	return element;
}
std::shared_ptr<ActivityParameterNode> umlFactoryImpl::createActivityParameterNode_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ActivityParameterNodeImpl> element(new ActivityParameterNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisActivityParameterNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityParameterNode> umlFactoryImpl::createActivityParameterNode_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ActivityParameterNodeImpl> element(new ActivityParameterNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisActivityParameterNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityParameterNode> umlFactoryImpl::createActivityParameterNode_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ActivityParameterNodeImpl> element(new ActivityParameterNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisActivityParameterNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityParameterNode> umlFactoryImpl::createActivityParameterNode_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ActivityParameterNodeImpl> element(new ActivityParameterNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisActivityParameterNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityParameterNode> umlFactoryImpl::createActivityParameterNode_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ActivityParameterNodeImpl> element(new ActivityParameterNodeImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisActivityParameterNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityParameterNode> umlFactoryImpl::createActivityParameterNode_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<ActivityParameterNodeImpl> element(new ActivityParameterNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisActivityParameterNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityParameterNode> umlFactoryImpl::createActivityParameterNode_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<ActivityParameterNodeImpl> element(new ActivityParameterNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisActivityParameterNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityParameterNode> umlFactoryImpl::createActivityParameterNode_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<ActivityParameterNodeImpl> element(new ActivityParameterNodeImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisActivityParameterNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityParameterNode> umlFactoryImpl::createActivityParameterNode_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ActivityParameterNodeImpl> element(new ActivityParameterNodeImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisActivityParameterNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityParameterNode> umlFactoryImpl::createActivityParameterNode_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ActivityParameterNodeImpl> element(new ActivityParameterNodeImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisActivityParameterNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityParameterNode> umlFactoryImpl::createActivityParameterNode_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ActivityParameterNodeImpl> element(new ActivityParameterNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisActivityParameterNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityParameterNode> umlFactoryImpl::createActivityParameterNode_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<ActivityParameterNodeImpl> element(new ActivityParameterNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisActivityParameterNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityParameterNode> umlFactoryImpl::createActivityParameterNode_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ActivityParameterNodeImpl> element(new ActivityParameterNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisActivityParameterNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityParameterNode> umlFactoryImpl::createActivityParameterNode_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ActivityParameterNodeImpl> element(new ActivityParameterNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisActivityParameterNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityParameterNode> umlFactoryImpl::createActivityParameterNode_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ActivityParameterNodeImpl> element(new ActivityParameterNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisActivityParameterNodePtr(element);
	return element;
	
}
std::shared_ptr<ActivityPartition> umlFactoryImpl::createActivityPartition(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ActivityPartitionImpl> element(new ActivityPartitionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisActivityPartitionPtr(element);
	return element;
}
std::shared_ptr<ActivityPartition> umlFactoryImpl::createActivityPartition_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ActivityPartitionImpl> element(new ActivityPartitionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisActivityPartitionPtr(element);
	return element;
	
}
std::shared_ptr<ActivityPartition> umlFactoryImpl::createActivityPartition_as_group_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ActivityPartitionImpl> element(new ActivityPartitionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getGroup()->push_back(element);
	}
	
	element->setThisActivityPartitionPtr(element);
	return element;
	
}
std::shared_ptr<ActivityPartition> umlFactoryImpl::createActivityPartition_as_inPartition_in_ActivityEdge(std::shared_ptr<uml::ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<ActivityPartitionImpl> element(new ActivityPartitionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->getInPartition()->push_back(element);
	}
	
	element->setThisActivityPartitionPtr(element);
	return element;
	
}
std::shared_ptr<ActivityPartition> umlFactoryImpl::createActivityPartition_as_inPartition_in_ActivityNode(std::shared_ptr<uml::ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<ActivityPartitionImpl> element(new ActivityPartitionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getInPartition()->push_back(element);
	}
	
	element->setThisActivityPartitionPtr(element);
	return element;
	
}
std::shared_ptr<ActivityPartition> umlFactoryImpl::createActivityPartition_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ActivityPartitionImpl> element(new ActivityPartitionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisActivityPartitionPtr(element);
	return element;
	
}
std::shared_ptr<ActivityPartition> umlFactoryImpl::createActivityPartition_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ActivityPartitionImpl> element(new ActivityPartitionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisActivityPartitionPtr(element);
	return element;
	
}
std::shared_ptr<ActivityPartition> umlFactoryImpl::createActivityPartition_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ActivityPartitionImpl> element(new ActivityPartitionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisActivityPartitionPtr(element);
	return element;
	
}
std::shared_ptr<ActivityPartition> umlFactoryImpl::createActivityPartition_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ActivityPartitionImpl> element(new ActivityPartitionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisActivityPartitionPtr(element);
	return element;
	
}
std::shared_ptr<ActivityPartition> umlFactoryImpl::createActivityPartition_as_ownedGroup_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ActivityPartitionImpl> element(new ActivityPartitionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedGroup()->push_back(element);
	}
	
	element->setThisActivityPartitionPtr(element);
	return element;
	
}
std::shared_ptr<ActivityPartition> umlFactoryImpl::createActivityPartition_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ActivityPartitionImpl> element(new ActivityPartitionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisActivityPartitionPtr(element);
	return element;
	
}
std::shared_ptr<ActivityPartition> umlFactoryImpl::createActivityPartition_as_partition_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ActivityPartitionImpl> element(new ActivityPartitionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getPartition()->push_back(element);
	}
	
	element->setThisActivityPartitionPtr(element);
	return element;
	
}
std::shared_ptr<ActivityPartition> umlFactoryImpl::createActivityPartition_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ActivityPartitionImpl> element(new ActivityPartitionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisActivityPartitionPtr(element);
	return element;
	
}
std::shared_ptr<ActivityPartition> umlFactoryImpl::createActivityPartition_as_subgroup_in_ActivityGroup(std::weak_ptr<uml::ActivityGroup> par_ActivityGroup, const int metaElementID) const
{
	std::shared_ptr<ActivityPartitionImpl> element(new ActivityPartitionImpl(par_ActivityGroup));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ActivityGroup.lock())
	{
		wp->getSubgroup()->push_back(element);
	}
	
	element->setThisActivityPartitionPtr(element);
	return element;
	
}
std::shared_ptr<ActivityPartition> umlFactoryImpl::createActivityPartition_as_subpartition_in_ActivityPartition(std::weak_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<ActivityPartitionImpl> element(new ActivityPartitionImpl(par_ActivityPartition));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ActivityPartition.lock())
	{
		wp->getSubpartition()->push_back(element);
	}
	
	element->setThisActivityPartitionPtr(element);
	return element;
	
}
std::shared_ptr<ActivityPartition> umlFactoryImpl::createActivityPartition_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ActivityPartitionImpl> element(new ActivityPartitionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisActivityPartitionPtr(element);
	return element;
	
}
std::shared_ptr<ActivityPartition> umlFactoryImpl::createActivityPartition_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ActivityPartitionImpl> element(new ActivityPartitionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisActivityPartitionPtr(element);
	return element;
	
}
std::shared_ptr<Actor> umlFactoryImpl::createActor(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl());
	element->setMetaElementID(metaElementID);
	element->setThisActorPtr(element);
	return element;
}
std::shared_ptr<Actor> umlFactoryImpl::createActor_as_classifier_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->setClassifier(element);
	}
	
	element->setThisActorPtr(element);
	return element;
	
}
std::shared_ptr<Actor> umlFactoryImpl::createActor_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisActorPtr(element);
	return element;
	
}
std::shared_ptr<Actor> umlFactoryImpl::createActor_as_context_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->setContext(element);
	}
	
	element->setThisActorPtr(element);
	return element;
	
}
std::shared_ptr<Actor> umlFactoryImpl::createActor_as_contract_in_Substitution(std::shared_ptr<Substitution> par_Substitution, const int metaElementID) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Substitution)
	{
		par_Substitution->setContract(element);
	}
	
	element->setThisActorPtr(element);
	return element;
	
}
std::shared_ptr<Actor> umlFactoryImpl::createActor_as_endType_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getEndType()->push_back(element);
	}
	
	element->setThisActorPtr(element);
	return element;
	
}
std::shared_ptr<Actor> umlFactoryImpl::createActor_as_general_in_Generalization(std::shared_ptr<Generalization> par_Generalization, const int metaElementID) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Generalization)
	{
		par_Generalization->setGeneral(element);
	}
	
	element->setThisActorPtr(element);
	return element;
	
}
std::shared_ptr<Actor> umlFactoryImpl::createActor_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisActorPtr(element);
	return element;
	
}
std::shared_ptr<Actor> umlFactoryImpl::createActor_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisActorPtr(element);
	return element;
	
}
std::shared_ptr<Actor> umlFactoryImpl::createActor_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisActorPtr(element);
	return element;
	
}
std::shared_ptr<Actor> umlFactoryImpl::createActor_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisActorPtr(element);
	return element;
	
}
std::shared_ptr<Actor> umlFactoryImpl::createActor_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisActorPtr(element);
	return element;
	
}
std::shared_ptr<Actor> umlFactoryImpl::createActor_as_nestedClassifier_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getNestedClassifier()->push_back(element);
	}
	
	element->setThisActorPtr(element);
	return element;
	
}
std::shared_ptr<Actor> umlFactoryImpl::createActor_as_nestedClassifier_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getNestedClassifier()->push_back(element);
	}
	
	element->setThisActorPtr(element);
	return element;
	
}
std::shared_ptr<Actor> umlFactoryImpl::createActor_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisActorPtr(element);
	return element;
	
}
std::shared_ptr<Actor> umlFactoryImpl::createActor_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisActorPtr(element);
	return element;
	
}
std::shared_ptr<Actor> umlFactoryImpl::createActor_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisActorPtr(element);
	return element;
	
}
std::shared_ptr<Actor> umlFactoryImpl::createActor_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisActorPtr(element);
	return element;
	
}
std::shared_ptr<Actor> umlFactoryImpl::createActor_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisActorPtr(element);
	return element;
	
}
std::shared_ptr<Actor> umlFactoryImpl::createActor_as_ownedType_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl(par_Package, uml::umlPackage::TYPE_ATTRIBUTE_PACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getOwnedType()->push_back(element);
	}
	
	element->setThisActorPtr(element);
	return element;
	
}
std::shared_ptr<Actor> umlFactoryImpl::createActor_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisActorPtr(element);
	return element;
	
}
std::shared_ptr<Actor> umlFactoryImpl::createActor_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisActorPtr(element);
	return element;
	
}
std::shared_ptr<Actor> umlFactoryImpl::createActor_as_realizingClassifier_in_ComponentRealization(std::shared_ptr<ComponentRealization> par_ComponentRealization, const int metaElementID) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ComponentRealization)
	{
		par_ComponentRealization->getRealizingClassifier()->push_back(element);
	}
	
	element->setThisActorPtr(element);
	return element;
	
}
std::shared_ptr<Actor> umlFactoryImpl::createActor_as_redefinedClassifier_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getRedefinedClassifier()->push_back(element);
	}
	
	element->setThisActorPtr(element);
	return element;
	
}
std::shared_ptr<Actor> umlFactoryImpl::createActor_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisActorPtr(element);
	return element;
	
}
std::shared_ptr<Actor> umlFactoryImpl::createActor_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisActorPtr(element);
	return element;
	
}
std::shared_ptr<Actor> umlFactoryImpl::createActor_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisActorPtr(element);
	return element;
	
}
std::shared_ptr<Actor> umlFactoryImpl::createActor_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<ActorImpl> element(new ActorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisActorPtr(element);
	return element;
	
}
std::shared_ptr<AddStructuralFeatureValueAction> umlFactoryImpl::createAddStructuralFeatureValueAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<AddStructuralFeatureValueActionImpl> element(new AddStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisAddStructuralFeatureValueActionPtr(element);
	return element;
}
std::shared_ptr<AddStructuralFeatureValueAction> umlFactoryImpl::createAddStructuralFeatureValueAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<AddStructuralFeatureValueActionImpl> element(new AddStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisAddStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddStructuralFeatureValueAction> umlFactoryImpl::createAddStructuralFeatureValueAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<AddStructuralFeatureValueActionImpl> element(new AddStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisAddStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddStructuralFeatureValueAction> umlFactoryImpl::createAddStructuralFeatureValueAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<AddStructuralFeatureValueActionImpl> element(new AddStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisAddStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddStructuralFeatureValueAction> umlFactoryImpl::createAddStructuralFeatureValueAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<AddStructuralFeatureValueActionImpl> element(new AddStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisAddStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddStructuralFeatureValueAction> umlFactoryImpl::createAddStructuralFeatureValueAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<AddStructuralFeatureValueActionImpl> element(new AddStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisAddStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddStructuralFeatureValueAction> umlFactoryImpl::createAddStructuralFeatureValueAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<AddStructuralFeatureValueActionImpl> element(new AddStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisAddStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddStructuralFeatureValueAction> umlFactoryImpl::createAddStructuralFeatureValueAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<AddStructuralFeatureValueActionImpl> element(new AddStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisAddStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddStructuralFeatureValueAction> umlFactoryImpl::createAddStructuralFeatureValueAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<AddStructuralFeatureValueActionImpl> element(new AddStructuralFeatureValueActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisAddStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddStructuralFeatureValueAction> umlFactoryImpl::createAddStructuralFeatureValueAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<AddStructuralFeatureValueActionImpl> element(new AddStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisAddStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddStructuralFeatureValueAction> umlFactoryImpl::createAddStructuralFeatureValueAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<AddStructuralFeatureValueActionImpl> element(new AddStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisAddStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddStructuralFeatureValueAction> umlFactoryImpl::createAddStructuralFeatureValueAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<AddStructuralFeatureValueActionImpl> element(new AddStructuralFeatureValueActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisAddStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddStructuralFeatureValueAction> umlFactoryImpl::createAddStructuralFeatureValueAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<AddStructuralFeatureValueActionImpl> element(new AddStructuralFeatureValueActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisAddStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddStructuralFeatureValueAction> umlFactoryImpl::createAddStructuralFeatureValueAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<AddStructuralFeatureValueActionImpl> element(new AddStructuralFeatureValueActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisAddStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddStructuralFeatureValueAction> umlFactoryImpl::createAddStructuralFeatureValueAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<AddStructuralFeatureValueActionImpl> element(new AddStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisAddStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddStructuralFeatureValueAction> umlFactoryImpl::createAddStructuralFeatureValueAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<AddStructuralFeatureValueActionImpl> element(new AddStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisAddStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddStructuralFeatureValueAction> umlFactoryImpl::createAddStructuralFeatureValueAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<AddStructuralFeatureValueActionImpl> element(new AddStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisAddStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddStructuralFeatureValueAction> umlFactoryImpl::createAddStructuralFeatureValueAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<AddStructuralFeatureValueActionImpl> element(new AddStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisAddStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddStructuralFeatureValueAction> umlFactoryImpl::createAddStructuralFeatureValueAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<AddStructuralFeatureValueActionImpl> element(new AddStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisAddStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddVariableValueAction> umlFactoryImpl::createAddVariableValueAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<AddVariableValueActionImpl> element(new AddVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisAddVariableValueActionPtr(element);
	return element;
}
std::shared_ptr<AddVariableValueAction> umlFactoryImpl::createAddVariableValueAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<AddVariableValueActionImpl> element(new AddVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisAddVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddVariableValueAction> umlFactoryImpl::createAddVariableValueAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<AddVariableValueActionImpl> element(new AddVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisAddVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddVariableValueAction> umlFactoryImpl::createAddVariableValueAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<AddVariableValueActionImpl> element(new AddVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisAddVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddVariableValueAction> umlFactoryImpl::createAddVariableValueAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<AddVariableValueActionImpl> element(new AddVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisAddVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddVariableValueAction> umlFactoryImpl::createAddVariableValueAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<AddVariableValueActionImpl> element(new AddVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisAddVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddVariableValueAction> umlFactoryImpl::createAddVariableValueAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<AddVariableValueActionImpl> element(new AddVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisAddVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddVariableValueAction> umlFactoryImpl::createAddVariableValueAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<AddVariableValueActionImpl> element(new AddVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisAddVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddVariableValueAction> umlFactoryImpl::createAddVariableValueAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<AddVariableValueActionImpl> element(new AddVariableValueActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisAddVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddVariableValueAction> umlFactoryImpl::createAddVariableValueAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<AddVariableValueActionImpl> element(new AddVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisAddVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddVariableValueAction> umlFactoryImpl::createAddVariableValueAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<AddVariableValueActionImpl> element(new AddVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisAddVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddVariableValueAction> umlFactoryImpl::createAddVariableValueAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<AddVariableValueActionImpl> element(new AddVariableValueActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisAddVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddVariableValueAction> umlFactoryImpl::createAddVariableValueAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<AddVariableValueActionImpl> element(new AddVariableValueActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisAddVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddVariableValueAction> umlFactoryImpl::createAddVariableValueAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<AddVariableValueActionImpl> element(new AddVariableValueActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisAddVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddVariableValueAction> umlFactoryImpl::createAddVariableValueAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<AddVariableValueActionImpl> element(new AddVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisAddVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddVariableValueAction> umlFactoryImpl::createAddVariableValueAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<AddVariableValueActionImpl> element(new AddVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisAddVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddVariableValueAction> umlFactoryImpl::createAddVariableValueAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<AddVariableValueActionImpl> element(new AddVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisAddVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddVariableValueAction> umlFactoryImpl::createAddVariableValueAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<AddVariableValueActionImpl> element(new AddVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisAddVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AddVariableValueAction> umlFactoryImpl::createAddVariableValueAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<AddVariableValueActionImpl> element(new AddVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisAddVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<AnyReceiveEvent> umlFactoryImpl::createAnyReceiveEvent(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<AnyReceiveEventImpl> element(new AnyReceiveEventImpl());
	element->setMetaElementID(metaElementID);
	element->setThisAnyReceiveEventPtr(element);
	return element;
}
std::shared_ptr<AnyReceiveEvent> umlFactoryImpl::createAnyReceiveEvent_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<AnyReceiveEventImpl> element(new AnyReceiveEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisAnyReceiveEventPtr(element);
	return element;
	
}
std::shared_ptr<AnyReceiveEvent> umlFactoryImpl::createAnyReceiveEvent_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<AnyReceiveEventImpl> element(new AnyReceiveEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisAnyReceiveEventPtr(element);
	return element;
	
}
std::shared_ptr<AnyReceiveEvent> umlFactoryImpl::createAnyReceiveEvent_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<AnyReceiveEventImpl> element(new AnyReceiveEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisAnyReceiveEventPtr(element);
	return element;
	
}
std::shared_ptr<AnyReceiveEvent> umlFactoryImpl::createAnyReceiveEvent_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<AnyReceiveEventImpl> element(new AnyReceiveEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisAnyReceiveEventPtr(element);
	return element;
	
}
std::shared_ptr<AnyReceiveEvent> umlFactoryImpl::createAnyReceiveEvent_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<AnyReceiveEventImpl> element(new AnyReceiveEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisAnyReceiveEventPtr(element);
	return element;
	
}
std::shared_ptr<AnyReceiveEvent> umlFactoryImpl::createAnyReceiveEvent_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<AnyReceiveEventImpl> element(new AnyReceiveEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisAnyReceiveEventPtr(element);
	return element;
	
}
std::shared_ptr<AnyReceiveEvent> umlFactoryImpl::createAnyReceiveEvent_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<AnyReceiveEventImpl> element(new AnyReceiveEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisAnyReceiveEventPtr(element);
	return element;
	
}
std::shared_ptr<AnyReceiveEvent> umlFactoryImpl::createAnyReceiveEvent_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<AnyReceiveEventImpl> element(new AnyReceiveEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisAnyReceiveEventPtr(element);
	return element;
	
}
std::shared_ptr<AnyReceiveEvent> umlFactoryImpl::createAnyReceiveEvent_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<AnyReceiveEventImpl> element(new AnyReceiveEventImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisAnyReceiveEventPtr(element);
	return element;
	
}
std::shared_ptr<AnyReceiveEvent> umlFactoryImpl::createAnyReceiveEvent_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<AnyReceiveEventImpl> element(new AnyReceiveEventImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisAnyReceiveEventPtr(element);
	return element;
	
}
std::shared_ptr<AnyReceiveEvent> umlFactoryImpl::createAnyReceiveEvent_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<AnyReceiveEventImpl> element(new AnyReceiveEventImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisAnyReceiveEventPtr(element);
	return element;
	
}
std::shared_ptr<AnyReceiveEvent> umlFactoryImpl::createAnyReceiveEvent_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<AnyReceiveEventImpl> element(new AnyReceiveEventImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisAnyReceiveEventPtr(element);
	return element;
	
}
std::shared_ptr<AnyReceiveEvent> umlFactoryImpl::createAnyReceiveEvent_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<AnyReceiveEventImpl> element(new AnyReceiveEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisAnyReceiveEventPtr(element);
	return element;
	
}
std::shared_ptr<AnyReceiveEvent> umlFactoryImpl::createAnyReceiveEvent_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<AnyReceiveEventImpl> element(new AnyReceiveEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisAnyReceiveEventPtr(element);
	return element;
	
}
std::shared_ptr<AnyReceiveEvent> umlFactoryImpl::createAnyReceiveEvent_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<AnyReceiveEventImpl> element(new AnyReceiveEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisAnyReceiveEventPtr(element);
	return element;
	
}
std::shared_ptr<AnyReceiveEvent> umlFactoryImpl::createAnyReceiveEvent_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<AnyReceiveEventImpl> element(new AnyReceiveEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisAnyReceiveEventPtr(element);
	return element;
	
}
std::shared_ptr<AnyReceiveEvent> umlFactoryImpl::createAnyReceiveEvent_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<AnyReceiveEventImpl> element(new AnyReceiveEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisAnyReceiveEventPtr(element);
	return element;
	
}
std::shared_ptr<Argument> umlFactoryImpl::createArgument(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ArgumentImpl> element(new ArgumentImpl());
	element->setMetaElementID(metaElementID);
	element->setThisArgumentPtr(element);
	return element;
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl());
	element->setMetaElementID(metaElementID);
	element->setThisArtifactPtr(element);
	return element;
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_classifier_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->setClassifier(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_contract_in_Substitution(std::shared_ptr<Substitution> par_Substitution, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Substitution)
	{
		par_Substitution->setContract(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_deployedArtifact_in_Deployment(std::shared_ptr<Deployment> par_Deployment, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Deployment)
	{
		par_Deployment->getDeployedArtifact()->push_back(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_endType_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getEndType()->push_back(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_general_in_Generalization(std::shared_ptr<Generalization> par_Generalization, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Generalization)
	{
		par_Generalization->setGeneral(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_nestedArtifact_in_Artifact(std::shared_ptr<Artifact> par_Artifact, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Artifact)
	{
		par_Artifact->getNestedArtifact()->push_back(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_nestedClassifier_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getNestedClassifier()->push_back(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_nestedClassifier_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getNestedClassifier()->push_back(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_ownedType_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl(par_Package, uml::umlPackage::TYPE_ATTRIBUTE_PACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getOwnedType()->push_back(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_realizingClassifier_in_ComponentRealization(std::shared_ptr<ComponentRealization> par_ComponentRealization, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ComponentRealization)
	{
		par_ComponentRealization->getRealizingClassifier()->push_back(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_redefinedClassifier_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getRedefinedClassifier()->push_back(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Artifact> umlFactoryImpl::createArtifact_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<ArtifactImpl> element(new ArtifactImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisArtifactPtr(element);
	return element;
	
}
std::shared_ptr<Association> umlFactoryImpl::createAssociation(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<AssociationImpl> element(new AssociationImpl());
	element->setMetaElementID(metaElementID);
	element->setThisAssociationPtr(element);
	return element;
}
std::shared_ptr<Association> umlFactoryImpl::createAssociation_as_classifier_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<AssociationImpl> element(new AssociationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->setClassifier(element);
	}
	
	element->setThisAssociationPtr(element);
	return element;
	
}
std::shared_ptr<Association> umlFactoryImpl::createAssociation_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<AssociationImpl> element(new AssociationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisAssociationPtr(element);
	return element;
	
}
std::shared_ptr<Association> umlFactoryImpl::createAssociation_as_contract_in_Substitution(std::shared_ptr<Substitution> par_Substitution, const int metaElementID) const
{
	std::shared_ptr<AssociationImpl> element(new AssociationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Substitution)
	{
		par_Substitution->setContract(element);
	}
	
	element->setThisAssociationPtr(element);
	return element;
	
}
std::shared_ptr<Association> umlFactoryImpl::createAssociation_as_endType_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<AssociationImpl> element(new AssociationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getEndType()->push_back(element);
	}
	
	element->setThisAssociationPtr(element);
	return element;
	
}
std::shared_ptr<Association> umlFactoryImpl::createAssociation_as_general_in_Generalization(std::shared_ptr<Generalization> par_Generalization, const int metaElementID) const
{
	std::shared_ptr<AssociationImpl> element(new AssociationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Generalization)
	{
		par_Generalization->setGeneral(element);
	}
	
	element->setThisAssociationPtr(element);
	return element;
	
}
std::shared_ptr<Association> umlFactoryImpl::createAssociation_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<AssociationImpl> element(new AssociationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisAssociationPtr(element);
	return element;
	
}
std::shared_ptr<Association> umlFactoryImpl::createAssociation_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<AssociationImpl> element(new AssociationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisAssociationPtr(element);
	return element;
	
}
std::shared_ptr<Association> umlFactoryImpl::createAssociation_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<AssociationImpl> element(new AssociationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisAssociationPtr(element);
	return element;
	
}
std::shared_ptr<Association> umlFactoryImpl::createAssociation_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<AssociationImpl> element(new AssociationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisAssociationPtr(element);
	return element;
	
}
std::shared_ptr<Association> umlFactoryImpl::createAssociation_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<AssociationImpl> element(new AssociationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisAssociationPtr(element);
	return element;
	
}
std::shared_ptr<Association> umlFactoryImpl::createAssociation_as_nestedClassifier_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<AssociationImpl> element(new AssociationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getNestedClassifier()->push_back(element);
	}
	
	element->setThisAssociationPtr(element);
	return element;
	
}
std::shared_ptr<Association> umlFactoryImpl::createAssociation_as_nestedClassifier_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<AssociationImpl> element(new AssociationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getNestedClassifier()->push_back(element);
	}
	
	element->setThisAssociationPtr(element);
	return element;
	
}
std::shared_ptr<Association> umlFactoryImpl::createAssociation_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<AssociationImpl> element(new AssociationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisAssociationPtr(element);
	return element;
	
}
std::shared_ptr<Association> umlFactoryImpl::createAssociation_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<AssociationImpl> element(new AssociationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisAssociationPtr(element);
	return element;
	
}
std::shared_ptr<Association> umlFactoryImpl::createAssociation_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<AssociationImpl> element(new AssociationImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisAssociationPtr(element);
	return element;
	
}
std::shared_ptr<Association> umlFactoryImpl::createAssociation_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<AssociationImpl> element(new AssociationImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisAssociationPtr(element);
	return element;
	
}
std::shared_ptr<Association> umlFactoryImpl::createAssociation_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<AssociationImpl> element(new AssociationImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisAssociationPtr(element);
	return element;
	
}
std::shared_ptr<Association> umlFactoryImpl::createAssociation_as_ownedType_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<AssociationImpl> element(new AssociationImpl(par_Package, uml::umlPackage::TYPE_ATTRIBUTE_PACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getOwnedType()->push_back(element);
	}
	
	element->setThisAssociationPtr(element);
	return element;
	
}
std::shared_ptr<Association> umlFactoryImpl::createAssociation_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<AssociationImpl> element(new AssociationImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisAssociationPtr(element);
	return element;
	
}
std::shared_ptr<Association> umlFactoryImpl::createAssociation_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<AssociationImpl> element(new AssociationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisAssociationPtr(element);
	return element;
	
}
std::shared_ptr<Association> umlFactoryImpl::createAssociation_as_realizingClassifier_in_ComponentRealization(std::shared_ptr<ComponentRealization> par_ComponentRealization, const int metaElementID) const
{
	std::shared_ptr<AssociationImpl> element(new AssociationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ComponentRealization)
	{
		par_ComponentRealization->getRealizingClassifier()->push_back(element);
	}
	
	element->setThisAssociationPtr(element);
	return element;
	
}
std::shared_ptr<Association> umlFactoryImpl::createAssociation_as_redefinedClassifier_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<AssociationImpl> element(new AssociationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getRedefinedClassifier()->push_back(element);
	}
	
	element->setThisAssociationPtr(element);
	return element;
	
}
std::shared_ptr<Association> umlFactoryImpl::createAssociation_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<AssociationImpl> element(new AssociationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisAssociationPtr(element);
	return element;
	
}
std::shared_ptr<Association> umlFactoryImpl::createAssociation_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<AssociationImpl> element(new AssociationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisAssociationPtr(element);
	return element;
	
}
std::shared_ptr<Association> umlFactoryImpl::createAssociation_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<AssociationImpl> element(new AssociationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisAssociationPtr(element);
	return element;
	
}
std::shared_ptr<Association> umlFactoryImpl::createAssociation_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<AssociationImpl> element(new AssociationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisAssociationPtr(element);
	return element;
	
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl());
	element->setMetaElementID(metaElementID);
	element->setThisAssociationClassPtr(element);
	return element;
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass_as_classifier_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->setClassifier(element);
	}
	
	element->setThisAssociationClassPtr(element);
	return element;
	
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisAssociationClassPtr(element);
	return element;
	
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass_as_context_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->setContext(element);
	}
	
	element->setThisAssociationClassPtr(element);
	return element;
	
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass_as_contract_in_Substitution(std::shared_ptr<Substitution> par_Substitution, const int metaElementID) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Substitution)
	{
		par_Substitution->setContract(element);
	}
	
	element->setThisAssociationClassPtr(element);
	return element;
	
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass_as_endType_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getEndType()->push_back(element);
	}
	
	element->setThisAssociationClassPtr(element);
	return element;
	
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass_as_general_in_Generalization(std::shared_ptr<Generalization> par_Generalization, const int metaElementID) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Generalization)
	{
		par_Generalization->setGeneral(element);
	}
	
	element->setThisAssociationClassPtr(element);
	return element;
	
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisAssociationClassPtr(element);
	return element;
	
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisAssociationClassPtr(element);
	return element;
	
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisAssociationClassPtr(element);
	return element;
	
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisAssociationClassPtr(element);
	return element;
	
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisAssociationClassPtr(element);
	return element;
	
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass_as_nestedClassifier_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getNestedClassifier()->push_back(element);
	}
	
	element->setThisAssociationClassPtr(element);
	return element;
	
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass_as_nestedClassifier_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getNestedClassifier()->push_back(element);
	}
	
	element->setThisAssociationClassPtr(element);
	return element;
	
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisAssociationClassPtr(element);
	return element;
	
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisAssociationClassPtr(element);
	return element;
	
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisAssociationClassPtr(element);
	return element;
	
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisAssociationClassPtr(element);
	return element;
	
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisAssociationClassPtr(element);
	return element;
	
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass_as_ownedType_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl(par_Package, uml::umlPackage::TYPE_ATTRIBUTE_PACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getOwnedType()->push_back(element);
	}
	
	element->setThisAssociationClassPtr(element);
	return element;
	
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisAssociationClassPtr(element);
	return element;
	
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisAssociationClassPtr(element);
	return element;
	
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass_as_realizingClassifier_in_ComponentRealization(std::shared_ptr<ComponentRealization> par_ComponentRealization, const int metaElementID) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ComponentRealization)
	{
		par_ComponentRealization->getRealizingClassifier()->push_back(element);
	}
	
	element->setThisAssociationClassPtr(element);
	return element;
	
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass_as_redefinedClassifier_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getRedefinedClassifier()->push_back(element);
	}
	
	element->setThisAssociationClassPtr(element);
	return element;
	
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisAssociationClassPtr(element);
	return element;
	
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisAssociationClassPtr(element);
	return element;
	
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisAssociationClassPtr(element);
	return element;
	
}
std::shared_ptr<AssociationClass> umlFactoryImpl::createAssociationClass_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<AssociationClassImpl> element(new AssociationClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisAssociationClassPtr(element);
	return element;
	
}
std::shared_ptr<BehaviorExecutionSpecification> umlFactoryImpl::createBehaviorExecutionSpecification(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<BehaviorExecutionSpecificationImpl> element(new BehaviorExecutionSpecificationImpl());
	element->setMetaElementID(metaElementID);
	element->setThisBehaviorExecutionSpecificationPtr(element);
	return element;
}
std::shared_ptr<BehaviorExecutionSpecification> umlFactoryImpl::createBehaviorExecutionSpecification_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<BehaviorExecutionSpecificationImpl> element(new BehaviorExecutionSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisBehaviorExecutionSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<BehaviorExecutionSpecification> umlFactoryImpl::createBehaviorExecutionSpecification_as_fragment_in_Interaction(std::weak_ptr<uml::Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<BehaviorExecutionSpecificationImpl> element(new BehaviorExecutionSpecificationImpl(par_Interaction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Interaction.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisBehaviorExecutionSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<BehaviorExecutionSpecification> umlFactoryImpl::createBehaviorExecutionSpecification_as_fragment_in_InteractionOperand(std::weak_ptr<uml::InteractionOperand> par_InteractionOperand, const int metaElementID) const
{
	std::shared_ptr<BehaviorExecutionSpecificationImpl> element(new BehaviorExecutionSpecificationImpl(par_InteractionOperand));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_InteractionOperand.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisBehaviorExecutionSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<BehaviorExecutionSpecification> umlFactoryImpl::createBehaviorExecutionSpecification_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<BehaviorExecutionSpecificationImpl> element(new BehaviorExecutionSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisBehaviorExecutionSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<BehaviorExecutionSpecification> umlFactoryImpl::createBehaviorExecutionSpecification_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<BehaviorExecutionSpecificationImpl> element(new BehaviorExecutionSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisBehaviorExecutionSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<BehaviorExecutionSpecification> umlFactoryImpl::createBehaviorExecutionSpecification_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<BehaviorExecutionSpecificationImpl> element(new BehaviorExecutionSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisBehaviorExecutionSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<BehaviorExecutionSpecification> umlFactoryImpl::createBehaviorExecutionSpecification_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<BehaviorExecutionSpecificationImpl> element(new BehaviorExecutionSpecificationImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisBehaviorExecutionSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<BehaviorExecutionSpecification> umlFactoryImpl::createBehaviorExecutionSpecification_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<BehaviorExecutionSpecificationImpl> element(new BehaviorExecutionSpecificationImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisBehaviorExecutionSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<BehaviorExecutionSpecification> umlFactoryImpl::createBehaviorExecutionSpecification_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<BehaviorExecutionSpecificationImpl> element(new BehaviorExecutionSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisBehaviorExecutionSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<BehaviorExecutionSpecification> umlFactoryImpl::createBehaviorExecutionSpecification_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<BehaviorExecutionSpecificationImpl> element(new BehaviorExecutionSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisBehaviorExecutionSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<BehaviorExecutionSpecification> umlFactoryImpl::createBehaviorExecutionSpecification_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<BehaviorExecutionSpecificationImpl> element(new BehaviorExecutionSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisBehaviorExecutionSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<BroadcastSignalAction> umlFactoryImpl::createBroadcastSignalAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<BroadcastSignalActionImpl> element(new BroadcastSignalActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisBroadcastSignalActionPtr(element);
	return element;
}
std::shared_ptr<BroadcastSignalAction> umlFactoryImpl::createBroadcastSignalAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<BroadcastSignalActionImpl> element(new BroadcastSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisBroadcastSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<BroadcastSignalAction> umlFactoryImpl::createBroadcastSignalAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<BroadcastSignalActionImpl> element(new BroadcastSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisBroadcastSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<BroadcastSignalAction> umlFactoryImpl::createBroadcastSignalAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<BroadcastSignalActionImpl> element(new BroadcastSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisBroadcastSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<BroadcastSignalAction> umlFactoryImpl::createBroadcastSignalAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<BroadcastSignalActionImpl> element(new BroadcastSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisBroadcastSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<BroadcastSignalAction> umlFactoryImpl::createBroadcastSignalAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<BroadcastSignalActionImpl> element(new BroadcastSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisBroadcastSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<BroadcastSignalAction> umlFactoryImpl::createBroadcastSignalAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<BroadcastSignalActionImpl> element(new BroadcastSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisBroadcastSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<BroadcastSignalAction> umlFactoryImpl::createBroadcastSignalAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<BroadcastSignalActionImpl> element(new BroadcastSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisBroadcastSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<BroadcastSignalAction> umlFactoryImpl::createBroadcastSignalAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<BroadcastSignalActionImpl> element(new BroadcastSignalActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisBroadcastSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<BroadcastSignalAction> umlFactoryImpl::createBroadcastSignalAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<BroadcastSignalActionImpl> element(new BroadcastSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisBroadcastSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<BroadcastSignalAction> umlFactoryImpl::createBroadcastSignalAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<BroadcastSignalActionImpl> element(new BroadcastSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisBroadcastSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<BroadcastSignalAction> umlFactoryImpl::createBroadcastSignalAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<BroadcastSignalActionImpl> element(new BroadcastSignalActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisBroadcastSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<BroadcastSignalAction> umlFactoryImpl::createBroadcastSignalAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<BroadcastSignalActionImpl> element(new BroadcastSignalActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisBroadcastSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<BroadcastSignalAction> umlFactoryImpl::createBroadcastSignalAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<BroadcastSignalActionImpl> element(new BroadcastSignalActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisBroadcastSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<BroadcastSignalAction> umlFactoryImpl::createBroadcastSignalAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<BroadcastSignalActionImpl> element(new BroadcastSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisBroadcastSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<BroadcastSignalAction> umlFactoryImpl::createBroadcastSignalAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<BroadcastSignalActionImpl> element(new BroadcastSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisBroadcastSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<BroadcastSignalAction> umlFactoryImpl::createBroadcastSignalAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<BroadcastSignalActionImpl> element(new BroadcastSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisBroadcastSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<BroadcastSignalAction> umlFactoryImpl::createBroadcastSignalAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<BroadcastSignalActionImpl> element(new BroadcastSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisBroadcastSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<BroadcastSignalAction> umlFactoryImpl::createBroadcastSignalAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<BroadcastSignalActionImpl> element(new BroadcastSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisBroadcastSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<CallBehaviorAction> umlFactoryImpl::createCallBehaviorAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<CallBehaviorActionImpl> element(new CallBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisCallBehaviorActionPtr(element);
	return element;
}
std::shared_ptr<CallBehaviorAction> umlFactoryImpl::createCallBehaviorAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<CallBehaviorActionImpl> element(new CallBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisCallBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<CallBehaviorAction> umlFactoryImpl::createCallBehaviorAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<CallBehaviorActionImpl> element(new CallBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisCallBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<CallBehaviorAction> umlFactoryImpl::createCallBehaviorAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<CallBehaviorActionImpl> element(new CallBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisCallBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<CallBehaviorAction> umlFactoryImpl::createCallBehaviorAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<CallBehaviorActionImpl> element(new CallBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisCallBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<CallBehaviorAction> umlFactoryImpl::createCallBehaviorAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<CallBehaviorActionImpl> element(new CallBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisCallBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<CallBehaviorAction> umlFactoryImpl::createCallBehaviorAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<CallBehaviorActionImpl> element(new CallBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisCallBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<CallBehaviorAction> umlFactoryImpl::createCallBehaviorAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<CallBehaviorActionImpl> element(new CallBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisCallBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<CallBehaviorAction> umlFactoryImpl::createCallBehaviorAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<CallBehaviorActionImpl> element(new CallBehaviorActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisCallBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<CallBehaviorAction> umlFactoryImpl::createCallBehaviorAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<CallBehaviorActionImpl> element(new CallBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisCallBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<CallBehaviorAction> umlFactoryImpl::createCallBehaviorAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<CallBehaviorActionImpl> element(new CallBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisCallBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<CallBehaviorAction> umlFactoryImpl::createCallBehaviorAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<CallBehaviorActionImpl> element(new CallBehaviorActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisCallBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<CallBehaviorAction> umlFactoryImpl::createCallBehaviorAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<CallBehaviorActionImpl> element(new CallBehaviorActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisCallBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<CallBehaviorAction> umlFactoryImpl::createCallBehaviorAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<CallBehaviorActionImpl> element(new CallBehaviorActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisCallBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<CallBehaviorAction> umlFactoryImpl::createCallBehaviorAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<CallBehaviorActionImpl> element(new CallBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisCallBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<CallBehaviorAction> umlFactoryImpl::createCallBehaviorAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<CallBehaviorActionImpl> element(new CallBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisCallBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<CallBehaviorAction> umlFactoryImpl::createCallBehaviorAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<CallBehaviorActionImpl> element(new CallBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisCallBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<CallBehaviorAction> umlFactoryImpl::createCallBehaviorAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<CallBehaviorActionImpl> element(new CallBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisCallBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<CallBehaviorAction> umlFactoryImpl::createCallBehaviorAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<CallBehaviorActionImpl> element(new CallBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisCallBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<CallEvent> umlFactoryImpl::createCallEvent(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<CallEventImpl> element(new CallEventImpl());
	element->setMetaElementID(metaElementID);
	element->setThisCallEventPtr(element);
	return element;
}
std::shared_ptr<CallEvent> umlFactoryImpl::createCallEvent_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<CallEventImpl> element(new CallEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisCallEventPtr(element);
	return element;
	
}
std::shared_ptr<CallEvent> umlFactoryImpl::createCallEvent_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<CallEventImpl> element(new CallEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisCallEventPtr(element);
	return element;
	
}
std::shared_ptr<CallEvent> umlFactoryImpl::createCallEvent_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<CallEventImpl> element(new CallEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisCallEventPtr(element);
	return element;
	
}
std::shared_ptr<CallEvent> umlFactoryImpl::createCallEvent_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<CallEventImpl> element(new CallEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisCallEventPtr(element);
	return element;
	
}
std::shared_ptr<CallEvent> umlFactoryImpl::createCallEvent_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<CallEventImpl> element(new CallEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisCallEventPtr(element);
	return element;
	
}
std::shared_ptr<CallEvent> umlFactoryImpl::createCallEvent_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<CallEventImpl> element(new CallEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisCallEventPtr(element);
	return element;
	
}
std::shared_ptr<CallEvent> umlFactoryImpl::createCallEvent_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<CallEventImpl> element(new CallEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisCallEventPtr(element);
	return element;
	
}
std::shared_ptr<CallEvent> umlFactoryImpl::createCallEvent_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<CallEventImpl> element(new CallEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisCallEventPtr(element);
	return element;
	
}
std::shared_ptr<CallEvent> umlFactoryImpl::createCallEvent_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<CallEventImpl> element(new CallEventImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisCallEventPtr(element);
	return element;
	
}
std::shared_ptr<CallEvent> umlFactoryImpl::createCallEvent_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<CallEventImpl> element(new CallEventImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisCallEventPtr(element);
	return element;
	
}
std::shared_ptr<CallEvent> umlFactoryImpl::createCallEvent_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<CallEventImpl> element(new CallEventImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisCallEventPtr(element);
	return element;
	
}
std::shared_ptr<CallEvent> umlFactoryImpl::createCallEvent_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<CallEventImpl> element(new CallEventImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisCallEventPtr(element);
	return element;
	
}
std::shared_ptr<CallEvent> umlFactoryImpl::createCallEvent_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<CallEventImpl> element(new CallEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisCallEventPtr(element);
	return element;
	
}
std::shared_ptr<CallEvent> umlFactoryImpl::createCallEvent_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<CallEventImpl> element(new CallEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisCallEventPtr(element);
	return element;
	
}
std::shared_ptr<CallEvent> umlFactoryImpl::createCallEvent_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<CallEventImpl> element(new CallEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisCallEventPtr(element);
	return element;
	
}
std::shared_ptr<CallEvent> umlFactoryImpl::createCallEvent_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<CallEventImpl> element(new CallEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisCallEventPtr(element);
	return element;
	
}
std::shared_ptr<CallEvent> umlFactoryImpl::createCallEvent_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<CallEventImpl> element(new CallEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisCallEventPtr(element);
	return element;
	
}
std::shared_ptr<CallOperationAction> umlFactoryImpl::createCallOperationAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<CallOperationActionImpl> element(new CallOperationActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisCallOperationActionPtr(element);
	return element;
}
std::shared_ptr<CallOperationAction> umlFactoryImpl::createCallOperationAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<CallOperationActionImpl> element(new CallOperationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisCallOperationActionPtr(element);
	return element;
	
}
std::shared_ptr<CallOperationAction> umlFactoryImpl::createCallOperationAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<CallOperationActionImpl> element(new CallOperationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisCallOperationActionPtr(element);
	return element;
	
}
std::shared_ptr<CallOperationAction> umlFactoryImpl::createCallOperationAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<CallOperationActionImpl> element(new CallOperationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisCallOperationActionPtr(element);
	return element;
	
}
std::shared_ptr<CallOperationAction> umlFactoryImpl::createCallOperationAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<CallOperationActionImpl> element(new CallOperationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisCallOperationActionPtr(element);
	return element;
	
}
std::shared_ptr<CallOperationAction> umlFactoryImpl::createCallOperationAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<CallOperationActionImpl> element(new CallOperationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisCallOperationActionPtr(element);
	return element;
	
}
std::shared_ptr<CallOperationAction> umlFactoryImpl::createCallOperationAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<CallOperationActionImpl> element(new CallOperationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisCallOperationActionPtr(element);
	return element;
	
}
std::shared_ptr<CallOperationAction> umlFactoryImpl::createCallOperationAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<CallOperationActionImpl> element(new CallOperationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisCallOperationActionPtr(element);
	return element;
	
}
std::shared_ptr<CallOperationAction> umlFactoryImpl::createCallOperationAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<CallOperationActionImpl> element(new CallOperationActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisCallOperationActionPtr(element);
	return element;
	
}
std::shared_ptr<CallOperationAction> umlFactoryImpl::createCallOperationAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<CallOperationActionImpl> element(new CallOperationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisCallOperationActionPtr(element);
	return element;
	
}
std::shared_ptr<CallOperationAction> umlFactoryImpl::createCallOperationAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<CallOperationActionImpl> element(new CallOperationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisCallOperationActionPtr(element);
	return element;
	
}
std::shared_ptr<CallOperationAction> umlFactoryImpl::createCallOperationAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<CallOperationActionImpl> element(new CallOperationActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisCallOperationActionPtr(element);
	return element;
	
}
std::shared_ptr<CallOperationAction> umlFactoryImpl::createCallOperationAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<CallOperationActionImpl> element(new CallOperationActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisCallOperationActionPtr(element);
	return element;
	
}
std::shared_ptr<CallOperationAction> umlFactoryImpl::createCallOperationAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<CallOperationActionImpl> element(new CallOperationActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisCallOperationActionPtr(element);
	return element;
	
}
std::shared_ptr<CallOperationAction> umlFactoryImpl::createCallOperationAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<CallOperationActionImpl> element(new CallOperationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisCallOperationActionPtr(element);
	return element;
	
}
std::shared_ptr<CallOperationAction> umlFactoryImpl::createCallOperationAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<CallOperationActionImpl> element(new CallOperationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisCallOperationActionPtr(element);
	return element;
	
}
std::shared_ptr<CallOperationAction> umlFactoryImpl::createCallOperationAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<CallOperationActionImpl> element(new CallOperationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisCallOperationActionPtr(element);
	return element;
	
}
std::shared_ptr<CallOperationAction> umlFactoryImpl::createCallOperationAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<CallOperationActionImpl> element(new CallOperationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisCallOperationActionPtr(element);
	return element;
	
}
std::shared_ptr<CallOperationAction> umlFactoryImpl::createCallOperationAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<CallOperationActionImpl> element(new CallOperationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisCallOperationActionPtr(element);
	return element;
	
}
std::shared_ptr<CentralBufferNode> umlFactoryImpl::createCentralBufferNode(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<CentralBufferNodeImpl> element(new CentralBufferNodeImpl());
	element->setMetaElementID(metaElementID);
	element->setThisCentralBufferNodePtr(element);
	return element;
}
std::shared_ptr<CentralBufferNode> umlFactoryImpl::createCentralBufferNode_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<CentralBufferNodeImpl> element(new CentralBufferNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisCentralBufferNodePtr(element);
	return element;
	
}
std::shared_ptr<CentralBufferNode> umlFactoryImpl::createCentralBufferNode_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<CentralBufferNodeImpl> element(new CentralBufferNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisCentralBufferNodePtr(element);
	return element;
	
}
std::shared_ptr<CentralBufferNode> umlFactoryImpl::createCentralBufferNode_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<CentralBufferNodeImpl> element(new CentralBufferNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisCentralBufferNodePtr(element);
	return element;
	
}
std::shared_ptr<CentralBufferNode> umlFactoryImpl::createCentralBufferNode_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<CentralBufferNodeImpl> element(new CentralBufferNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisCentralBufferNodePtr(element);
	return element;
	
}
std::shared_ptr<CentralBufferNode> umlFactoryImpl::createCentralBufferNode_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<CentralBufferNodeImpl> element(new CentralBufferNodeImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisCentralBufferNodePtr(element);
	return element;
	
}
std::shared_ptr<CentralBufferNode> umlFactoryImpl::createCentralBufferNode_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<CentralBufferNodeImpl> element(new CentralBufferNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisCentralBufferNodePtr(element);
	return element;
	
}
std::shared_ptr<CentralBufferNode> umlFactoryImpl::createCentralBufferNode_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<CentralBufferNodeImpl> element(new CentralBufferNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisCentralBufferNodePtr(element);
	return element;
	
}
std::shared_ptr<CentralBufferNode> umlFactoryImpl::createCentralBufferNode_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<CentralBufferNodeImpl> element(new CentralBufferNodeImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisCentralBufferNodePtr(element);
	return element;
	
}
std::shared_ptr<CentralBufferNode> umlFactoryImpl::createCentralBufferNode_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<CentralBufferNodeImpl> element(new CentralBufferNodeImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisCentralBufferNodePtr(element);
	return element;
	
}
std::shared_ptr<CentralBufferNode> umlFactoryImpl::createCentralBufferNode_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<CentralBufferNodeImpl> element(new CentralBufferNodeImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisCentralBufferNodePtr(element);
	return element;
	
}
std::shared_ptr<CentralBufferNode> umlFactoryImpl::createCentralBufferNode_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<CentralBufferNodeImpl> element(new CentralBufferNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisCentralBufferNodePtr(element);
	return element;
	
}
std::shared_ptr<CentralBufferNode> umlFactoryImpl::createCentralBufferNode_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<CentralBufferNodeImpl> element(new CentralBufferNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisCentralBufferNodePtr(element);
	return element;
	
}
std::shared_ptr<CentralBufferNode> umlFactoryImpl::createCentralBufferNode_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<CentralBufferNodeImpl> element(new CentralBufferNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisCentralBufferNodePtr(element);
	return element;
	
}
std::shared_ptr<CentralBufferNode> umlFactoryImpl::createCentralBufferNode_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<CentralBufferNodeImpl> element(new CentralBufferNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisCentralBufferNodePtr(element);
	return element;
	
}
std::shared_ptr<CentralBufferNode> umlFactoryImpl::createCentralBufferNode_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<CentralBufferNodeImpl> element(new CentralBufferNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisCentralBufferNodePtr(element);
	return element;
	
}
std::shared_ptr<ChangeEvent> umlFactoryImpl::createChangeEvent(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ChangeEventImpl> element(new ChangeEventImpl());
	element->setMetaElementID(metaElementID);
	element->setThisChangeEventPtr(element);
	return element;
}
std::shared_ptr<ChangeEvent> umlFactoryImpl::createChangeEvent_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ChangeEventImpl> element(new ChangeEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisChangeEventPtr(element);
	return element;
	
}
std::shared_ptr<ChangeEvent> umlFactoryImpl::createChangeEvent_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<ChangeEventImpl> element(new ChangeEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisChangeEventPtr(element);
	return element;
	
}
std::shared_ptr<ChangeEvent> umlFactoryImpl::createChangeEvent_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ChangeEventImpl> element(new ChangeEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisChangeEventPtr(element);
	return element;
	
}
std::shared_ptr<ChangeEvent> umlFactoryImpl::createChangeEvent_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ChangeEventImpl> element(new ChangeEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisChangeEventPtr(element);
	return element;
	
}
std::shared_ptr<ChangeEvent> umlFactoryImpl::createChangeEvent_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ChangeEventImpl> element(new ChangeEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisChangeEventPtr(element);
	return element;
	
}
std::shared_ptr<ChangeEvent> umlFactoryImpl::createChangeEvent_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ChangeEventImpl> element(new ChangeEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisChangeEventPtr(element);
	return element;
	
}
std::shared_ptr<ChangeEvent> umlFactoryImpl::createChangeEvent_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<ChangeEventImpl> element(new ChangeEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisChangeEventPtr(element);
	return element;
	
}
std::shared_ptr<ChangeEvent> umlFactoryImpl::createChangeEvent_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ChangeEventImpl> element(new ChangeEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisChangeEventPtr(element);
	return element;
	
}
std::shared_ptr<ChangeEvent> umlFactoryImpl::createChangeEvent_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ChangeEventImpl> element(new ChangeEventImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisChangeEventPtr(element);
	return element;
	
}
std::shared_ptr<ChangeEvent> umlFactoryImpl::createChangeEvent_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ChangeEventImpl> element(new ChangeEventImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisChangeEventPtr(element);
	return element;
	
}
std::shared_ptr<ChangeEvent> umlFactoryImpl::createChangeEvent_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ChangeEventImpl> element(new ChangeEventImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisChangeEventPtr(element);
	return element;
	
}
std::shared_ptr<ChangeEvent> umlFactoryImpl::createChangeEvent_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<ChangeEventImpl> element(new ChangeEventImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisChangeEventPtr(element);
	return element;
	
}
std::shared_ptr<ChangeEvent> umlFactoryImpl::createChangeEvent_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<ChangeEventImpl> element(new ChangeEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisChangeEventPtr(element);
	return element;
	
}
std::shared_ptr<ChangeEvent> umlFactoryImpl::createChangeEvent_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ChangeEventImpl> element(new ChangeEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisChangeEventPtr(element);
	return element;
	
}
std::shared_ptr<ChangeEvent> umlFactoryImpl::createChangeEvent_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ChangeEventImpl> element(new ChangeEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisChangeEventPtr(element);
	return element;
	
}
std::shared_ptr<ChangeEvent> umlFactoryImpl::createChangeEvent_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ChangeEventImpl> element(new ChangeEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisChangeEventPtr(element);
	return element;
	
}
std::shared_ptr<ChangeEvent> umlFactoryImpl::createChangeEvent_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<ChangeEventImpl> element(new ChangeEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisChangeEventPtr(element);
	return element;
	
}
std::shared_ptr<Class> umlFactoryImpl::createClass(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl());
	element->setMetaElementID(metaElementID);
	element->setThisClassPtr(element);
	return element;
}
std::shared_ptr<Class> umlFactoryImpl::createClass_as_classifier_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->setClassifier(element);
	}
	
	element->setThisClassPtr(element);
	return element;
	
}
std::shared_ptr<Class> umlFactoryImpl::createClass_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisClassPtr(element);
	return element;
	
}
std::shared_ptr<Class> umlFactoryImpl::createClass_as_context_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->setContext(element);
	}
	
	element->setThisClassPtr(element);
	return element;
	
}
std::shared_ptr<Class> umlFactoryImpl::createClass_as_contract_in_Substitution(std::shared_ptr<Substitution> par_Substitution, const int metaElementID) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Substitution)
	{
		par_Substitution->setContract(element);
	}
	
	element->setThisClassPtr(element);
	return element;
	
}
std::shared_ptr<Class> umlFactoryImpl::createClass_as_endType_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getEndType()->push_back(element);
	}
	
	element->setThisClassPtr(element);
	return element;
	
}
std::shared_ptr<Class> umlFactoryImpl::createClass_as_general_in_Generalization(std::shared_ptr<Generalization> par_Generalization, const int metaElementID) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Generalization)
	{
		par_Generalization->setGeneral(element);
	}
	
	element->setThisClassPtr(element);
	return element;
	
}
std::shared_ptr<Class> umlFactoryImpl::createClass_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisClassPtr(element);
	return element;
	
}
std::shared_ptr<Class> umlFactoryImpl::createClass_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisClassPtr(element);
	return element;
	
}
std::shared_ptr<Class> umlFactoryImpl::createClass_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisClassPtr(element);
	return element;
	
}
std::shared_ptr<Class> umlFactoryImpl::createClass_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisClassPtr(element);
	return element;
	
}
std::shared_ptr<Class> umlFactoryImpl::createClass_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisClassPtr(element);
	return element;
	
}
std::shared_ptr<Class> umlFactoryImpl::createClass_as_nestedClassifier_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getNestedClassifier()->push_back(element);
	}
	
	element->setThisClassPtr(element);
	return element;
	
}
std::shared_ptr<Class> umlFactoryImpl::createClass_as_nestedClassifier_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getNestedClassifier()->push_back(element);
	}
	
	element->setThisClassPtr(element);
	return element;
	
}
std::shared_ptr<Class> umlFactoryImpl::createClass_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisClassPtr(element);
	return element;
	
}
std::shared_ptr<Class> umlFactoryImpl::createClass_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisClassPtr(element);
	return element;
	
}
std::shared_ptr<Class> umlFactoryImpl::createClass_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisClassPtr(element);
	return element;
	
}
std::shared_ptr<Class> umlFactoryImpl::createClass_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisClassPtr(element);
	return element;
	
}
std::shared_ptr<Class> umlFactoryImpl::createClass_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisClassPtr(element);
	return element;
	
}
std::shared_ptr<Class> umlFactoryImpl::createClass_as_ownedType_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl(par_Package, uml::umlPackage::TYPE_ATTRIBUTE_PACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getOwnedType()->push_back(element);
	}
	
	element->setThisClassPtr(element);
	return element;
	
}
std::shared_ptr<Class> umlFactoryImpl::createClass_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisClassPtr(element);
	return element;
	
}
std::shared_ptr<Class> umlFactoryImpl::createClass_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisClassPtr(element);
	return element;
	
}
std::shared_ptr<Class> umlFactoryImpl::createClass_as_realizingClassifier_in_ComponentRealization(std::shared_ptr<ComponentRealization> par_ComponentRealization, const int metaElementID) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ComponentRealization)
	{
		par_ComponentRealization->getRealizingClassifier()->push_back(element);
	}
	
	element->setThisClassPtr(element);
	return element;
	
}
std::shared_ptr<Class> umlFactoryImpl::createClass_as_redefinedClassifier_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getRedefinedClassifier()->push_back(element);
	}
	
	element->setThisClassPtr(element);
	return element;
	
}
std::shared_ptr<Class> umlFactoryImpl::createClass_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisClassPtr(element);
	return element;
	
}
std::shared_ptr<Class> umlFactoryImpl::createClass_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisClassPtr(element);
	return element;
	
}
std::shared_ptr<Class> umlFactoryImpl::createClass_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisClassPtr(element);
	return element;
	
}
std::shared_ptr<Class> umlFactoryImpl::createClass_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<ClassImpl> element(new ClassImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisClassPtr(element);
	return element;
	
}
std::shared_ptr<ClassifierTemplateParameter> umlFactoryImpl::createClassifierTemplateParameter(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ClassifierTemplateParameterImpl> element(new ClassifierTemplateParameterImpl());
	element->setMetaElementID(metaElementID);
	element->setThisClassifierTemplateParameterPtr(element);
	return element;
}
std::shared_ptr<ClassifierTemplateParameter> umlFactoryImpl::createClassifierTemplateParameter_as_inheritedParameter_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<ClassifierTemplateParameterImpl> element(new ClassifierTemplateParameterImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->getInheritedParameter()->push_back(element);
	}
	
	element->setThisClassifierTemplateParameterPtr(element);
	return element;
	
}
std::shared_ptr<ClassifierTemplateParameter> umlFactoryImpl::createClassifierTemplateParameter_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ClassifierTemplateParameterImpl> element(new ClassifierTemplateParameterImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisClassifierTemplateParameterPtr(element);
	return element;
	
}
std::shared_ptr<ClassifierTemplateParameter> umlFactoryImpl::createClassifierTemplateParameter_as_ownedParameter_in_TemplateSignature(std::weak_ptr<uml::TemplateSignature> par_TemplateSignature, const int metaElementID) const
{
	std::shared_ptr<ClassifierTemplateParameterImpl> element(new ClassifierTemplateParameterImpl(par_TemplateSignature));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateSignature.lock())
	{
		wp->getOwnedParameter()->push_back(element);
	}
	
	element->setThisClassifierTemplateParameterPtr(element);
	return element;
	
}
std::shared_ptr<ClassifierTemplateParameter> umlFactoryImpl::createClassifierTemplateParameter_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ClassifierTemplateParameterImpl> element(new ClassifierTemplateParameterImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisClassifierTemplateParameterPtr(element);
	return element;
	
}
std::shared_ptr<ClassifierTemplateParameter> umlFactoryImpl::createClassifierTemplateParameter_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ClassifierTemplateParameterImpl> element(new ClassifierTemplateParameterImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisClassifierTemplateParameterPtr(element);
	return element;
	
}
std::shared_ptr<Clause> umlFactoryImpl::createClause(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ClauseImpl> element(new ClauseImpl());
	element->setMetaElementID(metaElementID);
	element->setThisClausePtr(element);
	return element;
}
std::shared_ptr<Clause> umlFactoryImpl::createClause_as_clause_in_ConditionalNode(std::shared_ptr<ConditionalNode> par_ConditionalNode, const int metaElementID) const
{
	std::shared_ptr<ClauseImpl> element(new ClauseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ConditionalNode)
	{
		par_ConditionalNode->getClause()->push_back(element);
	}
	
	element->setThisClausePtr(element);
	return element;
	
}
std::shared_ptr<Clause> umlFactoryImpl::createClause_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ClauseImpl> element(new ClauseImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisClausePtr(element);
	return element;
	
}
std::shared_ptr<Clause> umlFactoryImpl::createClause_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ClauseImpl> element(new ClauseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisClausePtr(element);
	return element;
	
}
std::shared_ptr<Clause> umlFactoryImpl::createClause_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ClauseImpl> element(new ClauseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisClausePtr(element);
	return element;
	
}
std::shared_ptr<ClearAssociationAction> umlFactoryImpl::createClearAssociationAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ClearAssociationActionImpl> element(new ClearAssociationActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisClearAssociationActionPtr(element);
	return element;
}
std::shared_ptr<ClearAssociationAction> umlFactoryImpl::createClearAssociationAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<ClearAssociationActionImpl> element(new ClearAssociationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisClearAssociationActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearAssociationAction> umlFactoryImpl::createClearAssociationAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ClearAssociationActionImpl> element(new ClearAssociationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisClearAssociationActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearAssociationAction> umlFactoryImpl::createClearAssociationAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<ClearAssociationActionImpl> element(new ClearAssociationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisClearAssociationActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearAssociationAction> umlFactoryImpl::createClearAssociationAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<ClearAssociationActionImpl> element(new ClearAssociationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisClearAssociationActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearAssociationAction> umlFactoryImpl::createClearAssociationAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ClearAssociationActionImpl> element(new ClearAssociationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisClearAssociationActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearAssociationAction> umlFactoryImpl::createClearAssociationAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ClearAssociationActionImpl> element(new ClearAssociationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisClearAssociationActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearAssociationAction> umlFactoryImpl::createClearAssociationAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ClearAssociationActionImpl> element(new ClearAssociationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisClearAssociationActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearAssociationAction> umlFactoryImpl::createClearAssociationAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ClearAssociationActionImpl> element(new ClearAssociationActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisClearAssociationActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearAssociationAction> umlFactoryImpl::createClearAssociationAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<ClearAssociationActionImpl> element(new ClearAssociationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisClearAssociationActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearAssociationAction> umlFactoryImpl::createClearAssociationAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<ClearAssociationActionImpl> element(new ClearAssociationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisClearAssociationActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearAssociationAction> umlFactoryImpl::createClearAssociationAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<ClearAssociationActionImpl> element(new ClearAssociationActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisClearAssociationActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearAssociationAction> umlFactoryImpl::createClearAssociationAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ClearAssociationActionImpl> element(new ClearAssociationActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisClearAssociationActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearAssociationAction> umlFactoryImpl::createClearAssociationAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ClearAssociationActionImpl> element(new ClearAssociationActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisClearAssociationActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearAssociationAction> umlFactoryImpl::createClearAssociationAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ClearAssociationActionImpl> element(new ClearAssociationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisClearAssociationActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearAssociationAction> umlFactoryImpl::createClearAssociationAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<ClearAssociationActionImpl> element(new ClearAssociationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisClearAssociationActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearAssociationAction> umlFactoryImpl::createClearAssociationAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ClearAssociationActionImpl> element(new ClearAssociationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisClearAssociationActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearAssociationAction> umlFactoryImpl::createClearAssociationAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ClearAssociationActionImpl> element(new ClearAssociationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisClearAssociationActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearAssociationAction> umlFactoryImpl::createClearAssociationAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ClearAssociationActionImpl> element(new ClearAssociationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisClearAssociationActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearStructuralFeatureAction> umlFactoryImpl::createClearStructuralFeatureAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ClearStructuralFeatureActionImpl> element(new ClearStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisClearStructuralFeatureActionPtr(element);
	return element;
}
std::shared_ptr<ClearStructuralFeatureAction> umlFactoryImpl::createClearStructuralFeatureAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<ClearStructuralFeatureActionImpl> element(new ClearStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisClearStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearStructuralFeatureAction> umlFactoryImpl::createClearStructuralFeatureAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ClearStructuralFeatureActionImpl> element(new ClearStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisClearStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearStructuralFeatureAction> umlFactoryImpl::createClearStructuralFeatureAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<ClearStructuralFeatureActionImpl> element(new ClearStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisClearStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearStructuralFeatureAction> umlFactoryImpl::createClearStructuralFeatureAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<ClearStructuralFeatureActionImpl> element(new ClearStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisClearStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearStructuralFeatureAction> umlFactoryImpl::createClearStructuralFeatureAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ClearStructuralFeatureActionImpl> element(new ClearStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisClearStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearStructuralFeatureAction> umlFactoryImpl::createClearStructuralFeatureAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ClearStructuralFeatureActionImpl> element(new ClearStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisClearStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearStructuralFeatureAction> umlFactoryImpl::createClearStructuralFeatureAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ClearStructuralFeatureActionImpl> element(new ClearStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisClearStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearStructuralFeatureAction> umlFactoryImpl::createClearStructuralFeatureAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ClearStructuralFeatureActionImpl> element(new ClearStructuralFeatureActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisClearStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearStructuralFeatureAction> umlFactoryImpl::createClearStructuralFeatureAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<ClearStructuralFeatureActionImpl> element(new ClearStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisClearStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearStructuralFeatureAction> umlFactoryImpl::createClearStructuralFeatureAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<ClearStructuralFeatureActionImpl> element(new ClearStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisClearStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearStructuralFeatureAction> umlFactoryImpl::createClearStructuralFeatureAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<ClearStructuralFeatureActionImpl> element(new ClearStructuralFeatureActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisClearStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearStructuralFeatureAction> umlFactoryImpl::createClearStructuralFeatureAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ClearStructuralFeatureActionImpl> element(new ClearStructuralFeatureActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisClearStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearStructuralFeatureAction> umlFactoryImpl::createClearStructuralFeatureAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ClearStructuralFeatureActionImpl> element(new ClearStructuralFeatureActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisClearStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearStructuralFeatureAction> umlFactoryImpl::createClearStructuralFeatureAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ClearStructuralFeatureActionImpl> element(new ClearStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisClearStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearStructuralFeatureAction> umlFactoryImpl::createClearStructuralFeatureAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<ClearStructuralFeatureActionImpl> element(new ClearStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisClearStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearStructuralFeatureAction> umlFactoryImpl::createClearStructuralFeatureAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ClearStructuralFeatureActionImpl> element(new ClearStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisClearStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearStructuralFeatureAction> umlFactoryImpl::createClearStructuralFeatureAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ClearStructuralFeatureActionImpl> element(new ClearStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisClearStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearStructuralFeatureAction> umlFactoryImpl::createClearStructuralFeatureAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ClearStructuralFeatureActionImpl> element(new ClearStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisClearStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearVariableAction> umlFactoryImpl::createClearVariableAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ClearVariableActionImpl> element(new ClearVariableActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisClearVariableActionPtr(element);
	return element;
}
std::shared_ptr<ClearVariableAction> umlFactoryImpl::createClearVariableAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<ClearVariableActionImpl> element(new ClearVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisClearVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearVariableAction> umlFactoryImpl::createClearVariableAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ClearVariableActionImpl> element(new ClearVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisClearVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearVariableAction> umlFactoryImpl::createClearVariableAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<ClearVariableActionImpl> element(new ClearVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisClearVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearVariableAction> umlFactoryImpl::createClearVariableAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<ClearVariableActionImpl> element(new ClearVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisClearVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearVariableAction> umlFactoryImpl::createClearVariableAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ClearVariableActionImpl> element(new ClearVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisClearVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearVariableAction> umlFactoryImpl::createClearVariableAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ClearVariableActionImpl> element(new ClearVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisClearVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearVariableAction> umlFactoryImpl::createClearVariableAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ClearVariableActionImpl> element(new ClearVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisClearVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearVariableAction> umlFactoryImpl::createClearVariableAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ClearVariableActionImpl> element(new ClearVariableActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisClearVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearVariableAction> umlFactoryImpl::createClearVariableAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<ClearVariableActionImpl> element(new ClearVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisClearVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearVariableAction> umlFactoryImpl::createClearVariableAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<ClearVariableActionImpl> element(new ClearVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisClearVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearVariableAction> umlFactoryImpl::createClearVariableAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<ClearVariableActionImpl> element(new ClearVariableActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisClearVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearVariableAction> umlFactoryImpl::createClearVariableAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ClearVariableActionImpl> element(new ClearVariableActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisClearVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearVariableAction> umlFactoryImpl::createClearVariableAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ClearVariableActionImpl> element(new ClearVariableActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisClearVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearVariableAction> umlFactoryImpl::createClearVariableAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ClearVariableActionImpl> element(new ClearVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisClearVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearVariableAction> umlFactoryImpl::createClearVariableAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<ClearVariableActionImpl> element(new ClearVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisClearVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearVariableAction> umlFactoryImpl::createClearVariableAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ClearVariableActionImpl> element(new ClearVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisClearVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearVariableAction> umlFactoryImpl::createClearVariableAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ClearVariableActionImpl> element(new ClearVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisClearVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ClearVariableAction> umlFactoryImpl::createClearVariableAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ClearVariableActionImpl> element(new ClearVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisClearVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl());
	element->setMetaElementID(metaElementID);
	element->setThisCollaborationPtr(element);
	return element;
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration_as_classifier_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->setClassifier(element);
	}
	
	element->setThisCollaborationPtr(element);
	return element;
	
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisCollaborationPtr(element);
	return element;
	
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration_as_context_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->setContext(element);
	}
	
	element->setThisCollaborationPtr(element);
	return element;
	
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration_as_contract_in_Substitution(std::shared_ptr<Substitution> par_Substitution, const int metaElementID) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Substitution)
	{
		par_Substitution->setContract(element);
	}
	
	element->setThisCollaborationPtr(element);
	return element;
	
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration_as_endType_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getEndType()->push_back(element);
	}
	
	element->setThisCollaborationPtr(element);
	return element;
	
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration_as_general_in_Generalization(std::shared_ptr<Generalization> par_Generalization, const int metaElementID) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Generalization)
	{
		par_Generalization->setGeneral(element);
	}
	
	element->setThisCollaborationPtr(element);
	return element;
	
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisCollaborationPtr(element);
	return element;
	
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisCollaborationPtr(element);
	return element;
	
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisCollaborationPtr(element);
	return element;
	
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisCollaborationPtr(element);
	return element;
	
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisCollaborationPtr(element);
	return element;
	
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration_as_nestedClassifier_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getNestedClassifier()->push_back(element);
	}
	
	element->setThisCollaborationPtr(element);
	return element;
	
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration_as_nestedClassifier_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getNestedClassifier()->push_back(element);
	}
	
	element->setThisCollaborationPtr(element);
	return element;
	
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisCollaborationPtr(element);
	return element;
	
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisCollaborationPtr(element);
	return element;
	
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisCollaborationPtr(element);
	return element;
	
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisCollaborationPtr(element);
	return element;
	
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisCollaborationPtr(element);
	return element;
	
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration_as_ownedType_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl(par_Package, uml::umlPackage::TYPE_ATTRIBUTE_PACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getOwnedType()->push_back(element);
	}
	
	element->setThisCollaborationPtr(element);
	return element;
	
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisCollaborationPtr(element);
	return element;
	
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisCollaborationPtr(element);
	return element;
	
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration_as_realizingClassifier_in_ComponentRealization(std::shared_ptr<ComponentRealization> par_ComponentRealization, const int metaElementID) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ComponentRealization)
	{
		par_ComponentRealization->getRealizingClassifier()->push_back(element);
	}
	
	element->setThisCollaborationPtr(element);
	return element;
	
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration_as_redefinedClassifier_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getRedefinedClassifier()->push_back(element);
	}
	
	element->setThisCollaborationPtr(element);
	return element;
	
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisCollaborationPtr(element);
	return element;
	
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisCollaborationPtr(element);
	return element;
	
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisCollaborationPtr(element);
	return element;
	
}
std::shared_ptr<Collaboration> umlFactoryImpl::createCollaboration_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<CollaborationImpl> element(new CollaborationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisCollaborationPtr(element);
	return element;
	
}
std::shared_ptr<CollaborationUse> umlFactoryImpl::createCollaborationUse(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<CollaborationUseImpl> element(new CollaborationUseImpl());
	element->setMetaElementID(metaElementID);
	element->setThisCollaborationUsePtr(element);
	return element;
}
std::shared_ptr<CollaborationUse> umlFactoryImpl::createCollaborationUse_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<CollaborationUseImpl> element(new CollaborationUseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisCollaborationUsePtr(element);
	return element;
	
}
std::shared_ptr<CollaborationUse> umlFactoryImpl::createCollaborationUse_as_collaborationUse_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<CollaborationUseImpl> element(new CollaborationUseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getCollaborationUse()->push_back(element);
	}
	
	element->setThisCollaborationUsePtr(element);
	return element;
	
}
std::shared_ptr<CollaborationUse> umlFactoryImpl::createCollaborationUse_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<CollaborationUseImpl> element(new CollaborationUseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisCollaborationUsePtr(element);
	return element;
	
}
std::shared_ptr<CollaborationUse> umlFactoryImpl::createCollaborationUse_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<CollaborationUseImpl> element(new CollaborationUseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisCollaborationUsePtr(element);
	return element;
	
}
std::shared_ptr<CollaborationUse> umlFactoryImpl::createCollaborationUse_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<CollaborationUseImpl> element(new CollaborationUseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisCollaborationUsePtr(element);
	return element;
	
}
std::shared_ptr<CollaborationUse> umlFactoryImpl::createCollaborationUse_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<CollaborationUseImpl> element(new CollaborationUseImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisCollaborationUsePtr(element);
	return element;
	
}
std::shared_ptr<CollaborationUse> umlFactoryImpl::createCollaborationUse_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<CollaborationUseImpl> element(new CollaborationUseImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisCollaborationUsePtr(element);
	return element;
	
}
std::shared_ptr<CollaborationUse> umlFactoryImpl::createCollaborationUse_as_representation_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<CollaborationUseImpl> element(new CollaborationUseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->setRepresentation(element);
	}
	
	element->setThisCollaborationUsePtr(element);
	return element;
	
}
std::shared_ptr<CollaborationUse> umlFactoryImpl::createCollaborationUse_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<CollaborationUseImpl> element(new CollaborationUseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisCollaborationUsePtr(element);
	return element;
	
}
std::shared_ptr<CollaborationUse> umlFactoryImpl::createCollaborationUse_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<CollaborationUseImpl> element(new CollaborationUseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisCollaborationUsePtr(element);
	return element;
	
}
std::shared_ptr<CollaborationUse> umlFactoryImpl::createCollaborationUse_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<CollaborationUseImpl> element(new CollaborationUseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisCollaborationUsePtr(element);
	return element;
	
}
std::shared_ptr<CombinedFragment> umlFactoryImpl::createCombinedFragment(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<CombinedFragmentImpl> element(new CombinedFragmentImpl());
	element->setMetaElementID(metaElementID);
	element->setThisCombinedFragmentPtr(element);
	return element;
}
std::shared_ptr<CombinedFragment> umlFactoryImpl::createCombinedFragment_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<CombinedFragmentImpl> element(new CombinedFragmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisCombinedFragmentPtr(element);
	return element;
	
}
std::shared_ptr<CombinedFragment> umlFactoryImpl::createCombinedFragment_as_fragment_in_Interaction(std::weak_ptr<uml::Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<CombinedFragmentImpl> element(new CombinedFragmentImpl(par_Interaction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Interaction.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisCombinedFragmentPtr(element);
	return element;
	
}
std::shared_ptr<CombinedFragment> umlFactoryImpl::createCombinedFragment_as_fragment_in_InteractionOperand(std::weak_ptr<uml::InteractionOperand> par_InteractionOperand, const int metaElementID) const
{
	std::shared_ptr<CombinedFragmentImpl> element(new CombinedFragmentImpl(par_InteractionOperand));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_InteractionOperand.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisCombinedFragmentPtr(element);
	return element;
	
}
std::shared_ptr<CombinedFragment> umlFactoryImpl::createCombinedFragment_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<CombinedFragmentImpl> element(new CombinedFragmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisCombinedFragmentPtr(element);
	return element;
	
}
std::shared_ptr<CombinedFragment> umlFactoryImpl::createCombinedFragment_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<CombinedFragmentImpl> element(new CombinedFragmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisCombinedFragmentPtr(element);
	return element;
	
}
std::shared_ptr<CombinedFragment> umlFactoryImpl::createCombinedFragment_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<CombinedFragmentImpl> element(new CombinedFragmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisCombinedFragmentPtr(element);
	return element;
	
}
std::shared_ptr<CombinedFragment> umlFactoryImpl::createCombinedFragment_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<CombinedFragmentImpl> element(new CombinedFragmentImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisCombinedFragmentPtr(element);
	return element;
	
}
std::shared_ptr<CombinedFragment> umlFactoryImpl::createCombinedFragment_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<CombinedFragmentImpl> element(new CombinedFragmentImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisCombinedFragmentPtr(element);
	return element;
	
}
std::shared_ptr<CombinedFragment> umlFactoryImpl::createCombinedFragment_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<CombinedFragmentImpl> element(new CombinedFragmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisCombinedFragmentPtr(element);
	return element;
	
}
std::shared_ptr<CombinedFragment> umlFactoryImpl::createCombinedFragment_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<CombinedFragmentImpl> element(new CombinedFragmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisCombinedFragmentPtr(element);
	return element;
	
}
std::shared_ptr<CombinedFragment> umlFactoryImpl::createCombinedFragment_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<CombinedFragmentImpl> element(new CombinedFragmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisCombinedFragmentPtr(element);
	return element;
	
}
std::shared_ptr<Comment> umlFactoryImpl::createComment(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<CommentImpl> element(new CommentImpl());
	element->setMetaElementID(metaElementID);
	element->setThisCommentPtr(element);
	return element;
}
std::shared_ptr<Comment> umlFactoryImpl::createComment_as_ownedComment_in_Element(std::shared_ptr<Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<CommentImpl> element(new CommentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Element)
	{
		par_Element->getOwnedComment()->push_back(element);
	}
	
	element->setThisCommentPtr(element);
	return element;
	
}
std::shared_ptr<Comment> umlFactoryImpl::createComment_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<CommentImpl> element(new CommentImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisCommentPtr(element);
	return element;
	
}
std::shared_ptr<Comment> umlFactoryImpl::createComment_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<CommentImpl> element(new CommentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisCommentPtr(element);
	return element;
	
}
std::shared_ptr<Comment> umlFactoryImpl::createComment_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<CommentImpl> element(new CommentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisCommentPtr(element);
	return element;
	
}
std::shared_ptr<CommunicationPath> umlFactoryImpl::createCommunicationPath(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<CommunicationPathImpl> element(new CommunicationPathImpl());
	element->setMetaElementID(metaElementID);
	element->setThisCommunicationPathPtr(element);
	return element;
}
std::shared_ptr<CommunicationPath> umlFactoryImpl::createCommunicationPath_as_classifier_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<CommunicationPathImpl> element(new CommunicationPathImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->setClassifier(element);
	}
	
	element->setThisCommunicationPathPtr(element);
	return element;
	
}
std::shared_ptr<CommunicationPath> umlFactoryImpl::createCommunicationPath_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<CommunicationPathImpl> element(new CommunicationPathImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisCommunicationPathPtr(element);
	return element;
	
}
std::shared_ptr<CommunicationPath> umlFactoryImpl::createCommunicationPath_as_contract_in_Substitution(std::shared_ptr<Substitution> par_Substitution, const int metaElementID) const
{
	std::shared_ptr<CommunicationPathImpl> element(new CommunicationPathImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Substitution)
	{
		par_Substitution->setContract(element);
	}
	
	element->setThisCommunicationPathPtr(element);
	return element;
	
}
std::shared_ptr<CommunicationPath> umlFactoryImpl::createCommunicationPath_as_endType_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<CommunicationPathImpl> element(new CommunicationPathImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getEndType()->push_back(element);
	}
	
	element->setThisCommunicationPathPtr(element);
	return element;
	
}
std::shared_ptr<CommunicationPath> umlFactoryImpl::createCommunicationPath_as_general_in_Generalization(std::shared_ptr<Generalization> par_Generalization, const int metaElementID) const
{
	std::shared_ptr<CommunicationPathImpl> element(new CommunicationPathImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Generalization)
	{
		par_Generalization->setGeneral(element);
	}
	
	element->setThisCommunicationPathPtr(element);
	return element;
	
}
std::shared_ptr<CommunicationPath> umlFactoryImpl::createCommunicationPath_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<CommunicationPathImpl> element(new CommunicationPathImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisCommunicationPathPtr(element);
	return element;
	
}
std::shared_ptr<CommunicationPath> umlFactoryImpl::createCommunicationPath_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<CommunicationPathImpl> element(new CommunicationPathImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisCommunicationPathPtr(element);
	return element;
	
}
std::shared_ptr<CommunicationPath> umlFactoryImpl::createCommunicationPath_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<CommunicationPathImpl> element(new CommunicationPathImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisCommunicationPathPtr(element);
	return element;
	
}
std::shared_ptr<CommunicationPath> umlFactoryImpl::createCommunicationPath_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<CommunicationPathImpl> element(new CommunicationPathImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisCommunicationPathPtr(element);
	return element;
	
}
std::shared_ptr<CommunicationPath> umlFactoryImpl::createCommunicationPath_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<CommunicationPathImpl> element(new CommunicationPathImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisCommunicationPathPtr(element);
	return element;
	
}
std::shared_ptr<CommunicationPath> umlFactoryImpl::createCommunicationPath_as_nestedClassifier_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<CommunicationPathImpl> element(new CommunicationPathImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getNestedClassifier()->push_back(element);
	}
	
	element->setThisCommunicationPathPtr(element);
	return element;
	
}
std::shared_ptr<CommunicationPath> umlFactoryImpl::createCommunicationPath_as_nestedClassifier_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<CommunicationPathImpl> element(new CommunicationPathImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getNestedClassifier()->push_back(element);
	}
	
	element->setThisCommunicationPathPtr(element);
	return element;
	
}
std::shared_ptr<CommunicationPath> umlFactoryImpl::createCommunicationPath_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<CommunicationPathImpl> element(new CommunicationPathImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisCommunicationPathPtr(element);
	return element;
	
}
std::shared_ptr<CommunicationPath> umlFactoryImpl::createCommunicationPath_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<CommunicationPathImpl> element(new CommunicationPathImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisCommunicationPathPtr(element);
	return element;
	
}
std::shared_ptr<CommunicationPath> umlFactoryImpl::createCommunicationPath_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<CommunicationPathImpl> element(new CommunicationPathImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisCommunicationPathPtr(element);
	return element;
	
}
std::shared_ptr<CommunicationPath> umlFactoryImpl::createCommunicationPath_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<CommunicationPathImpl> element(new CommunicationPathImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisCommunicationPathPtr(element);
	return element;
	
}
std::shared_ptr<CommunicationPath> umlFactoryImpl::createCommunicationPath_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<CommunicationPathImpl> element(new CommunicationPathImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisCommunicationPathPtr(element);
	return element;
	
}
std::shared_ptr<CommunicationPath> umlFactoryImpl::createCommunicationPath_as_ownedType_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<CommunicationPathImpl> element(new CommunicationPathImpl(par_Package, uml::umlPackage::TYPE_ATTRIBUTE_PACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getOwnedType()->push_back(element);
	}
	
	element->setThisCommunicationPathPtr(element);
	return element;
	
}
std::shared_ptr<CommunicationPath> umlFactoryImpl::createCommunicationPath_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<CommunicationPathImpl> element(new CommunicationPathImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisCommunicationPathPtr(element);
	return element;
	
}
std::shared_ptr<CommunicationPath> umlFactoryImpl::createCommunicationPath_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<CommunicationPathImpl> element(new CommunicationPathImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisCommunicationPathPtr(element);
	return element;
	
}
std::shared_ptr<CommunicationPath> umlFactoryImpl::createCommunicationPath_as_realizingClassifier_in_ComponentRealization(std::shared_ptr<ComponentRealization> par_ComponentRealization, const int metaElementID) const
{
	std::shared_ptr<CommunicationPathImpl> element(new CommunicationPathImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ComponentRealization)
	{
		par_ComponentRealization->getRealizingClassifier()->push_back(element);
	}
	
	element->setThisCommunicationPathPtr(element);
	return element;
	
}
std::shared_ptr<CommunicationPath> umlFactoryImpl::createCommunicationPath_as_redefinedClassifier_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<CommunicationPathImpl> element(new CommunicationPathImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getRedefinedClassifier()->push_back(element);
	}
	
	element->setThisCommunicationPathPtr(element);
	return element;
	
}
std::shared_ptr<CommunicationPath> umlFactoryImpl::createCommunicationPath_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<CommunicationPathImpl> element(new CommunicationPathImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisCommunicationPathPtr(element);
	return element;
	
}
std::shared_ptr<CommunicationPath> umlFactoryImpl::createCommunicationPath_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<CommunicationPathImpl> element(new CommunicationPathImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisCommunicationPathPtr(element);
	return element;
	
}
std::shared_ptr<CommunicationPath> umlFactoryImpl::createCommunicationPath_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<CommunicationPathImpl> element(new CommunicationPathImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisCommunicationPathPtr(element);
	return element;
	
}
std::shared_ptr<CommunicationPath> umlFactoryImpl::createCommunicationPath_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<CommunicationPathImpl> element(new CommunicationPathImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisCommunicationPathPtr(element);
	return element;
	
}
std::shared_ptr<Component> umlFactoryImpl::createComponent(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl());
	element->setMetaElementID(metaElementID);
	element->setThisComponentPtr(element);
	return element;
}
std::shared_ptr<Component> umlFactoryImpl::createComponent_as_classifier_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->setClassifier(element);
	}
	
	element->setThisComponentPtr(element);
	return element;
	
}
std::shared_ptr<Component> umlFactoryImpl::createComponent_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisComponentPtr(element);
	return element;
	
}
std::shared_ptr<Component> umlFactoryImpl::createComponent_as_context_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->setContext(element);
	}
	
	element->setThisComponentPtr(element);
	return element;
	
}
std::shared_ptr<Component> umlFactoryImpl::createComponent_as_contract_in_Substitution(std::shared_ptr<Substitution> par_Substitution, const int metaElementID) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Substitution)
	{
		par_Substitution->setContract(element);
	}
	
	element->setThisComponentPtr(element);
	return element;
	
}
std::shared_ptr<Component> umlFactoryImpl::createComponent_as_endType_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getEndType()->push_back(element);
	}
	
	element->setThisComponentPtr(element);
	return element;
	
}
std::shared_ptr<Component> umlFactoryImpl::createComponent_as_general_in_Generalization(std::shared_ptr<Generalization> par_Generalization, const int metaElementID) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Generalization)
	{
		par_Generalization->setGeneral(element);
	}
	
	element->setThisComponentPtr(element);
	return element;
	
}
std::shared_ptr<Component> umlFactoryImpl::createComponent_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisComponentPtr(element);
	return element;
	
}
std::shared_ptr<Component> umlFactoryImpl::createComponent_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisComponentPtr(element);
	return element;
	
}
std::shared_ptr<Component> umlFactoryImpl::createComponent_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisComponentPtr(element);
	return element;
	
}
std::shared_ptr<Component> umlFactoryImpl::createComponent_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisComponentPtr(element);
	return element;
	
}
std::shared_ptr<Component> umlFactoryImpl::createComponent_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisComponentPtr(element);
	return element;
	
}
std::shared_ptr<Component> umlFactoryImpl::createComponent_as_nestedClassifier_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getNestedClassifier()->push_back(element);
	}
	
	element->setThisComponentPtr(element);
	return element;
	
}
std::shared_ptr<Component> umlFactoryImpl::createComponent_as_nestedClassifier_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getNestedClassifier()->push_back(element);
	}
	
	element->setThisComponentPtr(element);
	return element;
	
}
std::shared_ptr<Component> umlFactoryImpl::createComponent_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisComponentPtr(element);
	return element;
	
}
std::shared_ptr<Component> umlFactoryImpl::createComponent_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisComponentPtr(element);
	return element;
	
}
std::shared_ptr<Component> umlFactoryImpl::createComponent_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisComponentPtr(element);
	return element;
	
}
std::shared_ptr<Component> umlFactoryImpl::createComponent_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisComponentPtr(element);
	return element;
	
}
std::shared_ptr<Component> umlFactoryImpl::createComponent_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisComponentPtr(element);
	return element;
	
}
std::shared_ptr<Component> umlFactoryImpl::createComponent_as_ownedType_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl(par_Package, uml::umlPackage::TYPE_ATTRIBUTE_PACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getOwnedType()->push_back(element);
	}
	
	element->setThisComponentPtr(element);
	return element;
	
}
std::shared_ptr<Component> umlFactoryImpl::createComponent_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisComponentPtr(element);
	return element;
	
}
std::shared_ptr<Component> umlFactoryImpl::createComponent_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisComponentPtr(element);
	return element;
	
}
std::shared_ptr<Component> umlFactoryImpl::createComponent_as_realizingClassifier_in_ComponentRealization(std::shared_ptr<ComponentRealization> par_ComponentRealization, const int metaElementID) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ComponentRealization)
	{
		par_ComponentRealization->getRealizingClassifier()->push_back(element);
	}
	
	element->setThisComponentPtr(element);
	return element;
	
}
std::shared_ptr<Component> umlFactoryImpl::createComponent_as_redefinedClassifier_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getRedefinedClassifier()->push_back(element);
	}
	
	element->setThisComponentPtr(element);
	return element;
	
}
std::shared_ptr<Component> umlFactoryImpl::createComponent_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisComponentPtr(element);
	return element;
	
}
std::shared_ptr<Component> umlFactoryImpl::createComponent_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisComponentPtr(element);
	return element;
	
}
std::shared_ptr<Component> umlFactoryImpl::createComponent_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisComponentPtr(element);
	return element;
	
}
std::shared_ptr<Component> umlFactoryImpl::createComponent_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<ComponentImpl> element(new ComponentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisComponentPtr(element);
	return element;
	
}
std::shared_ptr<ComponentRealization> umlFactoryImpl::createComponentRealization(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ComponentRealizationImpl> element(new ComponentRealizationImpl());
	element->setMetaElementID(metaElementID);
	element->setThisComponentRealizationPtr(element);
	return element;
}
std::shared_ptr<ComponentRealization> umlFactoryImpl::createComponentRealization_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ComponentRealizationImpl> element(new ComponentRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisComponentRealizationPtr(element);
	return element;
	
}
std::shared_ptr<ComponentRealization> umlFactoryImpl::createComponentRealization_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<ComponentRealizationImpl> element(new ComponentRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisComponentRealizationPtr(element);
	return element;
	
}
std::shared_ptr<ComponentRealization> umlFactoryImpl::createComponentRealization_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ComponentRealizationImpl> element(new ComponentRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisComponentRealizationPtr(element);
	return element;
	
}
std::shared_ptr<ComponentRealization> umlFactoryImpl::createComponentRealization_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ComponentRealizationImpl> element(new ComponentRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisComponentRealizationPtr(element);
	return element;
	
}
std::shared_ptr<ComponentRealization> umlFactoryImpl::createComponentRealization_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ComponentRealizationImpl> element(new ComponentRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisComponentRealizationPtr(element);
	return element;
	
}
std::shared_ptr<ComponentRealization> umlFactoryImpl::createComponentRealization_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ComponentRealizationImpl> element(new ComponentRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisComponentRealizationPtr(element);
	return element;
	
}
std::shared_ptr<ComponentRealization> umlFactoryImpl::createComponentRealization_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<ComponentRealizationImpl> element(new ComponentRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisComponentRealizationPtr(element);
	return element;
	
}
std::shared_ptr<ComponentRealization> umlFactoryImpl::createComponentRealization_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ComponentRealizationImpl> element(new ComponentRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisComponentRealizationPtr(element);
	return element;
	
}
std::shared_ptr<ComponentRealization> umlFactoryImpl::createComponentRealization_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ComponentRealizationImpl> element(new ComponentRealizationImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisComponentRealizationPtr(element);
	return element;
	
}
std::shared_ptr<ComponentRealization> umlFactoryImpl::createComponentRealization_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ComponentRealizationImpl> element(new ComponentRealizationImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisComponentRealizationPtr(element);
	return element;
	
}
std::shared_ptr<ComponentRealization> umlFactoryImpl::createComponentRealization_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ComponentRealizationImpl> element(new ComponentRealizationImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisComponentRealizationPtr(element);
	return element;
	
}
std::shared_ptr<ComponentRealization> umlFactoryImpl::createComponentRealization_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<ComponentRealizationImpl> element(new ComponentRealizationImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisComponentRealizationPtr(element);
	return element;
	
}
std::shared_ptr<ComponentRealization> umlFactoryImpl::createComponentRealization_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<ComponentRealizationImpl> element(new ComponentRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisComponentRealizationPtr(element);
	return element;
	
}
std::shared_ptr<ComponentRealization> umlFactoryImpl::createComponentRealization_as_realization_in_Component(std::weak_ptr<uml::Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<ComponentRealizationImpl> element(new ComponentRealizationImpl(par_Component));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Component.lock())
	{
		wp->getRealization()->push_back(element);
	}
	
	element->setThisComponentRealizationPtr(element);
	return element;
	
}
std::shared_ptr<ComponentRealization> umlFactoryImpl::createComponentRealization_as_roleBinding_in_CollaborationUse(std::shared_ptr<CollaborationUse> par_CollaborationUse, const int metaElementID) const
{
	std::shared_ptr<ComponentRealizationImpl> element(new ComponentRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_CollaborationUse)
	{
		par_CollaborationUse->getRoleBinding()->push_back(element);
	}
	
	element->setThisComponentRealizationPtr(element);
	return element;
	
}
std::shared_ptr<ComponentRealization> umlFactoryImpl::createComponentRealization_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ComponentRealizationImpl> element(new ComponentRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisComponentRealizationPtr(element);
	return element;
	
}
std::shared_ptr<ComponentRealization> umlFactoryImpl::createComponentRealization_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ComponentRealizationImpl> element(new ComponentRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisComponentRealizationPtr(element);
	return element;
	
}
std::shared_ptr<ComponentRealization> umlFactoryImpl::createComponentRealization_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ComponentRealizationImpl> element(new ComponentRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisComponentRealizationPtr(element);
	return element;
	
}
std::shared_ptr<ComponentRealization> umlFactoryImpl::createComponentRealization_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<ComponentRealizationImpl> element(new ComponentRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisComponentRealizationPtr(element);
	return element;
	
}
std::shared_ptr<ConditionalNode> umlFactoryImpl::createConditionalNode(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ConditionalNodeImpl> element(new ConditionalNodeImpl());
	element->setMetaElementID(metaElementID);
	element->setThisConditionalNodePtr(element);
	return element;
}
std::shared_ptr<ConditionalNode> umlFactoryImpl::createConditionalNode_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<ConditionalNodeImpl> element(new ConditionalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisConditionalNodePtr(element);
	return element;
	
}
std::shared_ptr<ConditionalNode> umlFactoryImpl::createConditionalNode_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ConditionalNodeImpl> element(new ConditionalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisConditionalNodePtr(element);
	return element;
	
}
std::shared_ptr<ConditionalNode> umlFactoryImpl::createConditionalNode_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<ConditionalNodeImpl> element(new ConditionalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisConditionalNodePtr(element);
	return element;
	
}
std::shared_ptr<ConditionalNode> umlFactoryImpl::createConditionalNode_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<ConditionalNodeImpl> element(new ConditionalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisConditionalNodePtr(element);
	return element;
	
}
std::shared_ptr<ConditionalNode> umlFactoryImpl::createConditionalNode_as_group_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ConditionalNodeImpl> element(new ConditionalNodeImpl(par_Activity, uml::umlPackage::ACTIVITYGROUP_ATTRIBUTE_INACTIVITY));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getGroup()->push_back(element);
	}
	
	element->setThisConditionalNodePtr(element);
	return element;
	
}
std::shared_ptr<ConditionalNode> umlFactoryImpl::createConditionalNode_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ConditionalNodeImpl> element(new ConditionalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisConditionalNodePtr(element);
	return element;
	
}
std::shared_ptr<ConditionalNode> umlFactoryImpl::createConditionalNode_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ConditionalNodeImpl> element(new ConditionalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisConditionalNodePtr(element);
	return element;
	
}
std::shared_ptr<ConditionalNode> umlFactoryImpl::createConditionalNode_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ConditionalNodeImpl> element(new ConditionalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisConditionalNodePtr(element);
	return element;
	
}
std::shared_ptr<ConditionalNode> umlFactoryImpl::createConditionalNode_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ConditionalNodeImpl> element(new ConditionalNodeImpl(par_Activity, uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_ACTIVITY));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisConditionalNodePtr(element);
	return element;
	
}
std::shared_ptr<ConditionalNode> umlFactoryImpl::createConditionalNode_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<ConditionalNodeImpl> element(new ConditionalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisConditionalNodePtr(element);
	return element;
	
}
std::shared_ptr<ConditionalNode> umlFactoryImpl::createConditionalNode_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<ConditionalNodeImpl> element(new ConditionalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisConditionalNodePtr(element);
	return element;
	
}
std::shared_ptr<ConditionalNode> umlFactoryImpl::createConditionalNode_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<ConditionalNodeImpl> element(new ConditionalNodeImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisConditionalNodePtr(element);
	return element;
	
}
std::shared_ptr<ConditionalNode> umlFactoryImpl::createConditionalNode_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ConditionalNodeImpl> element(new ConditionalNodeImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisConditionalNodePtr(element);
	return element;
	
}
std::shared_ptr<ConditionalNode> umlFactoryImpl::createConditionalNode_as_ownedGroup_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ConditionalNodeImpl> element(new ConditionalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedGroup()->push_back(element);
	}
	
	element->setThisConditionalNodePtr(element);
	return element;
	
}
std::shared_ptr<ConditionalNode> umlFactoryImpl::createConditionalNode_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ConditionalNodeImpl> element(new ConditionalNodeImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisConditionalNodePtr(element);
	return element;
	
}
std::shared_ptr<ConditionalNode> umlFactoryImpl::createConditionalNode_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ConditionalNodeImpl> element(new ConditionalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisConditionalNodePtr(element);
	return element;
	
}
std::shared_ptr<ConditionalNode> umlFactoryImpl::createConditionalNode_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<ConditionalNodeImpl> element(new ConditionalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisConditionalNodePtr(element);
	return element;
	
}
std::shared_ptr<ConditionalNode> umlFactoryImpl::createConditionalNode_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ConditionalNodeImpl> element(new ConditionalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisConditionalNodePtr(element);
	return element;
	
}
std::shared_ptr<ConditionalNode> umlFactoryImpl::createConditionalNode_as_structuredNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ConditionalNodeImpl> element(new ConditionalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getStructuredNode()->push_back(element);
	}
	
	element->setThisConditionalNodePtr(element);
	return element;
	
}
std::shared_ptr<ConditionalNode> umlFactoryImpl::createConditionalNode_as_subgroup_in_ActivityGroup(std::weak_ptr<uml::ActivityGroup> par_ActivityGroup, const int metaElementID) const
{
	std::shared_ptr<ConditionalNodeImpl> element(new ConditionalNodeImpl(par_ActivityGroup));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ActivityGroup.lock())
	{
		wp->getSubgroup()->push_back(element);
	}
	
	element->setThisConditionalNodePtr(element);
	return element;
	
}
std::shared_ptr<ConditionalNode> umlFactoryImpl::createConditionalNode_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ConditionalNodeImpl> element(new ConditionalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisConditionalNodePtr(element);
	return element;
	
}
std::shared_ptr<ConditionalNode> umlFactoryImpl::createConditionalNode_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ConditionalNodeImpl> element(new ConditionalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisConditionalNodePtr(element);
	return element;
	
}
std::shared_ptr<ConnectableElementTemplateParameter> umlFactoryImpl::createConnectableElementTemplateParameter(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ConnectableElementTemplateParameterImpl> element(new ConnectableElementTemplateParameterImpl());
	element->setMetaElementID(metaElementID);
	element->setThisConnectableElementTemplateParameterPtr(element);
	return element;
}
std::shared_ptr<ConnectableElementTemplateParameter> umlFactoryImpl::createConnectableElementTemplateParameter_as_inheritedParameter_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<ConnectableElementTemplateParameterImpl> element(new ConnectableElementTemplateParameterImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->getInheritedParameter()->push_back(element);
	}
	
	element->setThisConnectableElementTemplateParameterPtr(element);
	return element;
	
}
std::shared_ptr<ConnectableElementTemplateParameter> umlFactoryImpl::createConnectableElementTemplateParameter_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ConnectableElementTemplateParameterImpl> element(new ConnectableElementTemplateParameterImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisConnectableElementTemplateParameterPtr(element);
	return element;
	
}
std::shared_ptr<ConnectableElementTemplateParameter> umlFactoryImpl::createConnectableElementTemplateParameter_as_ownedParameter_in_TemplateSignature(std::weak_ptr<uml::TemplateSignature> par_TemplateSignature, const int metaElementID) const
{
	std::shared_ptr<ConnectableElementTemplateParameterImpl> element(new ConnectableElementTemplateParameterImpl(par_TemplateSignature));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateSignature.lock())
	{
		wp->getOwnedParameter()->push_back(element);
	}
	
	element->setThisConnectableElementTemplateParameterPtr(element);
	return element;
	
}
std::shared_ptr<ConnectableElementTemplateParameter> umlFactoryImpl::createConnectableElementTemplateParameter_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ConnectableElementTemplateParameterImpl> element(new ConnectableElementTemplateParameterImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisConnectableElementTemplateParameterPtr(element);
	return element;
	
}
std::shared_ptr<ConnectableElementTemplateParameter> umlFactoryImpl::createConnectableElementTemplateParameter_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ConnectableElementTemplateParameterImpl> element(new ConnectableElementTemplateParameterImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisConnectableElementTemplateParameterPtr(element);
	return element;
	
}
std::shared_ptr<ConnectionPointReference> umlFactoryImpl::createConnectionPointReference(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ConnectionPointReferenceImpl> element(new ConnectionPointReferenceImpl());
	element->setMetaElementID(metaElementID);
	element->setThisConnectionPointReferencePtr(element);
	return element;
}
std::shared_ptr<ConnectionPointReference> umlFactoryImpl::createConnectionPointReference_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ConnectionPointReferenceImpl> element(new ConnectionPointReferenceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisConnectionPointReferencePtr(element);
	return element;
	
}
std::shared_ptr<ConnectionPointReference> umlFactoryImpl::createConnectionPointReference_as_connection_in_State(std::weak_ptr<uml::State> par_State, const int metaElementID) const
{
	std::shared_ptr<ConnectionPointReferenceImpl> element(new ConnectionPointReferenceImpl(par_State));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_State.lock())
	{
		wp->getConnection()->push_back(element);
	}
	
	element->setThisConnectionPointReferencePtr(element);
	return element;
	
}
std::shared_ptr<ConnectionPointReference> umlFactoryImpl::createConnectionPointReference_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ConnectionPointReferenceImpl> element(new ConnectionPointReferenceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisConnectionPointReferencePtr(element);
	return element;
	
}
std::shared_ptr<ConnectionPointReference> umlFactoryImpl::createConnectionPointReference_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ConnectionPointReferenceImpl> element(new ConnectionPointReferenceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisConnectionPointReferencePtr(element);
	return element;
	
}
std::shared_ptr<ConnectionPointReference> umlFactoryImpl::createConnectionPointReference_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ConnectionPointReferenceImpl> element(new ConnectionPointReferenceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisConnectionPointReferencePtr(element);
	return element;
	
}
std::shared_ptr<ConnectionPointReference> umlFactoryImpl::createConnectionPointReference_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ConnectionPointReferenceImpl> element(new ConnectionPointReferenceImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisConnectionPointReferencePtr(element);
	return element;
	
}
std::shared_ptr<ConnectionPointReference> umlFactoryImpl::createConnectionPointReference_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ConnectionPointReferenceImpl> element(new ConnectionPointReferenceImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisConnectionPointReferencePtr(element);
	return element;
	
}
std::shared_ptr<ConnectionPointReference> umlFactoryImpl::createConnectionPointReference_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ConnectionPointReferenceImpl> element(new ConnectionPointReferenceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisConnectionPointReferencePtr(element);
	return element;
	
}
std::shared_ptr<ConnectionPointReference> umlFactoryImpl::createConnectionPointReference_as_subvertex_in_Region(std::weak_ptr<uml::Region> par_Region, const int metaElementID) const
{
	std::shared_ptr<ConnectionPointReferenceImpl> element(new ConnectionPointReferenceImpl(par_Region));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Region.lock())
	{
		wp->getSubvertex()->push_back(element);
	}
	
	element->setThisConnectionPointReferencePtr(element);
	return element;
	
}
std::shared_ptr<ConnectionPointReference> umlFactoryImpl::createConnectionPointReference_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ConnectionPointReferenceImpl> element(new ConnectionPointReferenceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisConnectionPointReferencePtr(element);
	return element;
	
}
std::shared_ptr<ConnectionPointReference> umlFactoryImpl::createConnectionPointReference_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ConnectionPointReferenceImpl> element(new ConnectionPointReferenceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisConnectionPointReferencePtr(element);
	return element;
	
}
std::shared_ptr<Connector> umlFactoryImpl::createConnector(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ConnectorImpl> element(new ConnectorImpl());
	element->setMetaElementID(metaElementID);
	element->setThisConnectorPtr(element);
	return element;
}
std::shared_ptr<Connector> umlFactoryImpl::createConnector_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ConnectorImpl> element(new ConnectorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisConnectorPtr(element);
	return element;
	
}
std::shared_ptr<Connector> umlFactoryImpl::createConnector_as_feature_in_Classifier(std::shared_ptr<uml::Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ConnectorImpl> element(new ConnectorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getFeature()->push_back(element);
	}
	
	element->setThisConnectorPtr(element);
	return element;
	
}
std::shared_ptr<Connector> umlFactoryImpl::createConnector_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ConnectorImpl> element(new ConnectorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisConnectorPtr(element);
	return element;
	
}
std::shared_ptr<Connector> umlFactoryImpl::createConnector_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ConnectorImpl> element(new ConnectorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisConnectorPtr(element);
	return element;
	
}
std::shared_ptr<Connector> umlFactoryImpl::createConnector_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ConnectorImpl> element(new ConnectorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisConnectorPtr(element);
	return element;
	
}
std::shared_ptr<Connector> umlFactoryImpl::createConnector_as_ownedConnector_in_StructuredClassifier(std::weak_ptr<uml::StructuredClassifier> par_StructuredClassifier, const int metaElementID) const
{
	std::shared_ptr<ConnectorImpl> element(new ConnectorImpl(par_StructuredClassifier));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredClassifier.lock())
	{
		wp->getOwnedConnector()->push_back(element);
	}
	
	element->setThisConnectorPtr(element);
	return element;
	
}
std::shared_ptr<Connector> umlFactoryImpl::createConnector_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ConnectorImpl> element(new ConnectorImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisConnectorPtr(element);
	return element;
	
}
std::shared_ptr<Connector> umlFactoryImpl::createConnector_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ConnectorImpl> element(new ConnectorImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisConnectorPtr(element);
	return element;
	
}
std::shared_ptr<Connector> umlFactoryImpl::createConnector_as_redefinedConnector_in_Connector(std::shared_ptr<Connector> par_Connector, const int metaElementID) const
{
	std::shared_ptr<ConnectorImpl> element(new ConnectorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Connector)
	{
		par_Connector->getRedefinedConnector()->push_back(element);
	}
	
	element->setThisConnectorPtr(element);
	return element;
	
}
std::shared_ptr<Connector> umlFactoryImpl::createConnector_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ConnectorImpl> element(new ConnectorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisConnectorPtr(element);
	return element;
	
}
std::shared_ptr<Connector> umlFactoryImpl::createConnector_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ConnectorImpl> element(new ConnectorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisConnectorPtr(element);
	return element;
	
}
std::shared_ptr<Connector> umlFactoryImpl::createConnector_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ConnectorImpl> element(new ConnectorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisConnectorPtr(element);
	return element;
	
}
std::shared_ptr<ConnectorEnd> umlFactoryImpl::createConnectorEnd(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ConnectorEndImpl> element(new ConnectorEndImpl());
	element->setMetaElementID(metaElementID);
	element->setThisConnectorEndPtr(element);
	return element;
}
std::shared_ptr<ConnectorEnd> umlFactoryImpl::createConnectorEnd_as_end_in_Connector(std::weak_ptr<uml::Connector> par_Connector, const int metaElementID) const
{
	std::shared_ptr<ConnectorEndImpl> element(new ConnectorEndImpl(par_Connector));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Connector.lock())
	{
		wp->getEnd()->push_back(element);
	}
	
	element->setThisConnectorEndPtr(element);
	return element;
	
}
std::shared_ptr<ConnectorEnd> umlFactoryImpl::createConnectorEnd_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ConnectorEndImpl> element(new ConnectorEndImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisConnectorEndPtr(element);
	return element;
	
}
std::shared_ptr<ConnectorEnd> umlFactoryImpl::createConnectorEnd_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ConnectorEndImpl> element(new ConnectorEndImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisConnectorEndPtr(element);
	return element;
	
}
std::shared_ptr<ConnectorEnd> umlFactoryImpl::createConnectorEnd_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ConnectorEndImpl> element(new ConnectorEndImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisConnectorEndPtr(element);
	return element;
	
}
std::shared_ptr<ConsiderIgnoreFragment> umlFactoryImpl::createConsiderIgnoreFragment(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ConsiderIgnoreFragmentImpl> element(new ConsiderIgnoreFragmentImpl());
	element->setMetaElementID(metaElementID);
	element->setThisConsiderIgnoreFragmentPtr(element);
	return element;
}
std::shared_ptr<ConsiderIgnoreFragment> umlFactoryImpl::createConsiderIgnoreFragment_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ConsiderIgnoreFragmentImpl> element(new ConsiderIgnoreFragmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisConsiderIgnoreFragmentPtr(element);
	return element;
	
}
std::shared_ptr<ConsiderIgnoreFragment> umlFactoryImpl::createConsiderIgnoreFragment_as_fragment_in_Interaction(std::weak_ptr<uml::Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<ConsiderIgnoreFragmentImpl> element(new ConsiderIgnoreFragmentImpl(par_Interaction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Interaction.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisConsiderIgnoreFragmentPtr(element);
	return element;
	
}
std::shared_ptr<ConsiderIgnoreFragment> umlFactoryImpl::createConsiderIgnoreFragment_as_fragment_in_InteractionOperand(std::weak_ptr<uml::InteractionOperand> par_InteractionOperand, const int metaElementID) const
{
	std::shared_ptr<ConsiderIgnoreFragmentImpl> element(new ConsiderIgnoreFragmentImpl(par_InteractionOperand));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_InteractionOperand.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisConsiderIgnoreFragmentPtr(element);
	return element;
	
}
std::shared_ptr<ConsiderIgnoreFragment> umlFactoryImpl::createConsiderIgnoreFragment_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ConsiderIgnoreFragmentImpl> element(new ConsiderIgnoreFragmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisConsiderIgnoreFragmentPtr(element);
	return element;
	
}
std::shared_ptr<ConsiderIgnoreFragment> umlFactoryImpl::createConsiderIgnoreFragment_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ConsiderIgnoreFragmentImpl> element(new ConsiderIgnoreFragmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisConsiderIgnoreFragmentPtr(element);
	return element;
	
}
std::shared_ptr<ConsiderIgnoreFragment> umlFactoryImpl::createConsiderIgnoreFragment_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ConsiderIgnoreFragmentImpl> element(new ConsiderIgnoreFragmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisConsiderIgnoreFragmentPtr(element);
	return element;
	
}
std::shared_ptr<ConsiderIgnoreFragment> umlFactoryImpl::createConsiderIgnoreFragment_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ConsiderIgnoreFragmentImpl> element(new ConsiderIgnoreFragmentImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisConsiderIgnoreFragmentPtr(element);
	return element;
	
}
std::shared_ptr<ConsiderIgnoreFragment> umlFactoryImpl::createConsiderIgnoreFragment_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ConsiderIgnoreFragmentImpl> element(new ConsiderIgnoreFragmentImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisConsiderIgnoreFragmentPtr(element);
	return element;
	
}
std::shared_ptr<ConsiderIgnoreFragment> umlFactoryImpl::createConsiderIgnoreFragment_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ConsiderIgnoreFragmentImpl> element(new ConsiderIgnoreFragmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisConsiderIgnoreFragmentPtr(element);
	return element;
	
}
std::shared_ptr<ConsiderIgnoreFragment> umlFactoryImpl::createConsiderIgnoreFragment_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ConsiderIgnoreFragmentImpl> element(new ConsiderIgnoreFragmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisConsiderIgnoreFragmentPtr(element);
	return element;
	
}
std::shared_ptr<ConsiderIgnoreFragment> umlFactoryImpl::createConsiderIgnoreFragment_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ConsiderIgnoreFragmentImpl> element(new ConsiderIgnoreFragmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisConsiderIgnoreFragmentPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	element->setThisConstraintPtr(element);
	return element;
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_bodyCondition_in_Operation(std::shared_ptr<Operation> par_Operation, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Operation)
	{
		par_Operation->setBodyCondition(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_condition_in_ParameterSet(std::shared_ptr<ParameterSet> par_ParameterSet, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ParameterSet)
	{
		par_ParameterSet->getCondition()->push_back(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_condition_in_Extend(std::shared_ptr<Extend> par_Extend, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Extend)
	{
		par_Extend->setCondition(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_guard_in_Transition(std::shared_ptr<Transition> par_Transition, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Transition)
	{
		par_Transition->setGuard(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_invariant_in_StateInvariant(std::shared_ptr<StateInvariant> par_StateInvariant, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_StateInvariant)
	{
		par_StateInvariant->setInvariant(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_localPostcondition_in_Action(std::shared_ptr<Action> par_Action, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Action)
	{
		par_Action->getLocalPostcondition()->push_back(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_localPrecondition_in_Action(std::shared_ptr<Action> par_Action, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Action)
	{
		par_Action->getLocalPrecondition()->push_back(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl(par_Namespace, uml::umlPackage::NAMEDELEMENT_ATTRIBUTE_NAMESPACE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_ownedRule_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl(par_Namespace, uml::umlPackage::CONSTRAINT_ATTRIBUTE_CONTEXT));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedRule()->push_back(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_postCondition_in_ProtocolTransition(std::shared_ptr<ProtocolTransition> par_ProtocolTransition, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ProtocolTransition)
	{
		par_ProtocolTransition->setPostCondition(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_postcondition_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->getPostcondition()->push_back(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_postcondition_in_Operation(std::shared_ptr<Operation> par_Operation, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Operation)
	{
		par_Operation->getPostcondition()->push_back(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_preCondition_in_ProtocolTransition(std::shared_ptr<ProtocolTransition> par_ProtocolTransition, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ProtocolTransition)
	{
		par_ProtocolTransition->setPreCondition(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_precondition_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->getPrecondition()->push_back(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_precondition_in_Operation(std::shared_ptr<Operation> par_Operation, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Operation)
	{
		par_Operation->getPrecondition()->push_back(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_stateInvariant_in_State(std::shared_ptr<State> par_State, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_State)
	{
		par_State->setStateInvariant(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Constraint> umlFactoryImpl::createConstraint_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<ConstraintImpl> element(new ConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisConstraintPtr(element);
	return element;
	
}
std::shared_ptr<Continuation> umlFactoryImpl::createContinuation(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ContinuationImpl> element(new ContinuationImpl());
	element->setMetaElementID(metaElementID);
	element->setThisContinuationPtr(element);
	return element;
}
std::shared_ptr<Continuation> umlFactoryImpl::createContinuation_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ContinuationImpl> element(new ContinuationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisContinuationPtr(element);
	return element;
	
}
std::shared_ptr<Continuation> umlFactoryImpl::createContinuation_as_fragment_in_Interaction(std::weak_ptr<uml::Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<ContinuationImpl> element(new ContinuationImpl(par_Interaction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Interaction.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisContinuationPtr(element);
	return element;
	
}
std::shared_ptr<Continuation> umlFactoryImpl::createContinuation_as_fragment_in_InteractionOperand(std::weak_ptr<uml::InteractionOperand> par_InteractionOperand, const int metaElementID) const
{
	std::shared_ptr<ContinuationImpl> element(new ContinuationImpl(par_InteractionOperand));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_InteractionOperand.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisContinuationPtr(element);
	return element;
	
}
std::shared_ptr<Continuation> umlFactoryImpl::createContinuation_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ContinuationImpl> element(new ContinuationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisContinuationPtr(element);
	return element;
	
}
std::shared_ptr<Continuation> umlFactoryImpl::createContinuation_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ContinuationImpl> element(new ContinuationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisContinuationPtr(element);
	return element;
	
}
std::shared_ptr<Continuation> umlFactoryImpl::createContinuation_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ContinuationImpl> element(new ContinuationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisContinuationPtr(element);
	return element;
	
}
std::shared_ptr<Continuation> umlFactoryImpl::createContinuation_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ContinuationImpl> element(new ContinuationImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisContinuationPtr(element);
	return element;
	
}
std::shared_ptr<Continuation> umlFactoryImpl::createContinuation_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ContinuationImpl> element(new ContinuationImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisContinuationPtr(element);
	return element;
	
}
std::shared_ptr<Continuation> umlFactoryImpl::createContinuation_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ContinuationImpl> element(new ContinuationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisContinuationPtr(element);
	return element;
	
}
std::shared_ptr<Continuation> umlFactoryImpl::createContinuation_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ContinuationImpl> element(new ContinuationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisContinuationPtr(element);
	return element;
	
}
std::shared_ptr<Continuation> umlFactoryImpl::createContinuation_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ContinuationImpl> element(new ContinuationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisContinuationPtr(element);
	return element;
	
}
std::shared_ptr<ControlFlow> umlFactoryImpl::createControlFlow(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ControlFlowImpl> element(new ControlFlowImpl());
	element->setMetaElementID(metaElementID);
	element->setThisControlFlowPtr(element);
	return element;
}
std::shared_ptr<ControlFlow> umlFactoryImpl::createControlFlow_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ControlFlowImpl> element(new ControlFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisControlFlowPtr(element);
	return element;
	
}
std::shared_ptr<ControlFlow> umlFactoryImpl::createControlFlow_as_edge_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ControlFlowImpl> element(new ControlFlowImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getEdge()->push_back(element);
	}
	
	element->setThisControlFlowPtr(element);
	return element;
	
}
std::shared_ptr<ControlFlow> umlFactoryImpl::createControlFlow_as_edge_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<ControlFlowImpl> element(new ControlFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getEdge()->push_back(element);
	}
	
	element->setThisControlFlowPtr(element);
	return element;
	
}
std::shared_ptr<ControlFlow> umlFactoryImpl::createControlFlow_as_edge_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<ControlFlowImpl> element(new ControlFlowImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getEdge()->push_back(element);
	}
	
	element->setThisControlFlowPtr(element);
	return element;
	
}
std::shared_ptr<ControlFlow> umlFactoryImpl::createControlFlow_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ControlFlowImpl> element(new ControlFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisControlFlowPtr(element);
	return element;
	
}
std::shared_ptr<ControlFlow> umlFactoryImpl::createControlFlow_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ControlFlowImpl> element(new ControlFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisControlFlowPtr(element);
	return element;
	
}
std::shared_ptr<ControlFlow> umlFactoryImpl::createControlFlow_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ControlFlowImpl> element(new ControlFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisControlFlowPtr(element);
	return element;
	
}
std::shared_ptr<ControlFlow> umlFactoryImpl::createControlFlow_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ControlFlowImpl> element(new ControlFlowImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisControlFlowPtr(element);
	return element;
	
}
std::shared_ptr<ControlFlow> umlFactoryImpl::createControlFlow_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ControlFlowImpl> element(new ControlFlowImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisControlFlowPtr(element);
	return element;
	
}
std::shared_ptr<ControlFlow> umlFactoryImpl::createControlFlow_as_redefinedEdge_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<ControlFlowImpl> element(new ControlFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->getRedefinedEdge()->push_back(element);
	}
	
	element->setThisControlFlowPtr(element);
	return element;
	
}
std::shared_ptr<ControlFlow> umlFactoryImpl::createControlFlow_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ControlFlowImpl> element(new ControlFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisControlFlowPtr(element);
	return element;
	
}
std::shared_ptr<ControlFlow> umlFactoryImpl::createControlFlow_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ControlFlowImpl> element(new ControlFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisControlFlowPtr(element);
	return element;
	
}
std::shared_ptr<ControlFlow> umlFactoryImpl::createControlFlow_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ControlFlowImpl> element(new ControlFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisControlFlowPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkAction> umlFactoryImpl::createCreateLinkAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<CreateLinkActionImpl> element(new CreateLinkActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisCreateLinkActionPtr(element);
	return element;
}
std::shared_ptr<CreateLinkAction> umlFactoryImpl::createCreateLinkAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<CreateLinkActionImpl> element(new CreateLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisCreateLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkAction> umlFactoryImpl::createCreateLinkAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<CreateLinkActionImpl> element(new CreateLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisCreateLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkAction> umlFactoryImpl::createCreateLinkAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<CreateLinkActionImpl> element(new CreateLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisCreateLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkAction> umlFactoryImpl::createCreateLinkAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<CreateLinkActionImpl> element(new CreateLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisCreateLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkAction> umlFactoryImpl::createCreateLinkAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<CreateLinkActionImpl> element(new CreateLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisCreateLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkAction> umlFactoryImpl::createCreateLinkAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<CreateLinkActionImpl> element(new CreateLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisCreateLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkAction> umlFactoryImpl::createCreateLinkAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<CreateLinkActionImpl> element(new CreateLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisCreateLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkAction> umlFactoryImpl::createCreateLinkAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<CreateLinkActionImpl> element(new CreateLinkActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisCreateLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkAction> umlFactoryImpl::createCreateLinkAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<CreateLinkActionImpl> element(new CreateLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisCreateLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkAction> umlFactoryImpl::createCreateLinkAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<CreateLinkActionImpl> element(new CreateLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisCreateLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkAction> umlFactoryImpl::createCreateLinkAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<CreateLinkActionImpl> element(new CreateLinkActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisCreateLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkAction> umlFactoryImpl::createCreateLinkAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<CreateLinkActionImpl> element(new CreateLinkActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisCreateLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkAction> umlFactoryImpl::createCreateLinkAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<CreateLinkActionImpl> element(new CreateLinkActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisCreateLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkAction> umlFactoryImpl::createCreateLinkAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<CreateLinkActionImpl> element(new CreateLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisCreateLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkAction> umlFactoryImpl::createCreateLinkAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<CreateLinkActionImpl> element(new CreateLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisCreateLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkAction> umlFactoryImpl::createCreateLinkAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<CreateLinkActionImpl> element(new CreateLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisCreateLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkAction> umlFactoryImpl::createCreateLinkAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<CreateLinkActionImpl> element(new CreateLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisCreateLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkAction> umlFactoryImpl::createCreateLinkAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<CreateLinkActionImpl> element(new CreateLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisCreateLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkObjectAction> umlFactoryImpl::createCreateLinkObjectAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<CreateLinkObjectActionImpl> element(new CreateLinkObjectActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisCreateLinkObjectActionPtr(element);
	return element;
}
std::shared_ptr<CreateLinkObjectAction> umlFactoryImpl::createCreateLinkObjectAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<CreateLinkObjectActionImpl> element(new CreateLinkObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisCreateLinkObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkObjectAction> umlFactoryImpl::createCreateLinkObjectAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<CreateLinkObjectActionImpl> element(new CreateLinkObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisCreateLinkObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkObjectAction> umlFactoryImpl::createCreateLinkObjectAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<CreateLinkObjectActionImpl> element(new CreateLinkObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisCreateLinkObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkObjectAction> umlFactoryImpl::createCreateLinkObjectAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<CreateLinkObjectActionImpl> element(new CreateLinkObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisCreateLinkObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkObjectAction> umlFactoryImpl::createCreateLinkObjectAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<CreateLinkObjectActionImpl> element(new CreateLinkObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisCreateLinkObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkObjectAction> umlFactoryImpl::createCreateLinkObjectAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<CreateLinkObjectActionImpl> element(new CreateLinkObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisCreateLinkObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkObjectAction> umlFactoryImpl::createCreateLinkObjectAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<CreateLinkObjectActionImpl> element(new CreateLinkObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisCreateLinkObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkObjectAction> umlFactoryImpl::createCreateLinkObjectAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<CreateLinkObjectActionImpl> element(new CreateLinkObjectActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisCreateLinkObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkObjectAction> umlFactoryImpl::createCreateLinkObjectAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<CreateLinkObjectActionImpl> element(new CreateLinkObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisCreateLinkObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkObjectAction> umlFactoryImpl::createCreateLinkObjectAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<CreateLinkObjectActionImpl> element(new CreateLinkObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisCreateLinkObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkObjectAction> umlFactoryImpl::createCreateLinkObjectAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<CreateLinkObjectActionImpl> element(new CreateLinkObjectActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisCreateLinkObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkObjectAction> umlFactoryImpl::createCreateLinkObjectAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<CreateLinkObjectActionImpl> element(new CreateLinkObjectActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisCreateLinkObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkObjectAction> umlFactoryImpl::createCreateLinkObjectAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<CreateLinkObjectActionImpl> element(new CreateLinkObjectActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisCreateLinkObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkObjectAction> umlFactoryImpl::createCreateLinkObjectAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<CreateLinkObjectActionImpl> element(new CreateLinkObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisCreateLinkObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkObjectAction> umlFactoryImpl::createCreateLinkObjectAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<CreateLinkObjectActionImpl> element(new CreateLinkObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisCreateLinkObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkObjectAction> umlFactoryImpl::createCreateLinkObjectAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<CreateLinkObjectActionImpl> element(new CreateLinkObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisCreateLinkObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkObjectAction> umlFactoryImpl::createCreateLinkObjectAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<CreateLinkObjectActionImpl> element(new CreateLinkObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisCreateLinkObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateLinkObjectAction> umlFactoryImpl::createCreateLinkObjectAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<CreateLinkObjectActionImpl> element(new CreateLinkObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisCreateLinkObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateObjectAction> umlFactoryImpl::createCreateObjectAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<CreateObjectActionImpl> element(new CreateObjectActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisCreateObjectActionPtr(element);
	return element;
}
std::shared_ptr<CreateObjectAction> umlFactoryImpl::createCreateObjectAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<CreateObjectActionImpl> element(new CreateObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisCreateObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateObjectAction> umlFactoryImpl::createCreateObjectAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<CreateObjectActionImpl> element(new CreateObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisCreateObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateObjectAction> umlFactoryImpl::createCreateObjectAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<CreateObjectActionImpl> element(new CreateObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisCreateObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateObjectAction> umlFactoryImpl::createCreateObjectAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<CreateObjectActionImpl> element(new CreateObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisCreateObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateObjectAction> umlFactoryImpl::createCreateObjectAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<CreateObjectActionImpl> element(new CreateObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisCreateObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateObjectAction> umlFactoryImpl::createCreateObjectAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<CreateObjectActionImpl> element(new CreateObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisCreateObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateObjectAction> umlFactoryImpl::createCreateObjectAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<CreateObjectActionImpl> element(new CreateObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisCreateObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateObjectAction> umlFactoryImpl::createCreateObjectAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<CreateObjectActionImpl> element(new CreateObjectActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisCreateObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateObjectAction> umlFactoryImpl::createCreateObjectAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<CreateObjectActionImpl> element(new CreateObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisCreateObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateObjectAction> umlFactoryImpl::createCreateObjectAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<CreateObjectActionImpl> element(new CreateObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisCreateObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateObjectAction> umlFactoryImpl::createCreateObjectAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<CreateObjectActionImpl> element(new CreateObjectActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisCreateObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateObjectAction> umlFactoryImpl::createCreateObjectAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<CreateObjectActionImpl> element(new CreateObjectActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisCreateObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateObjectAction> umlFactoryImpl::createCreateObjectAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<CreateObjectActionImpl> element(new CreateObjectActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisCreateObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateObjectAction> umlFactoryImpl::createCreateObjectAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<CreateObjectActionImpl> element(new CreateObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisCreateObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateObjectAction> umlFactoryImpl::createCreateObjectAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<CreateObjectActionImpl> element(new CreateObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisCreateObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateObjectAction> umlFactoryImpl::createCreateObjectAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<CreateObjectActionImpl> element(new CreateObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisCreateObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateObjectAction> umlFactoryImpl::createCreateObjectAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<CreateObjectActionImpl> element(new CreateObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisCreateObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<CreateObjectAction> umlFactoryImpl::createCreateObjectAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<CreateObjectActionImpl> element(new CreateObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisCreateObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<DataStoreNode> umlFactoryImpl::createDataStoreNode(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<DataStoreNodeImpl> element(new DataStoreNodeImpl());
	element->setMetaElementID(metaElementID);
	element->setThisDataStoreNodePtr(element);
	return element;
}
std::shared_ptr<DataStoreNode> umlFactoryImpl::createDataStoreNode_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DataStoreNodeImpl> element(new DataStoreNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisDataStoreNodePtr(element);
	return element;
	
}
std::shared_ptr<DataStoreNode> umlFactoryImpl::createDataStoreNode_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DataStoreNodeImpl> element(new DataStoreNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisDataStoreNodePtr(element);
	return element;
	
}
std::shared_ptr<DataStoreNode> umlFactoryImpl::createDataStoreNode_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DataStoreNodeImpl> element(new DataStoreNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisDataStoreNodePtr(element);
	return element;
	
}
std::shared_ptr<DataStoreNode> umlFactoryImpl::createDataStoreNode_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<DataStoreNodeImpl> element(new DataStoreNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisDataStoreNodePtr(element);
	return element;
	
}
std::shared_ptr<DataStoreNode> umlFactoryImpl::createDataStoreNode_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<DataStoreNodeImpl> element(new DataStoreNodeImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisDataStoreNodePtr(element);
	return element;
	
}
std::shared_ptr<DataStoreNode> umlFactoryImpl::createDataStoreNode_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<DataStoreNodeImpl> element(new DataStoreNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisDataStoreNodePtr(element);
	return element;
	
}
std::shared_ptr<DataStoreNode> umlFactoryImpl::createDataStoreNode_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<DataStoreNodeImpl> element(new DataStoreNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisDataStoreNodePtr(element);
	return element;
	
}
std::shared_ptr<DataStoreNode> umlFactoryImpl::createDataStoreNode_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<DataStoreNodeImpl> element(new DataStoreNodeImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisDataStoreNodePtr(element);
	return element;
	
}
std::shared_ptr<DataStoreNode> umlFactoryImpl::createDataStoreNode_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<DataStoreNodeImpl> element(new DataStoreNodeImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisDataStoreNodePtr(element);
	return element;
	
}
std::shared_ptr<DataStoreNode> umlFactoryImpl::createDataStoreNode_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<DataStoreNodeImpl> element(new DataStoreNodeImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisDataStoreNodePtr(element);
	return element;
	
}
std::shared_ptr<DataStoreNode> umlFactoryImpl::createDataStoreNode_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<DataStoreNodeImpl> element(new DataStoreNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisDataStoreNodePtr(element);
	return element;
	
}
std::shared_ptr<DataStoreNode> umlFactoryImpl::createDataStoreNode_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<DataStoreNodeImpl> element(new DataStoreNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisDataStoreNodePtr(element);
	return element;
	
}
std::shared_ptr<DataStoreNode> umlFactoryImpl::createDataStoreNode_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DataStoreNodeImpl> element(new DataStoreNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisDataStoreNodePtr(element);
	return element;
	
}
std::shared_ptr<DataStoreNode> umlFactoryImpl::createDataStoreNode_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DataStoreNodeImpl> element(new DataStoreNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisDataStoreNodePtr(element);
	return element;
	
}
std::shared_ptr<DataStoreNode> umlFactoryImpl::createDataStoreNode_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DataStoreNodeImpl> element(new DataStoreNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisDataStoreNodePtr(element);
	return element;
	
}
std::shared_ptr<DataType> umlFactoryImpl::createDataType(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<DataTypeImpl> element(new DataTypeImpl());
	element->setMetaElementID(metaElementID);
	element->setThisDataTypePtr(element);
	return element;
}
std::shared_ptr<DataType> umlFactoryImpl::createDataType_as_classifier_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<DataTypeImpl> element(new DataTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->setClassifier(element);
	}
	
	element->setThisDataTypePtr(element);
	return element;
	
}
std::shared_ptr<DataType> umlFactoryImpl::createDataType_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DataTypeImpl> element(new DataTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisDataTypePtr(element);
	return element;
	
}
std::shared_ptr<DataType> umlFactoryImpl::createDataType_as_contract_in_Substitution(std::shared_ptr<Substitution> par_Substitution, const int metaElementID) const
{
	std::shared_ptr<DataTypeImpl> element(new DataTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Substitution)
	{
		par_Substitution->setContract(element);
	}
	
	element->setThisDataTypePtr(element);
	return element;
	
}
std::shared_ptr<DataType> umlFactoryImpl::createDataType_as_endType_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<DataTypeImpl> element(new DataTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getEndType()->push_back(element);
	}
	
	element->setThisDataTypePtr(element);
	return element;
	
}
std::shared_ptr<DataType> umlFactoryImpl::createDataType_as_general_in_Generalization(std::shared_ptr<Generalization> par_Generalization, const int metaElementID) const
{
	std::shared_ptr<DataTypeImpl> element(new DataTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Generalization)
	{
		par_Generalization->setGeneral(element);
	}
	
	element->setThisDataTypePtr(element);
	return element;
	
}
std::shared_ptr<DataType> umlFactoryImpl::createDataType_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<DataTypeImpl> element(new DataTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisDataTypePtr(element);
	return element;
	
}
std::shared_ptr<DataType> umlFactoryImpl::createDataType_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<DataTypeImpl> element(new DataTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisDataTypePtr(element);
	return element;
	
}
std::shared_ptr<DataType> umlFactoryImpl::createDataType_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DataTypeImpl> element(new DataTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisDataTypePtr(element);
	return element;
	
}
std::shared_ptr<DataType> umlFactoryImpl::createDataType_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DataTypeImpl> element(new DataTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisDataTypePtr(element);
	return element;
	
}
std::shared_ptr<DataType> umlFactoryImpl::createDataType_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<DataTypeImpl> element(new DataTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisDataTypePtr(element);
	return element;
	
}
std::shared_ptr<DataType> umlFactoryImpl::createDataType_as_nestedClassifier_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<DataTypeImpl> element(new DataTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getNestedClassifier()->push_back(element);
	}
	
	element->setThisDataTypePtr(element);
	return element;
	
}
std::shared_ptr<DataType> umlFactoryImpl::createDataType_as_nestedClassifier_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<DataTypeImpl> element(new DataTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getNestedClassifier()->push_back(element);
	}
	
	element->setThisDataTypePtr(element);
	return element;
	
}
std::shared_ptr<DataType> umlFactoryImpl::createDataType_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<DataTypeImpl> element(new DataTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisDataTypePtr(element);
	return element;
	
}
std::shared_ptr<DataType> umlFactoryImpl::createDataType_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<DataTypeImpl> element(new DataTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisDataTypePtr(element);
	return element;
	
}
std::shared_ptr<DataType> umlFactoryImpl::createDataType_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<DataTypeImpl> element(new DataTypeImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisDataTypePtr(element);
	return element;
	
}
std::shared_ptr<DataType> umlFactoryImpl::createDataType_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<DataTypeImpl> element(new DataTypeImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisDataTypePtr(element);
	return element;
	
}
std::shared_ptr<DataType> umlFactoryImpl::createDataType_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<DataTypeImpl> element(new DataTypeImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisDataTypePtr(element);
	return element;
	
}
std::shared_ptr<DataType> umlFactoryImpl::createDataType_as_ownedType_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<DataTypeImpl> element(new DataTypeImpl(par_Package, uml::umlPackage::TYPE_ATTRIBUTE_PACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getOwnedType()->push_back(element);
	}
	
	element->setThisDataTypePtr(element);
	return element;
	
}
std::shared_ptr<DataType> umlFactoryImpl::createDataType_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<DataTypeImpl> element(new DataTypeImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisDataTypePtr(element);
	return element;
	
}
std::shared_ptr<DataType> umlFactoryImpl::createDataType_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<DataTypeImpl> element(new DataTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisDataTypePtr(element);
	return element;
	
}
std::shared_ptr<DataType> umlFactoryImpl::createDataType_as_realizingClassifier_in_ComponentRealization(std::shared_ptr<ComponentRealization> par_ComponentRealization, const int metaElementID) const
{
	std::shared_ptr<DataTypeImpl> element(new DataTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ComponentRealization)
	{
		par_ComponentRealization->getRealizingClassifier()->push_back(element);
	}
	
	element->setThisDataTypePtr(element);
	return element;
	
}
std::shared_ptr<DataType> umlFactoryImpl::createDataType_as_redefinedClassifier_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<DataTypeImpl> element(new DataTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getRedefinedClassifier()->push_back(element);
	}
	
	element->setThisDataTypePtr(element);
	return element;
	
}
std::shared_ptr<DataType> umlFactoryImpl::createDataType_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DataTypeImpl> element(new DataTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisDataTypePtr(element);
	return element;
	
}
std::shared_ptr<DataType> umlFactoryImpl::createDataType_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DataTypeImpl> element(new DataTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisDataTypePtr(element);
	return element;
	
}
std::shared_ptr<DataType> umlFactoryImpl::createDataType_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DataTypeImpl> element(new DataTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisDataTypePtr(element);
	return element;
	
}
std::shared_ptr<DataType> umlFactoryImpl::createDataType_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<DataTypeImpl> element(new DataTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisDataTypePtr(element);
	return element;
	
}
std::shared_ptr<DecisionNode> umlFactoryImpl::createDecisionNode(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<DecisionNodeImpl> element(new DecisionNodeImpl());
	element->setMetaElementID(metaElementID);
	element->setThisDecisionNodePtr(element);
	return element;
}
std::shared_ptr<DecisionNode> umlFactoryImpl::createDecisionNode_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DecisionNodeImpl> element(new DecisionNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisDecisionNodePtr(element);
	return element;
	
}
std::shared_ptr<DecisionNode> umlFactoryImpl::createDecisionNode_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DecisionNodeImpl> element(new DecisionNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisDecisionNodePtr(element);
	return element;
	
}
std::shared_ptr<DecisionNode> umlFactoryImpl::createDecisionNode_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DecisionNodeImpl> element(new DecisionNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisDecisionNodePtr(element);
	return element;
	
}
std::shared_ptr<DecisionNode> umlFactoryImpl::createDecisionNode_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<DecisionNodeImpl> element(new DecisionNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisDecisionNodePtr(element);
	return element;
	
}
std::shared_ptr<DecisionNode> umlFactoryImpl::createDecisionNode_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<DecisionNodeImpl> element(new DecisionNodeImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisDecisionNodePtr(element);
	return element;
	
}
std::shared_ptr<DecisionNode> umlFactoryImpl::createDecisionNode_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<DecisionNodeImpl> element(new DecisionNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisDecisionNodePtr(element);
	return element;
	
}
std::shared_ptr<DecisionNode> umlFactoryImpl::createDecisionNode_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<DecisionNodeImpl> element(new DecisionNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisDecisionNodePtr(element);
	return element;
	
}
std::shared_ptr<DecisionNode> umlFactoryImpl::createDecisionNode_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<DecisionNodeImpl> element(new DecisionNodeImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisDecisionNodePtr(element);
	return element;
	
}
std::shared_ptr<DecisionNode> umlFactoryImpl::createDecisionNode_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<DecisionNodeImpl> element(new DecisionNodeImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisDecisionNodePtr(element);
	return element;
	
}
std::shared_ptr<DecisionNode> umlFactoryImpl::createDecisionNode_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<DecisionNodeImpl> element(new DecisionNodeImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisDecisionNodePtr(element);
	return element;
	
}
std::shared_ptr<DecisionNode> umlFactoryImpl::createDecisionNode_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<DecisionNodeImpl> element(new DecisionNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisDecisionNodePtr(element);
	return element;
	
}
std::shared_ptr<DecisionNode> umlFactoryImpl::createDecisionNode_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<DecisionNodeImpl> element(new DecisionNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisDecisionNodePtr(element);
	return element;
	
}
std::shared_ptr<DecisionNode> umlFactoryImpl::createDecisionNode_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DecisionNodeImpl> element(new DecisionNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisDecisionNodePtr(element);
	return element;
	
}
std::shared_ptr<DecisionNode> umlFactoryImpl::createDecisionNode_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DecisionNodeImpl> element(new DecisionNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisDecisionNodePtr(element);
	return element;
	
}
std::shared_ptr<DecisionNode> umlFactoryImpl::createDecisionNode_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DecisionNodeImpl> element(new DecisionNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisDecisionNodePtr(element);
	return element;
	
}
std::shared_ptr<Dependency> umlFactoryImpl::createDependency(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<DependencyImpl> element(new DependencyImpl());
	element->setMetaElementID(metaElementID);
	element->setThisDependencyPtr(element);
	return element;
}
std::shared_ptr<Dependency> umlFactoryImpl::createDependency_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DependencyImpl> element(new DependencyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisDependencyPtr(element);
	return element;
	
}
std::shared_ptr<Dependency> umlFactoryImpl::createDependency_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<DependencyImpl> element(new DependencyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisDependencyPtr(element);
	return element;
	
}
std::shared_ptr<Dependency> umlFactoryImpl::createDependency_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<DependencyImpl> element(new DependencyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisDependencyPtr(element);
	return element;
	
}
std::shared_ptr<Dependency> umlFactoryImpl::createDependency_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DependencyImpl> element(new DependencyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisDependencyPtr(element);
	return element;
	
}
std::shared_ptr<Dependency> umlFactoryImpl::createDependency_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DependencyImpl> element(new DependencyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisDependencyPtr(element);
	return element;
	
}
std::shared_ptr<Dependency> umlFactoryImpl::createDependency_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<DependencyImpl> element(new DependencyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisDependencyPtr(element);
	return element;
	
}
std::shared_ptr<Dependency> umlFactoryImpl::createDependency_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<DependencyImpl> element(new DependencyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisDependencyPtr(element);
	return element;
	
}
std::shared_ptr<Dependency> umlFactoryImpl::createDependency_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<DependencyImpl> element(new DependencyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisDependencyPtr(element);
	return element;
	
}
std::shared_ptr<Dependency> umlFactoryImpl::createDependency_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<DependencyImpl> element(new DependencyImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisDependencyPtr(element);
	return element;
	
}
std::shared_ptr<Dependency> umlFactoryImpl::createDependency_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<DependencyImpl> element(new DependencyImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisDependencyPtr(element);
	return element;
	
}
std::shared_ptr<Dependency> umlFactoryImpl::createDependency_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<DependencyImpl> element(new DependencyImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisDependencyPtr(element);
	return element;
	
}
std::shared_ptr<Dependency> umlFactoryImpl::createDependency_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<DependencyImpl> element(new DependencyImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisDependencyPtr(element);
	return element;
	
}
std::shared_ptr<Dependency> umlFactoryImpl::createDependency_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<DependencyImpl> element(new DependencyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisDependencyPtr(element);
	return element;
	
}
std::shared_ptr<Dependency> umlFactoryImpl::createDependency_as_roleBinding_in_CollaborationUse(std::shared_ptr<CollaborationUse> par_CollaborationUse, const int metaElementID) const
{
	std::shared_ptr<DependencyImpl> element(new DependencyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_CollaborationUse)
	{
		par_CollaborationUse->getRoleBinding()->push_back(element);
	}
	
	element->setThisDependencyPtr(element);
	return element;
	
}
std::shared_ptr<Dependency> umlFactoryImpl::createDependency_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DependencyImpl> element(new DependencyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisDependencyPtr(element);
	return element;
	
}
std::shared_ptr<Dependency> umlFactoryImpl::createDependency_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DependencyImpl> element(new DependencyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisDependencyPtr(element);
	return element;
	
}
std::shared_ptr<Dependency> umlFactoryImpl::createDependency_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DependencyImpl> element(new DependencyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisDependencyPtr(element);
	return element;
	
}
std::shared_ptr<Dependency> umlFactoryImpl::createDependency_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<DependencyImpl> element(new DependencyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisDependencyPtr(element);
	return element;
	
}
std::shared_ptr<Deployment> umlFactoryImpl::createDeployment(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<DeploymentImpl> element(new DeploymentImpl());
	element->setMetaElementID(metaElementID);
	element->setThisDeploymentPtr(element);
	return element;
}
std::shared_ptr<Deployment> umlFactoryImpl::createDeployment_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DeploymentImpl> element(new DeploymentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisDeploymentPtr(element);
	return element;
	
}
std::shared_ptr<Deployment> umlFactoryImpl::createDeployment_as_deployment_in_DeploymentTarget(std::weak_ptr<uml::DeploymentTarget> par_DeploymentTarget, const int metaElementID) const
{
	std::shared_ptr<DeploymentImpl> element(new DeploymentImpl(par_DeploymentTarget));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_DeploymentTarget.lock())
	{
		wp->getDeployment()->push_back(element);
	}
	
	element->setThisDeploymentPtr(element);
	return element;
	
}
std::shared_ptr<Deployment> umlFactoryImpl::createDeployment_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<DeploymentImpl> element(new DeploymentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisDeploymentPtr(element);
	return element;
	
}
std::shared_ptr<Deployment> umlFactoryImpl::createDeployment_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<DeploymentImpl> element(new DeploymentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisDeploymentPtr(element);
	return element;
	
}
std::shared_ptr<Deployment> umlFactoryImpl::createDeployment_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DeploymentImpl> element(new DeploymentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisDeploymentPtr(element);
	return element;
	
}
std::shared_ptr<Deployment> umlFactoryImpl::createDeployment_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DeploymentImpl> element(new DeploymentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisDeploymentPtr(element);
	return element;
	
}
std::shared_ptr<Deployment> umlFactoryImpl::createDeployment_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<DeploymentImpl> element(new DeploymentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisDeploymentPtr(element);
	return element;
	
}
std::shared_ptr<Deployment> umlFactoryImpl::createDeployment_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<DeploymentImpl> element(new DeploymentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisDeploymentPtr(element);
	return element;
	
}
std::shared_ptr<Deployment> umlFactoryImpl::createDeployment_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<DeploymentImpl> element(new DeploymentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisDeploymentPtr(element);
	return element;
	
}
std::shared_ptr<Deployment> umlFactoryImpl::createDeployment_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<DeploymentImpl> element(new DeploymentImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisDeploymentPtr(element);
	return element;
	
}
std::shared_ptr<Deployment> umlFactoryImpl::createDeployment_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<DeploymentImpl> element(new DeploymentImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisDeploymentPtr(element);
	return element;
	
}
std::shared_ptr<Deployment> umlFactoryImpl::createDeployment_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<DeploymentImpl> element(new DeploymentImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisDeploymentPtr(element);
	return element;
	
}
std::shared_ptr<Deployment> umlFactoryImpl::createDeployment_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<DeploymentImpl> element(new DeploymentImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisDeploymentPtr(element);
	return element;
	
}
std::shared_ptr<Deployment> umlFactoryImpl::createDeployment_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<DeploymentImpl> element(new DeploymentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisDeploymentPtr(element);
	return element;
	
}
std::shared_ptr<Deployment> umlFactoryImpl::createDeployment_as_roleBinding_in_CollaborationUse(std::shared_ptr<CollaborationUse> par_CollaborationUse, const int metaElementID) const
{
	std::shared_ptr<DeploymentImpl> element(new DeploymentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_CollaborationUse)
	{
		par_CollaborationUse->getRoleBinding()->push_back(element);
	}
	
	element->setThisDeploymentPtr(element);
	return element;
	
}
std::shared_ptr<Deployment> umlFactoryImpl::createDeployment_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DeploymentImpl> element(new DeploymentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisDeploymentPtr(element);
	return element;
	
}
std::shared_ptr<Deployment> umlFactoryImpl::createDeployment_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DeploymentImpl> element(new DeploymentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisDeploymentPtr(element);
	return element;
	
}
std::shared_ptr<Deployment> umlFactoryImpl::createDeployment_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DeploymentImpl> element(new DeploymentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisDeploymentPtr(element);
	return element;
	
}
std::shared_ptr<Deployment> umlFactoryImpl::createDeployment_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<DeploymentImpl> element(new DeploymentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisDeploymentPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl());
	element->setMetaElementID(metaElementID);
	element->setThisDeploymentSpecificationPtr(element);
	return element;
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_classifier_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->setClassifier(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_configuration_in_Deployment(std::weak_ptr<uml::Deployment> par_Deployment, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl(par_Deployment));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Deployment.lock())
	{
		wp->getConfiguration()->push_back(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_contract_in_Substitution(std::shared_ptr<Substitution> par_Substitution, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Substitution)
	{
		par_Substitution->setContract(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_deployedArtifact_in_Deployment(std::shared_ptr<Deployment> par_Deployment, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Deployment)
	{
		par_Deployment->getDeployedArtifact()->push_back(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_endType_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getEndType()->push_back(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_general_in_Generalization(std::shared_ptr<Generalization> par_Generalization, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Generalization)
	{
		par_Generalization->setGeneral(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_nestedArtifact_in_Artifact(std::shared_ptr<Artifact> par_Artifact, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Artifact)
	{
		par_Artifact->getNestedArtifact()->push_back(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_nestedClassifier_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getNestedClassifier()->push_back(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_nestedClassifier_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getNestedClassifier()->push_back(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_ownedType_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl(par_Package, uml::umlPackage::TYPE_ATTRIBUTE_PACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getOwnedType()->push_back(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_realizingClassifier_in_ComponentRealization(std::shared_ptr<ComponentRealization> par_ComponentRealization, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ComponentRealization)
	{
		par_ComponentRealization->getRealizingClassifier()->push_back(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_redefinedClassifier_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getRedefinedClassifier()->push_back(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DeploymentSpecification> umlFactoryImpl::createDeploymentSpecification_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<DeploymentSpecificationImpl> element(new DeploymentSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisDeploymentSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DestroyLinkAction> umlFactoryImpl::createDestroyLinkAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<DestroyLinkActionImpl> element(new DestroyLinkActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisDestroyLinkActionPtr(element);
	return element;
}
std::shared_ptr<DestroyLinkAction> umlFactoryImpl::createDestroyLinkAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<DestroyLinkActionImpl> element(new DestroyLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisDestroyLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyLinkAction> umlFactoryImpl::createDestroyLinkAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DestroyLinkActionImpl> element(new DestroyLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisDestroyLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyLinkAction> umlFactoryImpl::createDestroyLinkAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<DestroyLinkActionImpl> element(new DestroyLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisDestroyLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyLinkAction> umlFactoryImpl::createDestroyLinkAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<DestroyLinkActionImpl> element(new DestroyLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisDestroyLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyLinkAction> umlFactoryImpl::createDestroyLinkAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DestroyLinkActionImpl> element(new DestroyLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisDestroyLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyLinkAction> umlFactoryImpl::createDestroyLinkAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DestroyLinkActionImpl> element(new DestroyLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisDestroyLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyLinkAction> umlFactoryImpl::createDestroyLinkAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<DestroyLinkActionImpl> element(new DestroyLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisDestroyLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyLinkAction> umlFactoryImpl::createDestroyLinkAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<DestroyLinkActionImpl> element(new DestroyLinkActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisDestroyLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyLinkAction> umlFactoryImpl::createDestroyLinkAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<DestroyLinkActionImpl> element(new DestroyLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisDestroyLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyLinkAction> umlFactoryImpl::createDestroyLinkAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<DestroyLinkActionImpl> element(new DestroyLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisDestroyLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyLinkAction> umlFactoryImpl::createDestroyLinkAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<DestroyLinkActionImpl> element(new DestroyLinkActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisDestroyLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyLinkAction> umlFactoryImpl::createDestroyLinkAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<DestroyLinkActionImpl> element(new DestroyLinkActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisDestroyLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyLinkAction> umlFactoryImpl::createDestroyLinkAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<DestroyLinkActionImpl> element(new DestroyLinkActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisDestroyLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyLinkAction> umlFactoryImpl::createDestroyLinkAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<DestroyLinkActionImpl> element(new DestroyLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisDestroyLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyLinkAction> umlFactoryImpl::createDestroyLinkAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<DestroyLinkActionImpl> element(new DestroyLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisDestroyLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyLinkAction> umlFactoryImpl::createDestroyLinkAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DestroyLinkActionImpl> element(new DestroyLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisDestroyLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyLinkAction> umlFactoryImpl::createDestroyLinkAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DestroyLinkActionImpl> element(new DestroyLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisDestroyLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyLinkAction> umlFactoryImpl::createDestroyLinkAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DestroyLinkActionImpl> element(new DestroyLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisDestroyLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyObjectAction> umlFactoryImpl::createDestroyObjectAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<DestroyObjectActionImpl> element(new DestroyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisDestroyObjectActionPtr(element);
	return element;
}
std::shared_ptr<DestroyObjectAction> umlFactoryImpl::createDestroyObjectAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<DestroyObjectActionImpl> element(new DestroyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisDestroyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyObjectAction> umlFactoryImpl::createDestroyObjectAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DestroyObjectActionImpl> element(new DestroyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisDestroyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyObjectAction> umlFactoryImpl::createDestroyObjectAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<DestroyObjectActionImpl> element(new DestroyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisDestroyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyObjectAction> umlFactoryImpl::createDestroyObjectAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<DestroyObjectActionImpl> element(new DestroyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisDestroyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyObjectAction> umlFactoryImpl::createDestroyObjectAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DestroyObjectActionImpl> element(new DestroyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisDestroyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyObjectAction> umlFactoryImpl::createDestroyObjectAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DestroyObjectActionImpl> element(new DestroyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisDestroyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyObjectAction> umlFactoryImpl::createDestroyObjectAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<DestroyObjectActionImpl> element(new DestroyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisDestroyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyObjectAction> umlFactoryImpl::createDestroyObjectAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<DestroyObjectActionImpl> element(new DestroyObjectActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisDestroyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyObjectAction> umlFactoryImpl::createDestroyObjectAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<DestroyObjectActionImpl> element(new DestroyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisDestroyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyObjectAction> umlFactoryImpl::createDestroyObjectAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<DestroyObjectActionImpl> element(new DestroyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisDestroyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyObjectAction> umlFactoryImpl::createDestroyObjectAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<DestroyObjectActionImpl> element(new DestroyObjectActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisDestroyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyObjectAction> umlFactoryImpl::createDestroyObjectAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<DestroyObjectActionImpl> element(new DestroyObjectActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisDestroyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyObjectAction> umlFactoryImpl::createDestroyObjectAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<DestroyObjectActionImpl> element(new DestroyObjectActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisDestroyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyObjectAction> umlFactoryImpl::createDestroyObjectAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<DestroyObjectActionImpl> element(new DestroyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisDestroyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyObjectAction> umlFactoryImpl::createDestroyObjectAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<DestroyObjectActionImpl> element(new DestroyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisDestroyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyObjectAction> umlFactoryImpl::createDestroyObjectAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DestroyObjectActionImpl> element(new DestroyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisDestroyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyObjectAction> umlFactoryImpl::createDestroyObjectAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DestroyObjectActionImpl> element(new DestroyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisDestroyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<DestroyObjectAction> umlFactoryImpl::createDestroyObjectAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DestroyObjectActionImpl> element(new DestroyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisDestroyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<DestructionOccurrenceSpecification> umlFactoryImpl::createDestructionOccurrenceSpecification(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<DestructionOccurrenceSpecificationImpl> element(new DestructionOccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	element->setThisDestructionOccurrenceSpecificationPtr(element);
	return element;
}
std::shared_ptr<DestructionOccurrenceSpecification> umlFactoryImpl::createDestructionOccurrenceSpecification_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DestructionOccurrenceSpecificationImpl> element(new DestructionOccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisDestructionOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DestructionOccurrenceSpecification> umlFactoryImpl::createDestructionOccurrenceSpecification_as_fragment_in_Interaction(std::weak_ptr<uml::Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<DestructionOccurrenceSpecificationImpl> element(new DestructionOccurrenceSpecificationImpl(par_Interaction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Interaction.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisDestructionOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DestructionOccurrenceSpecification> umlFactoryImpl::createDestructionOccurrenceSpecification_as_fragment_in_InteractionOperand(std::weak_ptr<uml::InteractionOperand> par_InteractionOperand, const int metaElementID) const
{
	std::shared_ptr<DestructionOccurrenceSpecificationImpl> element(new DestructionOccurrenceSpecificationImpl(par_InteractionOperand));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_InteractionOperand.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisDestructionOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DestructionOccurrenceSpecification> umlFactoryImpl::createDestructionOccurrenceSpecification_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DestructionOccurrenceSpecificationImpl> element(new DestructionOccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisDestructionOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DestructionOccurrenceSpecification> umlFactoryImpl::createDestructionOccurrenceSpecification_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DestructionOccurrenceSpecificationImpl> element(new DestructionOccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisDestructionOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DestructionOccurrenceSpecification> umlFactoryImpl::createDestructionOccurrenceSpecification_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<DestructionOccurrenceSpecificationImpl> element(new DestructionOccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisDestructionOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DestructionOccurrenceSpecification> umlFactoryImpl::createDestructionOccurrenceSpecification_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<DestructionOccurrenceSpecificationImpl> element(new DestructionOccurrenceSpecificationImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisDestructionOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DestructionOccurrenceSpecification> umlFactoryImpl::createDestructionOccurrenceSpecification_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<DestructionOccurrenceSpecificationImpl> element(new DestructionOccurrenceSpecificationImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisDestructionOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DestructionOccurrenceSpecification> umlFactoryImpl::createDestructionOccurrenceSpecification_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DestructionOccurrenceSpecificationImpl> element(new DestructionOccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisDestructionOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DestructionOccurrenceSpecification> umlFactoryImpl::createDestructionOccurrenceSpecification_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DestructionOccurrenceSpecificationImpl> element(new DestructionOccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisDestructionOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<DestructionOccurrenceSpecification> umlFactoryImpl::createDestructionOccurrenceSpecification_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DestructionOccurrenceSpecificationImpl> element(new DestructionOccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisDestructionOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl());
	element->setMetaElementID(metaElementID);
	element->setThisDevicePtr(element);
	return element;
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_classifier_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->setClassifier(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_context_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->setContext(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_contract_in_Substitution(std::shared_ptr<Substitution> par_Substitution, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Substitution)
	{
		par_Substitution->setContract(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_endType_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getEndType()->push_back(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_general_in_Generalization(std::shared_ptr<Generalization> par_Generalization, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Generalization)
	{
		par_Generalization->setGeneral(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_nestedClassifier_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getNestedClassifier()->push_back(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_nestedClassifier_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getNestedClassifier()->push_back(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_nestedNode_in_Node(std::shared_ptr<Node> par_Node, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Node)
	{
		par_Node->getNestedNode()->push_back(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_ownedType_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl(par_Package, uml::umlPackage::TYPE_ATTRIBUTE_PACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getOwnedType()->push_back(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_realizingClassifier_in_ComponentRealization(std::shared_ptr<ComponentRealization> par_ComponentRealization, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ComponentRealization)
	{
		par_ComponentRealization->getRealizingClassifier()->push_back(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_redefinedClassifier_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getRedefinedClassifier()->push_back(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Device> umlFactoryImpl::createDevice_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<DeviceImpl> element(new DeviceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisDevicePtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	element->setThisDurationPtr(element);
	return element;
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_argument_in_Message(std::shared_ptr<Message> par_Message, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Message)
	{
		par_Message->getArgument()->push_back(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_argument_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->getArgument()->push_back(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_changeExpression_in_ChangeEvent(std::shared_ptr<ChangeEvent> par_ChangeEvent, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ChangeEvent)
	{
		par_ChangeEvent->setChangeExpression(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_defaultValue_in_Property(std::shared_ptr<Property> par_Property, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Property)
	{
		par_Property->setDefaultValue(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_defaultValue_in_Parameter(std::shared_ptr<Parameter> par_Parameter, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Parameter)
	{
		par_Parameter->setDefaultValue(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_expr_in_TimeExpression(std::shared_ptr<TimeExpression> par_TimeExpression, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TimeExpression)
	{
		par_TimeExpression->setExpr(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_expr_in_Duration(std::shared_ptr<Duration> par_Duration, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Duration)
	{
		par_Duration->setExpr(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_guard_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setGuard(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_joinSpec_in_JoinNode(std::shared_ptr<JoinNode> par_JoinNode, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_JoinNode)
	{
		par_JoinNode->setJoinSpec(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_lowerValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setLowerValue(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_maxint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMaxint(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_minint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMinint(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_operand_in_Expression(std::shared_ptr<Expression> par_Expression, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Expression)
	{
		par_Expression->getOperand()->push_back(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_returnValue_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->setReturnValue(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_selector_in_Lifeline(std::shared_ptr<Lifeline> par_Lifeline, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Lifeline)
	{
		par_Lifeline->setSelector(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_specification_in_Constraint(std::shared_ptr<Constraint> par_Constraint, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Constraint)
	{
		par_Constraint->setSpecification(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_specification_in_InstanceSpecification(std::shared_ptr<InstanceSpecification> par_InstanceSpecification, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InstanceSpecification)
	{
		par_InstanceSpecification->setSpecification(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_upperBound_in_ObjectNode(std::shared_ptr<ObjectNode> par_ObjectNode, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ObjectNode)
	{
		par_ObjectNode->setUpperBound(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_upperValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setUpperValue(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_value_in_Slot(std::weak_ptr<uml::Slot> par_Slot, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl(par_Slot));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Slot.lock())
	{
		wp->getValue()->push_back(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_value_in_ValueSpecificationAction(std::weak_ptr<uml::ValueSpecificationAction> par_ValueSpecificationAction, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl(par_ValueSpecificationAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ValueSpecificationAction.lock())
	{
		wp->setValue(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_value_in_ValuePin(std::shared_ptr<ValuePin> par_ValuePin, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ValuePin)
	{
		par_ValuePin->setValue(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<Duration> umlFactoryImpl::createDuration_as_weight_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<DurationImpl> element(new DurationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setWeight(element);
	}
	
	element->setThisDurationPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	element->setThisDurationConstraintPtr(element);
	return element;
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_bodyCondition_in_Operation(std::shared_ptr<Operation> par_Operation, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Operation)
	{
		par_Operation->setBodyCondition(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_condition_in_ParameterSet(std::shared_ptr<ParameterSet> par_ParameterSet, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ParameterSet)
	{
		par_ParameterSet->getCondition()->push_back(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_condition_in_Extend(std::shared_ptr<Extend> par_Extend, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Extend)
	{
		par_Extend->setCondition(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_guard_in_Transition(std::shared_ptr<Transition> par_Transition, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Transition)
	{
		par_Transition->setGuard(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_invariant_in_StateInvariant(std::shared_ptr<StateInvariant> par_StateInvariant, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_StateInvariant)
	{
		par_StateInvariant->setInvariant(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_localPostcondition_in_Action(std::shared_ptr<Action> par_Action, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Action)
	{
		par_Action->getLocalPostcondition()->push_back(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_localPrecondition_in_Action(std::shared_ptr<Action> par_Action, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Action)
	{
		par_Action->getLocalPrecondition()->push_back(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl(par_Namespace, uml::umlPackage::NAMEDELEMENT_ATTRIBUTE_NAMESPACE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_ownedRule_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl(par_Namespace, uml::umlPackage::CONSTRAINT_ATTRIBUTE_CONTEXT));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedRule()->push_back(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_postCondition_in_ProtocolTransition(std::shared_ptr<ProtocolTransition> par_ProtocolTransition, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ProtocolTransition)
	{
		par_ProtocolTransition->setPostCondition(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_postcondition_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->getPostcondition()->push_back(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_postcondition_in_Operation(std::shared_ptr<Operation> par_Operation, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Operation)
	{
		par_Operation->getPostcondition()->push_back(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_preCondition_in_ProtocolTransition(std::shared_ptr<ProtocolTransition> par_ProtocolTransition, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ProtocolTransition)
	{
		par_ProtocolTransition->setPreCondition(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_precondition_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->getPrecondition()->push_back(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_precondition_in_Operation(std::shared_ptr<Operation> par_Operation, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Operation)
	{
		par_Operation->getPrecondition()->push_back(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_stateInvariant_in_State(std::shared_ptr<State> par_State, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_State)
	{
		par_State->setStateInvariant(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationConstraint> umlFactoryImpl::createDurationConstraint_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<DurationConstraintImpl> element(new DurationConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisDurationConstraintPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	element->setThisDurationIntervalPtr(element);
	return element;
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_argument_in_Message(std::shared_ptr<Message> par_Message, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Message)
	{
		par_Message->getArgument()->push_back(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_argument_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->getArgument()->push_back(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_changeExpression_in_ChangeEvent(std::shared_ptr<ChangeEvent> par_ChangeEvent, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ChangeEvent)
	{
		par_ChangeEvent->setChangeExpression(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_defaultValue_in_Property(std::shared_ptr<Property> par_Property, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Property)
	{
		par_Property->setDefaultValue(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_defaultValue_in_Parameter(std::shared_ptr<Parameter> par_Parameter, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Parameter)
	{
		par_Parameter->setDefaultValue(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_expr_in_TimeExpression(std::shared_ptr<TimeExpression> par_TimeExpression, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TimeExpression)
	{
		par_TimeExpression->setExpr(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_expr_in_Duration(std::shared_ptr<Duration> par_Duration, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Duration)
	{
		par_Duration->setExpr(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_guard_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setGuard(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_joinSpec_in_JoinNode(std::shared_ptr<JoinNode> par_JoinNode, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_JoinNode)
	{
		par_JoinNode->setJoinSpec(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_lowerValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setLowerValue(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_maxint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMaxint(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_minint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMinint(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_operand_in_Expression(std::shared_ptr<Expression> par_Expression, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Expression)
	{
		par_Expression->getOperand()->push_back(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_returnValue_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->setReturnValue(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_selector_in_Lifeline(std::shared_ptr<Lifeline> par_Lifeline, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Lifeline)
	{
		par_Lifeline->setSelector(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_specification_in_Constraint(std::shared_ptr<Constraint> par_Constraint, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Constraint)
	{
		par_Constraint->setSpecification(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_specification_in_InstanceSpecification(std::shared_ptr<InstanceSpecification> par_InstanceSpecification, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InstanceSpecification)
	{
		par_InstanceSpecification->setSpecification(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_upperBound_in_ObjectNode(std::shared_ptr<ObjectNode> par_ObjectNode, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ObjectNode)
	{
		par_ObjectNode->setUpperBound(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_upperValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setUpperValue(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_value_in_Slot(std::weak_ptr<uml::Slot> par_Slot, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl(par_Slot));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Slot.lock())
	{
		wp->getValue()->push_back(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_value_in_ValueSpecificationAction(std::weak_ptr<uml::ValueSpecificationAction> par_ValueSpecificationAction, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl(par_ValueSpecificationAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ValueSpecificationAction.lock())
	{
		wp->setValue(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_value_in_ValuePin(std::shared_ptr<ValuePin> par_ValuePin, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ValuePin)
	{
		par_ValuePin->setValue(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationInterval> umlFactoryImpl::createDurationInterval_as_weight_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<DurationIntervalImpl> element(new DurationIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setWeight(element);
	}
	
	element->setThisDurationIntervalPtr(element);
	return element;
	
}
std::shared_ptr<DurationObservation> umlFactoryImpl::createDurationObservation(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<DurationObservationImpl> element(new DurationObservationImpl());
	element->setMetaElementID(metaElementID);
	element->setThisDurationObservationPtr(element);
	return element;
}
std::shared_ptr<DurationObservation> umlFactoryImpl::createDurationObservation_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DurationObservationImpl> element(new DurationObservationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisDurationObservationPtr(element);
	return element;
	
}
std::shared_ptr<DurationObservation> umlFactoryImpl::createDurationObservation_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<DurationObservationImpl> element(new DurationObservationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisDurationObservationPtr(element);
	return element;
	
}
std::shared_ptr<DurationObservation> umlFactoryImpl::createDurationObservation_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<DurationObservationImpl> element(new DurationObservationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisDurationObservationPtr(element);
	return element;
	
}
std::shared_ptr<DurationObservation> umlFactoryImpl::createDurationObservation_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DurationObservationImpl> element(new DurationObservationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisDurationObservationPtr(element);
	return element;
	
}
std::shared_ptr<DurationObservation> umlFactoryImpl::createDurationObservation_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<DurationObservationImpl> element(new DurationObservationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisDurationObservationPtr(element);
	return element;
	
}
std::shared_ptr<DurationObservation> umlFactoryImpl::createDurationObservation_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<DurationObservationImpl> element(new DurationObservationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisDurationObservationPtr(element);
	return element;
	
}
std::shared_ptr<DurationObservation> umlFactoryImpl::createDurationObservation_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<DurationObservationImpl> element(new DurationObservationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisDurationObservationPtr(element);
	return element;
	
}
std::shared_ptr<DurationObservation> umlFactoryImpl::createDurationObservation_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<DurationObservationImpl> element(new DurationObservationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisDurationObservationPtr(element);
	return element;
	
}
std::shared_ptr<DurationObservation> umlFactoryImpl::createDurationObservation_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<DurationObservationImpl> element(new DurationObservationImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisDurationObservationPtr(element);
	return element;
	
}
std::shared_ptr<DurationObservation> umlFactoryImpl::createDurationObservation_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<DurationObservationImpl> element(new DurationObservationImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisDurationObservationPtr(element);
	return element;
	
}
std::shared_ptr<DurationObservation> umlFactoryImpl::createDurationObservation_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<DurationObservationImpl> element(new DurationObservationImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisDurationObservationPtr(element);
	return element;
	
}
std::shared_ptr<DurationObservation> umlFactoryImpl::createDurationObservation_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<DurationObservationImpl> element(new DurationObservationImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisDurationObservationPtr(element);
	return element;
	
}
std::shared_ptr<DurationObservation> umlFactoryImpl::createDurationObservation_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<DurationObservationImpl> element(new DurationObservationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisDurationObservationPtr(element);
	return element;
	
}
std::shared_ptr<DurationObservation> umlFactoryImpl::createDurationObservation_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DurationObservationImpl> element(new DurationObservationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisDurationObservationPtr(element);
	return element;
	
}
std::shared_ptr<DurationObservation> umlFactoryImpl::createDurationObservation_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<DurationObservationImpl> element(new DurationObservationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisDurationObservationPtr(element);
	return element;
	
}
std::shared_ptr<DurationObservation> umlFactoryImpl::createDurationObservation_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<DurationObservationImpl> element(new DurationObservationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisDurationObservationPtr(element);
	return element;
	
}
std::shared_ptr<DurationObservation> umlFactoryImpl::createDurationObservation_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<DurationObservationImpl> element(new DurationObservationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisDurationObservationPtr(element);
	return element;
	
}
std::shared_ptr<ElementImport> umlFactoryImpl::createElementImport(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ElementImportImpl> element(new ElementImportImpl());
	element->setMetaElementID(metaElementID);
	element->setThisElementImportPtr(element);
	return element;
}
std::shared_ptr<ElementImport> umlFactoryImpl::createElementImport_as_elementImport_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ElementImportImpl> element(new ElementImportImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getElementImport()->push_back(element);
	}
	
	element->setThisElementImportPtr(element);
	return element;
	
}
std::shared_ptr<ElementImport> umlFactoryImpl::createElementImport_as_metaclassReference_in_Profile(std::shared_ptr<Profile> par_Profile, const int metaElementID) const
{
	std::shared_ptr<ElementImportImpl> element(new ElementImportImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Profile)
	{
		par_Profile->getMetaclassReference()->push_back(element);
	}
	
	element->setThisElementImportPtr(element);
	return element;
	
}
std::shared_ptr<ElementImport> umlFactoryImpl::createElementImport_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ElementImportImpl> element(new ElementImportImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisElementImportPtr(element);
	return element;
	
}
std::shared_ptr<ElementImport> umlFactoryImpl::createElementImport_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ElementImportImpl> element(new ElementImportImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisElementImportPtr(element);
	return element;
	
}
std::shared_ptr<ElementImport> umlFactoryImpl::createElementImport_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ElementImportImpl> element(new ElementImportImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisElementImportPtr(element);
	return element;
	
}
std::shared_ptr<Enumeration> umlFactoryImpl::createEnumeration(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<EnumerationImpl> element(new EnumerationImpl());
	element->setMetaElementID(metaElementID);
	element->setThisEnumerationPtr(element);
	return element;
}
std::shared_ptr<Enumeration> umlFactoryImpl::createEnumeration_as_classifier_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<EnumerationImpl> element(new EnumerationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->setClassifier(element);
	}
	
	element->setThisEnumerationPtr(element);
	return element;
	
}
std::shared_ptr<Enumeration> umlFactoryImpl::createEnumeration_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<EnumerationImpl> element(new EnumerationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisEnumerationPtr(element);
	return element;
	
}
std::shared_ptr<Enumeration> umlFactoryImpl::createEnumeration_as_contract_in_Substitution(std::shared_ptr<Substitution> par_Substitution, const int metaElementID) const
{
	std::shared_ptr<EnumerationImpl> element(new EnumerationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Substitution)
	{
		par_Substitution->setContract(element);
	}
	
	element->setThisEnumerationPtr(element);
	return element;
	
}
std::shared_ptr<Enumeration> umlFactoryImpl::createEnumeration_as_endType_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<EnumerationImpl> element(new EnumerationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getEndType()->push_back(element);
	}
	
	element->setThisEnumerationPtr(element);
	return element;
	
}
std::shared_ptr<Enumeration> umlFactoryImpl::createEnumeration_as_general_in_Generalization(std::shared_ptr<Generalization> par_Generalization, const int metaElementID) const
{
	std::shared_ptr<EnumerationImpl> element(new EnumerationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Generalization)
	{
		par_Generalization->setGeneral(element);
	}
	
	element->setThisEnumerationPtr(element);
	return element;
	
}
std::shared_ptr<Enumeration> umlFactoryImpl::createEnumeration_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<EnumerationImpl> element(new EnumerationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisEnumerationPtr(element);
	return element;
	
}
std::shared_ptr<Enumeration> umlFactoryImpl::createEnumeration_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<EnumerationImpl> element(new EnumerationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisEnumerationPtr(element);
	return element;
	
}
std::shared_ptr<Enumeration> umlFactoryImpl::createEnumeration_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<EnumerationImpl> element(new EnumerationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisEnumerationPtr(element);
	return element;
	
}
std::shared_ptr<Enumeration> umlFactoryImpl::createEnumeration_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<EnumerationImpl> element(new EnumerationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisEnumerationPtr(element);
	return element;
	
}
std::shared_ptr<Enumeration> umlFactoryImpl::createEnumeration_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<EnumerationImpl> element(new EnumerationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisEnumerationPtr(element);
	return element;
	
}
std::shared_ptr<Enumeration> umlFactoryImpl::createEnumeration_as_nestedClassifier_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<EnumerationImpl> element(new EnumerationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getNestedClassifier()->push_back(element);
	}
	
	element->setThisEnumerationPtr(element);
	return element;
	
}
std::shared_ptr<Enumeration> umlFactoryImpl::createEnumeration_as_nestedClassifier_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<EnumerationImpl> element(new EnumerationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getNestedClassifier()->push_back(element);
	}
	
	element->setThisEnumerationPtr(element);
	return element;
	
}
std::shared_ptr<Enumeration> umlFactoryImpl::createEnumeration_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<EnumerationImpl> element(new EnumerationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisEnumerationPtr(element);
	return element;
	
}
std::shared_ptr<Enumeration> umlFactoryImpl::createEnumeration_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<EnumerationImpl> element(new EnumerationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisEnumerationPtr(element);
	return element;
	
}
std::shared_ptr<Enumeration> umlFactoryImpl::createEnumeration_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<EnumerationImpl> element(new EnumerationImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisEnumerationPtr(element);
	return element;
	
}
std::shared_ptr<Enumeration> umlFactoryImpl::createEnumeration_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<EnumerationImpl> element(new EnumerationImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisEnumerationPtr(element);
	return element;
	
}
std::shared_ptr<Enumeration> umlFactoryImpl::createEnumeration_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<EnumerationImpl> element(new EnumerationImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisEnumerationPtr(element);
	return element;
	
}
std::shared_ptr<Enumeration> umlFactoryImpl::createEnumeration_as_ownedType_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<EnumerationImpl> element(new EnumerationImpl(par_Package, uml::umlPackage::TYPE_ATTRIBUTE_PACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getOwnedType()->push_back(element);
	}
	
	element->setThisEnumerationPtr(element);
	return element;
	
}
std::shared_ptr<Enumeration> umlFactoryImpl::createEnumeration_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<EnumerationImpl> element(new EnumerationImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisEnumerationPtr(element);
	return element;
	
}
std::shared_ptr<Enumeration> umlFactoryImpl::createEnumeration_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<EnumerationImpl> element(new EnumerationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisEnumerationPtr(element);
	return element;
	
}
std::shared_ptr<Enumeration> umlFactoryImpl::createEnumeration_as_realizingClassifier_in_ComponentRealization(std::shared_ptr<ComponentRealization> par_ComponentRealization, const int metaElementID) const
{
	std::shared_ptr<EnumerationImpl> element(new EnumerationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ComponentRealization)
	{
		par_ComponentRealization->getRealizingClassifier()->push_back(element);
	}
	
	element->setThisEnumerationPtr(element);
	return element;
	
}
std::shared_ptr<Enumeration> umlFactoryImpl::createEnumeration_as_redefinedClassifier_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<EnumerationImpl> element(new EnumerationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getRedefinedClassifier()->push_back(element);
	}
	
	element->setThisEnumerationPtr(element);
	return element;
	
}
std::shared_ptr<Enumeration> umlFactoryImpl::createEnumeration_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<EnumerationImpl> element(new EnumerationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisEnumerationPtr(element);
	return element;
	
}
std::shared_ptr<Enumeration> umlFactoryImpl::createEnumeration_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<EnumerationImpl> element(new EnumerationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisEnumerationPtr(element);
	return element;
	
}
std::shared_ptr<Enumeration> umlFactoryImpl::createEnumeration_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<EnumerationImpl> element(new EnumerationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisEnumerationPtr(element);
	return element;
	
}
std::shared_ptr<Enumeration> umlFactoryImpl::createEnumeration_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<EnumerationImpl> element(new EnumerationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisEnumerationPtr(element);
	return element;
	
}
std::shared_ptr<EnumerationLiteral> umlFactoryImpl::createEnumerationLiteral(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<EnumerationLiteralImpl> element(new EnumerationLiteralImpl());
	element->setMetaElementID(metaElementID);
	element->setThisEnumerationLiteralPtr(element);
	return element;
}
std::shared_ptr<EnumerationLiteral> umlFactoryImpl::createEnumerationLiteral_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<EnumerationLiteralImpl> element(new EnumerationLiteralImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisEnumerationLiteralPtr(element);
	return element;
	
}
std::shared_ptr<EnumerationLiteral> umlFactoryImpl::createEnumerationLiteral_as_deployedArtifact_in_Deployment(std::shared_ptr<Deployment> par_Deployment, const int metaElementID) const
{
	std::shared_ptr<EnumerationLiteralImpl> element(new EnumerationLiteralImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Deployment)
	{
		par_Deployment->getDeployedArtifact()->push_back(element);
	}
	
	element->setThisEnumerationLiteralPtr(element);
	return element;
	
}
std::shared_ptr<EnumerationLiteral> umlFactoryImpl::createEnumerationLiteral_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<EnumerationLiteralImpl> element(new EnumerationLiteralImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisEnumerationLiteralPtr(element);
	return element;
	
}
std::shared_ptr<EnumerationLiteral> umlFactoryImpl::createEnumerationLiteral_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<EnumerationLiteralImpl> element(new EnumerationLiteralImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisEnumerationLiteralPtr(element);
	return element;
	
}
std::shared_ptr<EnumerationLiteral> umlFactoryImpl::createEnumerationLiteral_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<EnumerationLiteralImpl> element(new EnumerationLiteralImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisEnumerationLiteralPtr(element);
	return element;
	
}
std::shared_ptr<EnumerationLiteral> umlFactoryImpl::createEnumerationLiteral_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<EnumerationLiteralImpl> element(new EnumerationLiteralImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisEnumerationLiteralPtr(element);
	return element;
	
}
std::shared_ptr<EnumerationLiteral> umlFactoryImpl::createEnumerationLiteral_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<EnumerationLiteralImpl> element(new EnumerationLiteralImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisEnumerationLiteralPtr(element);
	return element;
	
}
std::shared_ptr<EnumerationLiteral> umlFactoryImpl::createEnumerationLiteral_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<EnumerationLiteralImpl> element(new EnumerationLiteralImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisEnumerationLiteralPtr(element);
	return element;
	
}
std::shared_ptr<EnumerationLiteral> umlFactoryImpl::createEnumerationLiteral_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<EnumerationLiteralImpl> element(new EnumerationLiteralImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisEnumerationLiteralPtr(element);
	return element;
	
}
std::shared_ptr<EnumerationLiteral> umlFactoryImpl::createEnumerationLiteral_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<EnumerationLiteralImpl> element(new EnumerationLiteralImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisEnumerationLiteralPtr(element);
	return element;
	
}
std::shared_ptr<EnumerationLiteral> umlFactoryImpl::createEnumerationLiteral_as_ownedLiteral_in_Enumeration(std::weak_ptr<uml::Enumeration> par_Enumeration, const int metaElementID) const
{
	std::shared_ptr<EnumerationLiteralImpl> element(new EnumerationLiteralImpl(par_Enumeration));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Enumeration.lock())
	{
		wp->getOwnedLiteral()->push_back(element);
	}
	
	element->setThisEnumerationLiteralPtr(element);
	return element;
	
}
std::shared_ptr<EnumerationLiteral> umlFactoryImpl::createEnumerationLiteral_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<EnumerationLiteralImpl> element(new EnumerationLiteralImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisEnumerationLiteralPtr(element);
	return element;
	
}
std::shared_ptr<EnumerationLiteral> umlFactoryImpl::createEnumerationLiteral_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<EnumerationLiteralImpl> element(new EnumerationLiteralImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisEnumerationLiteralPtr(element);
	return element;
	
}
std::shared_ptr<EnumerationLiteral> umlFactoryImpl::createEnumerationLiteral_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<EnumerationLiteralImpl> element(new EnumerationLiteralImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisEnumerationLiteralPtr(element);
	return element;
	
}
std::shared_ptr<EnumerationLiteral> umlFactoryImpl::createEnumerationLiteral_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<EnumerationLiteralImpl> element(new EnumerationLiteralImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisEnumerationLiteralPtr(element);
	return element;
	
}
std::shared_ptr<EnumerationLiteral> umlFactoryImpl::createEnumerationLiteral_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<EnumerationLiteralImpl> element(new EnumerationLiteralImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisEnumerationLiteralPtr(element);
	return element;
	
}
std::shared_ptr<EnumerationLiteral> umlFactoryImpl::createEnumerationLiteral_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<EnumerationLiteralImpl> element(new EnumerationLiteralImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisEnumerationLiteralPtr(element);
	return element;
	
}
std::shared_ptr<EnumerationLiteral> umlFactoryImpl::createEnumerationLiteral_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<EnumerationLiteralImpl> element(new EnumerationLiteralImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisEnumerationLiteralPtr(element);
	return element;
	
}
std::shared_ptr<EnumerationLiteral> umlFactoryImpl::createEnumerationLiteral_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<EnumerationLiteralImpl> element(new EnumerationLiteralImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisEnumerationLiteralPtr(element);
	return element;
	
}
std::shared_ptr<ExceptionHandler> umlFactoryImpl::createExceptionHandler(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ExceptionHandlerImpl> element(new ExceptionHandlerImpl());
	element->setMetaElementID(metaElementID);
	element->setThisExceptionHandlerPtr(element);
	return element;
}
std::shared_ptr<ExceptionHandler> umlFactoryImpl::createExceptionHandler_as_handler_in_ExecutableNode(std::weak_ptr<uml::ExecutableNode> par_ExecutableNode, const int metaElementID) const
{
	std::shared_ptr<ExceptionHandlerImpl> element(new ExceptionHandlerImpl(par_ExecutableNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ExecutableNode.lock())
	{
		wp->getHandler()->push_back(element);
	}
	
	element->setThisExceptionHandlerPtr(element);
	return element;
	
}
std::shared_ptr<ExceptionHandler> umlFactoryImpl::createExceptionHandler_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ExceptionHandlerImpl> element(new ExceptionHandlerImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisExceptionHandlerPtr(element);
	return element;
	
}
std::shared_ptr<ExceptionHandler> umlFactoryImpl::createExceptionHandler_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ExceptionHandlerImpl> element(new ExceptionHandlerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisExceptionHandlerPtr(element);
	return element;
	
}
std::shared_ptr<ExceptionHandler> umlFactoryImpl::createExceptionHandler_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ExceptionHandlerImpl> element(new ExceptionHandlerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisExceptionHandlerPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl());
	element->setMetaElementID(metaElementID);
	element->setThisExecutionEnvironmentPtr(element);
	return element;
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_classifier_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->setClassifier(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_context_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->setContext(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_contract_in_Substitution(std::shared_ptr<Substitution> par_Substitution, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Substitution)
	{
		par_Substitution->setContract(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_endType_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getEndType()->push_back(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_general_in_Generalization(std::shared_ptr<Generalization> par_Generalization, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Generalization)
	{
		par_Generalization->setGeneral(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_nestedClassifier_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getNestedClassifier()->push_back(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_nestedClassifier_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getNestedClassifier()->push_back(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_nestedNode_in_Node(std::shared_ptr<Node> par_Node, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Node)
	{
		par_Node->getNestedNode()->push_back(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_ownedType_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl(par_Package, uml::umlPackage::TYPE_ATTRIBUTE_PACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getOwnedType()->push_back(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_realizingClassifier_in_ComponentRealization(std::shared_ptr<ComponentRealization> par_ComponentRealization, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ComponentRealization)
	{
		par_ComponentRealization->getRealizingClassifier()->push_back(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_redefinedClassifier_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getRedefinedClassifier()->push_back(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionEnvironment> umlFactoryImpl::createExecutionEnvironment_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<ExecutionEnvironmentImpl> element(new ExecutionEnvironmentImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisExecutionEnvironmentPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionOccurrenceSpecification> umlFactoryImpl::createExecutionOccurrenceSpecification(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ExecutionOccurrenceSpecificationImpl> element(new ExecutionOccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	element->setThisExecutionOccurrenceSpecificationPtr(element);
	return element;
}
std::shared_ptr<ExecutionOccurrenceSpecification> umlFactoryImpl::createExecutionOccurrenceSpecification_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ExecutionOccurrenceSpecificationImpl> element(new ExecutionOccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisExecutionOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionOccurrenceSpecification> umlFactoryImpl::createExecutionOccurrenceSpecification_as_fragment_in_Interaction(std::weak_ptr<uml::Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<ExecutionOccurrenceSpecificationImpl> element(new ExecutionOccurrenceSpecificationImpl(par_Interaction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Interaction.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisExecutionOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionOccurrenceSpecification> umlFactoryImpl::createExecutionOccurrenceSpecification_as_fragment_in_InteractionOperand(std::weak_ptr<uml::InteractionOperand> par_InteractionOperand, const int metaElementID) const
{
	std::shared_ptr<ExecutionOccurrenceSpecificationImpl> element(new ExecutionOccurrenceSpecificationImpl(par_InteractionOperand));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_InteractionOperand.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisExecutionOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionOccurrenceSpecification> umlFactoryImpl::createExecutionOccurrenceSpecification_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ExecutionOccurrenceSpecificationImpl> element(new ExecutionOccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisExecutionOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionOccurrenceSpecification> umlFactoryImpl::createExecutionOccurrenceSpecification_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ExecutionOccurrenceSpecificationImpl> element(new ExecutionOccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisExecutionOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionOccurrenceSpecification> umlFactoryImpl::createExecutionOccurrenceSpecification_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ExecutionOccurrenceSpecificationImpl> element(new ExecutionOccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisExecutionOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionOccurrenceSpecification> umlFactoryImpl::createExecutionOccurrenceSpecification_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ExecutionOccurrenceSpecificationImpl> element(new ExecutionOccurrenceSpecificationImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisExecutionOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionOccurrenceSpecification> umlFactoryImpl::createExecutionOccurrenceSpecification_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ExecutionOccurrenceSpecificationImpl> element(new ExecutionOccurrenceSpecificationImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisExecutionOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionOccurrenceSpecification> umlFactoryImpl::createExecutionOccurrenceSpecification_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ExecutionOccurrenceSpecificationImpl> element(new ExecutionOccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisExecutionOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionOccurrenceSpecification> umlFactoryImpl::createExecutionOccurrenceSpecification_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ExecutionOccurrenceSpecificationImpl> element(new ExecutionOccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisExecutionOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<ExecutionOccurrenceSpecification> umlFactoryImpl::createExecutionOccurrenceSpecification_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ExecutionOccurrenceSpecificationImpl> element(new ExecutionOccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisExecutionOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<ExpansionNode> umlFactoryImpl::createExpansionNode(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ExpansionNodeImpl> element(new ExpansionNodeImpl());
	element->setMetaElementID(metaElementID);
	element->setThisExpansionNodePtr(element);
	return element;
}
std::shared_ptr<ExpansionNode> umlFactoryImpl::createExpansionNode_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ExpansionNodeImpl> element(new ExpansionNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisExpansionNodePtr(element);
	return element;
	
}
std::shared_ptr<ExpansionNode> umlFactoryImpl::createExpansionNode_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ExpansionNodeImpl> element(new ExpansionNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisExpansionNodePtr(element);
	return element;
	
}
std::shared_ptr<ExpansionNode> umlFactoryImpl::createExpansionNode_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ExpansionNodeImpl> element(new ExpansionNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisExpansionNodePtr(element);
	return element;
	
}
std::shared_ptr<ExpansionNode> umlFactoryImpl::createExpansionNode_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ExpansionNodeImpl> element(new ExpansionNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisExpansionNodePtr(element);
	return element;
	
}
std::shared_ptr<ExpansionNode> umlFactoryImpl::createExpansionNode_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ExpansionNodeImpl> element(new ExpansionNodeImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisExpansionNodePtr(element);
	return element;
	
}
std::shared_ptr<ExpansionNode> umlFactoryImpl::createExpansionNode_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<ExpansionNodeImpl> element(new ExpansionNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisExpansionNodePtr(element);
	return element;
	
}
std::shared_ptr<ExpansionNode> umlFactoryImpl::createExpansionNode_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<ExpansionNodeImpl> element(new ExpansionNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisExpansionNodePtr(element);
	return element;
	
}
std::shared_ptr<ExpansionNode> umlFactoryImpl::createExpansionNode_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<ExpansionNodeImpl> element(new ExpansionNodeImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisExpansionNodePtr(element);
	return element;
	
}
std::shared_ptr<ExpansionNode> umlFactoryImpl::createExpansionNode_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ExpansionNodeImpl> element(new ExpansionNodeImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisExpansionNodePtr(element);
	return element;
	
}
std::shared_ptr<ExpansionNode> umlFactoryImpl::createExpansionNode_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ExpansionNodeImpl> element(new ExpansionNodeImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisExpansionNodePtr(element);
	return element;
	
}
std::shared_ptr<ExpansionNode> umlFactoryImpl::createExpansionNode_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ExpansionNodeImpl> element(new ExpansionNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisExpansionNodePtr(element);
	return element;
	
}
std::shared_ptr<ExpansionNode> umlFactoryImpl::createExpansionNode_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<ExpansionNodeImpl> element(new ExpansionNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisExpansionNodePtr(element);
	return element;
	
}
std::shared_ptr<ExpansionNode> umlFactoryImpl::createExpansionNode_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ExpansionNodeImpl> element(new ExpansionNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisExpansionNodePtr(element);
	return element;
	
}
std::shared_ptr<ExpansionNode> umlFactoryImpl::createExpansionNode_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ExpansionNodeImpl> element(new ExpansionNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisExpansionNodePtr(element);
	return element;
	
}
std::shared_ptr<ExpansionNode> umlFactoryImpl::createExpansionNode_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ExpansionNodeImpl> element(new ExpansionNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisExpansionNodePtr(element);
	return element;
	
}
std::shared_ptr<ExpansionRegion> umlFactoryImpl::createExpansionRegion(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ExpansionRegionImpl> element(new ExpansionRegionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisExpansionRegionPtr(element);
	return element;
}
std::shared_ptr<ExpansionRegion> umlFactoryImpl::createExpansionRegion_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<ExpansionRegionImpl> element(new ExpansionRegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisExpansionRegionPtr(element);
	return element;
	
}
std::shared_ptr<ExpansionRegion> umlFactoryImpl::createExpansionRegion_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ExpansionRegionImpl> element(new ExpansionRegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisExpansionRegionPtr(element);
	return element;
	
}
std::shared_ptr<ExpansionRegion> umlFactoryImpl::createExpansionRegion_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<ExpansionRegionImpl> element(new ExpansionRegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisExpansionRegionPtr(element);
	return element;
	
}
std::shared_ptr<ExpansionRegion> umlFactoryImpl::createExpansionRegion_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<ExpansionRegionImpl> element(new ExpansionRegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisExpansionRegionPtr(element);
	return element;
	
}
std::shared_ptr<ExpansionRegion> umlFactoryImpl::createExpansionRegion_as_group_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ExpansionRegionImpl> element(new ExpansionRegionImpl(par_Activity, uml::umlPackage::ACTIVITYGROUP_ATTRIBUTE_INACTIVITY));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getGroup()->push_back(element);
	}
	
	element->setThisExpansionRegionPtr(element);
	return element;
	
}
std::shared_ptr<ExpansionRegion> umlFactoryImpl::createExpansionRegion_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ExpansionRegionImpl> element(new ExpansionRegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisExpansionRegionPtr(element);
	return element;
	
}
std::shared_ptr<ExpansionRegion> umlFactoryImpl::createExpansionRegion_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ExpansionRegionImpl> element(new ExpansionRegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisExpansionRegionPtr(element);
	return element;
	
}
std::shared_ptr<ExpansionRegion> umlFactoryImpl::createExpansionRegion_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ExpansionRegionImpl> element(new ExpansionRegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisExpansionRegionPtr(element);
	return element;
	
}
std::shared_ptr<ExpansionRegion> umlFactoryImpl::createExpansionRegion_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ExpansionRegionImpl> element(new ExpansionRegionImpl(par_Activity, uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_ACTIVITY));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisExpansionRegionPtr(element);
	return element;
	
}
std::shared_ptr<ExpansionRegion> umlFactoryImpl::createExpansionRegion_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<ExpansionRegionImpl> element(new ExpansionRegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisExpansionRegionPtr(element);
	return element;
	
}
std::shared_ptr<ExpansionRegion> umlFactoryImpl::createExpansionRegion_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<ExpansionRegionImpl> element(new ExpansionRegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisExpansionRegionPtr(element);
	return element;
	
}
std::shared_ptr<ExpansionRegion> umlFactoryImpl::createExpansionRegion_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<ExpansionRegionImpl> element(new ExpansionRegionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisExpansionRegionPtr(element);
	return element;
	
}
std::shared_ptr<ExpansionRegion> umlFactoryImpl::createExpansionRegion_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ExpansionRegionImpl> element(new ExpansionRegionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisExpansionRegionPtr(element);
	return element;
	
}
std::shared_ptr<ExpansionRegion> umlFactoryImpl::createExpansionRegion_as_ownedGroup_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ExpansionRegionImpl> element(new ExpansionRegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedGroup()->push_back(element);
	}
	
	element->setThisExpansionRegionPtr(element);
	return element;
	
}
std::shared_ptr<ExpansionRegion> umlFactoryImpl::createExpansionRegion_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ExpansionRegionImpl> element(new ExpansionRegionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisExpansionRegionPtr(element);
	return element;
	
}
std::shared_ptr<ExpansionRegion> umlFactoryImpl::createExpansionRegion_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ExpansionRegionImpl> element(new ExpansionRegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisExpansionRegionPtr(element);
	return element;
	
}
std::shared_ptr<ExpansionRegion> umlFactoryImpl::createExpansionRegion_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<ExpansionRegionImpl> element(new ExpansionRegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisExpansionRegionPtr(element);
	return element;
	
}
std::shared_ptr<ExpansionRegion> umlFactoryImpl::createExpansionRegion_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ExpansionRegionImpl> element(new ExpansionRegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisExpansionRegionPtr(element);
	return element;
	
}
std::shared_ptr<ExpansionRegion> umlFactoryImpl::createExpansionRegion_as_structuredNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ExpansionRegionImpl> element(new ExpansionRegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getStructuredNode()->push_back(element);
	}
	
	element->setThisExpansionRegionPtr(element);
	return element;
	
}
std::shared_ptr<ExpansionRegion> umlFactoryImpl::createExpansionRegion_as_subgroup_in_ActivityGroup(std::weak_ptr<uml::ActivityGroup> par_ActivityGroup, const int metaElementID) const
{
	std::shared_ptr<ExpansionRegionImpl> element(new ExpansionRegionImpl(par_ActivityGroup));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ActivityGroup.lock())
	{
		wp->getSubgroup()->push_back(element);
	}
	
	element->setThisExpansionRegionPtr(element);
	return element;
	
}
std::shared_ptr<ExpansionRegion> umlFactoryImpl::createExpansionRegion_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ExpansionRegionImpl> element(new ExpansionRegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisExpansionRegionPtr(element);
	return element;
	
}
std::shared_ptr<ExpansionRegion> umlFactoryImpl::createExpansionRegion_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ExpansionRegionImpl> element(new ExpansionRegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisExpansionRegionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisExpressionPtr(element);
	return element;
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_argument_in_Message(std::shared_ptr<Message> par_Message, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Message)
	{
		par_Message->getArgument()->push_back(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_argument_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->getArgument()->push_back(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_changeExpression_in_ChangeEvent(std::shared_ptr<ChangeEvent> par_ChangeEvent, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ChangeEvent)
	{
		par_ChangeEvent->setChangeExpression(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_defaultValue_in_Property(std::shared_ptr<Property> par_Property, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Property)
	{
		par_Property->setDefaultValue(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_defaultValue_in_Parameter(std::shared_ptr<Parameter> par_Parameter, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Parameter)
	{
		par_Parameter->setDefaultValue(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_expr_in_TimeExpression(std::shared_ptr<TimeExpression> par_TimeExpression, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TimeExpression)
	{
		par_TimeExpression->setExpr(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_expr_in_Duration(std::shared_ptr<Duration> par_Duration, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Duration)
	{
		par_Duration->setExpr(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_guard_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setGuard(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_joinSpec_in_JoinNode(std::shared_ptr<JoinNode> par_JoinNode, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_JoinNode)
	{
		par_JoinNode->setJoinSpec(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_lowerValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setLowerValue(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_maxint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMaxint(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_minint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMinint(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_operand_in_Expression(std::shared_ptr<Expression> par_Expression, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Expression)
	{
		par_Expression->getOperand()->push_back(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_returnValue_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->setReturnValue(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_selector_in_Lifeline(std::shared_ptr<Lifeline> par_Lifeline, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Lifeline)
	{
		par_Lifeline->setSelector(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_specification_in_Constraint(std::shared_ptr<Constraint> par_Constraint, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Constraint)
	{
		par_Constraint->setSpecification(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_specification_in_InstanceSpecification(std::shared_ptr<InstanceSpecification> par_InstanceSpecification, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InstanceSpecification)
	{
		par_InstanceSpecification->setSpecification(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_upperBound_in_ObjectNode(std::shared_ptr<ObjectNode> par_ObjectNode, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ObjectNode)
	{
		par_ObjectNode->setUpperBound(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_upperValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setUpperValue(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_value_in_Slot(std::weak_ptr<uml::Slot> par_Slot, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl(par_Slot));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Slot.lock())
	{
		wp->getValue()->push_back(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_value_in_ValueSpecificationAction(std::weak_ptr<uml::ValueSpecificationAction> par_ValueSpecificationAction, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl(par_ValueSpecificationAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ValueSpecificationAction.lock())
	{
		wp->setValue(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_value_in_ValuePin(std::shared_ptr<ValuePin> par_ValuePin, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ValuePin)
	{
		par_ValuePin->setValue(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Expression> umlFactoryImpl::createExpression_as_weight_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<ExpressionImpl> element(new ExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setWeight(element);
	}
	
	element->setThisExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Extend> umlFactoryImpl::createExtend(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ExtendImpl> element(new ExtendImpl());
	element->setMetaElementID(metaElementID);
	element->setThisExtendPtr(element);
	return element;
}
std::shared_ptr<Extend> umlFactoryImpl::createExtend_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ExtendImpl> element(new ExtendImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisExtendPtr(element);
	return element;
	
}
std::shared_ptr<Extend> umlFactoryImpl::createExtend_as_extend_in_UseCase(std::weak_ptr<uml::UseCase> par_UseCase, const int metaElementID) const
{
	std::shared_ptr<ExtendImpl> element(new ExtendImpl(par_UseCase));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_UseCase.lock())
	{
		wp->getExtend()->push_back(element);
	}
	
	element->setThisExtendPtr(element);
	return element;
	
}
std::shared_ptr<Extend> umlFactoryImpl::createExtend_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ExtendImpl> element(new ExtendImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisExtendPtr(element);
	return element;
	
}
std::shared_ptr<Extend> umlFactoryImpl::createExtend_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ExtendImpl> element(new ExtendImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisExtendPtr(element);
	return element;
	
}
std::shared_ptr<Extend> umlFactoryImpl::createExtend_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ExtendImpl> element(new ExtendImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisExtendPtr(element);
	return element;
	
}
std::shared_ptr<Extend> umlFactoryImpl::createExtend_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ExtendImpl> element(new ExtendImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisExtendPtr(element);
	return element;
	
}
std::shared_ptr<Extend> umlFactoryImpl::createExtend_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ExtendImpl> element(new ExtendImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisExtendPtr(element);
	return element;
	
}
std::shared_ptr<Extend> umlFactoryImpl::createExtend_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ExtendImpl> element(new ExtendImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisExtendPtr(element);
	return element;
	
}
std::shared_ptr<Extend> umlFactoryImpl::createExtend_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ExtendImpl> element(new ExtendImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisExtendPtr(element);
	return element;
	
}
std::shared_ptr<Extend> umlFactoryImpl::createExtend_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ExtendImpl> element(new ExtendImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisExtendPtr(element);
	return element;
	
}
std::shared_ptr<Extension> umlFactoryImpl::createExtension(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ExtensionImpl> element(new ExtensionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisExtensionPtr(element);
	return element;
}
std::shared_ptr<Extension> umlFactoryImpl::createExtension_as_classifier_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<ExtensionImpl> element(new ExtensionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->setClassifier(element);
	}
	
	element->setThisExtensionPtr(element);
	return element;
	
}
std::shared_ptr<Extension> umlFactoryImpl::createExtension_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ExtensionImpl> element(new ExtensionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisExtensionPtr(element);
	return element;
	
}
std::shared_ptr<Extension> umlFactoryImpl::createExtension_as_contract_in_Substitution(std::shared_ptr<Substitution> par_Substitution, const int metaElementID) const
{
	std::shared_ptr<ExtensionImpl> element(new ExtensionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Substitution)
	{
		par_Substitution->setContract(element);
	}
	
	element->setThisExtensionPtr(element);
	return element;
	
}
std::shared_ptr<Extension> umlFactoryImpl::createExtension_as_endType_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<ExtensionImpl> element(new ExtensionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getEndType()->push_back(element);
	}
	
	element->setThisExtensionPtr(element);
	return element;
	
}
std::shared_ptr<Extension> umlFactoryImpl::createExtension_as_general_in_Generalization(std::shared_ptr<Generalization> par_Generalization, const int metaElementID) const
{
	std::shared_ptr<ExtensionImpl> element(new ExtensionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Generalization)
	{
		par_Generalization->setGeneral(element);
	}
	
	element->setThisExtensionPtr(element);
	return element;
	
}
std::shared_ptr<Extension> umlFactoryImpl::createExtension_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<ExtensionImpl> element(new ExtensionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisExtensionPtr(element);
	return element;
	
}
std::shared_ptr<Extension> umlFactoryImpl::createExtension_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ExtensionImpl> element(new ExtensionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisExtensionPtr(element);
	return element;
	
}
std::shared_ptr<Extension> umlFactoryImpl::createExtension_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ExtensionImpl> element(new ExtensionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisExtensionPtr(element);
	return element;
	
}
std::shared_ptr<Extension> umlFactoryImpl::createExtension_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ExtensionImpl> element(new ExtensionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisExtensionPtr(element);
	return element;
	
}
std::shared_ptr<Extension> umlFactoryImpl::createExtension_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ExtensionImpl> element(new ExtensionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisExtensionPtr(element);
	return element;
	
}
std::shared_ptr<Extension> umlFactoryImpl::createExtension_as_nestedClassifier_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<ExtensionImpl> element(new ExtensionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getNestedClassifier()->push_back(element);
	}
	
	element->setThisExtensionPtr(element);
	return element;
	
}
std::shared_ptr<Extension> umlFactoryImpl::createExtension_as_nestedClassifier_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<ExtensionImpl> element(new ExtensionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getNestedClassifier()->push_back(element);
	}
	
	element->setThisExtensionPtr(element);
	return element;
	
}
std::shared_ptr<Extension> umlFactoryImpl::createExtension_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<ExtensionImpl> element(new ExtensionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisExtensionPtr(element);
	return element;
	
}
std::shared_ptr<Extension> umlFactoryImpl::createExtension_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ExtensionImpl> element(new ExtensionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisExtensionPtr(element);
	return element;
	
}
std::shared_ptr<Extension> umlFactoryImpl::createExtension_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ExtensionImpl> element(new ExtensionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisExtensionPtr(element);
	return element;
	
}
std::shared_ptr<Extension> umlFactoryImpl::createExtension_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ExtensionImpl> element(new ExtensionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisExtensionPtr(element);
	return element;
	
}
std::shared_ptr<Extension> umlFactoryImpl::createExtension_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ExtensionImpl> element(new ExtensionImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisExtensionPtr(element);
	return element;
	
}
std::shared_ptr<Extension> umlFactoryImpl::createExtension_as_ownedType_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<ExtensionImpl> element(new ExtensionImpl(par_Package, uml::umlPackage::TYPE_ATTRIBUTE_PACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getOwnedType()->push_back(element);
	}
	
	element->setThisExtensionPtr(element);
	return element;
	
}
std::shared_ptr<Extension> umlFactoryImpl::createExtension_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<ExtensionImpl> element(new ExtensionImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisExtensionPtr(element);
	return element;
	
}
std::shared_ptr<Extension> umlFactoryImpl::createExtension_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<ExtensionImpl> element(new ExtensionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisExtensionPtr(element);
	return element;
	
}
std::shared_ptr<Extension> umlFactoryImpl::createExtension_as_realizingClassifier_in_ComponentRealization(std::shared_ptr<ComponentRealization> par_ComponentRealization, const int metaElementID) const
{
	std::shared_ptr<ExtensionImpl> element(new ExtensionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ComponentRealization)
	{
		par_ComponentRealization->getRealizingClassifier()->push_back(element);
	}
	
	element->setThisExtensionPtr(element);
	return element;
	
}
std::shared_ptr<Extension> umlFactoryImpl::createExtension_as_redefinedClassifier_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ExtensionImpl> element(new ExtensionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getRedefinedClassifier()->push_back(element);
	}
	
	element->setThisExtensionPtr(element);
	return element;
	
}
std::shared_ptr<Extension> umlFactoryImpl::createExtension_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ExtensionImpl> element(new ExtensionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisExtensionPtr(element);
	return element;
	
}
std::shared_ptr<Extension> umlFactoryImpl::createExtension_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ExtensionImpl> element(new ExtensionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisExtensionPtr(element);
	return element;
	
}
std::shared_ptr<Extension> umlFactoryImpl::createExtension_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ExtensionImpl> element(new ExtensionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisExtensionPtr(element);
	return element;
	
}
std::shared_ptr<Extension> umlFactoryImpl::createExtension_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<ExtensionImpl> element(new ExtensionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisExtensionPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl());
	element->setMetaElementID(metaElementID);
	element->setThisExtensionEndPtr(element);
	return element;
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd_as_attribute_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getAttribute()->push_back(element);
	}
	
	element->setThisExtensionEndPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisExtensionEndPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd_as_collaborationRole_in_Collaboration(std::shared_ptr<Collaboration> par_Collaboration, const int metaElementID) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Collaboration)
	{
		par_Collaboration->getCollaborationRole()->push_back(element);
	}
	
	element->setThisExtensionEndPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd_as_feature_in_Classifier(std::shared_ptr<uml::Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getFeature()->push_back(element);
	}
	
	element->setThisExtensionEndPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisExtensionEndPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisExtensionEndPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisExtensionEndPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd_as_memberEnd_in_Association(std::shared_ptr<uml::Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getMemberEnd()->push_back(element);
	}
	
	element->setThisExtensionEndPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd_as_navigableOwnedEnd_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getNavigableOwnedEnd()->push_back(element);
	}
	
	element->setThisExtensionEndPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisExtensionEndPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd_as_ownedAttribute_in_Class(std::weak_ptr<uml::Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl(par_Class));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Class.lock())
	{
		wp->getOwnedAttribute()->push_back(element);
	}
	
	element->setThisExtensionEndPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd_as_ownedAttribute_in_Artifact(std::shared_ptr<Artifact> par_Artifact, const int metaElementID) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Artifact)
	{
		par_Artifact->getOwnedAttribute()->push_back(element);
	}
	
	element->setThisExtensionEndPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd_as_ownedAttribute_in_DataType(std::weak_ptr<uml::DataType> par_DataType, const int metaElementID) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl(par_DataType));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_DataType.lock())
	{
		wp->getOwnedAttribute()->push_back(element);
	}
	
	element->setThisExtensionEndPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd_as_ownedAttribute_in_Interface(std::weak_ptr<uml::Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl(par_Interface));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Interface.lock())
	{
		wp->getOwnedAttribute()->push_back(element);
	}
	
	element->setThisExtensionEndPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd_as_ownedAttribute_in_Signal(std::shared_ptr<Signal> par_Signal, const int metaElementID) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Signal)
	{
		par_Signal->getOwnedAttribute()->push_back(element);
	}
	
	element->setThisExtensionEndPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd_as_ownedAttribute_in_StructuredClassifier(std::shared_ptr<StructuredClassifier> par_StructuredClassifier, const int metaElementID) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_StructuredClassifier)
	{
		par_StructuredClassifier->getOwnedAttribute()->push_back(element);
	}
	
	element->setThisExtensionEndPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisExtensionEndPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisExtensionEndPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd_as_ownedEnd_in_Association(std::weak_ptr<uml::Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl(par_Association));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Association.lock())
	{
		wp->getOwnedEnd()->push_back(element);
	}
	
	element->setThisExtensionEndPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisExtensionEndPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisExtensionEndPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd_as_qualifier_in_Property(std::weak_ptr<uml::Property> par_Property, const int metaElementID) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl(par_Property));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Property.lock())
	{
		wp->getQualifier()->push_back(element);
	}
	
	element->setThisExtensionEndPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd_as_redefinedProperty_in_Property(std::shared_ptr<Property> par_Property, const int metaElementID) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Property)
	{
		par_Property->getRedefinedProperty()->push_back(element);
	}
	
	element->setThisExtensionEndPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd_as_role_in_StructuredClassifier(std::shared_ptr<StructuredClassifier> par_StructuredClassifier, const int metaElementID) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_StructuredClassifier)
	{
		par_StructuredClassifier->getRole()->push_back(element);
	}
	
	element->setThisExtensionEndPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisExtensionEndPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisExtensionEndPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionEnd> umlFactoryImpl::createExtensionEnd_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ExtensionEndImpl> element(new ExtensionEndImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisExtensionEndPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionPoint> umlFactoryImpl::createExtensionPoint(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ExtensionPointImpl> element(new ExtensionPointImpl());
	element->setMetaElementID(metaElementID);
	element->setThisExtensionPointPtr(element);
	return element;
}
std::shared_ptr<ExtensionPoint> umlFactoryImpl::createExtensionPoint_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ExtensionPointImpl> element(new ExtensionPointImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisExtensionPointPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionPoint> umlFactoryImpl::createExtensionPoint_as_extensionPoint_in_UseCase(std::weak_ptr<uml::UseCase> par_UseCase, const int metaElementID) const
{
	std::shared_ptr<ExtensionPointImpl> element(new ExtensionPointImpl(par_UseCase));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_UseCase.lock())
	{
		wp->getExtensionPoint()->push_back(element);
	}
	
	element->setThisExtensionPointPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionPoint> umlFactoryImpl::createExtensionPoint_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ExtensionPointImpl> element(new ExtensionPointImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisExtensionPointPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionPoint> umlFactoryImpl::createExtensionPoint_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ExtensionPointImpl> element(new ExtensionPointImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisExtensionPointPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionPoint> umlFactoryImpl::createExtensionPoint_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ExtensionPointImpl> element(new ExtensionPointImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisExtensionPointPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionPoint> umlFactoryImpl::createExtensionPoint_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ExtensionPointImpl> element(new ExtensionPointImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisExtensionPointPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionPoint> umlFactoryImpl::createExtensionPoint_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ExtensionPointImpl> element(new ExtensionPointImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisExtensionPointPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionPoint> umlFactoryImpl::createExtensionPoint_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ExtensionPointImpl> element(new ExtensionPointImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisExtensionPointPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionPoint> umlFactoryImpl::createExtensionPoint_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ExtensionPointImpl> element(new ExtensionPointImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisExtensionPointPtr(element);
	return element;
	
}
std::shared_ptr<ExtensionPoint> umlFactoryImpl::createExtensionPoint_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ExtensionPointImpl> element(new ExtensionPointImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisExtensionPointPtr(element);
	return element;
	
}
std::shared_ptr<Factory> umlFactoryImpl::createFactory(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<FactoryImpl> element(new FactoryImpl());
	element->setMetaElementID(metaElementID);
	element->setThisFactoryPtr(element);
	return element;
}
std::shared_ptr<Factory> umlFactoryImpl::createFactory_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<FactoryImpl> element(new FactoryImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisFactoryPtr(element);
	return element;
	
}
std::shared_ptr<Factory> umlFactoryImpl::createFactory_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<FactoryImpl> element(new FactoryImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisFactoryPtr(element);
	return element;
	
}
std::shared_ptr<Factory> umlFactoryImpl::createFactory_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<FactoryImpl> element(new FactoryImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisFactoryPtr(element);
	return element;
	
}
std::shared_ptr<FinalState> umlFactoryImpl::createFinalState(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<FinalStateImpl> element(new FinalStateImpl());
	element->setMetaElementID(metaElementID);
	element->setThisFinalStatePtr(element);
	return element;
}
std::shared_ptr<FinalState> umlFactoryImpl::createFinalState_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<FinalStateImpl> element(new FinalStateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisFinalStatePtr(element);
	return element;
	
}
std::shared_ptr<FinalState> umlFactoryImpl::createFinalState_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<FinalStateImpl> element(new FinalStateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisFinalStatePtr(element);
	return element;
	
}
std::shared_ptr<FinalState> umlFactoryImpl::createFinalState_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<FinalStateImpl> element(new FinalStateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisFinalStatePtr(element);
	return element;
	
}
std::shared_ptr<FinalState> umlFactoryImpl::createFinalState_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<FinalStateImpl> element(new FinalStateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisFinalStatePtr(element);
	return element;
	
}
std::shared_ptr<FinalState> umlFactoryImpl::createFinalState_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<FinalStateImpl> element(new FinalStateImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisFinalStatePtr(element);
	return element;
	
}
std::shared_ptr<FinalState> umlFactoryImpl::createFinalState_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<FinalStateImpl> element(new FinalStateImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisFinalStatePtr(element);
	return element;
	
}
std::shared_ptr<FinalState> umlFactoryImpl::createFinalState_as_redefinedState_in_State(std::shared_ptr<State> par_State, const int metaElementID) const
{
	std::shared_ptr<FinalStateImpl> element(new FinalStateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_State)
	{
		par_State->setRedefinedState(element);
	}
	
	element->setThisFinalStatePtr(element);
	return element;
	
}
std::shared_ptr<FinalState> umlFactoryImpl::createFinalState_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<FinalStateImpl> element(new FinalStateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisFinalStatePtr(element);
	return element;
	
}
std::shared_ptr<FinalState> umlFactoryImpl::createFinalState_as_subvertex_in_Region(std::weak_ptr<uml::Region> par_Region, const int metaElementID) const
{
	std::shared_ptr<FinalStateImpl> element(new FinalStateImpl(par_Region));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Region.lock())
	{
		wp->getSubvertex()->push_back(element);
	}
	
	element->setThisFinalStatePtr(element);
	return element;
	
}
std::shared_ptr<FinalState> umlFactoryImpl::createFinalState_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<FinalStateImpl> element(new FinalStateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisFinalStatePtr(element);
	return element;
	
}
std::shared_ptr<FinalState> umlFactoryImpl::createFinalState_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<FinalStateImpl> element(new FinalStateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisFinalStatePtr(element);
	return element;
	
}
std::shared_ptr<FlowFinalNode> umlFactoryImpl::createFlowFinalNode(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<FlowFinalNodeImpl> element(new FlowFinalNodeImpl());
	element->setMetaElementID(metaElementID);
	element->setThisFlowFinalNodePtr(element);
	return element;
}
std::shared_ptr<FlowFinalNode> umlFactoryImpl::createFlowFinalNode_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<FlowFinalNodeImpl> element(new FlowFinalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisFlowFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<FlowFinalNode> umlFactoryImpl::createFlowFinalNode_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<FlowFinalNodeImpl> element(new FlowFinalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisFlowFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<FlowFinalNode> umlFactoryImpl::createFlowFinalNode_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<FlowFinalNodeImpl> element(new FlowFinalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisFlowFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<FlowFinalNode> umlFactoryImpl::createFlowFinalNode_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<FlowFinalNodeImpl> element(new FlowFinalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisFlowFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<FlowFinalNode> umlFactoryImpl::createFlowFinalNode_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<FlowFinalNodeImpl> element(new FlowFinalNodeImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisFlowFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<FlowFinalNode> umlFactoryImpl::createFlowFinalNode_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<FlowFinalNodeImpl> element(new FlowFinalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisFlowFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<FlowFinalNode> umlFactoryImpl::createFlowFinalNode_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<FlowFinalNodeImpl> element(new FlowFinalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisFlowFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<FlowFinalNode> umlFactoryImpl::createFlowFinalNode_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<FlowFinalNodeImpl> element(new FlowFinalNodeImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisFlowFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<FlowFinalNode> umlFactoryImpl::createFlowFinalNode_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<FlowFinalNodeImpl> element(new FlowFinalNodeImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisFlowFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<FlowFinalNode> umlFactoryImpl::createFlowFinalNode_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<FlowFinalNodeImpl> element(new FlowFinalNodeImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisFlowFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<FlowFinalNode> umlFactoryImpl::createFlowFinalNode_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<FlowFinalNodeImpl> element(new FlowFinalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisFlowFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<FlowFinalNode> umlFactoryImpl::createFlowFinalNode_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<FlowFinalNodeImpl> element(new FlowFinalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisFlowFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<FlowFinalNode> umlFactoryImpl::createFlowFinalNode_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<FlowFinalNodeImpl> element(new FlowFinalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisFlowFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<FlowFinalNode> umlFactoryImpl::createFlowFinalNode_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<FlowFinalNodeImpl> element(new FlowFinalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisFlowFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<FlowFinalNode> umlFactoryImpl::createFlowFinalNode_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<FlowFinalNodeImpl> element(new FlowFinalNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisFlowFinalNodePtr(element);
	return element;
	
}
std::shared_ptr<ForkNode> umlFactoryImpl::createForkNode(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ForkNodeImpl> element(new ForkNodeImpl());
	element->setMetaElementID(metaElementID);
	element->setThisForkNodePtr(element);
	return element;
}
std::shared_ptr<ForkNode> umlFactoryImpl::createForkNode_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ForkNodeImpl> element(new ForkNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisForkNodePtr(element);
	return element;
	
}
std::shared_ptr<ForkNode> umlFactoryImpl::createForkNode_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ForkNodeImpl> element(new ForkNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisForkNodePtr(element);
	return element;
	
}
std::shared_ptr<ForkNode> umlFactoryImpl::createForkNode_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ForkNodeImpl> element(new ForkNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisForkNodePtr(element);
	return element;
	
}
std::shared_ptr<ForkNode> umlFactoryImpl::createForkNode_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ForkNodeImpl> element(new ForkNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisForkNodePtr(element);
	return element;
	
}
std::shared_ptr<ForkNode> umlFactoryImpl::createForkNode_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ForkNodeImpl> element(new ForkNodeImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisForkNodePtr(element);
	return element;
	
}
std::shared_ptr<ForkNode> umlFactoryImpl::createForkNode_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<ForkNodeImpl> element(new ForkNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisForkNodePtr(element);
	return element;
	
}
std::shared_ptr<ForkNode> umlFactoryImpl::createForkNode_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<ForkNodeImpl> element(new ForkNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisForkNodePtr(element);
	return element;
	
}
std::shared_ptr<ForkNode> umlFactoryImpl::createForkNode_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<ForkNodeImpl> element(new ForkNodeImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisForkNodePtr(element);
	return element;
	
}
std::shared_ptr<ForkNode> umlFactoryImpl::createForkNode_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ForkNodeImpl> element(new ForkNodeImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisForkNodePtr(element);
	return element;
	
}
std::shared_ptr<ForkNode> umlFactoryImpl::createForkNode_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ForkNodeImpl> element(new ForkNodeImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisForkNodePtr(element);
	return element;
	
}
std::shared_ptr<ForkNode> umlFactoryImpl::createForkNode_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ForkNodeImpl> element(new ForkNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisForkNodePtr(element);
	return element;
	
}
std::shared_ptr<ForkNode> umlFactoryImpl::createForkNode_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<ForkNodeImpl> element(new ForkNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisForkNodePtr(element);
	return element;
	
}
std::shared_ptr<ForkNode> umlFactoryImpl::createForkNode_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ForkNodeImpl> element(new ForkNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisForkNodePtr(element);
	return element;
	
}
std::shared_ptr<ForkNode> umlFactoryImpl::createForkNode_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ForkNodeImpl> element(new ForkNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisForkNodePtr(element);
	return element;
	
}
std::shared_ptr<ForkNode> umlFactoryImpl::createForkNode_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ForkNodeImpl> element(new ForkNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisForkNodePtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	element->setThisFunctionBehaviorPtr(element);
	return element;
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_classifier_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->setClassifier(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_classifierBehavior_in_BehavioredClassifier(std::shared_ptr<BehavioredClassifier> par_BehavioredClassifier, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_BehavioredClassifier)
	{
		par_BehavioredClassifier->setClassifierBehavior(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_context_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->setContext(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_contract_in_Substitution(std::shared_ptr<Substitution> par_Substitution, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Substitution)
	{
		par_Substitution->setContract(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_doActivity_in_State(std::shared_ptr<State> par_State, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_State)
	{
		par_State->setDoActivity(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_effect_in_Transition(std::shared_ptr<Transition> par_Transition, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Transition)
	{
		par_Transition->setEffect(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_endType_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getEndType()->push_back(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_entry_in_State(std::shared_ptr<State> par_State, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_State)
	{
		par_State->setEntry(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_exit_in_State(std::shared_ptr<State> par_State, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_State)
	{
		par_State->setExit(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_general_in_Generalization(std::shared_ptr<Generalization> par_Generalization, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Generalization)
	{
		par_Generalization->setGeneral(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_nestedClassifier_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getNestedClassifier()->push_back(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_nestedClassifier_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getNestedClassifier()->push_back(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_ownedBehavior_in_BehavioredClassifier(std::weak_ptr<uml::BehavioredClassifier> par_BehavioredClassifier, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl(par_BehavioredClassifier));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_BehavioredClassifier.lock())
	{
		wp->getOwnedBehavior()->push_back(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_ownedType_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl(par_Package, uml::umlPackage::TYPE_ATTRIBUTE_PACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getOwnedType()->push_back(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_realizingClassifier_in_ComponentRealization(std::shared_ptr<ComponentRealization> par_ComponentRealization, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ComponentRealization)
	{
		par_ComponentRealization->getRealizingClassifier()->push_back(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_redefinedBehavior_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->getRedefinedBehavior()->push_back(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_redefinedClassifier_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getRedefinedClassifier()->push_back(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<FunctionBehavior> umlFactoryImpl::createFunctionBehavior_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<FunctionBehaviorImpl> element(new FunctionBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisFunctionBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<Gate> umlFactoryImpl::createGate(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<GateImpl> element(new GateImpl());
	element->setMetaElementID(metaElementID);
	element->setThisGatePtr(element);
	return element;
}
std::shared_ptr<Gate> umlFactoryImpl::createGate_as_actualGate_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<GateImpl> element(new GateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->getActualGate()->push_back(element);
	}
	
	element->setThisGatePtr(element);
	return element;
	
}
std::shared_ptr<Gate> umlFactoryImpl::createGate_as_cfragmentGate_in_CombinedFragment(std::shared_ptr<CombinedFragment> par_CombinedFragment, const int metaElementID) const
{
	std::shared_ptr<GateImpl> element(new GateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_CombinedFragment)
	{
		par_CombinedFragment->getCfragmentGate()->push_back(element);
	}
	
	element->setThisGatePtr(element);
	return element;
	
}
std::shared_ptr<Gate> umlFactoryImpl::createGate_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<GateImpl> element(new GateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisGatePtr(element);
	return element;
	
}
std::shared_ptr<Gate> umlFactoryImpl::createGate_as_formalGate_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<GateImpl> element(new GateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getFormalGate()->push_back(element);
	}
	
	element->setThisGatePtr(element);
	return element;
	
}
std::shared_ptr<Gate> umlFactoryImpl::createGate_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<GateImpl> element(new GateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisGatePtr(element);
	return element;
	
}
std::shared_ptr<Gate> umlFactoryImpl::createGate_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<GateImpl> element(new GateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisGatePtr(element);
	return element;
	
}
std::shared_ptr<Gate> umlFactoryImpl::createGate_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<GateImpl> element(new GateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisGatePtr(element);
	return element;
	
}
std::shared_ptr<Gate> umlFactoryImpl::createGate_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<GateImpl> element(new GateImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisGatePtr(element);
	return element;
	
}
std::shared_ptr<Gate> umlFactoryImpl::createGate_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<GateImpl> element(new GateImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisGatePtr(element);
	return element;
	
}
std::shared_ptr<Gate> umlFactoryImpl::createGate_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<GateImpl> element(new GateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisGatePtr(element);
	return element;
	
}
std::shared_ptr<Gate> umlFactoryImpl::createGate_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<GateImpl> element(new GateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisGatePtr(element);
	return element;
	
}
std::shared_ptr<Gate> umlFactoryImpl::createGate_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<GateImpl> element(new GateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisGatePtr(element);
	return element;
	
}
std::shared_ptr<GeneralOrdering> umlFactoryImpl::createGeneralOrdering(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<GeneralOrderingImpl> element(new GeneralOrderingImpl());
	element->setMetaElementID(metaElementID);
	element->setThisGeneralOrderingPtr(element);
	return element;
}
std::shared_ptr<GeneralOrdering> umlFactoryImpl::createGeneralOrdering_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<GeneralOrderingImpl> element(new GeneralOrderingImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisGeneralOrderingPtr(element);
	return element;
	
}
std::shared_ptr<GeneralOrdering> umlFactoryImpl::createGeneralOrdering_as_generalOrdering_in_InteractionFragment(std::shared_ptr<InteractionFragment> par_InteractionFragment, const int metaElementID) const
{
	std::shared_ptr<GeneralOrderingImpl> element(new GeneralOrderingImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionFragment)
	{
		par_InteractionFragment->getGeneralOrdering()->push_back(element);
	}
	
	element->setThisGeneralOrderingPtr(element);
	return element;
	
}
std::shared_ptr<GeneralOrdering> umlFactoryImpl::createGeneralOrdering_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<GeneralOrderingImpl> element(new GeneralOrderingImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisGeneralOrderingPtr(element);
	return element;
	
}
std::shared_ptr<GeneralOrdering> umlFactoryImpl::createGeneralOrdering_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<GeneralOrderingImpl> element(new GeneralOrderingImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisGeneralOrderingPtr(element);
	return element;
	
}
std::shared_ptr<GeneralOrdering> umlFactoryImpl::createGeneralOrdering_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<GeneralOrderingImpl> element(new GeneralOrderingImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisGeneralOrderingPtr(element);
	return element;
	
}
std::shared_ptr<GeneralOrdering> umlFactoryImpl::createGeneralOrdering_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<GeneralOrderingImpl> element(new GeneralOrderingImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisGeneralOrderingPtr(element);
	return element;
	
}
std::shared_ptr<GeneralOrdering> umlFactoryImpl::createGeneralOrdering_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<GeneralOrderingImpl> element(new GeneralOrderingImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisGeneralOrderingPtr(element);
	return element;
	
}
std::shared_ptr<GeneralOrdering> umlFactoryImpl::createGeneralOrdering_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<GeneralOrderingImpl> element(new GeneralOrderingImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisGeneralOrderingPtr(element);
	return element;
	
}
std::shared_ptr<GeneralOrdering> umlFactoryImpl::createGeneralOrdering_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<GeneralOrderingImpl> element(new GeneralOrderingImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisGeneralOrderingPtr(element);
	return element;
	
}
std::shared_ptr<GeneralOrdering> umlFactoryImpl::createGeneralOrdering_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<GeneralOrderingImpl> element(new GeneralOrderingImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisGeneralOrderingPtr(element);
	return element;
	
}
std::shared_ptr<Generalization> umlFactoryImpl::createGeneralization(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<GeneralizationImpl> element(new GeneralizationImpl());
	element->setMetaElementID(metaElementID);
	element->setThisGeneralizationPtr(element);
	return element;
}
std::shared_ptr<Generalization> umlFactoryImpl::createGeneralization_as_generalization_in_Classifier(std::weak_ptr<uml::Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<GeneralizationImpl> element(new GeneralizationImpl(par_Classifier));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Classifier.lock())
	{
		wp->getGeneralization()->push_back(element);
	}
	
	element->setThisGeneralizationPtr(element);
	return element;
	
}
std::shared_ptr<Generalization> umlFactoryImpl::createGeneralization_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<GeneralizationImpl> element(new GeneralizationImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisGeneralizationPtr(element);
	return element;
	
}
std::shared_ptr<Generalization> umlFactoryImpl::createGeneralization_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<GeneralizationImpl> element(new GeneralizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisGeneralizationPtr(element);
	return element;
	
}
std::shared_ptr<Generalization> umlFactoryImpl::createGeneralization_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<GeneralizationImpl> element(new GeneralizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisGeneralizationPtr(element);
	return element;
	
}
std::shared_ptr<GeneralizationSet> umlFactoryImpl::createGeneralizationSet(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<GeneralizationSetImpl> element(new GeneralizationSetImpl());
	element->setMetaElementID(metaElementID);
	element->setThisGeneralizationSetPtr(element);
	return element;
}
std::shared_ptr<GeneralizationSet> umlFactoryImpl::createGeneralizationSet_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<GeneralizationSetImpl> element(new GeneralizationSetImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisGeneralizationSetPtr(element);
	return element;
	
}
std::shared_ptr<GeneralizationSet> umlFactoryImpl::createGeneralizationSet_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<GeneralizationSetImpl> element(new GeneralizationSetImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisGeneralizationSetPtr(element);
	return element;
	
}
std::shared_ptr<GeneralizationSet> umlFactoryImpl::createGeneralizationSet_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<GeneralizationSetImpl> element(new GeneralizationSetImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisGeneralizationSetPtr(element);
	return element;
	
}
std::shared_ptr<GeneralizationSet> umlFactoryImpl::createGeneralizationSet_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<GeneralizationSetImpl> element(new GeneralizationSetImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisGeneralizationSetPtr(element);
	return element;
	
}
std::shared_ptr<GeneralizationSet> umlFactoryImpl::createGeneralizationSet_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<GeneralizationSetImpl> element(new GeneralizationSetImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisGeneralizationSetPtr(element);
	return element;
	
}
std::shared_ptr<GeneralizationSet> umlFactoryImpl::createGeneralizationSet_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<GeneralizationSetImpl> element(new GeneralizationSetImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisGeneralizationSetPtr(element);
	return element;
	
}
std::shared_ptr<GeneralizationSet> umlFactoryImpl::createGeneralizationSet_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<GeneralizationSetImpl> element(new GeneralizationSetImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisGeneralizationSetPtr(element);
	return element;
	
}
std::shared_ptr<GeneralizationSet> umlFactoryImpl::createGeneralizationSet_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<GeneralizationSetImpl> element(new GeneralizationSetImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisGeneralizationSetPtr(element);
	return element;
	
}
std::shared_ptr<GeneralizationSet> umlFactoryImpl::createGeneralizationSet_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<GeneralizationSetImpl> element(new GeneralizationSetImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisGeneralizationSetPtr(element);
	return element;
	
}
std::shared_ptr<GeneralizationSet> umlFactoryImpl::createGeneralizationSet_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<GeneralizationSetImpl> element(new GeneralizationSetImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisGeneralizationSetPtr(element);
	return element;
	
}
std::shared_ptr<GeneralizationSet> umlFactoryImpl::createGeneralizationSet_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<GeneralizationSetImpl> element(new GeneralizationSetImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisGeneralizationSetPtr(element);
	return element;
	
}
std::shared_ptr<GeneralizationSet> umlFactoryImpl::createGeneralizationSet_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<GeneralizationSetImpl> element(new GeneralizationSetImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisGeneralizationSetPtr(element);
	return element;
	
}
std::shared_ptr<GeneralizationSet> umlFactoryImpl::createGeneralizationSet_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<GeneralizationSetImpl> element(new GeneralizationSetImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisGeneralizationSetPtr(element);
	return element;
	
}
std::shared_ptr<GeneralizationSet> umlFactoryImpl::createGeneralizationSet_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<GeneralizationSetImpl> element(new GeneralizationSetImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisGeneralizationSetPtr(element);
	return element;
	
}
std::shared_ptr<GeneralizationSet> umlFactoryImpl::createGeneralizationSet_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<GeneralizationSetImpl> element(new GeneralizationSetImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisGeneralizationSetPtr(element);
	return element;
	
}
std::shared_ptr<GeneralizationSet> umlFactoryImpl::createGeneralizationSet_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<GeneralizationSetImpl> element(new GeneralizationSetImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisGeneralizationSetPtr(element);
	return element;
	
}
std::shared_ptr<GeneralizationSet> umlFactoryImpl::createGeneralizationSet_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<GeneralizationSetImpl> element(new GeneralizationSetImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisGeneralizationSetPtr(element);
	return element;
	
}
std::shared_ptr<Image> umlFactoryImpl::createImage(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ImageImpl> element(new ImageImpl());
	element->setMetaElementID(metaElementID);
	element->setThisImagePtr(element);
	return element;
}
std::shared_ptr<Image> umlFactoryImpl::createImage_as_icon_in_Stereotype(std::shared_ptr<Stereotype> par_Stereotype, const int metaElementID) const
{
	std::shared_ptr<ImageImpl> element(new ImageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Stereotype)
	{
		par_Stereotype->getIcon()->push_back(element);
	}
	
	element->setThisImagePtr(element);
	return element;
	
}
std::shared_ptr<Image> umlFactoryImpl::createImage_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ImageImpl> element(new ImageImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisImagePtr(element);
	return element;
	
}
std::shared_ptr<Image> umlFactoryImpl::createImage_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ImageImpl> element(new ImageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisImagePtr(element);
	return element;
	
}
std::shared_ptr<Image> umlFactoryImpl::createImage_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ImageImpl> element(new ImageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisImagePtr(element);
	return element;
	
}
std::shared_ptr<Include> umlFactoryImpl::createInclude(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<IncludeImpl> element(new IncludeImpl());
	element->setMetaElementID(metaElementID);
	element->setThisIncludePtr(element);
	return element;
}
std::shared_ptr<Include> umlFactoryImpl::createInclude_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<IncludeImpl> element(new IncludeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisIncludePtr(element);
	return element;
	
}
std::shared_ptr<Include> umlFactoryImpl::createInclude_as_include_in_UseCase(std::weak_ptr<uml::UseCase> par_UseCase, const int metaElementID) const
{
	std::shared_ptr<IncludeImpl> element(new IncludeImpl(par_UseCase));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_UseCase.lock())
	{
		wp->getInclude()->push_back(element);
	}
	
	element->setThisIncludePtr(element);
	return element;
	
}
std::shared_ptr<Include> umlFactoryImpl::createInclude_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<IncludeImpl> element(new IncludeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisIncludePtr(element);
	return element;
	
}
std::shared_ptr<Include> umlFactoryImpl::createInclude_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<IncludeImpl> element(new IncludeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisIncludePtr(element);
	return element;
	
}
std::shared_ptr<Include> umlFactoryImpl::createInclude_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<IncludeImpl> element(new IncludeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisIncludePtr(element);
	return element;
	
}
std::shared_ptr<Include> umlFactoryImpl::createInclude_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<IncludeImpl> element(new IncludeImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisIncludePtr(element);
	return element;
	
}
std::shared_ptr<Include> umlFactoryImpl::createInclude_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<IncludeImpl> element(new IncludeImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisIncludePtr(element);
	return element;
	
}
std::shared_ptr<Include> umlFactoryImpl::createInclude_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<IncludeImpl> element(new IncludeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisIncludePtr(element);
	return element;
	
}
std::shared_ptr<Include> umlFactoryImpl::createInclude_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<IncludeImpl> element(new IncludeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisIncludePtr(element);
	return element;
	
}
std::shared_ptr<Include> umlFactoryImpl::createInclude_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<IncludeImpl> element(new IncludeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisIncludePtr(element);
	return element;
	
}
std::shared_ptr<InformationFlow> umlFactoryImpl::createInformationFlow(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<InformationFlowImpl> element(new InformationFlowImpl());
	element->setMetaElementID(metaElementID);
	element->setThisInformationFlowPtr(element);
	return element;
}
std::shared_ptr<InformationFlow> umlFactoryImpl::createInformationFlow_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<InformationFlowImpl> element(new InformationFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisInformationFlowPtr(element);
	return element;
	
}
std::shared_ptr<InformationFlow> umlFactoryImpl::createInformationFlow_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<InformationFlowImpl> element(new InformationFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisInformationFlowPtr(element);
	return element;
	
}
std::shared_ptr<InformationFlow> umlFactoryImpl::createInformationFlow_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<InformationFlowImpl> element(new InformationFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisInformationFlowPtr(element);
	return element;
	
}
std::shared_ptr<InformationFlow> umlFactoryImpl::createInformationFlow_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<InformationFlowImpl> element(new InformationFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisInformationFlowPtr(element);
	return element;
	
}
std::shared_ptr<InformationFlow> umlFactoryImpl::createInformationFlow_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<InformationFlowImpl> element(new InformationFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisInformationFlowPtr(element);
	return element;
	
}
std::shared_ptr<InformationFlow> umlFactoryImpl::createInformationFlow_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<InformationFlowImpl> element(new InformationFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisInformationFlowPtr(element);
	return element;
	
}
std::shared_ptr<InformationFlow> umlFactoryImpl::createInformationFlow_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<InformationFlowImpl> element(new InformationFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisInformationFlowPtr(element);
	return element;
	
}
std::shared_ptr<InformationFlow> umlFactoryImpl::createInformationFlow_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<InformationFlowImpl> element(new InformationFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisInformationFlowPtr(element);
	return element;
	
}
std::shared_ptr<InformationFlow> umlFactoryImpl::createInformationFlow_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<InformationFlowImpl> element(new InformationFlowImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisInformationFlowPtr(element);
	return element;
	
}
std::shared_ptr<InformationFlow> umlFactoryImpl::createInformationFlow_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<InformationFlowImpl> element(new InformationFlowImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisInformationFlowPtr(element);
	return element;
	
}
std::shared_ptr<InformationFlow> umlFactoryImpl::createInformationFlow_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<InformationFlowImpl> element(new InformationFlowImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisInformationFlowPtr(element);
	return element;
	
}
std::shared_ptr<InformationFlow> umlFactoryImpl::createInformationFlow_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<InformationFlowImpl> element(new InformationFlowImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisInformationFlowPtr(element);
	return element;
	
}
std::shared_ptr<InformationFlow> umlFactoryImpl::createInformationFlow_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<InformationFlowImpl> element(new InformationFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisInformationFlowPtr(element);
	return element;
	
}
std::shared_ptr<InformationFlow> umlFactoryImpl::createInformationFlow_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<InformationFlowImpl> element(new InformationFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisInformationFlowPtr(element);
	return element;
	
}
std::shared_ptr<InformationFlow> umlFactoryImpl::createInformationFlow_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<InformationFlowImpl> element(new InformationFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisInformationFlowPtr(element);
	return element;
	
}
std::shared_ptr<InformationFlow> umlFactoryImpl::createInformationFlow_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<InformationFlowImpl> element(new InformationFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisInformationFlowPtr(element);
	return element;
	
}
std::shared_ptr<InformationFlow> umlFactoryImpl::createInformationFlow_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<InformationFlowImpl> element(new InformationFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisInformationFlowPtr(element);
	return element;
	
}
std::shared_ptr<InformationItem> umlFactoryImpl::createInformationItem(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<InformationItemImpl> element(new InformationItemImpl());
	element->setMetaElementID(metaElementID);
	element->setThisInformationItemPtr(element);
	return element;
}
std::shared_ptr<InformationItem> umlFactoryImpl::createInformationItem_as_classifier_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<InformationItemImpl> element(new InformationItemImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->setClassifier(element);
	}
	
	element->setThisInformationItemPtr(element);
	return element;
	
}
std::shared_ptr<InformationItem> umlFactoryImpl::createInformationItem_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<InformationItemImpl> element(new InformationItemImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisInformationItemPtr(element);
	return element;
	
}
std::shared_ptr<InformationItem> umlFactoryImpl::createInformationItem_as_contract_in_Substitution(std::shared_ptr<Substitution> par_Substitution, const int metaElementID) const
{
	std::shared_ptr<InformationItemImpl> element(new InformationItemImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Substitution)
	{
		par_Substitution->setContract(element);
	}
	
	element->setThisInformationItemPtr(element);
	return element;
	
}
std::shared_ptr<InformationItem> umlFactoryImpl::createInformationItem_as_endType_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<InformationItemImpl> element(new InformationItemImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getEndType()->push_back(element);
	}
	
	element->setThisInformationItemPtr(element);
	return element;
	
}
std::shared_ptr<InformationItem> umlFactoryImpl::createInformationItem_as_general_in_Generalization(std::shared_ptr<Generalization> par_Generalization, const int metaElementID) const
{
	std::shared_ptr<InformationItemImpl> element(new InformationItemImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Generalization)
	{
		par_Generalization->setGeneral(element);
	}
	
	element->setThisInformationItemPtr(element);
	return element;
	
}
std::shared_ptr<InformationItem> umlFactoryImpl::createInformationItem_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<InformationItemImpl> element(new InformationItemImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisInformationItemPtr(element);
	return element;
	
}
std::shared_ptr<InformationItem> umlFactoryImpl::createInformationItem_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<InformationItemImpl> element(new InformationItemImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisInformationItemPtr(element);
	return element;
	
}
std::shared_ptr<InformationItem> umlFactoryImpl::createInformationItem_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<InformationItemImpl> element(new InformationItemImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisInformationItemPtr(element);
	return element;
	
}
std::shared_ptr<InformationItem> umlFactoryImpl::createInformationItem_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<InformationItemImpl> element(new InformationItemImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisInformationItemPtr(element);
	return element;
	
}
std::shared_ptr<InformationItem> umlFactoryImpl::createInformationItem_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<InformationItemImpl> element(new InformationItemImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisInformationItemPtr(element);
	return element;
	
}
std::shared_ptr<InformationItem> umlFactoryImpl::createInformationItem_as_nestedClassifier_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<InformationItemImpl> element(new InformationItemImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getNestedClassifier()->push_back(element);
	}
	
	element->setThisInformationItemPtr(element);
	return element;
	
}
std::shared_ptr<InformationItem> umlFactoryImpl::createInformationItem_as_nestedClassifier_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<InformationItemImpl> element(new InformationItemImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getNestedClassifier()->push_back(element);
	}
	
	element->setThisInformationItemPtr(element);
	return element;
	
}
std::shared_ptr<InformationItem> umlFactoryImpl::createInformationItem_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<InformationItemImpl> element(new InformationItemImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisInformationItemPtr(element);
	return element;
	
}
std::shared_ptr<InformationItem> umlFactoryImpl::createInformationItem_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<InformationItemImpl> element(new InformationItemImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisInformationItemPtr(element);
	return element;
	
}
std::shared_ptr<InformationItem> umlFactoryImpl::createInformationItem_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<InformationItemImpl> element(new InformationItemImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisInformationItemPtr(element);
	return element;
	
}
std::shared_ptr<InformationItem> umlFactoryImpl::createInformationItem_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<InformationItemImpl> element(new InformationItemImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisInformationItemPtr(element);
	return element;
	
}
std::shared_ptr<InformationItem> umlFactoryImpl::createInformationItem_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<InformationItemImpl> element(new InformationItemImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisInformationItemPtr(element);
	return element;
	
}
std::shared_ptr<InformationItem> umlFactoryImpl::createInformationItem_as_ownedType_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<InformationItemImpl> element(new InformationItemImpl(par_Package, uml::umlPackage::TYPE_ATTRIBUTE_PACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getOwnedType()->push_back(element);
	}
	
	element->setThisInformationItemPtr(element);
	return element;
	
}
std::shared_ptr<InformationItem> umlFactoryImpl::createInformationItem_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<InformationItemImpl> element(new InformationItemImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisInformationItemPtr(element);
	return element;
	
}
std::shared_ptr<InformationItem> umlFactoryImpl::createInformationItem_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<InformationItemImpl> element(new InformationItemImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisInformationItemPtr(element);
	return element;
	
}
std::shared_ptr<InformationItem> umlFactoryImpl::createInformationItem_as_realizingClassifier_in_ComponentRealization(std::shared_ptr<ComponentRealization> par_ComponentRealization, const int metaElementID) const
{
	std::shared_ptr<InformationItemImpl> element(new InformationItemImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ComponentRealization)
	{
		par_ComponentRealization->getRealizingClassifier()->push_back(element);
	}
	
	element->setThisInformationItemPtr(element);
	return element;
	
}
std::shared_ptr<InformationItem> umlFactoryImpl::createInformationItem_as_redefinedClassifier_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<InformationItemImpl> element(new InformationItemImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getRedefinedClassifier()->push_back(element);
	}
	
	element->setThisInformationItemPtr(element);
	return element;
	
}
std::shared_ptr<InformationItem> umlFactoryImpl::createInformationItem_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<InformationItemImpl> element(new InformationItemImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisInformationItemPtr(element);
	return element;
	
}
std::shared_ptr<InformationItem> umlFactoryImpl::createInformationItem_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<InformationItemImpl> element(new InformationItemImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisInformationItemPtr(element);
	return element;
	
}
std::shared_ptr<InformationItem> umlFactoryImpl::createInformationItem_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<InformationItemImpl> element(new InformationItemImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisInformationItemPtr(element);
	return element;
	
}
std::shared_ptr<InformationItem> umlFactoryImpl::createInformationItem_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<InformationItemImpl> element(new InformationItemImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisInformationItemPtr(element);
	return element;
	
}
std::shared_ptr<InitialNode> umlFactoryImpl::createInitialNode(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<InitialNodeImpl> element(new InitialNodeImpl());
	element->setMetaElementID(metaElementID);
	element->setThisInitialNodePtr(element);
	return element;
}
std::shared_ptr<InitialNode> umlFactoryImpl::createInitialNode_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<InitialNodeImpl> element(new InitialNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisInitialNodePtr(element);
	return element;
	
}
std::shared_ptr<InitialNode> umlFactoryImpl::createInitialNode_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<InitialNodeImpl> element(new InitialNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisInitialNodePtr(element);
	return element;
	
}
std::shared_ptr<InitialNode> umlFactoryImpl::createInitialNode_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<InitialNodeImpl> element(new InitialNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisInitialNodePtr(element);
	return element;
	
}
std::shared_ptr<InitialNode> umlFactoryImpl::createInitialNode_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<InitialNodeImpl> element(new InitialNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisInitialNodePtr(element);
	return element;
	
}
std::shared_ptr<InitialNode> umlFactoryImpl::createInitialNode_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<InitialNodeImpl> element(new InitialNodeImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisInitialNodePtr(element);
	return element;
	
}
std::shared_ptr<InitialNode> umlFactoryImpl::createInitialNode_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<InitialNodeImpl> element(new InitialNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisInitialNodePtr(element);
	return element;
	
}
std::shared_ptr<InitialNode> umlFactoryImpl::createInitialNode_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<InitialNodeImpl> element(new InitialNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisInitialNodePtr(element);
	return element;
	
}
std::shared_ptr<InitialNode> umlFactoryImpl::createInitialNode_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<InitialNodeImpl> element(new InitialNodeImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisInitialNodePtr(element);
	return element;
	
}
std::shared_ptr<InitialNode> umlFactoryImpl::createInitialNode_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<InitialNodeImpl> element(new InitialNodeImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisInitialNodePtr(element);
	return element;
	
}
std::shared_ptr<InitialNode> umlFactoryImpl::createInitialNode_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<InitialNodeImpl> element(new InitialNodeImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisInitialNodePtr(element);
	return element;
	
}
std::shared_ptr<InitialNode> umlFactoryImpl::createInitialNode_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<InitialNodeImpl> element(new InitialNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisInitialNodePtr(element);
	return element;
	
}
std::shared_ptr<InitialNode> umlFactoryImpl::createInitialNode_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<InitialNodeImpl> element(new InitialNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisInitialNodePtr(element);
	return element;
	
}
std::shared_ptr<InitialNode> umlFactoryImpl::createInitialNode_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<InitialNodeImpl> element(new InitialNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisInitialNodePtr(element);
	return element;
	
}
std::shared_ptr<InitialNode> umlFactoryImpl::createInitialNode_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<InitialNodeImpl> element(new InitialNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisInitialNodePtr(element);
	return element;
	
}
std::shared_ptr<InitialNode> umlFactoryImpl::createInitialNode_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<InitialNodeImpl> element(new InitialNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisInitialNodePtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	element->setThisInputPinPtr(element);
	return element;
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_argument_in_InvocationAction(std::weak_ptr<uml::InvocationAction> par_InvocationAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl(par_InvocationAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_InvocationAction.lock())
	{
		wp->getArgument()->push_back(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_collection_in_ReduceAction(std::shared_ptr<ReduceAction> par_ReduceAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReduceAction)
	{
		par_ReduceAction->setCollection(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_exception_in_RaiseExceptionAction(std::shared_ptr<RaiseExceptionAction> par_RaiseExceptionAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RaiseExceptionAction)
	{
		par_RaiseExceptionAction->setException(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_first_in_TestIdentityAction(std::shared_ptr<TestIdentityAction> par_TestIdentityAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TestIdentityAction)
	{
		par_TestIdentityAction->setFirst(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_input_in_Action(std::weak_ptr<uml::Action> par_Action, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl(par_Action));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Action.lock())
	{
		wp->getInput()->push_back(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_inputValue_in_LinkAction(std::shared_ptr<LinkAction> par_LinkAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_LinkAction)
	{
		par_LinkAction->getInputValue()->push_back(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_inputValue_in_OpaqueAction(std::shared_ptr<OpaqueAction> par_OpaqueAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_OpaqueAction)
	{
		par_OpaqueAction->getInputValue()->push_back(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_insertAt_in_AddStructuralFeatureValueAction(std::weak_ptr<uml::AddStructuralFeatureValueAction> par_AddStructuralFeatureValueAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl(par_AddStructuralFeatureValueAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_AddStructuralFeatureValueAction.lock())
	{
		wp->setInsertAt(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_insertAt_in_AddVariableValueAction(std::shared_ptr<AddVariableValueAction> par_AddVariableValueAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_AddVariableValueAction)
	{
		par_AddVariableValueAction->setInsertAt(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_loopVariableInput_in_LoopNode(std::shared_ptr<LoopNode> par_LoopNode, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_LoopNode)
	{
		par_LoopNode->getLoopVariableInput()->push_back(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_object_in_StructuralFeatureAction(std::weak_ptr<uml::StructuralFeatureAction> par_StructuralFeatureAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl(par_StructuralFeatureAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuralFeatureAction.lock())
	{
		wp->setObject(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_object_in_ClearAssociationAction(std::shared_ptr<ClearAssociationAction> par_ClearAssociationAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ClearAssociationAction)
	{
		par_ClearAssociationAction->setObject(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_object_in_ReadIsClassifiedObjectAction(std::shared_ptr<ReadIsClassifiedObjectAction> par_ReadIsClassifiedObjectAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReadIsClassifiedObjectAction)
	{
		par_ReadIsClassifiedObjectAction->setObject(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_object_in_ReadLinkObjectEndAction(std::shared_ptr<ReadLinkObjectEndAction> par_ReadLinkObjectEndAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReadLinkObjectEndAction)
	{
		par_ReadLinkObjectEndAction->setObject(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_object_in_ReadLinkObjectEndQualifierAction(std::shared_ptr<ReadLinkObjectEndQualifierAction> par_ReadLinkObjectEndQualifierAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReadLinkObjectEndQualifierAction)
	{
		par_ReadLinkObjectEndQualifierAction->setObject(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_object_in_ReclassifyObjectAction(std::shared_ptr<ReclassifyObjectAction> par_ReclassifyObjectAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReclassifyObjectAction)
	{
		par_ReclassifyObjectAction->setObject(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_object_in_StartClassifierBehaviorAction(std::shared_ptr<StartClassifierBehaviorAction> par_StartClassifierBehaviorAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_StartClassifierBehaviorAction)
	{
		par_StartClassifierBehaviorAction->setObject(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_object_in_StartObjectBehaviorAction(std::shared_ptr<StartObjectBehaviorAction> par_StartObjectBehaviorAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_StartObjectBehaviorAction)
	{
		par_StartObjectBehaviorAction->setObject(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_object_in_UnmarshallAction(std::shared_ptr<UnmarshallAction> par_UnmarshallAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_UnmarshallAction)
	{
		par_UnmarshallAction->setObject(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_removeAt_in_RemoveStructuralFeatureValueAction(std::weak_ptr<uml::RemoveStructuralFeatureValueAction> par_RemoveStructuralFeatureValueAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl(par_RemoveStructuralFeatureValueAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_RemoveStructuralFeatureValueAction.lock())
	{
		wp->setRemoveAt(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_removeAt_in_RemoveVariableValueAction(std::shared_ptr<RemoveVariableValueAction> par_RemoveVariableValueAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RemoveVariableValueAction)
	{
		par_RemoveVariableValueAction->setRemoveAt(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_replyValue_in_ReplyAction(std::shared_ptr<ReplyAction> par_ReplyAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReplyAction)
	{
		par_ReplyAction->getReplyValue()->push_back(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_request_in_SendObjectAction(std::shared_ptr<SendObjectAction> par_SendObjectAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SendObjectAction)
	{
		par_SendObjectAction->setRequest(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_returnInformation_in_ReplyAction(std::shared_ptr<ReplyAction> par_ReplyAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReplyAction)
	{
		par_ReplyAction->setReturnInformation(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_second_in_TestIdentityAction(std::shared_ptr<TestIdentityAction> par_TestIdentityAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TestIdentityAction)
	{
		par_TestIdentityAction->setSecond(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_structuredNodeInput_in_StructuredActivityNode(std::shared_ptr<StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_StructuredActivityNode)
	{
		par_StructuredActivityNode->getStructuredNodeInput()->push_back(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_target_in_CallOperationAction(std::weak_ptr<uml::CallOperationAction> par_CallOperationAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl(par_CallOperationAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_CallOperationAction.lock())
	{
		wp->setTarget(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_target_in_DestroyObjectAction(std::weak_ptr<uml::DestroyObjectAction> par_DestroyObjectAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl(par_DestroyObjectAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_DestroyObjectAction.lock())
	{
		wp->setTarget(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_target_in_SendObjectAction(std::shared_ptr<SendObjectAction> par_SendObjectAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SendObjectAction)
	{
		par_SendObjectAction->setTarget(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_target_in_SendSignalAction(std::shared_ptr<SendSignalAction> par_SendSignalAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SendSignalAction)
	{
		par_SendSignalAction->setTarget(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_value_in_WriteStructuralFeatureAction(std::weak_ptr<uml::WriteStructuralFeatureAction> par_WriteStructuralFeatureAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl(par_WriteStructuralFeatureAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_WriteStructuralFeatureAction.lock())
	{
		wp->setValue(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InputPin> umlFactoryImpl::createInputPin_as_value_in_WriteVariableAction(std::shared_ptr<WriteVariableAction> par_WriteVariableAction, const int metaElementID) const
{
	std::shared_ptr<InputPinImpl> element(new InputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_WriteVariableAction)
	{
		par_WriteVariableAction->setValue(element);
	}
	
	element->setThisInputPinPtr(element);
	return element;
	
}
std::shared_ptr<InstanceSpecification> umlFactoryImpl::createInstanceSpecification(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<InstanceSpecificationImpl> element(new InstanceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	element->setThisInstanceSpecificationPtr(element);
	return element;
}
std::shared_ptr<InstanceSpecification> umlFactoryImpl::createInstanceSpecification_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<InstanceSpecificationImpl> element(new InstanceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisInstanceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<InstanceSpecification> umlFactoryImpl::createInstanceSpecification_as_deployedArtifact_in_Deployment(std::shared_ptr<Deployment> par_Deployment, const int metaElementID) const
{
	std::shared_ptr<InstanceSpecificationImpl> element(new InstanceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Deployment)
	{
		par_Deployment->getDeployedArtifact()->push_back(element);
	}
	
	element->setThisInstanceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<InstanceSpecification> umlFactoryImpl::createInstanceSpecification_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<InstanceSpecificationImpl> element(new InstanceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisInstanceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<InstanceSpecification> umlFactoryImpl::createInstanceSpecification_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<InstanceSpecificationImpl> element(new InstanceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisInstanceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<InstanceSpecification> umlFactoryImpl::createInstanceSpecification_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<InstanceSpecificationImpl> element(new InstanceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisInstanceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<InstanceSpecification> umlFactoryImpl::createInstanceSpecification_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<InstanceSpecificationImpl> element(new InstanceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisInstanceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<InstanceSpecification> umlFactoryImpl::createInstanceSpecification_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<InstanceSpecificationImpl> element(new InstanceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisInstanceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<InstanceSpecification> umlFactoryImpl::createInstanceSpecification_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<InstanceSpecificationImpl> element(new InstanceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisInstanceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<InstanceSpecification> umlFactoryImpl::createInstanceSpecification_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<InstanceSpecificationImpl> element(new InstanceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisInstanceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<InstanceSpecification> umlFactoryImpl::createInstanceSpecification_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<InstanceSpecificationImpl> element(new InstanceSpecificationImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisInstanceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<InstanceSpecification> umlFactoryImpl::createInstanceSpecification_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<InstanceSpecificationImpl> element(new InstanceSpecificationImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisInstanceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<InstanceSpecification> umlFactoryImpl::createInstanceSpecification_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<InstanceSpecificationImpl> element(new InstanceSpecificationImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisInstanceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<InstanceSpecification> umlFactoryImpl::createInstanceSpecification_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<InstanceSpecificationImpl> element(new InstanceSpecificationImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisInstanceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<InstanceSpecification> umlFactoryImpl::createInstanceSpecification_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<InstanceSpecificationImpl> element(new InstanceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisInstanceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<InstanceSpecification> umlFactoryImpl::createInstanceSpecification_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<InstanceSpecificationImpl> element(new InstanceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisInstanceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<InstanceSpecification> umlFactoryImpl::createInstanceSpecification_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<InstanceSpecificationImpl> element(new InstanceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisInstanceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<InstanceSpecification> umlFactoryImpl::createInstanceSpecification_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<InstanceSpecificationImpl> element(new InstanceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisInstanceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<InstanceSpecification> umlFactoryImpl::createInstanceSpecification_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<InstanceSpecificationImpl> element(new InstanceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisInstanceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	element->setThisInstanceValuePtr(element);
	return element;
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_argument_in_Message(std::shared_ptr<Message> par_Message, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Message)
	{
		par_Message->getArgument()->push_back(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_argument_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->getArgument()->push_back(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_changeExpression_in_ChangeEvent(std::shared_ptr<ChangeEvent> par_ChangeEvent, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ChangeEvent)
	{
		par_ChangeEvent->setChangeExpression(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_defaultValue_in_Property(std::shared_ptr<Property> par_Property, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Property)
	{
		par_Property->setDefaultValue(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_defaultValue_in_Parameter(std::shared_ptr<Parameter> par_Parameter, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Parameter)
	{
		par_Parameter->setDefaultValue(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_expr_in_TimeExpression(std::shared_ptr<TimeExpression> par_TimeExpression, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TimeExpression)
	{
		par_TimeExpression->setExpr(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_expr_in_Duration(std::shared_ptr<Duration> par_Duration, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Duration)
	{
		par_Duration->setExpr(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_guard_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setGuard(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_joinSpec_in_JoinNode(std::shared_ptr<JoinNode> par_JoinNode, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_JoinNode)
	{
		par_JoinNode->setJoinSpec(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_lowerValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setLowerValue(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_maxint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMaxint(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_minint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMinint(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_operand_in_Expression(std::shared_ptr<Expression> par_Expression, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Expression)
	{
		par_Expression->getOperand()->push_back(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_returnValue_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->setReturnValue(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_selector_in_Lifeline(std::shared_ptr<Lifeline> par_Lifeline, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Lifeline)
	{
		par_Lifeline->setSelector(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_specification_in_Constraint(std::shared_ptr<Constraint> par_Constraint, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Constraint)
	{
		par_Constraint->setSpecification(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_specification_in_InstanceSpecification(std::shared_ptr<InstanceSpecification> par_InstanceSpecification, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InstanceSpecification)
	{
		par_InstanceSpecification->setSpecification(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_upperBound_in_ObjectNode(std::shared_ptr<ObjectNode> par_ObjectNode, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ObjectNode)
	{
		par_ObjectNode->setUpperBound(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_upperValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setUpperValue(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_value_in_Slot(std::weak_ptr<uml::Slot> par_Slot, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl(par_Slot));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Slot.lock())
	{
		wp->getValue()->push_back(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_value_in_ValueSpecificationAction(std::weak_ptr<uml::ValueSpecificationAction> par_ValueSpecificationAction, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl(par_ValueSpecificationAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ValueSpecificationAction.lock())
	{
		wp->setValue(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_value_in_ValuePin(std::shared_ptr<ValuePin> par_ValuePin, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ValuePin)
	{
		par_ValuePin->setValue(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<InstanceValue> umlFactoryImpl::createInstanceValue_as_weight_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<InstanceValueImpl> element(new InstanceValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setWeight(element);
	}
	
	element->setThisInstanceValuePtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisInteractionPtr(element);
	return element;
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_classifier_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->setClassifier(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_classifierBehavior_in_BehavioredClassifier(std::shared_ptr<BehavioredClassifier> par_BehavioredClassifier, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_BehavioredClassifier)
	{
		par_BehavioredClassifier->setClassifierBehavior(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_context_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->setContext(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_contract_in_Substitution(std::shared_ptr<Substitution> par_Substitution, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Substitution)
	{
		par_Substitution->setContract(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_doActivity_in_State(std::shared_ptr<State> par_State, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_State)
	{
		par_State->setDoActivity(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_effect_in_Transition(std::shared_ptr<Transition> par_Transition, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Transition)
	{
		par_Transition->setEffect(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_endType_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getEndType()->push_back(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_entry_in_State(std::shared_ptr<State> par_State, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_State)
	{
		par_State->setEntry(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_exit_in_State(std::shared_ptr<State> par_State, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_State)
	{
		par_State->setExit(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_fragment_in_Interaction(std::weak_ptr<uml::Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl(par_Interaction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Interaction.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_fragment_in_InteractionOperand(std::weak_ptr<uml::InteractionOperand> par_InteractionOperand, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl(par_InteractionOperand));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_InteractionOperand.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_general_in_Generalization(std::shared_ptr<Generalization> par_Generalization, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Generalization)
	{
		par_Generalization->setGeneral(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_nestedClassifier_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getNestedClassifier()->push_back(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_nestedClassifier_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getNestedClassifier()->push_back(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_ownedBehavior_in_BehavioredClassifier(std::weak_ptr<uml::BehavioredClassifier> par_BehavioredClassifier, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl(par_BehavioredClassifier));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_BehavioredClassifier.lock())
	{
		wp->getOwnedBehavior()->push_back(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_ownedType_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl(par_Package, uml::umlPackage::TYPE_ATTRIBUTE_PACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getOwnedType()->push_back(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_realizingClassifier_in_ComponentRealization(std::shared_ptr<ComponentRealization> par_ComponentRealization, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ComponentRealization)
	{
		par_ComponentRealization->getRealizingClassifier()->push_back(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_redefinedBehavior_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->getRedefinedBehavior()->push_back(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_redefinedClassifier_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getRedefinedClassifier()->push_back(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<Interaction> umlFactoryImpl::createInteraction_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<InteractionImpl> element(new InteractionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisInteractionPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	element->setThisInteractionConstraintPtr(element);
	return element;
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_bodyCondition_in_Operation(std::shared_ptr<Operation> par_Operation, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Operation)
	{
		par_Operation->setBodyCondition(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_condition_in_ParameterSet(std::shared_ptr<ParameterSet> par_ParameterSet, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ParameterSet)
	{
		par_ParameterSet->getCondition()->push_back(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_condition_in_Extend(std::shared_ptr<Extend> par_Extend, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Extend)
	{
		par_Extend->setCondition(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_guard_in_Transition(std::shared_ptr<Transition> par_Transition, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Transition)
	{
		par_Transition->setGuard(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_guard_in_InteractionOperand(std::shared_ptr<InteractionOperand> par_InteractionOperand, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionOperand)
	{
		par_InteractionOperand->setGuard(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_invariant_in_StateInvariant(std::shared_ptr<StateInvariant> par_StateInvariant, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_StateInvariant)
	{
		par_StateInvariant->setInvariant(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_localPostcondition_in_Action(std::shared_ptr<Action> par_Action, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Action)
	{
		par_Action->getLocalPostcondition()->push_back(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_localPrecondition_in_Action(std::shared_ptr<Action> par_Action, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Action)
	{
		par_Action->getLocalPrecondition()->push_back(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl(par_Namespace, uml::umlPackage::NAMEDELEMENT_ATTRIBUTE_NAMESPACE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_ownedRule_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl(par_Namespace, uml::umlPackage::CONSTRAINT_ATTRIBUTE_CONTEXT));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedRule()->push_back(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_postCondition_in_ProtocolTransition(std::shared_ptr<ProtocolTransition> par_ProtocolTransition, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ProtocolTransition)
	{
		par_ProtocolTransition->setPostCondition(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_postcondition_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->getPostcondition()->push_back(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_postcondition_in_Operation(std::shared_ptr<Operation> par_Operation, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Operation)
	{
		par_Operation->getPostcondition()->push_back(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_preCondition_in_ProtocolTransition(std::shared_ptr<ProtocolTransition> par_ProtocolTransition, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ProtocolTransition)
	{
		par_ProtocolTransition->setPreCondition(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_precondition_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->getPrecondition()->push_back(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_precondition_in_Operation(std::shared_ptr<Operation> par_Operation, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Operation)
	{
		par_Operation->getPrecondition()->push_back(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_stateInvariant_in_State(std::shared_ptr<State> par_State, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_State)
	{
		par_State->setStateInvariant(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionConstraint> umlFactoryImpl::createInteractionConstraint_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<InteractionConstraintImpl> element(new InteractionConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisInteractionConstraintPtr(element);
	return element;
	
}
std::shared_ptr<InteractionOperand> umlFactoryImpl::createInteractionOperand(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<InteractionOperandImpl> element(new InteractionOperandImpl());
	element->setMetaElementID(metaElementID);
	element->setThisInteractionOperandPtr(element);
	return element;
}
std::shared_ptr<InteractionOperand> umlFactoryImpl::createInteractionOperand_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<InteractionOperandImpl> element(new InteractionOperandImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisInteractionOperandPtr(element);
	return element;
	
}
std::shared_ptr<InteractionOperand> umlFactoryImpl::createInteractionOperand_as_fragment_in_Interaction(std::weak_ptr<uml::Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<InteractionOperandImpl> element(new InteractionOperandImpl(par_Interaction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Interaction.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisInteractionOperandPtr(element);
	return element;
	
}
std::shared_ptr<InteractionOperand> umlFactoryImpl::createInteractionOperand_as_fragment_in_InteractionOperand(std::weak_ptr<uml::InteractionOperand> par_InteractionOperand, const int metaElementID) const
{
	std::shared_ptr<InteractionOperandImpl> element(new InteractionOperandImpl(par_InteractionOperand));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_InteractionOperand.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisInteractionOperandPtr(element);
	return element;
	
}
std::shared_ptr<InteractionOperand> umlFactoryImpl::createInteractionOperand_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<InteractionOperandImpl> element(new InteractionOperandImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisInteractionOperandPtr(element);
	return element;
	
}
std::shared_ptr<InteractionOperand> umlFactoryImpl::createInteractionOperand_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<InteractionOperandImpl> element(new InteractionOperandImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisInteractionOperandPtr(element);
	return element;
	
}
std::shared_ptr<InteractionOperand> umlFactoryImpl::createInteractionOperand_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<InteractionOperandImpl> element(new InteractionOperandImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisInteractionOperandPtr(element);
	return element;
	
}
std::shared_ptr<InteractionOperand> umlFactoryImpl::createInteractionOperand_as_operand_in_CombinedFragment(std::shared_ptr<CombinedFragment> par_CombinedFragment, const int metaElementID) const
{
	std::shared_ptr<InteractionOperandImpl> element(new InteractionOperandImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_CombinedFragment)
	{
		par_CombinedFragment->getOperand()->push_back(element);
	}
	
	element->setThisInteractionOperandPtr(element);
	return element;
	
}
std::shared_ptr<InteractionOperand> umlFactoryImpl::createInteractionOperand_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<InteractionOperandImpl> element(new InteractionOperandImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisInteractionOperandPtr(element);
	return element;
	
}
std::shared_ptr<InteractionOperand> umlFactoryImpl::createInteractionOperand_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<InteractionOperandImpl> element(new InteractionOperandImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisInteractionOperandPtr(element);
	return element;
	
}
std::shared_ptr<InteractionOperand> umlFactoryImpl::createInteractionOperand_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<InteractionOperandImpl> element(new InteractionOperandImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisInteractionOperandPtr(element);
	return element;
	
}
std::shared_ptr<InteractionOperand> umlFactoryImpl::createInteractionOperand_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<InteractionOperandImpl> element(new InteractionOperandImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisInteractionOperandPtr(element);
	return element;
	
}
std::shared_ptr<InteractionOperand> umlFactoryImpl::createInteractionOperand_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<InteractionOperandImpl> element(new InteractionOperandImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisInteractionOperandPtr(element);
	return element;
	
}
std::shared_ptr<InteractionUse> umlFactoryImpl::createInteractionUse(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<InteractionUseImpl> element(new InteractionUseImpl());
	element->setMetaElementID(metaElementID);
	element->setThisInteractionUsePtr(element);
	return element;
}
std::shared_ptr<InteractionUse> umlFactoryImpl::createInteractionUse_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<InteractionUseImpl> element(new InteractionUseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisInteractionUsePtr(element);
	return element;
	
}
std::shared_ptr<InteractionUse> umlFactoryImpl::createInteractionUse_as_fragment_in_Interaction(std::weak_ptr<uml::Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<InteractionUseImpl> element(new InteractionUseImpl(par_Interaction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Interaction.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisInteractionUsePtr(element);
	return element;
	
}
std::shared_ptr<InteractionUse> umlFactoryImpl::createInteractionUse_as_fragment_in_InteractionOperand(std::weak_ptr<uml::InteractionOperand> par_InteractionOperand, const int metaElementID) const
{
	std::shared_ptr<InteractionUseImpl> element(new InteractionUseImpl(par_InteractionOperand));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_InteractionOperand.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisInteractionUsePtr(element);
	return element;
	
}
std::shared_ptr<InteractionUse> umlFactoryImpl::createInteractionUse_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<InteractionUseImpl> element(new InteractionUseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisInteractionUsePtr(element);
	return element;
	
}
std::shared_ptr<InteractionUse> umlFactoryImpl::createInteractionUse_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<InteractionUseImpl> element(new InteractionUseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisInteractionUsePtr(element);
	return element;
	
}
std::shared_ptr<InteractionUse> umlFactoryImpl::createInteractionUse_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<InteractionUseImpl> element(new InteractionUseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisInteractionUsePtr(element);
	return element;
	
}
std::shared_ptr<InteractionUse> umlFactoryImpl::createInteractionUse_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<InteractionUseImpl> element(new InteractionUseImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisInteractionUsePtr(element);
	return element;
	
}
std::shared_ptr<InteractionUse> umlFactoryImpl::createInteractionUse_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<InteractionUseImpl> element(new InteractionUseImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisInteractionUsePtr(element);
	return element;
	
}
std::shared_ptr<InteractionUse> umlFactoryImpl::createInteractionUse_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<InteractionUseImpl> element(new InteractionUseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisInteractionUsePtr(element);
	return element;
	
}
std::shared_ptr<InteractionUse> umlFactoryImpl::createInteractionUse_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<InteractionUseImpl> element(new InteractionUseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisInteractionUsePtr(element);
	return element;
	
}
std::shared_ptr<InteractionUse> umlFactoryImpl::createInteractionUse_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<InteractionUseImpl> element(new InteractionUseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisInteractionUsePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl());
	element->setMetaElementID(metaElementID);
	element->setThisInterfacePtr(element);
	return element;
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_classifier_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->setClassifier(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_contract_in_Substitution(std::shared_ptr<Substitution> par_Substitution, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Substitution)
	{
		par_Substitution->setContract(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_contract_in_InterfaceRealization(std::shared_ptr<InterfaceRealization> par_InterfaceRealization, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterfaceRealization)
	{
		par_InterfaceRealization->setContract(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_endType_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getEndType()->push_back(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_general_in_Generalization(std::shared_ptr<Generalization> par_Generalization, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Generalization)
	{
		par_Generalization->setGeneral(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_nestedClassifier_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getNestedClassifier()->push_back(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_nestedClassifier_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getNestedClassifier()->push_back(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_ownedType_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl(par_Package, uml::umlPackage::TYPE_ATTRIBUTE_PACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getOwnedType()->push_back(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_realizingClassifier_in_ComponentRealization(std::shared_ptr<ComponentRealization> par_ComponentRealization, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ComponentRealization)
	{
		par_ComponentRealization->getRealizingClassifier()->push_back(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_redefinedClassifier_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getRedefinedClassifier()->push_back(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_redefinedInterface_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getRedefinedInterface()->push_back(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<Interface> umlFactoryImpl::createInterface_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<InterfaceImpl> element(new InterfaceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisInterfacePtr(element);
	return element;
	
}
std::shared_ptr<InterfaceRealization> umlFactoryImpl::createInterfaceRealization(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<InterfaceRealizationImpl> element(new InterfaceRealizationImpl());
	element->setMetaElementID(metaElementID);
	element->setThisInterfaceRealizationPtr(element);
	return element;
}
std::shared_ptr<InterfaceRealization> umlFactoryImpl::createInterfaceRealization_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<InterfaceRealizationImpl> element(new InterfaceRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisInterfaceRealizationPtr(element);
	return element;
	
}
std::shared_ptr<InterfaceRealization> umlFactoryImpl::createInterfaceRealization_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<InterfaceRealizationImpl> element(new InterfaceRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisInterfaceRealizationPtr(element);
	return element;
	
}
std::shared_ptr<InterfaceRealization> umlFactoryImpl::createInterfaceRealization_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<InterfaceRealizationImpl> element(new InterfaceRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisInterfaceRealizationPtr(element);
	return element;
	
}
std::shared_ptr<InterfaceRealization> umlFactoryImpl::createInterfaceRealization_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<InterfaceRealizationImpl> element(new InterfaceRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisInterfaceRealizationPtr(element);
	return element;
	
}
std::shared_ptr<InterfaceRealization> umlFactoryImpl::createInterfaceRealization_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<InterfaceRealizationImpl> element(new InterfaceRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisInterfaceRealizationPtr(element);
	return element;
	
}
std::shared_ptr<InterfaceRealization> umlFactoryImpl::createInterfaceRealization_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<InterfaceRealizationImpl> element(new InterfaceRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisInterfaceRealizationPtr(element);
	return element;
	
}
std::shared_ptr<InterfaceRealization> umlFactoryImpl::createInterfaceRealization_as_interfaceRealization_in_BehavioredClassifier(std::weak_ptr<uml::BehavioredClassifier> par_BehavioredClassifier, const int metaElementID) const
{
	std::shared_ptr<InterfaceRealizationImpl> element(new InterfaceRealizationImpl(par_BehavioredClassifier));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_BehavioredClassifier.lock())
	{
		wp->getInterfaceRealization()->push_back(element);
	}
	
	element->setThisInterfaceRealizationPtr(element);
	return element;
	
}
std::shared_ptr<InterfaceRealization> umlFactoryImpl::createInterfaceRealization_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<InterfaceRealizationImpl> element(new InterfaceRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisInterfaceRealizationPtr(element);
	return element;
	
}
std::shared_ptr<InterfaceRealization> umlFactoryImpl::createInterfaceRealization_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<InterfaceRealizationImpl> element(new InterfaceRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisInterfaceRealizationPtr(element);
	return element;
	
}
std::shared_ptr<InterfaceRealization> umlFactoryImpl::createInterfaceRealization_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<InterfaceRealizationImpl> element(new InterfaceRealizationImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisInterfaceRealizationPtr(element);
	return element;
	
}
std::shared_ptr<InterfaceRealization> umlFactoryImpl::createInterfaceRealization_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<InterfaceRealizationImpl> element(new InterfaceRealizationImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisInterfaceRealizationPtr(element);
	return element;
	
}
std::shared_ptr<InterfaceRealization> umlFactoryImpl::createInterfaceRealization_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<InterfaceRealizationImpl> element(new InterfaceRealizationImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisInterfaceRealizationPtr(element);
	return element;
	
}
std::shared_ptr<InterfaceRealization> umlFactoryImpl::createInterfaceRealization_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<InterfaceRealizationImpl> element(new InterfaceRealizationImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisInterfaceRealizationPtr(element);
	return element;
	
}
std::shared_ptr<InterfaceRealization> umlFactoryImpl::createInterfaceRealization_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<InterfaceRealizationImpl> element(new InterfaceRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisInterfaceRealizationPtr(element);
	return element;
	
}
std::shared_ptr<InterfaceRealization> umlFactoryImpl::createInterfaceRealization_as_roleBinding_in_CollaborationUse(std::shared_ptr<CollaborationUse> par_CollaborationUse, const int metaElementID) const
{
	std::shared_ptr<InterfaceRealizationImpl> element(new InterfaceRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_CollaborationUse)
	{
		par_CollaborationUse->getRoleBinding()->push_back(element);
	}
	
	element->setThisInterfaceRealizationPtr(element);
	return element;
	
}
std::shared_ptr<InterfaceRealization> umlFactoryImpl::createInterfaceRealization_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<InterfaceRealizationImpl> element(new InterfaceRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisInterfaceRealizationPtr(element);
	return element;
	
}
std::shared_ptr<InterfaceRealization> umlFactoryImpl::createInterfaceRealization_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<InterfaceRealizationImpl> element(new InterfaceRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisInterfaceRealizationPtr(element);
	return element;
	
}
std::shared_ptr<InterfaceRealization> umlFactoryImpl::createInterfaceRealization_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<InterfaceRealizationImpl> element(new InterfaceRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisInterfaceRealizationPtr(element);
	return element;
	
}
std::shared_ptr<InterfaceRealization> umlFactoryImpl::createInterfaceRealization_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<InterfaceRealizationImpl> element(new InterfaceRealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisInterfaceRealizationPtr(element);
	return element;
	
}
std::shared_ptr<InterruptibleActivityRegion> umlFactoryImpl::createInterruptibleActivityRegion(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<InterruptibleActivityRegionImpl> element(new InterruptibleActivityRegionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisInterruptibleActivityRegionPtr(element);
	return element;
}
std::shared_ptr<InterruptibleActivityRegion> umlFactoryImpl::createInterruptibleActivityRegion_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<InterruptibleActivityRegionImpl> element(new InterruptibleActivityRegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisInterruptibleActivityRegionPtr(element);
	return element;
	
}
std::shared_ptr<InterruptibleActivityRegion> umlFactoryImpl::createInterruptibleActivityRegion_as_group_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<InterruptibleActivityRegionImpl> element(new InterruptibleActivityRegionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getGroup()->push_back(element);
	}
	
	element->setThisInterruptibleActivityRegionPtr(element);
	return element;
	
}
std::shared_ptr<InterruptibleActivityRegion> umlFactoryImpl::createInterruptibleActivityRegion_as_inInterruptibleRegion_in_ActivityNode(std::shared_ptr<uml::ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<InterruptibleActivityRegionImpl> element(new InterruptibleActivityRegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getInInterruptibleRegion()->push_back(element);
	}
	
	element->setThisInterruptibleActivityRegionPtr(element);
	return element;
	
}
std::shared_ptr<InterruptibleActivityRegion> umlFactoryImpl::createInterruptibleActivityRegion_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<InterruptibleActivityRegionImpl> element(new InterruptibleActivityRegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisInterruptibleActivityRegionPtr(element);
	return element;
	
}
std::shared_ptr<InterruptibleActivityRegion> umlFactoryImpl::createInterruptibleActivityRegion_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<InterruptibleActivityRegionImpl> element(new InterruptibleActivityRegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisInterruptibleActivityRegionPtr(element);
	return element;
	
}
std::shared_ptr<InterruptibleActivityRegion> umlFactoryImpl::createInterruptibleActivityRegion_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<InterruptibleActivityRegionImpl> element(new InterruptibleActivityRegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisInterruptibleActivityRegionPtr(element);
	return element;
	
}
std::shared_ptr<InterruptibleActivityRegion> umlFactoryImpl::createInterruptibleActivityRegion_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<InterruptibleActivityRegionImpl> element(new InterruptibleActivityRegionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisInterruptibleActivityRegionPtr(element);
	return element;
	
}
std::shared_ptr<InterruptibleActivityRegion> umlFactoryImpl::createInterruptibleActivityRegion_as_ownedGroup_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<InterruptibleActivityRegionImpl> element(new InterruptibleActivityRegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedGroup()->push_back(element);
	}
	
	element->setThisInterruptibleActivityRegionPtr(element);
	return element;
	
}
std::shared_ptr<InterruptibleActivityRegion> umlFactoryImpl::createInterruptibleActivityRegion_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<InterruptibleActivityRegionImpl> element(new InterruptibleActivityRegionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisInterruptibleActivityRegionPtr(element);
	return element;
	
}
std::shared_ptr<InterruptibleActivityRegion> umlFactoryImpl::createInterruptibleActivityRegion_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<InterruptibleActivityRegionImpl> element(new InterruptibleActivityRegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisInterruptibleActivityRegionPtr(element);
	return element;
	
}
std::shared_ptr<InterruptibleActivityRegion> umlFactoryImpl::createInterruptibleActivityRegion_as_subgroup_in_ActivityGroup(std::weak_ptr<uml::ActivityGroup> par_ActivityGroup, const int metaElementID) const
{
	std::shared_ptr<InterruptibleActivityRegionImpl> element(new InterruptibleActivityRegionImpl(par_ActivityGroup));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ActivityGroup.lock())
	{
		wp->getSubgroup()->push_back(element);
	}
	
	element->setThisInterruptibleActivityRegionPtr(element);
	return element;
	
}
std::shared_ptr<InterruptibleActivityRegion> umlFactoryImpl::createInterruptibleActivityRegion_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<InterruptibleActivityRegionImpl> element(new InterruptibleActivityRegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisInterruptibleActivityRegionPtr(element);
	return element;
	
}
std::shared_ptr<InterruptibleActivityRegion> umlFactoryImpl::createInterruptibleActivityRegion_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<InterruptibleActivityRegionImpl> element(new InterruptibleActivityRegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisInterruptibleActivityRegionPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	element->setThisIntervalPtr(element);
	return element;
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_argument_in_Message(std::shared_ptr<Message> par_Message, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Message)
	{
		par_Message->getArgument()->push_back(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_argument_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->getArgument()->push_back(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_changeExpression_in_ChangeEvent(std::shared_ptr<ChangeEvent> par_ChangeEvent, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ChangeEvent)
	{
		par_ChangeEvent->setChangeExpression(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_defaultValue_in_Property(std::shared_ptr<Property> par_Property, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Property)
	{
		par_Property->setDefaultValue(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_defaultValue_in_Parameter(std::shared_ptr<Parameter> par_Parameter, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Parameter)
	{
		par_Parameter->setDefaultValue(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_expr_in_TimeExpression(std::shared_ptr<TimeExpression> par_TimeExpression, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TimeExpression)
	{
		par_TimeExpression->setExpr(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_expr_in_Duration(std::shared_ptr<Duration> par_Duration, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Duration)
	{
		par_Duration->setExpr(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_guard_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setGuard(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_joinSpec_in_JoinNode(std::shared_ptr<JoinNode> par_JoinNode, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_JoinNode)
	{
		par_JoinNode->setJoinSpec(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_lowerValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setLowerValue(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_maxint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMaxint(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_minint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMinint(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_operand_in_Expression(std::shared_ptr<Expression> par_Expression, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Expression)
	{
		par_Expression->getOperand()->push_back(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_returnValue_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->setReturnValue(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_selector_in_Lifeline(std::shared_ptr<Lifeline> par_Lifeline, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Lifeline)
	{
		par_Lifeline->setSelector(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_specification_in_Constraint(std::shared_ptr<Constraint> par_Constraint, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Constraint)
	{
		par_Constraint->setSpecification(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_specification_in_InstanceSpecification(std::shared_ptr<InstanceSpecification> par_InstanceSpecification, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InstanceSpecification)
	{
		par_InstanceSpecification->setSpecification(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_upperBound_in_ObjectNode(std::shared_ptr<ObjectNode> par_ObjectNode, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ObjectNode)
	{
		par_ObjectNode->setUpperBound(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_upperValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setUpperValue(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_value_in_Slot(std::weak_ptr<uml::Slot> par_Slot, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl(par_Slot));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Slot.lock())
	{
		wp->getValue()->push_back(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_value_in_ValueSpecificationAction(std::weak_ptr<uml::ValueSpecificationAction> par_ValueSpecificationAction, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl(par_ValueSpecificationAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ValueSpecificationAction.lock())
	{
		wp->setValue(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_value_in_ValuePin(std::shared_ptr<ValuePin> par_ValuePin, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ValuePin)
	{
		par_ValuePin->setValue(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<Interval> umlFactoryImpl::createInterval_as_weight_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<IntervalImpl> element(new IntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setWeight(element);
	}
	
	element->setThisIntervalPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	element->setThisIntervalConstraintPtr(element);
	return element;
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_bodyCondition_in_Operation(std::shared_ptr<Operation> par_Operation, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Operation)
	{
		par_Operation->setBodyCondition(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_condition_in_ParameterSet(std::shared_ptr<ParameterSet> par_ParameterSet, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ParameterSet)
	{
		par_ParameterSet->getCondition()->push_back(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_condition_in_Extend(std::shared_ptr<Extend> par_Extend, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Extend)
	{
		par_Extend->setCondition(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_guard_in_Transition(std::shared_ptr<Transition> par_Transition, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Transition)
	{
		par_Transition->setGuard(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_invariant_in_StateInvariant(std::shared_ptr<StateInvariant> par_StateInvariant, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_StateInvariant)
	{
		par_StateInvariant->setInvariant(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_localPostcondition_in_Action(std::shared_ptr<Action> par_Action, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Action)
	{
		par_Action->getLocalPostcondition()->push_back(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_localPrecondition_in_Action(std::shared_ptr<Action> par_Action, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Action)
	{
		par_Action->getLocalPrecondition()->push_back(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl(par_Namespace, uml::umlPackage::NAMEDELEMENT_ATTRIBUTE_NAMESPACE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_ownedRule_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl(par_Namespace, uml::umlPackage::CONSTRAINT_ATTRIBUTE_CONTEXT));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedRule()->push_back(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_postCondition_in_ProtocolTransition(std::shared_ptr<ProtocolTransition> par_ProtocolTransition, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ProtocolTransition)
	{
		par_ProtocolTransition->setPostCondition(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_postcondition_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->getPostcondition()->push_back(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_postcondition_in_Operation(std::shared_ptr<Operation> par_Operation, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Operation)
	{
		par_Operation->getPostcondition()->push_back(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_preCondition_in_ProtocolTransition(std::shared_ptr<ProtocolTransition> par_ProtocolTransition, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ProtocolTransition)
	{
		par_ProtocolTransition->setPreCondition(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_precondition_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->getPrecondition()->push_back(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_precondition_in_Operation(std::shared_ptr<Operation> par_Operation, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Operation)
	{
		par_Operation->getPrecondition()->push_back(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_stateInvariant_in_State(std::shared_ptr<State> par_State, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_State)
	{
		par_State->setStateInvariant(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<IntervalConstraint> umlFactoryImpl::createIntervalConstraint_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<IntervalConstraintImpl> element(new IntervalConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisIntervalConstraintPtr(element);
	return element;
	
}
std::shared_ptr<JoinNode> umlFactoryImpl::createJoinNode(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<JoinNodeImpl> element(new JoinNodeImpl());
	element->setMetaElementID(metaElementID);
	element->setThisJoinNodePtr(element);
	return element;
}
std::shared_ptr<JoinNode> umlFactoryImpl::createJoinNode_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<JoinNodeImpl> element(new JoinNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisJoinNodePtr(element);
	return element;
	
}
std::shared_ptr<JoinNode> umlFactoryImpl::createJoinNode_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<JoinNodeImpl> element(new JoinNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisJoinNodePtr(element);
	return element;
	
}
std::shared_ptr<JoinNode> umlFactoryImpl::createJoinNode_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<JoinNodeImpl> element(new JoinNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisJoinNodePtr(element);
	return element;
	
}
std::shared_ptr<JoinNode> umlFactoryImpl::createJoinNode_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<JoinNodeImpl> element(new JoinNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisJoinNodePtr(element);
	return element;
	
}
std::shared_ptr<JoinNode> umlFactoryImpl::createJoinNode_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<JoinNodeImpl> element(new JoinNodeImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisJoinNodePtr(element);
	return element;
	
}
std::shared_ptr<JoinNode> umlFactoryImpl::createJoinNode_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<JoinNodeImpl> element(new JoinNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisJoinNodePtr(element);
	return element;
	
}
std::shared_ptr<JoinNode> umlFactoryImpl::createJoinNode_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<JoinNodeImpl> element(new JoinNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisJoinNodePtr(element);
	return element;
	
}
std::shared_ptr<JoinNode> umlFactoryImpl::createJoinNode_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<JoinNodeImpl> element(new JoinNodeImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisJoinNodePtr(element);
	return element;
	
}
std::shared_ptr<JoinNode> umlFactoryImpl::createJoinNode_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<JoinNodeImpl> element(new JoinNodeImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisJoinNodePtr(element);
	return element;
	
}
std::shared_ptr<JoinNode> umlFactoryImpl::createJoinNode_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<JoinNodeImpl> element(new JoinNodeImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisJoinNodePtr(element);
	return element;
	
}
std::shared_ptr<JoinNode> umlFactoryImpl::createJoinNode_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<JoinNodeImpl> element(new JoinNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisJoinNodePtr(element);
	return element;
	
}
std::shared_ptr<JoinNode> umlFactoryImpl::createJoinNode_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<JoinNodeImpl> element(new JoinNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisJoinNodePtr(element);
	return element;
	
}
std::shared_ptr<JoinNode> umlFactoryImpl::createJoinNode_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<JoinNodeImpl> element(new JoinNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisJoinNodePtr(element);
	return element;
	
}
std::shared_ptr<JoinNode> umlFactoryImpl::createJoinNode_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<JoinNodeImpl> element(new JoinNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisJoinNodePtr(element);
	return element;
	
}
std::shared_ptr<JoinNode> umlFactoryImpl::createJoinNode_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<JoinNodeImpl> element(new JoinNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisJoinNodePtr(element);
	return element;
	
}
std::shared_ptr<Lifeline> umlFactoryImpl::createLifeline(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<LifelineImpl> element(new LifelineImpl());
	element->setMetaElementID(metaElementID);
	element->setThisLifelinePtr(element);
	return element;
}
std::shared_ptr<Lifeline> umlFactoryImpl::createLifeline_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<LifelineImpl> element(new LifelineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisLifelinePtr(element);
	return element;
	
}
std::shared_ptr<Lifeline> umlFactoryImpl::createLifeline_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<LifelineImpl> element(new LifelineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisLifelinePtr(element);
	return element;
	
}
std::shared_ptr<Lifeline> umlFactoryImpl::createLifeline_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<LifelineImpl> element(new LifelineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisLifelinePtr(element);
	return element;
	
}
std::shared_ptr<Lifeline> umlFactoryImpl::createLifeline_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<LifelineImpl> element(new LifelineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisLifelinePtr(element);
	return element;
	
}
std::shared_ptr<Lifeline> umlFactoryImpl::createLifeline_as_lifeline_in_Interaction(std::weak_ptr<uml::Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<LifelineImpl> element(new LifelineImpl(par_Interaction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Interaction.lock())
	{
		wp->getLifeline()->push_back(element);
	}
	
	element->setThisLifelinePtr(element);
	return element;
	
}
std::shared_ptr<Lifeline> umlFactoryImpl::createLifeline_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<LifelineImpl> element(new LifelineImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisLifelinePtr(element);
	return element;
	
}
std::shared_ptr<Lifeline> umlFactoryImpl::createLifeline_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<LifelineImpl> element(new LifelineImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisLifelinePtr(element);
	return element;
	
}
std::shared_ptr<Lifeline> umlFactoryImpl::createLifeline_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<LifelineImpl> element(new LifelineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisLifelinePtr(element);
	return element;
	
}
std::shared_ptr<Lifeline> umlFactoryImpl::createLifeline_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<LifelineImpl> element(new LifelineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisLifelinePtr(element);
	return element;
	
}
std::shared_ptr<Lifeline> umlFactoryImpl::createLifeline_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<LifelineImpl> element(new LifelineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisLifelinePtr(element);
	return element;
	
}
std::shared_ptr<LinkEndCreationData> umlFactoryImpl::createLinkEndCreationData(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<LinkEndCreationDataImpl> element(new LinkEndCreationDataImpl());
	element->setMetaElementID(metaElementID);
	element->setThisLinkEndCreationDataPtr(element);
	return element;
}
std::shared_ptr<LinkEndCreationData> umlFactoryImpl::createLinkEndCreationData_as_endData_in_LinkAction(std::shared_ptr<LinkAction> par_LinkAction, const int metaElementID) const
{
	std::shared_ptr<LinkEndCreationDataImpl> element(new LinkEndCreationDataImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_LinkAction)
	{
		par_LinkAction->getEndData()->push_back(element);
	}
	
	element->setThisLinkEndCreationDataPtr(element);
	return element;
	
}
std::shared_ptr<LinkEndCreationData> umlFactoryImpl::createLinkEndCreationData_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<LinkEndCreationDataImpl> element(new LinkEndCreationDataImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisLinkEndCreationDataPtr(element);
	return element;
	
}
std::shared_ptr<LinkEndCreationData> umlFactoryImpl::createLinkEndCreationData_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<LinkEndCreationDataImpl> element(new LinkEndCreationDataImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisLinkEndCreationDataPtr(element);
	return element;
	
}
std::shared_ptr<LinkEndCreationData> umlFactoryImpl::createLinkEndCreationData_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<LinkEndCreationDataImpl> element(new LinkEndCreationDataImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisLinkEndCreationDataPtr(element);
	return element;
	
}
std::shared_ptr<LinkEndData> umlFactoryImpl::createLinkEndData(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<LinkEndDataImpl> element(new LinkEndDataImpl());
	element->setMetaElementID(metaElementID);
	element->setThisLinkEndDataPtr(element);
	return element;
}
std::shared_ptr<LinkEndData> umlFactoryImpl::createLinkEndData_as_endData_in_LinkAction(std::shared_ptr<LinkAction> par_LinkAction, const int metaElementID) const
{
	std::shared_ptr<LinkEndDataImpl> element(new LinkEndDataImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_LinkAction)
	{
		par_LinkAction->getEndData()->push_back(element);
	}
	
	element->setThisLinkEndDataPtr(element);
	return element;
	
}
std::shared_ptr<LinkEndData> umlFactoryImpl::createLinkEndData_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<LinkEndDataImpl> element(new LinkEndDataImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisLinkEndDataPtr(element);
	return element;
	
}
std::shared_ptr<LinkEndData> umlFactoryImpl::createLinkEndData_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<LinkEndDataImpl> element(new LinkEndDataImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisLinkEndDataPtr(element);
	return element;
	
}
std::shared_ptr<LinkEndData> umlFactoryImpl::createLinkEndData_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<LinkEndDataImpl> element(new LinkEndDataImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisLinkEndDataPtr(element);
	return element;
	
}
std::shared_ptr<LinkEndDestructionData> umlFactoryImpl::createLinkEndDestructionData(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<LinkEndDestructionDataImpl> element(new LinkEndDestructionDataImpl());
	element->setMetaElementID(metaElementID);
	element->setThisLinkEndDestructionDataPtr(element);
	return element;
}
std::shared_ptr<LinkEndDestructionData> umlFactoryImpl::createLinkEndDestructionData_as_endData_in_LinkAction(std::shared_ptr<LinkAction> par_LinkAction, const int metaElementID) const
{
	std::shared_ptr<LinkEndDestructionDataImpl> element(new LinkEndDestructionDataImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_LinkAction)
	{
		par_LinkAction->getEndData()->push_back(element);
	}
	
	element->setThisLinkEndDestructionDataPtr(element);
	return element;
	
}
std::shared_ptr<LinkEndDestructionData> umlFactoryImpl::createLinkEndDestructionData_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<LinkEndDestructionDataImpl> element(new LinkEndDestructionDataImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisLinkEndDestructionDataPtr(element);
	return element;
	
}
std::shared_ptr<LinkEndDestructionData> umlFactoryImpl::createLinkEndDestructionData_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<LinkEndDestructionDataImpl> element(new LinkEndDestructionDataImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisLinkEndDestructionDataPtr(element);
	return element;
	
}
std::shared_ptr<LinkEndDestructionData> umlFactoryImpl::createLinkEndDestructionData_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<LinkEndDestructionDataImpl> element(new LinkEndDestructionDataImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisLinkEndDestructionDataPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	element->setThisLiteralBooleanPtr(element);
	return element;
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_argument_in_Message(std::shared_ptr<Message> par_Message, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Message)
	{
		par_Message->getArgument()->push_back(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_argument_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->getArgument()->push_back(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_changeExpression_in_ChangeEvent(std::shared_ptr<ChangeEvent> par_ChangeEvent, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ChangeEvent)
	{
		par_ChangeEvent->setChangeExpression(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_defaultValue_in_Property(std::shared_ptr<Property> par_Property, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Property)
	{
		par_Property->setDefaultValue(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_defaultValue_in_Parameter(std::shared_ptr<Parameter> par_Parameter, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Parameter)
	{
		par_Parameter->setDefaultValue(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_expr_in_TimeExpression(std::shared_ptr<TimeExpression> par_TimeExpression, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TimeExpression)
	{
		par_TimeExpression->setExpr(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_expr_in_Duration(std::shared_ptr<Duration> par_Duration, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Duration)
	{
		par_Duration->setExpr(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_guard_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setGuard(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_joinSpec_in_JoinNode(std::shared_ptr<JoinNode> par_JoinNode, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_JoinNode)
	{
		par_JoinNode->setJoinSpec(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_lowerValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setLowerValue(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_maxint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMaxint(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_minint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMinint(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_operand_in_Expression(std::shared_ptr<Expression> par_Expression, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Expression)
	{
		par_Expression->getOperand()->push_back(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_returnValue_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->setReturnValue(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_selector_in_Lifeline(std::shared_ptr<Lifeline> par_Lifeline, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Lifeline)
	{
		par_Lifeline->setSelector(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_specification_in_Constraint(std::shared_ptr<Constraint> par_Constraint, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Constraint)
	{
		par_Constraint->setSpecification(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_specification_in_InstanceSpecification(std::shared_ptr<InstanceSpecification> par_InstanceSpecification, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InstanceSpecification)
	{
		par_InstanceSpecification->setSpecification(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_upperBound_in_ObjectNode(std::shared_ptr<ObjectNode> par_ObjectNode, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ObjectNode)
	{
		par_ObjectNode->setUpperBound(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_upperValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setUpperValue(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_value_in_Slot(std::weak_ptr<uml::Slot> par_Slot, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl(par_Slot));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Slot.lock())
	{
		wp->getValue()->push_back(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_value_in_ValueSpecificationAction(std::weak_ptr<uml::ValueSpecificationAction> par_ValueSpecificationAction, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl(par_ValueSpecificationAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ValueSpecificationAction.lock())
	{
		wp->setValue(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_value_in_ValuePin(std::shared_ptr<ValuePin> par_ValuePin, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ValuePin)
	{
		par_ValuePin->setValue(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralBoolean> umlFactoryImpl::createLiteralBoolean_as_weight_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<LiteralBooleanImpl> element(new LiteralBooleanImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setWeight(element);
	}
	
	element->setThisLiteralBooleanPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	element->setThisLiteralIntegerPtr(element);
	return element;
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_argument_in_Message(std::shared_ptr<Message> par_Message, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Message)
	{
		par_Message->getArgument()->push_back(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_argument_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->getArgument()->push_back(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_changeExpression_in_ChangeEvent(std::shared_ptr<ChangeEvent> par_ChangeEvent, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ChangeEvent)
	{
		par_ChangeEvent->setChangeExpression(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_defaultValue_in_Property(std::shared_ptr<Property> par_Property, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Property)
	{
		par_Property->setDefaultValue(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_defaultValue_in_Parameter(std::shared_ptr<Parameter> par_Parameter, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Parameter)
	{
		par_Parameter->setDefaultValue(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_expr_in_TimeExpression(std::shared_ptr<TimeExpression> par_TimeExpression, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TimeExpression)
	{
		par_TimeExpression->setExpr(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_expr_in_Duration(std::shared_ptr<Duration> par_Duration, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Duration)
	{
		par_Duration->setExpr(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_guard_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setGuard(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_joinSpec_in_JoinNode(std::shared_ptr<JoinNode> par_JoinNode, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_JoinNode)
	{
		par_JoinNode->setJoinSpec(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_lowerValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setLowerValue(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_maxint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMaxint(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_minint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMinint(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_operand_in_Expression(std::shared_ptr<Expression> par_Expression, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Expression)
	{
		par_Expression->getOperand()->push_back(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_returnValue_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->setReturnValue(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_selector_in_Lifeline(std::shared_ptr<Lifeline> par_Lifeline, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Lifeline)
	{
		par_Lifeline->setSelector(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_specification_in_Constraint(std::shared_ptr<Constraint> par_Constraint, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Constraint)
	{
		par_Constraint->setSpecification(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_specification_in_InstanceSpecification(std::shared_ptr<InstanceSpecification> par_InstanceSpecification, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InstanceSpecification)
	{
		par_InstanceSpecification->setSpecification(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_upperBound_in_ObjectNode(std::shared_ptr<ObjectNode> par_ObjectNode, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ObjectNode)
	{
		par_ObjectNode->setUpperBound(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_upperValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setUpperValue(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_value_in_Slot(std::weak_ptr<uml::Slot> par_Slot, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl(par_Slot));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Slot.lock())
	{
		wp->getValue()->push_back(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_value_in_ValueSpecificationAction(std::weak_ptr<uml::ValueSpecificationAction> par_ValueSpecificationAction, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl(par_ValueSpecificationAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ValueSpecificationAction.lock())
	{
		wp->setValue(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_value_in_ValuePin(std::shared_ptr<ValuePin> par_ValuePin, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ValuePin)
	{
		par_ValuePin->setValue(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralInteger> umlFactoryImpl::createLiteralInteger_as_weight_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<LiteralIntegerImpl> element(new LiteralIntegerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setWeight(element);
	}
	
	element->setThisLiteralIntegerPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	element->setThisLiteralNullPtr(element);
	return element;
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_argument_in_Message(std::shared_ptr<Message> par_Message, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Message)
	{
		par_Message->getArgument()->push_back(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_argument_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->getArgument()->push_back(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_changeExpression_in_ChangeEvent(std::shared_ptr<ChangeEvent> par_ChangeEvent, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ChangeEvent)
	{
		par_ChangeEvent->setChangeExpression(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_defaultValue_in_Property(std::shared_ptr<Property> par_Property, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Property)
	{
		par_Property->setDefaultValue(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_defaultValue_in_Parameter(std::shared_ptr<Parameter> par_Parameter, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Parameter)
	{
		par_Parameter->setDefaultValue(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_expr_in_TimeExpression(std::shared_ptr<TimeExpression> par_TimeExpression, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TimeExpression)
	{
		par_TimeExpression->setExpr(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_expr_in_Duration(std::shared_ptr<Duration> par_Duration, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Duration)
	{
		par_Duration->setExpr(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_guard_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setGuard(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_joinSpec_in_JoinNode(std::shared_ptr<JoinNode> par_JoinNode, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_JoinNode)
	{
		par_JoinNode->setJoinSpec(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_lowerValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setLowerValue(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_maxint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMaxint(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_minint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMinint(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_operand_in_Expression(std::shared_ptr<Expression> par_Expression, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Expression)
	{
		par_Expression->getOperand()->push_back(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_returnValue_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->setReturnValue(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_selector_in_Lifeline(std::shared_ptr<Lifeline> par_Lifeline, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Lifeline)
	{
		par_Lifeline->setSelector(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_specification_in_Constraint(std::shared_ptr<Constraint> par_Constraint, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Constraint)
	{
		par_Constraint->setSpecification(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_specification_in_InstanceSpecification(std::shared_ptr<InstanceSpecification> par_InstanceSpecification, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InstanceSpecification)
	{
		par_InstanceSpecification->setSpecification(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_upperBound_in_ObjectNode(std::shared_ptr<ObjectNode> par_ObjectNode, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ObjectNode)
	{
		par_ObjectNode->setUpperBound(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_upperValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setUpperValue(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_value_in_Slot(std::weak_ptr<uml::Slot> par_Slot, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl(par_Slot));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Slot.lock())
	{
		wp->getValue()->push_back(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_value_in_ValueSpecificationAction(std::weak_ptr<uml::ValueSpecificationAction> par_ValueSpecificationAction, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl(par_ValueSpecificationAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ValueSpecificationAction.lock())
	{
		wp->setValue(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_value_in_ValuePin(std::shared_ptr<ValuePin> par_ValuePin, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ValuePin)
	{
		par_ValuePin->setValue(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralNull> umlFactoryImpl::createLiteralNull_as_weight_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<LiteralNullImpl> element(new LiteralNullImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setWeight(element);
	}
	
	element->setThisLiteralNullPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	element->setThisLiteralRealPtr(element);
	return element;
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_argument_in_Message(std::shared_ptr<Message> par_Message, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Message)
	{
		par_Message->getArgument()->push_back(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_argument_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->getArgument()->push_back(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_changeExpression_in_ChangeEvent(std::shared_ptr<ChangeEvent> par_ChangeEvent, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ChangeEvent)
	{
		par_ChangeEvent->setChangeExpression(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_defaultValue_in_Property(std::shared_ptr<Property> par_Property, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Property)
	{
		par_Property->setDefaultValue(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_defaultValue_in_Parameter(std::shared_ptr<Parameter> par_Parameter, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Parameter)
	{
		par_Parameter->setDefaultValue(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_expr_in_TimeExpression(std::shared_ptr<TimeExpression> par_TimeExpression, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TimeExpression)
	{
		par_TimeExpression->setExpr(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_expr_in_Duration(std::shared_ptr<Duration> par_Duration, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Duration)
	{
		par_Duration->setExpr(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_guard_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setGuard(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_joinSpec_in_JoinNode(std::shared_ptr<JoinNode> par_JoinNode, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_JoinNode)
	{
		par_JoinNode->setJoinSpec(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_lowerValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setLowerValue(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_maxint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMaxint(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_minint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMinint(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_operand_in_Expression(std::shared_ptr<Expression> par_Expression, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Expression)
	{
		par_Expression->getOperand()->push_back(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_returnValue_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->setReturnValue(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_selector_in_Lifeline(std::shared_ptr<Lifeline> par_Lifeline, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Lifeline)
	{
		par_Lifeline->setSelector(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_specification_in_Constraint(std::shared_ptr<Constraint> par_Constraint, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Constraint)
	{
		par_Constraint->setSpecification(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_specification_in_InstanceSpecification(std::shared_ptr<InstanceSpecification> par_InstanceSpecification, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InstanceSpecification)
	{
		par_InstanceSpecification->setSpecification(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_upperBound_in_ObjectNode(std::shared_ptr<ObjectNode> par_ObjectNode, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ObjectNode)
	{
		par_ObjectNode->setUpperBound(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_upperValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setUpperValue(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_value_in_Slot(std::weak_ptr<uml::Slot> par_Slot, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl(par_Slot));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Slot.lock())
	{
		wp->getValue()->push_back(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_value_in_ValueSpecificationAction(std::weak_ptr<uml::ValueSpecificationAction> par_ValueSpecificationAction, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl(par_ValueSpecificationAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ValueSpecificationAction.lock())
	{
		wp->setValue(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_value_in_ValuePin(std::shared_ptr<ValuePin> par_ValuePin, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ValuePin)
	{
		par_ValuePin->setValue(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralReal> umlFactoryImpl::createLiteralReal_as_weight_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<LiteralRealImpl> element(new LiteralRealImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setWeight(element);
	}
	
	element->setThisLiteralRealPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	element->setThisLiteralStringPtr(element);
	return element;
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_argument_in_Message(std::shared_ptr<Message> par_Message, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Message)
	{
		par_Message->getArgument()->push_back(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_argument_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->getArgument()->push_back(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_changeExpression_in_ChangeEvent(std::shared_ptr<ChangeEvent> par_ChangeEvent, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ChangeEvent)
	{
		par_ChangeEvent->setChangeExpression(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_defaultValue_in_Property(std::shared_ptr<Property> par_Property, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Property)
	{
		par_Property->setDefaultValue(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_defaultValue_in_Parameter(std::shared_ptr<Parameter> par_Parameter, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Parameter)
	{
		par_Parameter->setDefaultValue(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_expr_in_TimeExpression(std::shared_ptr<TimeExpression> par_TimeExpression, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TimeExpression)
	{
		par_TimeExpression->setExpr(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_expr_in_Duration(std::shared_ptr<Duration> par_Duration, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Duration)
	{
		par_Duration->setExpr(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_guard_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setGuard(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_joinSpec_in_JoinNode(std::shared_ptr<JoinNode> par_JoinNode, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_JoinNode)
	{
		par_JoinNode->setJoinSpec(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_lowerValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setLowerValue(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_maxint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMaxint(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_minint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMinint(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_operand_in_Expression(std::shared_ptr<Expression> par_Expression, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Expression)
	{
		par_Expression->getOperand()->push_back(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_returnValue_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->setReturnValue(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_selector_in_Lifeline(std::shared_ptr<Lifeline> par_Lifeline, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Lifeline)
	{
		par_Lifeline->setSelector(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_specification_in_Constraint(std::shared_ptr<Constraint> par_Constraint, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Constraint)
	{
		par_Constraint->setSpecification(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_specification_in_InstanceSpecification(std::shared_ptr<InstanceSpecification> par_InstanceSpecification, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InstanceSpecification)
	{
		par_InstanceSpecification->setSpecification(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_upperBound_in_ObjectNode(std::shared_ptr<ObjectNode> par_ObjectNode, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ObjectNode)
	{
		par_ObjectNode->setUpperBound(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_upperValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setUpperValue(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_value_in_Slot(std::weak_ptr<uml::Slot> par_Slot, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl(par_Slot));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Slot.lock())
	{
		wp->getValue()->push_back(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_value_in_ValueSpecificationAction(std::weak_ptr<uml::ValueSpecificationAction> par_ValueSpecificationAction, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl(par_ValueSpecificationAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ValueSpecificationAction.lock())
	{
		wp->setValue(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_value_in_ValuePin(std::shared_ptr<ValuePin> par_ValuePin, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ValuePin)
	{
		par_ValuePin->setValue(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralString> umlFactoryImpl::createLiteralString_as_weight_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<LiteralStringImpl> element(new LiteralStringImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setWeight(element);
	}
	
	element->setThisLiteralStringPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_argument_in_Message(std::shared_ptr<Message> par_Message, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Message)
	{
		par_Message->getArgument()->push_back(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_argument_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->getArgument()->push_back(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_changeExpression_in_ChangeEvent(std::shared_ptr<ChangeEvent> par_ChangeEvent, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ChangeEvent)
	{
		par_ChangeEvent->setChangeExpression(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_defaultValue_in_Property(std::shared_ptr<Property> par_Property, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Property)
	{
		par_Property->setDefaultValue(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_defaultValue_in_Parameter(std::shared_ptr<Parameter> par_Parameter, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Parameter)
	{
		par_Parameter->setDefaultValue(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_expr_in_TimeExpression(std::shared_ptr<TimeExpression> par_TimeExpression, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TimeExpression)
	{
		par_TimeExpression->setExpr(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_expr_in_Duration(std::shared_ptr<Duration> par_Duration, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Duration)
	{
		par_Duration->setExpr(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_guard_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setGuard(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_joinSpec_in_JoinNode(std::shared_ptr<JoinNode> par_JoinNode, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_JoinNode)
	{
		par_JoinNode->setJoinSpec(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_lowerValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setLowerValue(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_maxint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMaxint(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_minint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMinint(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_operand_in_Expression(std::shared_ptr<Expression> par_Expression, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Expression)
	{
		par_Expression->getOperand()->push_back(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_returnValue_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->setReturnValue(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_selector_in_Lifeline(std::shared_ptr<Lifeline> par_Lifeline, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Lifeline)
	{
		par_Lifeline->setSelector(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_specification_in_Constraint(std::shared_ptr<Constraint> par_Constraint, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Constraint)
	{
		par_Constraint->setSpecification(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_specification_in_InstanceSpecification(std::shared_ptr<InstanceSpecification> par_InstanceSpecification, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InstanceSpecification)
	{
		par_InstanceSpecification->setSpecification(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_upperBound_in_ObjectNode(std::shared_ptr<ObjectNode> par_ObjectNode, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ObjectNode)
	{
		par_ObjectNode->setUpperBound(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_upperValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setUpperValue(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_value_in_Slot(std::weak_ptr<uml::Slot> par_Slot, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl(par_Slot));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Slot.lock())
	{
		wp->getValue()->push_back(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_value_in_ValueSpecificationAction(std::weak_ptr<uml::ValueSpecificationAction> par_ValueSpecificationAction, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl(par_ValueSpecificationAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ValueSpecificationAction.lock())
	{
		wp->setValue(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_value_in_ValuePin(std::shared_ptr<ValuePin> par_ValuePin, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ValuePin)
	{
		par_ValuePin->setValue(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LiteralUnlimitedNatural> umlFactoryImpl::createLiteralUnlimitedNatural_as_weight_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<LiteralUnlimitedNaturalImpl> element(new LiteralUnlimitedNaturalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setWeight(element);
	}
	
	element->setThisLiteralUnlimitedNaturalPtr(element);
	return element;
	
}
std::shared_ptr<LoopNode> umlFactoryImpl::createLoopNode(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<LoopNodeImpl> element(new LoopNodeImpl());
	element->setMetaElementID(metaElementID);
	element->setThisLoopNodePtr(element);
	return element;
}
std::shared_ptr<LoopNode> umlFactoryImpl::createLoopNode_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<LoopNodeImpl> element(new LoopNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisLoopNodePtr(element);
	return element;
	
}
std::shared_ptr<LoopNode> umlFactoryImpl::createLoopNode_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<LoopNodeImpl> element(new LoopNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisLoopNodePtr(element);
	return element;
	
}
std::shared_ptr<LoopNode> umlFactoryImpl::createLoopNode_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<LoopNodeImpl> element(new LoopNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisLoopNodePtr(element);
	return element;
	
}
std::shared_ptr<LoopNode> umlFactoryImpl::createLoopNode_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<LoopNodeImpl> element(new LoopNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisLoopNodePtr(element);
	return element;
	
}
std::shared_ptr<LoopNode> umlFactoryImpl::createLoopNode_as_group_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<LoopNodeImpl> element(new LoopNodeImpl(par_Activity, uml::umlPackage::ACTIVITYGROUP_ATTRIBUTE_INACTIVITY));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getGroup()->push_back(element);
	}
	
	element->setThisLoopNodePtr(element);
	return element;
	
}
std::shared_ptr<LoopNode> umlFactoryImpl::createLoopNode_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<LoopNodeImpl> element(new LoopNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisLoopNodePtr(element);
	return element;
	
}
std::shared_ptr<LoopNode> umlFactoryImpl::createLoopNode_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<LoopNodeImpl> element(new LoopNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisLoopNodePtr(element);
	return element;
	
}
std::shared_ptr<LoopNode> umlFactoryImpl::createLoopNode_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<LoopNodeImpl> element(new LoopNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisLoopNodePtr(element);
	return element;
	
}
std::shared_ptr<LoopNode> umlFactoryImpl::createLoopNode_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<LoopNodeImpl> element(new LoopNodeImpl(par_Activity, uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_ACTIVITY));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisLoopNodePtr(element);
	return element;
	
}
std::shared_ptr<LoopNode> umlFactoryImpl::createLoopNode_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<LoopNodeImpl> element(new LoopNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisLoopNodePtr(element);
	return element;
	
}
std::shared_ptr<LoopNode> umlFactoryImpl::createLoopNode_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<LoopNodeImpl> element(new LoopNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisLoopNodePtr(element);
	return element;
	
}
std::shared_ptr<LoopNode> umlFactoryImpl::createLoopNode_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<LoopNodeImpl> element(new LoopNodeImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisLoopNodePtr(element);
	return element;
	
}
std::shared_ptr<LoopNode> umlFactoryImpl::createLoopNode_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<LoopNodeImpl> element(new LoopNodeImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisLoopNodePtr(element);
	return element;
	
}
std::shared_ptr<LoopNode> umlFactoryImpl::createLoopNode_as_ownedGroup_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<LoopNodeImpl> element(new LoopNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedGroup()->push_back(element);
	}
	
	element->setThisLoopNodePtr(element);
	return element;
	
}
std::shared_ptr<LoopNode> umlFactoryImpl::createLoopNode_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<LoopNodeImpl> element(new LoopNodeImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisLoopNodePtr(element);
	return element;
	
}
std::shared_ptr<LoopNode> umlFactoryImpl::createLoopNode_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<LoopNodeImpl> element(new LoopNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisLoopNodePtr(element);
	return element;
	
}
std::shared_ptr<LoopNode> umlFactoryImpl::createLoopNode_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<LoopNodeImpl> element(new LoopNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisLoopNodePtr(element);
	return element;
	
}
std::shared_ptr<LoopNode> umlFactoryImpl::createLoopNode_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<LoopNodeImpl> element(new LoopNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisLoopNodePtr(element);
	return element;
	
}
std::shared_ptr<LoopNode> umlFactoryImpl::createLoopNode_as_structuredNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<LoopNodeImpl> element(new LoopNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getStructuredNode()->push_back(element);
	}
	
	element->setThisLoopNodePtr(element);
	return element;
	
}
std::shared_ptr<LoopNode> umlFactoryImpl::createLoopNode_as_subgroup_in_ActivityGroup(std::weak_ptr<uml::ActivityGroup> par_ActivityGroup, const int metaElementID) const
{
	std::shared_ptr<LoopNodeImpl> element(new LoopNodeImpl(par_ActivityGroup));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ActivityGroup.lock())
	{
		wp->getSubgroup()->push_back(element);
	}
	
	element->setThisLoopNodePtr(element);
	return element;
	
}
std::shared_ptr<LoopNode> umlFactoryImpl::createLoopNode_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<LoopNodeImpl> element(new LoopNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisLoopNodePtr(element);
	return element;
	
}
std::shared_ptr<LoopNode> umlFactoryImpl::createLoopNode_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<LoopNodeImpl> element(new LoopNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisLoopNodePtr(element);
	return element;
	
}
std::shared_ptr<Manifestation> umlFactoryImpl::createManifestation(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ManifestationImpl> element(new ManifestationImpl());
	element->setMetaElementID(metaElementID);
	element->setThisManifestationPtr(element);
	return element;
}
std::shared_ptr<Manifestation> umlFactoryImpl::createManifestation_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ManifestationImpl> element(new ManifestationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisManifestationPtr(element);
	return element;
	
}
std::shared_ptr<Manifestation> umlFactoryImpl::createManifestation_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<ManifestationImpl> element(new ManifestationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisManifestationPtr(element);
	return element;
	
}
std::shared_ptr<Manifestation> umlFactoryImpl::createManifestation_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ManifestationImpl> element(new ManifestationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisManifestationPtr(element);
	return element;
	
}
std::shared_ptr<Manifestation> umlFactoryImpl::createManifestation_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ManifestationImpl> element(new ManifestationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisManifestationPtr(element);
	return element;
	
}
std::shared_ptr<Manifestation> umlFactoryImpl::createManifestation_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ManifestationImpl> element(new ManifestationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisManifestationPtr(element);
	return element;
	
}
std::shared_ptr<Manifestation> umlFactoryImpl::createManifestation_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ManifestationImpl> element(new ManifestationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisManifestationPtr(element);
	return element;
	
}
std::shared_ptr<Manifestation> umlFactoryImpl::createManifestation_as_manifestation_in_Artifact(std::shared_ptr<Artifact> par_Artifact, const int metaElementID) const
{
	std::shared_ptr<ManifestationImpl> element(new ManifestationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Artifact)
	{
		par_Artifact->getManifestation()->push_back(element);
	}
	
	element->setThisManifestationPtr(element);
	return element;
	
}
std::shared_ptr<Manifestation> umlFactoryImpl::createManifestation_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<ManifestationImpl> element(new ManifestationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisManifestationPtr(element);
	return element;
	
}
std::shared_ptr<Manifestation> umlFactoryImpl::createManifestation_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ManifestationImpl> element(new ManifestationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisManifestationPtr(element);
	return element;
	
}
std::shared_ptr<Manifestation> umlFactoryImpl::createManifestation_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ManifestationImpl> element(new ManifestationImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisManifestationPtr(element);
	return element;
	
}
std::shared_ptr<Manifestation> umlFactoryImpl::createManifestation_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ManifestationImpl> element(new ManifestationImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisManifestationPtr(element);
	return element;
	
}
std::shared_ptr<Manifestation> umlFactoryImpl::createManifestation_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ManifestationImpl> element(new ManifestationImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisManifestationPtr(element);
	return element;
	
}
std::shared_ptr<Manifestation> umlFactoryImpl::createManifestation_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<ManifestationImpl> element(new ManifestationImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisManifestationPtr(element);
	return element;
	
}
std::shared_ptr<Manifestation> umlFactoryImpl::createManifestation_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<ManifestationImpl> element(new ManifestationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisManifestationPtr(element);
	return element;
	
}
std::shared_ptr<Manifestation> umlFactoryImpl::createManifestation_as_roleBinding_in_CollaborationUse(std::shared_ptr<CollaborationUse> par_CollaborationUse, const int metaElementID) const
{
	std::shared_ptr<ManifestationImpl> element(new ManifestationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_CollaborationUse)
	{
		par_CollaborationUse->getRoleBinding()->push_back(element);
	}
	
	element->setThisManifestationPtr(element);
	return element;
	
}
std::shared_ptr<Manifestation> umlFactoryImpl::createManifestation_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ManifestationImpl> element(new ManifestationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisManifestationPtr(element);
	return element;
	
}
std::shared_ptr<Manifestation> umlFactoryImpl::createManifestation_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ManifestationImpl> element(new ManifestationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisManifestationPtr(element);
	return element;
	
}
std::shared_ptr<Manifestation> umlFactoryImpl::createManifestation_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ManifestationImpl> element(new ManifestationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisManifestationPtr(element);
	return element;
	
}
std::shared_ptr<Manifestation> umlFactoryImpl::createManifestation_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<ManifestationImpl> element(new ManifestationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisManifestationPtr(element);
	return element;
	
}
std::shared_ptr<MergeNode> umlFactoryImpl::createMergeNode(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<MergeNodeImpl> element(new MergeNodeImpl());
	element->setMetaElementID(metaElementID);
	element->setThisMergeNodePtr(element);
	return element;
}
std::shared_ptr<MergeNode> umlFactoryImpl::createMergeNode_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<MergeNodeImpl> element(new MergeNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisMergeNodePtr(element);
	return element;
	
}
std::shared_ptr<MergeNode> umlFactoryImpl::createMergeNode_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<MergeNodeImpl> element(new MergeNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisMergeNodePtr(element);
	return element;
	
}
std::shared_ptr<MergeNode> umlFactoryImpl::createMergeNode_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<MergeNodeImpl> element(new MergeNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisMergeNodePtr(element);
	return element;
	
}
std::shared_ptr<MergeNode> umlFactoryImpl::createMergeNode_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<MergeNodeImpl> element(new MergeNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisMergeNodePtr(element);
	return element;
	
}
std::shared_ptr<MergeNode> umlFactoryImpl::createMergeNode_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<MergeNodeImpl> element(new MergeNodeImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisMergeNodePtr(element);
	return element;
	
}
std::shared_ptr<MergeNode> umlFactoryImpl::createMergeNode_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<MergeNodeImpl> element(new MergeNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisMergeNodePtr(element);
	return element;
	
}
std::shared_ptr<MergeNode> umlFactoryImpl::createMergeNode_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<MergeNodeImpl> element(new MergeNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisMergeNodePtr(element);
	return element;
	
}
std::shared_ptr<MergeNode> umlFactoryImpl::createMergeNode_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<MergeNodeImpl> element(new MergeNodeImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisMergeNodePtr(element);
	return element;
	
}
std::shared_ptr<MergeNode> umlFactoryImpl::createMergeNode_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<MergeNodeImpl> element(new MergeNodeImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisMergeNodePtr(element);
	return element;
	
}
std::shared_ptr<MergeNode> umlFactoryImpl::createMergeNode_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<MergeNodeImpl> element(new MergeNodeImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisMergeNodePtr(element);
	return element;
	
}
std::shared_ptr<MergeNode> umlFactoryImpl::createMergeNode_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<MergeNodeImpl> element(new MergeNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisMergeNodePtr(element);
	return element;
	
}
std::shared_ptr<MergeNode> umlFactoryImpl::createMergeNode_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<MergeNodeImpl> element(new MergeNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisMergeNodePtr(element);
	return element;
	
}
std::shared_ptr<MergeNode> umlFactoryImpl::createMergeNode_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<MergeNodeImpl> element(new MergeNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisMergeNodePtr(element);
	return element;
	
}
std::shared_ptr<MergeNode> umlFactoryImpl::createMergeNode_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<MergeNodeImpl> element(new MergeNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisMergeNodePtr(element);
	return element;
	
}
std::shared_ptr<MergeNode> umlFactoryImpl::createMergeNode_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<MergeNodeImpl> element(new MergeNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisMergeNodePtr(element);
	return element;
	
}
std::shared_ptr<Message> umlFactoryImpl::createMessage(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<MessageImpl> element(new MessageImpl());
	element->setMetaElementID(metaElementID);
	element->setThisMessagePtr(element);
	return element;
}
std::shared_ptr<Message> umlFactoryImpl::createMessage_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<MessageImpl> element(new MessageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisMessagePtr(element);
	return element;
	
}
std::shared_ptr<Message> umlFactoryImpl::createMessage_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<MessageImpl> element(new MessageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisMessagePtr(element);
	return element;
	
}
std::shared_ptr<Message> umlFactoryImpl::createMessage_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<MessageImpl> element(new MessageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisMessagePtr(element);
	return element;
	
}
std::shared_ptr<Message> umlFactoryImpl::createMessage_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<MessageImpl> element(new MessageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisMessagePtr(element);
	return element;
	
}
std::shared_ptr<Message> umlFactoryImpl::createMessage_as_message_in_Interaction(std::weak_ptr<uml::Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<MessageImpl> element(new MessageImpl(par_Interaction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Interaction.lock())
	{
		wp->getMessage()->push_back(element);
	}
	
	element->setThisMessagePtr(element);
	return element;
	
}
std::shared_ptr<Message> umlFactoryImpl::createMessage_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<MessageImpl> element(new MessageImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisMessagePtr(element);
	return element;
	
}
std::shared_ptr<Message> umlFactoryImpl::createMessage_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<MessageImpl> element(new MessageImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisMessagePtr(element);
	return element;
	
}
std::shared_ptr<Message> umlFactoryImpl::createMessage_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<MessageImpl> element(new MessageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisMessagePtr(element);
	return element;
	
}
std::shared_ptr<Message> umlFactoryImpl::createMessage_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<MessageImpl> element(new MessageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisMessagePtr(element);
	return element;
	
}
std::shared_ptr<Message> umlFactoryImpl::createMessage_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<MessageImpl> element(new MessageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisMessagePtr(element);
	return element;
	
}
std::shared_ptr<MessageOccurrenceSpecification> umlFactoryImpl::createMessageOccurrenceSpecification(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<MessageOccurrenceSpecificationImpl> element(new MessageOccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	element->setThisMessageOccurrenceSpecificationPtr(element);
	return element;
}
std::shared_ptr<MessageOccurrenceSpecification> umlFactoryImpl::createMessageOccurrenceSpecification_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<MessageOccurrenceSpecificationImpl> element(new MessageOccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisMessageOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<MessageOccurrenceSpecification> umlFactoryImpl::createMessageOccurrenceSpecification_as_fragment_in_Interaction(std::weak_ptr<uml::Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<MessageOccurrenceSpecificationImpl> element(new MessageOccurrenceSpecificationImpl(par_Interaction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Interaction.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisMessageOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<MessageOccurrenceSpecification> umlFactoryImpl::createMessageOccurrenceSpecification_as_fragment_in_InteractionOperand(std::weak_ptr<uml::InteractionOperand> par_InteractionOperand, const int metaElementID) const
{
	std::shared_ptr<MessageOccurrenceSpecificationImpl> element(new MessageOccurrenceSpecificationImpl(par_InteractionOperand));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_InteractionOperand.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisMessageOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<MessageOccurrenceSpecification> umlFactoryImpl::createMessageOccurrenceSpecification_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<MessageOccurrenceSpecificationImpl> element(new MessageOccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisMessageOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<MessageOccurrenceSpecification> umlFactoryImpl::createMessageOccurrenceSpecification_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<MessageOccurrenceSpecificationImpl> element(new MessageOccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisMessageOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<MessageOccurrenceSpecification> umlFactoryImpl::createMessageOccurrenceSpecification_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<MessageOccurrenceSpecificationImpl> element(new MessageOccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisMessageOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<MessageOccurrenceSpecification> umlFactoryImpl::createMessageOccurrenceSpecification_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<MessageOccurrenceSpecificationImpl> element(new MessageOccurrenceSpecificationImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisMessageOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<MessageOccurrenceSpecification> umlFactoryImpl::createMessageOccurrenceSpecification_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<MessageOccurrenceSpecificationImpl> element(new MessageOccurrenceSpecificationImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisMessageOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<MessageOccurrenceSpecification> umlFactoryImpl::createMessageOccurrenceSpecification_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<MessageOccurrenceSpecificationImpl> element(new MessageOccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisMessageOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<MessageOccurrenceSpecification> umlFactoryImpl::createMessageOccurrenceSpecification_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<MessageOccurrenceSpecificationImpl> element(new MessageOccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisMessageOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<MessageOccurrenceSpecification> umlFactoryImpl::createMessageOccurrenceSpecification_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<MessageOccurrenceSpecificationImpl> element(new MessageOccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisMessageOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<Model> umlFactoryImpl::createModel(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ModelImpl> element(new ModelImpl());
	element->setMetaElementID(metaElementID);
	element->setThisModelPtr(element);
	return element;
}
std::shared_ptr<Model> umlFactoryImpl::createModel_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ModelImpl> element(new ModelImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisModelPtr(element);
	return element;
	
}
std::shared_ptr<Model> umlFactoryImpl::createModel_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<ModelImpl> element(new ModelImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisModelPtr(element);
	return element;
	
}
std::shared_ptr<Model> umlFactoryImpl::createModel_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ModelImpl> element(new ModelImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisModelPtr(element);
	return element;
	
}
std::shared_ptr<Model> umlFactoryImpl::createModel_as_importedPackage_in_PackageImport(std::shared_ptr<PackageImport> par_PackageImport, const int metaElementID) const
{
	std::shared_ptr<ModelImpl> element(new ModelImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_PackageImport)
	{
		par_PackageImport->setImportedPackage(element);
	}
	
	element->setThisModelPtr(element);
	return element;
	
}
std::shared_ptr<Model> umlFactoryImpl::createModel_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ModelImpl> element(new ModelImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisModelPtr(element);
	return element;
	
}
std::shared_ptr<Model> umlFactoryImpl::createModel_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ModelImpl> element(new ModelImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisModelPtr(element);
	return element;
	
}
std::shared_ptr<Model> umlFactoryImpl::createModel_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ModelImpl> element(new ModelImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisModelPtr(element);
	return element;
	
}
std::shared_ptr<Model> umlFactoryImpl::createModel_as_mergedPackage_in_PackageMerge(std::shared_ptr<PackageMerge> par_PackageMerge, const int metaElementID) const
{
	std::shared_ptr<ModelImpl> element(new ModelImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_PackageMerge)
	{
		par_PackageMerge->setMergedPackage(element);
	}
	
	element->setThisModelPtr(element);
	return element;
	
}
std::shared_ptr<Model> umlFactoryImpl::createModel_as_nestedPackage_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<ModelImpl> element(new ModelImpl(par_Package, uml::umlPackage::PACKAGE_ATTRIBUTE_NESTINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getNestedPackage()->push_back(element);
	}
	
	element->setThisModelPtr(element);
	return element;
	
}
std::shared_ptr<Model> umlFactoryImpl::createModel_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<ModelImpl> element(new ModelImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisModelPtr(element);
	return element;
	
}
std::shared_ptr<Model> umlFactoryImpl::createModel_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ModelImpl> element(new ModelImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisModelPtr(element);
	return element;
	
}
std::shared_ptr<Model> umlFactoryImpl::createModel_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ModelImpl> element(new ModelImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisModelPtr(element);
	return element;
	
}
std::shared_ptr<Model> umlFactoryImpl::createModel_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ModelImpl> element(new ModelImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisModelPtr(element);
	return element;
	
}
std::shared_ptr<Model> umlFactoryImpl::createModel_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ModelImpl> element(new ModelImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisModelPtr(element);
	return element;
	
}
std::shared_ptr<Model> umlFactoryImpl::createModel_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<ModelImpl> element(new ModelImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisModelPtr(element);
	return element;
	
}
std::shared_ptr<Model> umlFactoryImpl::createModel_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<ModelImpl> element(new ModelImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisModelPtr(element);
	return element;
	
}
std::shared_ptr<Model> umlFactoryImpl::createModel_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ModelImpl> element(new ModelImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisModelPtr(element);
	return element;
	
}
std::shared_ptr<Model> umlFactoryImpl::createModel_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ModelImpl> element(new ModelImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisModelPtr(element);
	return element;
	
}
std::shared_ptr<Model> umlFactoryImpl::createModel_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ModelImpl> element(new ModelImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisModelPtr(element);
	return element;
	
}
std::shared_ptr<Model> umlFactoryImpl::createModel_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<ModelImpl> element(new ModelImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisModelPtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl());
	element->setMetaElementID(metaElementID);
	element->setThisNodePtr(element);
	return element;
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_classifier_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->setClassifier(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_context_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->setContext(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_contract_in_Substitution(std::shared_ptr<Substitution> par_Substitution, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Substitution)
	{
		par_Substitution->setContract(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_endType_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getEndType()->push_back(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_general_in_Generalization(std::shared_ptr<Generalization> par_Generalization, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Generalization)
	{
		par_Generalization->setGeneral(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_nestedClassifier_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getNestedClassifier()->push_back(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_nestedClassifier_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getNestedClassifier()->push_back(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_nestedNode_in_Node(std::shared_ptr<Node> par_Node, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Node)
	{
		par_Node->getNestedNode()->push_back(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_ownedType_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl(par_Package, uml::umlPackage::TYPE_ATTRIBUTE_PACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getOwnedType()->push_back(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_realizingClassifier_in_ComponentRealization(std::shared_ptr<ComponentRealization> par_ComponentRealization, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ComponentRealization)
	{
		par_ComponentRealization->getRealizingClassifier()->push_back(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_redefinedClassifier_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getRedefinedClassifier()->push_back(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Node> umlFactoryImpl::createNode_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<NodeImpl> element(new NodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisNodePtr(element);
	return element;
	
}
std::shared_ptr<Object> umlFactoryImpl::createObject(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ObjectImpl> element(new ObjectImpl());
	element->setMetaElementID(metaElementID);
	element->setThisObjectPtr(element);
	return element;
}
std::shared_ptr<ObjectFlow> umlFactoryImpl::createObjectFlow(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ObjectFlowImpl> element(new ObjectFlowImpl());
	element->setMetaElementID(metaElementID);
	element->setThisObjectFlowPtr(element);
	return element;
}
std::shared_ptr<ObjectFlow> umlFactoryImpl::createObjectFlow_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ObjectFlowImpl> element(new ObjectFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisObjectFlowPtr(element);
	return element;
	
}
std::shared_ptr<ObjectFlow> umlFactoryImpl::createObjectFlow_as_edge_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ObjectFlowImpl> element(new ObjectFlowImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getEdge()->push_back(element);
	}
	
	element->setThisObjectFlowPtr(element);
	return element;
	
}
std::shared_ptr<ObjectFlow> umlFactoryImpl::createObjectFlow_as_edge_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<ObjectFlowImpl> element(new ObjectFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getEdge()->push_back(element);
	}
	
	element->setThisObjectFlowPtr(element);
	return element;
	
}
std::shared_ptr<ObjectFlow> umlFactoryImpl::createObjectFlow_as_edge_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<ObjectFlowImpl> element(new ObjectFlowImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getEdge()->push_back(element);
	}
	
	element->setThisObjectFlowPtr(element);
	return element;
	
}
std::shared_ptr<ObjectFlow> umlFactoryImpl::createObjectFlow_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ObjectFlowImpl> element(new ObjectFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisObjectFlowPtr(element);
	return element;
	
}
std::shared_ptr<ObjectFlow> umlFactoryImpl::createObjectFlow_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ObjectFlowImpl> element(new ObjectFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisObjectFlowPtr(element);
	return element;
	
}
std::shared_ptr<ObjectFlow> umlFactoryImpl::createObjectFlow_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ObjectFlowImpl> element(new ObjectFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisObjectFlowPtr(element);
	return element;
	
}
std::shared_ptr<ObjectFlow> umlFactoryImpl::createObjectFlow_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ObjectFlowImpl> element(new ObjectFlowImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisObjectFlowPtr(element);
	return element;
	
}
std::shared_ptr<ObjectFlow> umlFactoryImpl::createObjectFlow_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ObjectFlowImpl> element(new ObjectFlowImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisObjectFlowPtr(element);
	return element;
	
}
std::shared_ptr<ObjectFlow> umlFactoryImpl::createObjectFlow_as_redefinedEdge_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<ObjectFlowImpl> element(new ObjectFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->getRedefinedEdge()->push_back(element);
	}
	
	element->setThisObjectFlowPtr(element);
	return element;
	
}
std::shared_ptr<ObjectFlow> umlFactoryImpl::createObjectFlow_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ObjectFlowImpl> element(new ObjectFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisObjectFlowPtr(element);
	return element;
	
}
std::shared_ptr<ObjectFlow> umlFactoryImpl::createObjectFlow_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ObjectFlowImpl> element(new ObjectFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisObjectFlowPtr(element);
	return element;
	
}
std::shared_ptr<ObjectFlow> umlFactoryImpl::createObjectFlow_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ObjectFlowImpl> element(new ObjectFlowImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisObjectFlowPtr(element);
	return element;
	
}
std::shared_ptr<OccurrenceSpecification> umlFactoryImpl::createOccurrenceSpecification(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<OccurrenceSpecificationImpl> element(new OccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	element->setThisOccurrenceSpecificationPtr(element);
	return element;
}
std::shared_ptr<OccurrenceSpecification> umlFactoryImpl::createOccurrenceSpecification_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<OccurrenceSpecificationImpl> element(new OccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<OccurrenceSpecification> umlFactoryImpl::createOccurrenceSpecification_as_fragment_in_Interaction(std::weak_ptr<uml::Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<OccurrenceSpecificationImpl> element(new OccurrenceSpecificationImpl(par_Interaction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Interaction.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<OccurrenceSpecification> umlFactoryImpl::createOccurrenceSpecification_as_fragment_in_InteractionOperand(std::weak_ptr<uml::InteractionOperand> par_InteractionOperand, const int metaElementID) const
{
	std::shared_ptr<OccurrenceSpecificationImpl> element(new OccurrenceSpecificationImpl(par_InteractionOperand));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_InteractionOperand.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<OccurrenceSpecification> umlFactoryImpl::createOccurrenceSpecification_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<OccurrenceSpecificationImpl> element(new OccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<OccurrenceSpecification> umlFactoryImpl::createOccurrenceSpecification_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<OccurrenceSpecificationImpl> element(new OccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<OccurrenceSpecification> umlFactoryImpl::createOccurrenceSpecification_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<OccurrenceSpecificationImpl> element(new OccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<OccurrenceSpecification> umlFactoryImpl::createOccurrenceSpecification_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<OccurrenceSpecificationImpl> element(new OccurrenceSpecificationImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<OccurrenceSpecification> umlFactoryImpl::createOccurrenceSpecification_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<OccurrenceSpecificationImpl> element(new OccurrenceSpecificationImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<OccurrenceSpecification> umlFactoryImpl::createOccurrenceSpecification_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<OccurrenceSpecificationImpl> element(new OccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<OccurrenceSpecification> umlFactoryImpl::createOccurrenceSpecification_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<OccurrenceSpecificationImpl> element(new OccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<OccurrenceSpecification> umlFactoryImpl::createOccurrenceSpecification_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<OccurrenceSpecificationImpl> element(new OccurrenceSpecificationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisOccurrenceSpecificationPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueAction> umlFactoryImpl::createOpaqueAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<OpaqueActionImpl> element(new OpaqueActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisOpaqueActionPtr(element);
	return element;
}
std::shared_ptr<OpaqueAction> umlFactoryImpl::createOpaqueAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<OpaqueActionImpl> element(new OpaqueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisOpaqueActionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueAction> umlFactoryImpl::createOpaqueAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<OpaqueActionImpl> element(new OpaqueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisOpaqueActionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueAction> umlFactoryImpl::createOpaqueAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<OpaqueActionImpl> element(new OpaqueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisOpaqueActionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueAction> umlFactoryImpl::createOpaqueAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<OpaqueActionImpl> element(new OpaqueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisOpaqueActionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueAction> umlFactoryImpl::createOpaqueAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<OpaqueActionImpl> element(new OpaqueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisOpaqueActionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueAction> umlFactoryImpl::createOpaqueAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<OpaqueActionImpl> element(new OpaqueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisOpaqueActionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueAction> umlFactoryImpl::createOpaqueAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<OpaqueActionImpl> element(new OpaqueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisOpaqueActionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueAction> umlFactoryImpl::createOpaqueAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<OpaqueActionImpl> element(new OpaqueActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisOpaqueActionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueAction> umlFactoryImpl::createOpaqueAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<OpaqueActionImpl> element(new OpaqueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisOpaqueActionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueAction> umlFactoryImpl::createOpaqueAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<OpaqueActionImpl> element(new OpaqueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisOpaqueActionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueAction> umlFactoryImpl::createOpaqueAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<OpaqueActionImpl> element(new OpaqueActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisOpaqueActionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueAction> umlFactoryImpl::createOpaqueAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<OpaqueActionImpl> element(new OpaqueActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisOpaqueActionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueAction> umlFactoryImpl::createOpaqueAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<OpaqueActionImpl> element(new OpaqueActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisOpaqueActionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueAction> umlFactoryImpl::createOpaqueAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<OpaqueActionImpl> element(new OpaqueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisOpaqueActionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueAction> umlFactoryImpl::createOpaqueAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<OpaqueActionImpl> element(new OpaqueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisOpaqueActionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueAction> umlFactoryImpl::createOpaqueAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<OpaqueActionImpl> element(new OpaqueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisOpaqueActionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueAction> umlFactoryImpl::createOpaqueAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<OpaqueActionImpl> element(new OpaqueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisOpaqueActionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueAction> umlFactoryImpl::createOpaqueAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<OpaqueActionImpl> element(new OpaqueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisOpaqueActionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	element->setThisOpaqueBehaviorPtr(element);
	return element;
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_classifier_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->setClassifier(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_classifierBehavior_in_BehavioredClassifier(std::shared_ptr<BehavioredClassifier> par_BehavioredClassifier, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_BehavioredClassifier)
	{
		par_BehavioredClassifier->setClassifierBehavior(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_context_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->setContext(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_contract_in_Substitution(std::shared_ptr<Substitution> par_Substitution, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Substitution)
	{
		par_Substitution->setContract(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_doActivity_in_State(std::shared_ptr<State> par_State, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_State)
	{
		par_State->setDoActivity(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_effect_in_Transition(std::shared_ptr<Transition> par_Transition, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Transition)
	{
		par_Transition->setEffect(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_endType_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getEndType()->push_back(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_entry_in_State(std::shared_ptr<State> par_State, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_State)
	{
		par_State->setEntry(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_exit_in_State(std::shared_ptr<State> par_State, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_State)
	{
		par_State->setExit(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_general_in_Generalization(std::shared_ptr<Generalization> par_Generalization, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Generalization)
	{
		par_Generalization->setGeneral(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_nestedClassifier_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getNestedClassifier()->push_back(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_nestedClassifier_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getNestedClassifier()->push_back(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_ownedBehavior_in_BehavioredClassifier(std::weak_ptr<uml::BehavioredClassifier> par_BehavioredClassifier, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl(par_BehavioredClassifier));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_BehavioredClassifier.lock())
	{
		wp->getOwnedBehavior()->push_back(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_ownedType_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl(par_Package, uml::umlPackage::TYPE_ATTRIBUTE_PACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getOwnedType()->push_back(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_realizingClassifier_in_ComponentRealization(std::shared_ptr<ComponentRealization> par_ComponentRealization, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ComponentRealization)
	{
		par_ComponentRealization->getRealizingClassifier()->push_back(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_redefinedBehavior_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->getRedefinedBehavior()->push_back(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_redefinedClassifier_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getRedefinedClassifier()->push_back(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueBehavior> umlFactoryImpl::createOpaqueBehavior_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<OpaqueBehaviorImpl> element(new OpaqueBehaviorImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisOpaqueBehaviorPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisOpaqueExpressionPtr(element);
	return element;
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_argument_in_Message(std::shared_ptr<Message> par_Message, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Message)
	{
		par_Message->getArgument()->push_back(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_argument_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->getArgument()->push_back(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_changeExpression_in_ChangeEvent(std::shared_ptr<ChangeEvent> par_ChangeEvent, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ChangeEvent)
	{
		par_ChangeEvent->setChangeExpression(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_defaultValue_in_Property(std::shared_ptr<Property> par_Property, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Property)
	{
		par_Property->setDefaultValue(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_defaultValue_in_Parameter(std::shared_ptr<Parameter> par_Parameter, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Parameter)
	{
		par_Parameter->setDefaultValue(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_expr_in_TimeExpression(std::shared_ptr<TimeExpression> par_TimeExpression, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TimeExpression)
	{
		par_TimeExpression->setExpr(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_expr_in_Duration(std::shared_ptr<Duration> par_Duration, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Duration)
	{
		par_Duration->setExpr(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_guard_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setGuard(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_joinSpec_in_JoinNode(std::shared_ptr<JoinNode> par_JoinNode, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_JoinNode)
	{
		par_JoinNode->setJoinSpec(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_lowerValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setLowerValue(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_mapping_in_Abstraction(std::shared_ptr<Abstraction> par_Abstraction, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Abstraction)
	{
		par_Abstraction->setMapping(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_maxint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMaxint(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_minint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMinint(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_operand_in_Expression(std::shared_ptr<Expression> par_Expression, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Expression)
	{
		par_Expression->getOperand()->push_back(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_returnValue_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->setReturnValue(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_selector_in_Lifeline(std::shared_ptr<Lifeline> par_Lifeline, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Lifeline)
	{
		par_Lifeline->setSelector(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_specification_in_Constraint(std::shared_ptr<Constraint> par_Constraint, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Constraint)
	{
		par_Constraint->setSpecification(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_specification_in_InstanceSpecification(std::shared_ptr<InstanceSpecification> par_InstanceSpecification, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InstanceSpecification)
	{
		par_InstanceSpecification->setSpecification(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_upperBound_in_ObjectNode(std::shared_ptr<ObjectNode> par_ObjectNode, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ObjectNode)
	{
		par_ObjectNode->setUpperBound(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_upperValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setUpperValue(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_value_in_Slot(std::weak_ptr<uml::Slot> par_Slot, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl(par_Slot));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Slot.lock())
	{
		wp->getValue()->push_back(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_value_in_ValueSpecificationAction(std::weak_ptr<uml::ValueSpecificationAction> par_ValueSpecificationAction, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl(par_ValueSpecificationAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ValueSpecificationAction.lock())
	{
		wp->setValue(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_value_in_ValuePin(std::shared_ptr<ValuePin> par_ValuePin, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ValuePin)
	{
		par_ValuePin->setValue(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<OpaqueExpression> umlFactoryImpl::createOpaqueExpression_as_weight_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<OpaqueExpressionImpl> element(new OpaqueExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setWeight(element);
	}
	
	element->setThisOpaqueExpressionPtr(element);
	return element;
	
}
std::shared_ptr<Operation> umlFactoryImpl::createOperation(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<OperationImpl> element(new OperationImpl());
	element->setMetaElementID(metaElementID);
	element->setThisOperationPtr(element);
	return element;
}
std::shared_ptr<Operation> umlFactoryImpl::createOperation_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<OperationImpl> element(new OperationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisOperationPtr(element);
	return element;
	
}
std::shared_ptr<Operation> umlFactoryImpl::createOperation_as_feature_in_Classifier(std::shared_ptr<uml::Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<OperationImpl> element(new OperationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getFeature()->push_back(element);
	}
	
	element->setThisOperationPtr(element);
	return element;
	
}
std::shared_ptr<Operation> umlFactoryImpl::createOperation_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<OperationImpl> element(new OperationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisOperationPtr(element);
	return element;
	
}
std::shared_ptr<Operation> umlFactoryImpl::createOperation_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<OperationImpl> element(new OperationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisOperationPtr(element);
	return element;
	
}
std::shared_ptr<Operation> umlFactoryImpl::createOperation_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<OperationImpl> element(new OperationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisOperationPtr(element);
	return element;
	
}
std::shared_ptr<Operation> umlFactoryImpl::createOperation_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<OperationImpl> element(new OperationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisOperationPtr(element);
	return element;
	
}
std::shared_ptr<Operation> umlFactoryImpl::createOperation_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<OperationImpl> element(new OperationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisOperationPtr(element);
	return element;
	
}
std::shared_ptr<Operation> umlFactoryImpl::createOperation_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<OperationImpl> element(new OperationImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisOperationPtr(element);
	return element;
	
}
std::shared_ptr<Operation> umlFactoryImpl::createOperation_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<OperationImpl> element(new OperationImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisOperationPtr(element);
	return element;
	
}
std::shared_ptr<Operation> umlFactoryImpl::createOperation_as_ownedOperation_in_Class(std::weak_ptr<uml::Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<OperationImpl> element(new OperationImpl(par_Class));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Class.lock())
	{
		wp->getOwnedOperation()->push_back(element);
	}
	
	element->setThisOperationPtr(element);
	return element;
	
}
std::shared_ptr<Operation> umlFactoryImpl::createOperation_as_ownedOperation_in_Artifact(std::shared_ptr<Artifact> par_Artifact, const int metaElementID) const
{
	std::shared_ptr<OperationImpl> element(new OperationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Artifact)
	{
		par_Artifact->getOwnedOperation()->push_back(element);
	}
	
	element->setThisOperationPtr(element);
	return element;
	
}
std::shared_ptr<Operation> umlFactoryImpl::createOperation_as_ownedOperation_in_DataType(std::weak_ptr<uml::DataType> par_DataType, const int metaElementID) const
{
	std::shared_ptr<OperationImpl> element(new OperationImpl(par_DataType));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_DataType.lock())
	{
		wp->getOwnedOperation()->push_back(element);
	}
	
	element->setThisOperationPtr(element);
	return element;
	
}
std::shared_ptr<Operation> umlFactoryImpl::createOperation_as_ownedOperation_in_Interface(std::weak_ptr<uml::Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<OperationImpl> element(new OperationImpl(par_Interface));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Interface.lock())
	{
		wp->getOwnedOperation()->push_back(element);
	}
	
	element->setThisOperationPtr(element);
	return element;
	
}
std::shared_ptr<Operation> umlFactoryImpl::createOperation_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<OperationImpl> element(new OperationImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisOperationPtr(element);
	return element;
	
}
std::shared_ptr<Operation> umlFactoryImpl::createOperation_as_redefinedOperation_in_Operation(std::shared_ptr<Operation> par_Operation, const int metaElementID) const
{
	std::shared_ptr<OperationImpl> element(new OperationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Operation)
	{
		par_Operation->getRedefinedOperation()->push_back(element);
	}
	
	element->setThisOperationPtr(element);
	return element;
	
}
std::shared_ptr<Operation> umlFactoryImpl::createOperation_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<OperationImpl> element(new OperationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisOperationPtr(element);
	return element;
	
}
std::shared_ptr<Operation> umlFactoryImpl::createOperation_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<OperationImpl> element(new OperationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisOperationPtr(element);
	return element;
	
}
std::shared_ptr<Operation> umlFactoryImpl::createOperation_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<OperationImpl> element(new OperationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisOperationPtr(element);
	return element;
	
}
std::shared_ptr<OperationTemplateParameter> umlFactoryImpl::createOperationTemplateParameter(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<OperationTemplateParameterImpl> element(new OperationTemplateParameterImpl());
	element->setMetaElementID(metaElementID);
	element->setThisOperationTemplateParameterPtr(element);
	return element;
}
std::shared_ptr<OperationTemplateParameter> umlFactoryImpl::createOperationTemplateParameter_as_inheritedParameter_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<OperationTemplateParameterImpl> element(new OperationTemplateParameterImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->getInheritedParameter()->push_back(element);
	}
	
	element->setThisOperationTemplateParameterPtr(element);
	return element;
	
}
std::shared_ptr<OperationTemplateParameter> umlFactoryImpl::createOperationTemplateParameter_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<OperationTemplateParameterImpl> element(new OperationTemplateParameterImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisOperationTemplateParameterPtr(element);
	return element;
	
}
std::shared_ptr<OperationTemplateParameter> umlFactoryImpl::createOperationTemplateParameter_as_ownedParameter_in_TemplateSignature(std::weak_ptr<uml::TemplateSignature> par_TemplateSignature, const int metaElementID) const
{
	std::shared_ptr<OperationTemplateParameterImpl> element(new OperationTemplateParameterImpl(par_TemplateSignature));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateSignature.lock())
	{
		wp->getOwnedParameter()->push_back(element);
	}
	
	element->setThisOperationTemplateParameterPtr(element);
	return element;
	
}
std::shared_ptr<OperationTemplateParameter> umlFactoryImpl::createOperationTemplateParameter_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<OperationTemplateParameterImpl> element(new OperationTemplateParameterImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisOperationTemplateParameterPtr(element);
	return element;
	
}
std::shared_ptr<OperationTemplateParameter> umlFactoryImpl::createOperationTemplateParameter_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<OperationTemplateParameterImpl> element(new OperationTemplateParameterImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisOperationTemplateParameterPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	element->setThisOutputPinPtr(element);
	return element;
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_loopVariable_in_LoopNode(std::shared_ptr<LoopNode> par_LoopNode, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_LoopNode)
	{
		par_LoopNode->getLoopVariable()->push_back(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_output_in_Action(std::weak_ptr<uml::Action> par_Action, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl(par_Action));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Action.lock())
	{
		wp->getOutput()->push_back(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_outputValue_in_OpaqueAction(std::shared_ptr<OpaqueAction> par_OpaqueAction, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_OpaqueAction)
	{
		par_OpaqueAction->getOutputValue()->push_back(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_result_in_ValueSpecificationAction(std::weak_ptr<uml::ValueSpecificationAction> par_ValueSpecificationAction, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl(par_ValueSpecificationAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ValueSpecificationAction.lock())
	{
		wp->setResult(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_result_in_WriteStructuralFeatureAction(std::weak_ptr<uml::WriteStructuralFeatureAction> par_WriteStructuralFeatureAction, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl(par_WriteStructuralFeatureAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_WriteStructuralFeatureAction.lock())
	{
		wp->setResult(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_result_in_AcceptEventAction(std::shared_ptr<AcceptEventAction> par_AcceptEventAction, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_AcceptEventAction)
	{
		par_AcceptEventAction->getResult()->push_back(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_result_in_CallAction(std::weak_ptr<uml::CallAction> par_CallAction, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl(par_CallAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_CallAction.lock())
	{
		wp->getResult()->push_back(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_result_in_ClearStructuralFeatureAction(std::weak_ptr<uml::ClearStructuralFeatureAction> par_ClearStructuralFeatureAction, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl(par_ClearStructuralFeatureAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ClearStructuralFeatureAction.lock())
	{
		wp->setResult(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_result_in_ConditionalNode(std::shared_ptr<ConditionalNode> par_ConditionalNode, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ConditionalNode)
	{
		par_ConditionalNode->getResult()->push_back(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_result_in_CreateLinkObjectAction(std::shared_ptr<CreateLinkObjectAction> par_CreateLinkObjectAction, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_CreateLinkObjectAction)
	{
		par_CreateLinkObjectAction->setResult(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_result_in_CreateObjectAction(std::weak_ptr<uml::CreateObjectAction> par_CreateObjectAction, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl(par_CreateObjectAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_CreateObjectAction.lock())
	{
		wp->setResult(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_result_in_LoopNode(std::shared_ptr<LoopNode> par_LoopNode, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_LoopNode)
	{
		par_LoopNode->getResult()->push_back(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_result_in_ReadExtentAction(std::shared_ptr<ReadExtentAction> par_ReadExtentAction, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReadExtentAction)
	{
		par_ReadExtentAction->setResult(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_result_in_ReadIsClassifiedObjectAction(std::shared_ptr<ReadIsClassifiedObjectAction> par_ReadIsClassifiedObjectAction, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReadIsClassifiedObjectAction)
	{
		par_ReadIsClassifiedObjectAction->setResult(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_result_in_ReadLinkAction(std::shared_ptr<ReadLinkAction> par_ReadLinkAction, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReadLinkAction)
	{
		par_ReadLinkAction->setResult(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_result_in_ReadLinkObjectEndAction(std::shared_ptr<ReadLinkObjectEndAction> par_ReadLinkObjectEndAction, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReadLinkObjectEndAction)
	{
		par_ReadLinkObjectEndAction->setResult(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_result_in_ReadLinkObjectEndQualifierAction(std::shared_ptr<ReadLinkObjectEndQualifierAction> par_ReadLinkObjectEndQualifierAction, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReadLinkObjectEndQualifierAction)
	{
		par_ReadLinkObjectEndQualifierAction->setResult(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_result_in_ReadSelfAction(std::weak_ptr<uml::ReadSelfAction> par_ReadSelfAction, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl(par_ReadSelfAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ReadSelfAction.lock())
	{
		wp->setResult(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_result_in_ReadStructuralFeatureAction(std::weak_ptr<uml::ReadStructuralFeatureAction> par_ReadStructuralFeatureAction, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl(par_ReadStructuralFeatureAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ReadStructuralFeatureAction.lock())
	{
		wp->setResult(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_result_in_ReadVariableAction(std::shared_ptr<ReadVariableAction> par_ReadVariableAction, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReadVariableAction)
	{
		par_ReadVariableAction->setResult(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_result_in_ReduceAction(std::shared_ptr<ReduceAction> par_ReduceAction, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReduceAction)
	{
		par_ReduceAction->setResult(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_result_in_TestIdentityAction(std::shared_ptr<TestIdentityAction> par_TestIdentityAction, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TestIdentityAction)
	{
		par_TestIdentityAction->setResult(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_result_in_UnmarshallAction(std::shared_ptr<UnmarshallAction> par_UnmarshallAction, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_UnmarshallAction)
	{
		par_UnmarshallAction->getResult()->push_back(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_returnInformation_in_AcceptCallAction(std::shared_ptr<AcceptCallAction> par_AcceptCallAction, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_AcceptCallAction)
	{
		par_AcceptCallAction->setReturnInformation(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_structuredNodeOutput_in_StructuredActivityNode(std::shared_ptr<StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_StructuredActivityNode)
	{
		par_StructuredActivityNode->getStructuredNodeOutput()->push_back(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<OutputPin> umlFactoryImpl::createOutputPin_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<OutputPinImpl> element(new OutputPinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisOutputPinPtr(element);
	return element;
	
}
std::shared_ptr<Package> umlFactoryImpl::createPackage(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<PackageImpl> element(new PackageImpl());
	element->setMetaElementID(metaElementID);
	element->setThisPackagePtr(element);
	return element;
}
std::shared_ptr<Package> umlFactoryImpl::createPackage_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<PackageImpl> element(new PackageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisPackagePtr(element);
	return element;
	
}
std::shared_ptr<Package> umlFactoryImpl::createPackage_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<PackageImpl> element(new PackageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisPackagePtr(element);
	return element;
	
}
std::shared_ptr<Package> umlFactoryImpl::createPackage_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<PackageImpl> element(new PackageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisPackagePtr(element);
	return element;
	
}
std::shared_ptr<Package> umlFactoryImpl::createPackage_as_importedPackage_in_PackageImport(std::shared_ptr<PackageImport> par_PackageImport, const int metaElementID) const
{
	std::shared_ptr<PackageImpl> element(new PackageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_PackageImport)
	{
		par_PackageImport->setImportedPackage(element);
	}
	
	element->setThisPackagePtr(element);
	return element;
	
}
std::shared_ptr<Package> umlFactoryImpl::createPackage_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<PackageImpl> element(new PackageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisPackagePtr(element);
	return element;
	
}
std::shared_ptr<Package> umlFactoryImpl::createPackage_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<PackageImpl> element(new PackageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisPackagePtr(element);
	return element;
	
}
std::shared_ptr<Package> umlFactoryImpl::createPackage_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<PackageImpl> element(new PackageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisPackagePtr(element);
	return element;
	
}
std::shared_ptr<Package> umlFactoryImpl::createPackage_as_mergedPackage_in_PackageMerge(std::shared_ptr<PackageMerge> par_PackageMerge, const int metaElementID) const
{
	std::shared_ptr<PackageImpl> element(new PackageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_PackageMerge)
	{
		par_PackageMerge->setMergedPackage(element);
	}
	
	element->setThisPackagePtr(element);
	return element;
	
}
std::shared_ptr<Package> umlFactoryImpl::createPackage_as_nestedPackage_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<PackageImpl> element(new PackageImpl(par_Package, uml::umlPackage::PACKAGE_ATTRIBUTE_NESTINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getNestedPackage()->push_back(element);
	}
	
	element->setThisPackagePtr(element);
	return element;
	
}
std::shared_ptr<Package> umlFactoryImpl::createPackage_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<PackageImpl> element(new PackageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisPackagePtr(element);
	return element;
	
}
std::shared_ptr<Package> umlFactoryImpl::createPackage_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<PackageImpl> element(new PackageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisPackagePtr(element);
	return element;
	
}
std::shared_ptr<Package> umlFactoryImpl::createPackage_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<PackageImpl> element(new PackageImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisPackagePtr(element);
	return element;
	
}
std::shared_ptr<Package> umlFactoryImpl::createPackage_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<PackageImpl> element(new PackageImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisPackagePtr(element);
	return element;
	
}
std::shared_ptr<Package> umlFactoryImpl::createPackage_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<PackageImpl> element(new PackageImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisPackagePtr(element);
	return element;
	
}
std::shared_ptr<Package> umlFactoryImpl::createPackage_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<PackageImpl> element(new PackageImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisPackagePtr(element);
	return element;
	
}
std::shared_ptr<Package> umlFactoryImpl::createPackage_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<PackageImpl> element(new PackageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisPackagePtr(element);
	return element;
	
}
std::shared_ptr<Package> umlFactoryImpl::createPackage_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<PackageImpl> element(new PackageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisPackagePtr(element);
	return element;
	
}
std::shared_ptr<Package> umlFactoryImpl::createPackage_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<PackageImpl> element(new PackageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisPackagePtr(element);
	return element;
	
}
std::shared_ptr<Package> umlFactoryImpl::createPackage_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<PackageImpl> element(new PackageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisPackagePtr(element);
	return element;
	
}
std::shared_ptr<Package> umlFactoryImpl::createPackage_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<PackageImpl> element(new PackageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisPackagePtr(element);
	return element;
	
}
std::shared_ptr<PackageImport> umlFactoryImpl::createPackageImport(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<PackageImportImpl> element(new PackageImportImpl());
	element->setMetaElementID(metaElementID);
	element->setThisPackageImportPtr(element);
	return element;
}
std::shared_ptr<PackageImport> umlFactoryImpl::createPackageImport_as_metamodelReference_in_Profile(std::shared_ptr<Profile> par_Profile, const int metaElementID) const
{
	std::shared_ptr<PackageImportImpl> element(new PackageImportImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Profile)
	{
		par_Profile->getMetamodelReference()->push_back(element);
	}
	
	element->setThisPackageImportPtr(element);
	return element;
	
}
std::shared_ptr<PackageImport> umlFactoryImpl::createPackageImport_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<PackageImportImpl> element(new PackageImportImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisPackageImportPtr(element);
	return element;
	
}
std::shared_ptr<PackageImport> umlFactoryImpl::createPackageImport_as_packageImport_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<PackageImportImpl> element(new PackageImportImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getPackageImport()->push_back(element);
	}
	
	element->setThisPackageImportPtr(element);
	return element;
	
}
std::shared_ptr<PackageImport> umlFactoryImpl::createPackageImport_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<PackageImportImpl> element(new PackageImportImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisPackageImportPtr(element);
	return element;
	
}
std::shared_ptr<PackageImport> umlFactoryImpl::createPackageImport_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<PackageImportImpl> element(new PackageImportImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisPackageImportPtr(element);
	return element;
	
}
std::shared_ptr<PackageMerge> umlFactoryImpl::createPackageMerge(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<PackageMergeImpl> element(new PackageMergeImpl());
	element->setMetaElementID(metaElementID);
	element->setThisPackageMergePtr(element);
	return element;
}
std::shared_ptr<PackageMerge> umlFactoryImpl::createPackageMerge_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<PackageMergeImpl> element(new PackageMergeImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisPackageMergePtr(element);
	return element;
	
}
std::shared_ptr<PackageMerge> umlFactoryImpl::createPackageMerge_as_packageMerge_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<PackageMergeImpl> element(new PackageMergeImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackageMerge()->push_back(element);
	}
	
	element->setThisPackageMergePtr(element);
	return element;
	
}
std::shared_ptr<PackageMerge> umlFactoryImpl::createPackageMerge_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<PackageMergeImpl> element(new PackageMergeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisPackageMergePtr(element);
	return element;
	
}
std::shared_ptr<PackageMerge> umlFactoryImpl::createPackageMerge_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<PackageMergeImpl> element(new PackageMergeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisPackageMergePtr(element);
	return element;
	
}
std::shared_ptr<Parameter> umlFactoryImpl::createParameter(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ParameterImpl> element(new ParameterImpl());
	element->setMetaElementID(metaElementID);
	element->setThisParameterPtr(element);
	return element;
}
std::shared_ptr<Parameter> umlFactoryImpl::createParameter_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ParameterImpl> element(new ParameterImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisParameterPtr(element);
	return element;
	
}
std::shared_ptr<Parameter> umlFactoryImpl::createParameter_as_collaborationRole_in_Collaboration(std::shared_ptr<Collaboration> par_Collaboration, const int metaElementID) const
{
	std::shared_ptr<ParameterImpl> element(new ParameterImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Collaboration)
	{
		par_Collaboration->getCollaborationRole()->push_back(element);
	}
	
	element->setThisParameterPtr(element);
	return element;
	
}
std::shared_ptr<Parameter> umlFactoryImpl::createParameter_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ParameterImpl> element(new ParameterImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisParameterPtr(element);
	return element;
	
}
std::shared_ptr<Parameter> umlFactoryImpl::createParameter_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ParameterImpl> element(new ParameterImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisParameterPtr(element);
	return element;
	
}
std::shared_ptr<Parameter> umlFactoryImpl::createParameter_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ParameterImpl> element(new ParameterImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisParameterPtr(element);
	return element;
	
}
std::shared_ptr<Parameter> umlFactoryImpl::createParameter_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<ParameterImpl> element(new ParameterImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisParameterPtr(element);
	return element;
	
}
std::shared_ptr<Parameter> umlFactoryImpl::createParameter_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ParameterImpl> element(new ParameterImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisParameterPtr(element);
	return element;
	
}
std::shared_ptr<Parameter> umlFactoryImpl::createParameter_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ParameterImpl> element(new ParameterImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisParameterPtr(element);
	return element;
	
}
std::shared_ptr<Parameter> umlFactoryImpl::createParameter_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ParameterImpl> element(new ParameterImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisParameterPtr(element);
	return element;
	
}
std::shared_ptr<Parameter> umlFactoryImpl::createParameter_as_ownedParameter_in_Behavior(std::weak_ptr<uml::Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<ParameterImpl> element(new ParameterImpl(par_Behavior));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Behavior.lock())
	{
		wp->getOwnedParameter()->push_back(element);
	}
	
	element->setThisParameterPtr(element);
	return element;
	
}
std::shared_ptr<Parameter> umlFactoryImpl::createParameter_as_ownedParameter_in_Operation(std::weak_ptr<uml::Operation> par_Operation, const int metaElementID) const
{
	std::shared_ptr<ParameterImpl> element(new ParameterImpl(par_Operation));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Operation.lock())
	{
		wp->getOwnedParameter()->push_back(element);
	}
	
	element->setThisParameterPtr(element);
	return element;
	
}
std::shared_ptr<Parameter> umlFactoryImpl::createParameter_as_ownedParameter_in_BehavioralFeature(std::shared_ptr<BehavioralFeature> par_BehavioralFeature, const int metaElementID) const
{
	std::shared_ptr<ParameterImpl> element(new ParameterImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_BehavioralFeature)
	{
		par_BehavioralFeature->getOwnedParameter()->push_back(element);
	}
	
	element->setThisParameterPtr(element);
	return element;
	
}
std::shared_ptr<Parameter> umlFactoryImpl::createParameter_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ParameterImpl> element(new ParameterImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisParameterPtr(element);
	return element;
	
}
std::shared_ptr<Parameter> umlFactoryImpl::createParameter_as_role_in_StructuredClassifier(std::shared_ptr<StructuredClassifier> par_StructuredClassifier, const int metaElementID) const
{
	std::shared_ptr<ParameterImpl> element(new ParameterImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_StructuredClassifier)
	{
		par_StructuredClassifier->getRole()->push_back(element);
	}
	
	element->setThisParameterPtr(element);
	return element;
	
}
std::shared_ptr<Parameter> umlFactoryImpl::createParameter_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ParameterImpl> element(new ParameterImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisParameterPtr(element);
	return element;
	
}
std::shared_ptr<Parameter> umlFactoryImpl::createParameter_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ParameterImpl> element(new ParameterImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisParameterPtr(element);
	return element;
	
}
std::shared_ptr<Parameter> umlFactoryImpl::createParameter_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ParameterImpl> element(new ParameterImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisParameterPtr(element);
	return element;
	
}
std::shared_ptr<ParameterSet> umlFactoryImpl::createParameterSet(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ParameterSetImpl> element(new ParameterSetImpl());
	element->setMetaElementID(metaElementID);
	element->setThisParameterSetPtr(element);
	return element;
}
std::shared_ptr<ParameterSet> umlFactoryImpl::createParameterSet_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ParameterSetImpl> element(new ParameterSetImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisParameterSetPtr(element);
	return element;
	
}
std::shared_ptr<ParameterSet> umlFactoryImpl::createParameterSet_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ParameterSetImpl> element(new ParameterSetImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisParameterSetPtr(element);
	return element;
	
}
std::shared_ptr<ParameterSet> umlFactoryImpl::createParameterSet_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ParameterSetImpl> element(new ParameterSetImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisParameterSetPtr(element);
	return element;
	
}
std::shared_ptr<ParameterSet> umlFactoryImpl::createParameterSet_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ParameterSetImpl> element(new ParameterSetImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisParameterSetPtr(element);
	return element;
	
}
std::shared_ptr<ParameterSet> umlFactoryImpl::createParameterSet_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ParameterSetImpl> element(new ParameterSetImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisParameterSetPtr(element);
	return element;
	
}
std::shared_ptr<ParameterSet> umlFactoryImpl::createParameterSet_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ParameterSetImpl> element(new ParameterSetImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisParameterSetPtr(element);
	return element;
	
}
std::shared_ptr<ParameterSet> umlFactoryImpl::createParameterSet_as_ownedParameterSet_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<ParameterSetImpl> element(new ParameterSetImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->getOwnedParameterSet()->push_back(element);
	}
	
	element->setThisParameterSetPtr(element);
	return element;
	
}
std::shared_ptr<ParameterSet> umlFactoryImpl::createParameterSet_as_ownedParameterSet_in_BehavioralFeature(std::shared_ptr<BehavioralFeature> par_BehavioralFeature, const int metaElementID) const
{
	std::shared_ptr<ParameterSetImpl> element(new ParameterSetImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_BehavioralFeature)
	{
		par_BehavioralFeature->getOwnedParameterSet()->push_back(element);
	}
	
	element->setThisParameterSetPtr(element);
	return element;
	
}
std::shared_ptr<ParameterSet> umlFactoryImpl::createParameterSet_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ParameterSetImpl> element(new ParameterSetImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisParameterSetPtr(element);
	return element;
	
}
std::shared_ptr<ParameterSet> umlFactoryImpl::createParameterSet_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ParameterSetImpl> element(new ParameterSetImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisParameterSetPtr(element);
	return element;
	
}
std::shared_ptr<ParameterSet> umlFactoryImpl::createParameterSet_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ParameterSetImpl> element(new ParameterSetImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisParameterSetPtr(element);
	return element;
	
}
std::shared_ptr<PartDecomposition> umlFactoryImpl::createPartDecomposition(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<PartDecompositionImpl> element(new PartDecompositionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisPartDecompositionPtr(element);
	return element;
}
std::shared_ptr<PartDecomposition> umlFactoryImpl::createPartDecomposition_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<PartDecompositionImpl> element(new PartDecompositionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisPartDecompositionPtr(element);
	return element;
	
}
std::shared_ptr<PartDecomposition> umlFactoryImpl::createPartDecomposition_as_fragment_in_Interaction(std::weak_ptr<uml::Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<PartDecompositionImpl> element(new PartDecompositionImpl(par_Interaction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Interaction.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisPartDecompositionPtr(element);
	return element;
	
}
std::shared_ptr<PartDecomposition> umlFactoryImpl::createPartDecomposition_as_fragment_in_InteractionOperand(std::weak_ptr<uml::InteractionOperand> par_InteractionOperand, const int metaElementID) const
{
	std::shared_ptr<PartDecompositionImpl> element(new PartDecompositionImpl(par_InteractionOperand));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_InteractionOperand.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisPartDecompositionPtr(element);
	return element;
	
}
std::shared_ptr<PartDecomposition> umlFactoryImpl::createPartDecomposition_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<PartDecompositionImpl> element(new PartDecompositionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisPartDecompositionPtr(element);
	return element;
	
}
std::shared_ptr<PartDecomposition> umlFactoryImpl::createPartDecomposition_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<PartDecompositionImpl> element(new PartDecompositionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisPartDecompositionPtr(element);
	return element;
	
}
std::shared_ptr<PartDecomposition> umlFactoryImpl::createPartDecomposition_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<PartDecompositionImpl> element(new PartDecompositionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisPartDecompositionPtr(element);
	return element;
	
}
std::shared_ptr<PartDecomposition> umlFactoryImpl::createPartDecomposition_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<PartDecompositionImpl> element(new PartDecompositionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisPartDecompositionPtr(element);
	return element;
	
}
std::shared_ptr<PartDecomposition> umlFactoryImpl::createPartDecomposition_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<PartDecompositionImpl> element(new PartDecompositionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisPartDecompositionPtr(element);
	return element;
	
}
std::shared_ptr<PartDecomposition> umlFactoryImpl::createPartDecomposition_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<PartDecompositionImpl> element(new PartDecompositionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisPartDecompositionPtr(element);
	return element;
	
}
std::shared_ptr<PartDecomposition> umlFactoryImpl::createPartDecomposition_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<PartDecompositionImpl> element(new PartDecompositionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisPartDecompositionPtr(element);
	return element;
	
}
std::shared_ptr<PartDecomposition> umlFactoryImpl::createPartDecomposition_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<PartDecompositionImpl> element(new PartDecompositionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisPartDecompositionPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<PortImpl> element(new PortImpl());
	element->setMetaElementID(metaElementID);
	element->setThisPortPtr(element);
	return element;
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_attribute_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getAttribute()->push_back(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_collaborationRole_in_Collaboration(std::shared_ptr<Collaboration> par_Collaboration, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Collaboration)
	{
		par_Collaboration->getCollaborationRole()->push_back(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_feature_in_Classifier(std::shared_ptr<uml::Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getFeature()->push_back(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_memberEnd_in_Association(std::shared_ptr<uml::Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getMemberEnd()->push_back(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_navigableOwnedEnd_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getNavigableOwnedEnd()->push_back(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_ownedAttribute_in_Class(std::weak_ptr<uml::Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl(par_Class));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Class.lock())
	{
		wp->getOwnedAttribute()->push_back(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_ownedAttribute_in_Artifact(std::shared_ptr<Artifact> par_Artifact, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Artifact)
	{
		par_Artifact->getOwnedAttribute()->push_back(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_ownedAttribute_in_DataType(std::weak_ptr<uml::DataType> par_DataType, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl(par_DataType));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_DataType.lock())
	{
		wp->getOwnedAttribute()->push_back(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_ownedAttribute_in_Interface(std::weak_ptr<uml::Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl(par_Interface));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Interface.lock())
	{
		wp->getOwnedAttribute()->push_back(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_ownedAttribute_in_Signal(std::shared_ptr<Signal> par_Signal, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Signal)
	{
		par_Signal->getOwnedAttribute()->push_back(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_ownedAttribute_in_StructuredClassifier(std::shared_ptr<StructuredClassifier> par_StructuredClassifier, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_StructuredClassifier)
	{
		par_StructuredClassifier->getOwnedAttribute()->push_back(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_ownedEnd_in_Association(std::weak_ptr<uml::Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl(par_Association));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Association.lock())
	{
		wp->getOwnedEnd()->push_back(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_ownedPort_in_EncapsulatedClassifier(std::shared_ptr<EncapsulatedClassifier> par_EncapsulatedClassifier, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_EncapsulatedClassifier)
	{
		par_EncapsulatedClassifier->getOwnedPort()->push_back(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_qualifier_in_Property(std::weak_ptr<uml::Property> par_Property, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl(par_Property));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Property.lock())
	{
		wp->getQualifier()->push_back(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_redefinedPort_in_Port(std::shared_ptr<Port> par_Port, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Port)
	{
		par_Port->getRedefinedPort()->push_back(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_redefinedProperty_in_Property(std::shared_ptr<Property> par_Property, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Property)
	{
		par_Property->getRedefinedProperty()->push_back(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_role_in_StructuredClassifier(std::shared_ptr<StructuredClassifier> par_StructuredClassifier, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_StructuredClassifier)
	{
		par_StructuredClassifier->getRole()->push_back(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<Port> umlFactoryImpl::createPort_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<PortImpl> element(new PortImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisPortPtr(element);
	return element;
	
}
std::shared_ptr<PrimitiveType> umlFactoryImpl::createPrimitiveType(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<PrimitiveTypeImpl> element(new PrimitiveTypeImpl());
	element->setMetaElementID(metaElementID);
	element->setThisPrimitiveTypePtr(element);
	return element;
}
std::shared_ptr<PrimitiveType> umlFactoryImpl::createPrimitiveType_as_classifier_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<PrimitiveTypeImpl> element(new PrimitiveTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->setClassifier(element);
	}
	
	element->setThisPrimitiveTypePtr(element);
	return element;
	
}
std::shared_ptr<PrimitiveType> umlFactoryImpl::createPrimitiveType_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<PrimitiveTypeImpl> element(new PrimitiveTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisPrimitiveTypePtr(element);
	return element;
	
}
std::shared_ptr<PrimitiveType> umlFactoryImpl::createPrimitiveType_as_contract_in_Substitution(std::shared_ptr<Substitution> par_Substitution, const int metaElementID) const
{
	std::shared_ptr<PrimitiveTypeImpl> element(new PrimitiveTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Substitution)
	{
		par_Substitution->setContract(element);
	}
	
	element->setThisPrimitiveTypePtr(element);
	return element;
	
}
std::shared_ptr<PrimitiveType> umlFactoryImpl::createPrimitiveType_as_endType_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<PrimitiveTypeImpl> element(new PrimitiveTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getEndType()->push_back(element);
	}
	
	element->setThisPrimitiveTypePtr(element);
	return element;
	
}
std::shared_ptr<PrimitiveType> umlFactoryImpl::createPrimitiveType_as_general_in_Generalization(std::shared_ptr<Generalization> par_Generalization, const int metaElementID) const
{
	std::shared_ptr<PrimitiveTypeImpl> element(new PrimitiveTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Generalization)
	{
		par_Generalization->setGeneral(element);
	}
	
	element->setThisPrimitiveTypePtr(element);
	return element;
	
}
std::shared_ptr<PrimitiveType> umlFactoryImpl::createPrimitiveType_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<PrimitiveTypeImpl> element(new PrimitiveTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisPrimitiveTypePtr(element);
	return element;
	
}
std::shared_ptr<PrimitiveType> umlFactoryImpl::createPrimitiveType_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<PrimitiveTypeImpl> element(new PrimitiveTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisPrimitiveTypePtr(element);
	return element;
	
}
std::shared_ptr<PrimitiveType> umlFactoryImpl::createPrimitiveType_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<PrimitiveTypeImpl> element(new PrimitiveTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisPrimitiveTypePtr(element);
	return element;
	
}
std::shared_ptr<PrimitiveType> umlFactoryImpl::createPrimitiveType_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<PrimitiveTypeImpl> element(new PrimitiveTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisPrimitiveTypePtr(element);
	return element;
	
}
std::shared_ptr<PrimitiveType> umlFactoryImpl::createPrimitiveType_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<PrimitiveTypeImpl> element(new PrimitiveTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisPrimitiveTypePtr(element);
	return element;
	
}
std::shared_ptr<PrimitiveType> umlFactoryImpl::createPrimitiveType_as_nestedClassifier_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<PrimitiveTypeImpl> element(new PrimitiveTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getNestedClassifier()->push_back(element);
	}
	
	element->setThisPrimitiveTypePtr(element);
	return element;
	
}
std::shared_ptr<PrimitiveType> umlFactoryImpl::createPrimitiveType_as_nestedClassifier_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<PrimitiveTypeImpl> element(new PrimitiveTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getNestedClassifier()->push_back(element);
	}
	
	element->setThisPrimitiveTypePtr(element);
	return element;
	
}
std::shared_ptr<PrimitiveType> umlFactoryImpl::createPrimitiveType_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<PrimitiveTypeImpl> element(new PrimitiveTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisPrimitiveTypePtr(element);
	return element;
	
}
std::shared_ptr<PrimitiveType> umlFactoryImpl::createPrimitiveType_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<PrimitiveTypeImpl> element(new PrimitiveTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisPrimitiveTypePtr(element);
	return element;
	
}
std::shared_ptr<PrimitiveType> umlFactoryImpl::createPrimitiveType_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<PrimitiveTypeImpl> element(new PrimitiveTypeImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisPrimitiveTypePtr(element);
	return element;
	
}
std::shared_ptr<PrimitiveType> umlFactoryImpl::createPrimitiveType_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<PrimitiveTypeImpl> element(new PrimitiveTypeImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisPrimitiveTypePtr(element);
	return element;
	
}
std::shared_ptr<PrimitiveType> umlFactoryImpl::createPrimitiveType_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<PrimitiveTypeImpl> element(new PrimitiveTypeImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisPrimitiveTypePtr(element);
	return element;
	
}
std::shared_ptr<PrimitiveType> umlFactoryImpl::createPrimitiveType_as_ownedType_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<PrimitiveTypeImpl> element(new PrimitiveTypeImpl(par_Package, uml::umlPackage::TYPE_ATTRIBUTE_PACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getOwnedType()->push_back(element);
	}
	
	element->setThisPrimitiveTypePtr(element);
	return element;
	
}
std::shared_ptr<PrimitiveType> umlFactoryImpl::createPrimitiveType_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<PrimitiveTypeImpl> element(new PrimitiveTypeImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisPrimitiveTypePtr(element);
	return element;
	
}
std::shared_ptr<PrimitiveType> umlFactoryImpl::createPrimitiveType_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<PrimitiveTypeImpl> element(new PrimitiveTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisPrimitiveTypePtr(element);
	return element;
	
}
std::shared_ptr<PrimitiveType> umlFactoryImpl::createPrimitiveType_as_realizingClassifier_in_ComponentRealization(std::shared_ptr<ComponentRealization> par_ComponentRealization, const int metaElementID) const
{
	std::shared_ptr<PrimitiveTypeImpl> element(new PrimitiveTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ComponentRealization)
	{
		par_ComponentRealization->getRealizingClassifier()->push_back(element);
	}
	
	element->setThisPrimitiveTypePtr(element);
	return element;
	
}
std::shared_ptr<PrimitiveType> umlFactoryImpl::createPrimitiveType_as_redefinedClassifier_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<PrimitiveTypeImpl> element(new PrimitiveTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getRedefinedClassifier()->push_back(element);
	}
	
	element->setThisPrimitiveTypePtr(element);
	return element;
	
}
std::shared_ptr<PrimitiveType> umlFactoryImpl::createPrimitiveType_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<PrimitiveTypeImpl> element(new PrimitiveTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisPrimitiveTypePtr(element);
	return element;
	
}
std::shared_ptr<PrimitiveType> umlFactoryImpl::createPrimitiveType_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<PrimitiveTypeImpl> element(new PrimitiveTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisPrimitiveTypePtr(element);
	return element;
	
}
std::shared_ptr<PrimitiveType> umlFactoryImpl::createPrimitiveType_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<PrimitiveTypeImpl> element(new PrimitiveTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisPrimitiveTypePtr(element);
	return element;
	
}
std::shared_ptr<PrimitiveType> umlFactoryImpl::createPrimitiveType_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<PrimitiveTypeImpl> element(new PrimitiveTypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisPrimitiveTypePtr(element);
	return element;
	
}
std::shared_ptr<Profile> umlFactoryImpl::createProfile(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ProfileImpl> element(new ProfileImpl());
	element->setMetaElementID(metaElementID);
	element->setThisProfilePtr(element);
	return element;
}
std::shared_ptr<Profile> umlFactoryImpl::createProfile_as_appliedProfile_in_ProfileApplication(std::shared_ptr<ProfileApplication> par_ProfileApplication, const int metaElementID) const
{
	std::shared_ptr<ProfileImpl> element(new ProfileImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ProfileApplication)
	{
		par_ProfileApplication->setAppliedProfile(element);
	}
	
	element->setThisProfilePtr(element);
	return element;
	
}
std::shared_ptr<Profile> umlFactoryImpl::createProfile_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ProfileImpl> element(new ProfileImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisProfilePtr(element);
	return element;
	
}
std::shared_ptr<Profile> umlFactoryImpl::createProfile_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<ProfileImpl> element(new ProfileImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisProfilePtr(element);
	return element;
	
}
std::shared_ptr<Profile> umlFactoryImpl::createProfile_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ProfileImpl> element(new ProfileImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisProfilePtr(element);
	return element;
	
}
std::shared_ptr<Profile> umlFactoryImpl::createProfile_as_importedPackage_in_PackageImport(std::shared_ptr<PackageImport> par_PackageImport, const int metaElementID) const
{
	std::shared_ptr<ProfileImpl> element(new ProfileImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_PackageImport)
	{
		par_PackageImport->setImportedPackage(element);
	}
	
	element->setThisProfilePtr(element);
	return element;
	
}
std::shared_ptr<Profile> umlFactoryImpl::createProfile_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ProfileImpl> element(new ProfileImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisProfilePtr(element);
	return element;
	
}
std::shared_ptr<Profile> umlFactoryImpl::createProfile_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ProfileImpl> element(new ProfileImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisProfilePtr(element);
	return element;
	
}
std::shared_ptr<Profile> umlFactoryImpl::createProfile_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ProfileImpl> element(new ProfileImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisProfilePtr(element);
	return element;
	
}
std::shared_ptr<Profile> umlFactoryImpl::createProfile_as_mergedPackage_in_PackageMerge(std::shared_ptr<PackageMerge> par_PackageMerge, const int metaElementID) const
{
	std::shared_ptr<ProfileImpl> element(new ProfileImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_PackageMerge)
	{
		par_PackageMerge->setMergedPackage(element);
	}
	
	element->setThisProfilePtr(element);
	return element;
	
}
std::shared_ptr<Profile> umlFactoryImpl::createProfile_as_nestedPackage_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<ProfileImpl> element(new ProfileImpl(par_Package, uml::umlPackage::PACKAGE_ATTRIBUTE_NESTINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getNestedPackage()->push_back(element);
	}
	
	element->setThisProfilePtr(element);
	return element;
	
}
std::shared_ptr<Profile> umlFactoryImpl::createProfile_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<ProfileImpl> element(new ProfileImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisProfilePtr(element);
	return element;
	
}
std::shared_ptr<Profile> umlFactoryImpl::createProfile_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ProfileImpl> element(new ProfileImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisProfilePtr(element);
	return element;
	
}
std::shared_ptr<Profile> umlFactoryImpl::createProfile_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ProfileImpl> element(new ProfileImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisProfilePtr(element);
	return element;
	
}
std::shared_ptr<Profile> umlFactoryImpl::createProfile_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ProfileImpl> element(new ProfileImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisProfilePtr(element);
	return element;
	
}
std::shared_ptr<Profile> umlFactoryImpl::createProfile_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ProfileImpl> element(new ProfileImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisProfilePtr(element);
	return element;
	
}
std::shared_ptr<Profile> umlFactoryImpl::createProfile_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<ProfileImpl> element(new ProfileImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisProfilePtr(element);
	return element;
	
}
std::shared_ptr<Profile> umlFactoryImpl::createProfile_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<ProfileImpl> element(new ProfileImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisProfilePtr(element);
	return element;
	
}
std::shared_ptr<Profile> umlFactoryImpl::createProfile_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ProfileImpl> element(new ProfileImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisProfilePtr(element);
	return element;
	
}
std::shared_ptr<Profile> umlFactoryImpl::createProfile_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ProfileImpl> element(new ProfileImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisProfilePtr(element);
	return element;
	
}
std::shared_ptr<Profile> umlFactoryImpl::createProfile_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ProfileImpl> element(new ProfileImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisProfilePtr(element);
	return element;
	
}
std::shared_ptr<Profile> umlFactoryImpl::createProfile_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<ProfileImpl> element(new ProfileImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisProfilePtr(element);
	return element;
	
}
std::shared_ptr<ProfileApplication> umlFactoryImpl::createProfileApplication(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ProfileApplicationImpl> element(new ProfileApplicationImpl());
	element->setMetaElementID(metaElementID);
	element->setThisProfileApplicationPtr(element);
	return element;
}
std::shared_ptr<ProfileApplication> umlFactoryImpl::createProfileApplication_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ProfileApplicationImpl> element(new ProfileApplicationImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisProfileApplicationPtr(element);
	return element;
	
}
std::shared_ptr<ProfileApplication> umlFactoryImpl::createProfileApplication_as_profileApplication_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<ProfileApplicationImpl> element(new ProfileApplicationImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getProfileApplication()->push_back(element);
	}
	
	element->setThisProfileApplicationPtr(element);
	return element;
	
}
std::shared_ptr<ProfileApplication> umlFactoryImpl::createProfileApplication_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ProfileApplicationImpl> element(new ProfileApplicationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisProfileApplicationPtr(element);
	return element;
	
}
std::shared_ptr<ProfileApplication> umlFactoryImpl::createProfileApplication_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ProfileApplicationImpl> element(new ProfileApplicationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisProfileApplicationPtr(element);
	return element;
	
}
std::shared_ptr<Property> umlFactoryImpl::createProperty(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl());
	element->setMetaElementID(metaElementID);
	element->setThisPropertyPtr(element);
	return element;
}
std::shared_ptr<Property> umlFactoryImpl::createProperty_as_attribute_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getAttribute()->push_back(element);
	}
	
	element->setThisPropertyPtr(element);
	return element;
	
}
std::shared_ptr<Property> umlFactoryImpl::createProperty_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisPropertyPtr(element);
	return element;
	
}
std::shared_ptr<Property> umlFactoryImpl::createProperty_as_collaborationRole_in_Collaboration(std::shared_ptr<Collaboration> par_Collaboration, const int metaElementID) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Collaboration)
	{
		par_Collaboration->getCollaborationRole()->push_back(element);
	}
	
	element->setThisPropertyPtr(element);
	return element;
	
}
std::shared_ptr<Property> umlFactoryImpl::createProperty_as_feature_in_Classifier(std::shared_ptr<uml::Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getFeature()->push_back(element);
	}
	
	element->setThisPropertyPtr(element);
	return element;
	
}
std::shared_ptr<Property> umlFactoryImpl::createProperty_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisPropertyPtr(element);
	return element;
	
}
std::shared_ptr<Property> umlFactoryImpl::createProperty_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisPropertyPtr(element);
	return element;
	
}
std::shared_ptr<Property> umlFactoryImpl::createProperty_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisPropertyPtr(element);
	return element;
	
}
std::shared_ptr<Property> umlFactoryImpl::createProperty_as_memberEnd_in_Association(std::shared_ptr<uml::Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getMemberEnd()->push_back(element);
	}
	
	element->setThisPropertyPtr(element);
	return element;
	
}
std::shared_ptr<Property> umlFactoryImpl::createProperty_as_navigableOwnedEnd_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getNavigableOwnedEnd()->push_back(element);
	}
	
	element->setThisPropertyPtr(element);
	return element;
	
}
std::shared_ptr<Property> umlFactoryImpl::createProperty_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisPropertyPtr(element);
	return element;
	
}
std::shared_ptr<Property> umlFactoryImpl::createProperty_as_ownedAttribute_in_Class(std::weak_ptr<uml::Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl(par_Class));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Class.lock())
	{
		wp->getOwnedAttribute()->push_back(element);
	}
	
	element->setThisPropertyPtr(element);
	return element;
	
}
std::shared_ptr<Property> umlFactoryImpl::createProperty_as_ownedAttribute_in_Artifact(std::shared_ptr<Artifact> par_Artifact, const int metaElementID) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Artifact)
	{
		par_Artifact->getOwnedAttribute()->push_back(element);
	}
	
	element->setThisPropertyPtr(element);
	return element;
	
}
std::shared_ptr<Property> umlFactoryImpl::createProperty_as_ownedAttribute_in_DataType(std::weak_ptr<uml::DataType> par_DataType, const int metaElementID) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl(par_DataType));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_DataType.lock())
	{
		wp->getOwnedAttribute()->push_back(element);
	}
	
	element->setThisPropertyPtr(element);
	return element;
	
}
std::shared_ptr<Property> umlFactoryImpl::createProperty_as_ownedAttribute_in_Interface(std::weak_ptr<uml::Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl(par_Interface));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Interface.lock())
	{
		wp->getOwnedAttribute()->push_back(element);
	}
	
	element->setThisPropertyPtr(element);
	return element;
	
}
std::shared_ptr<Property> umlFactoryImpl::createProperty_as_ownedAttribute_in_Signal(std::shared_ptr<Signal> par_Signal, const int metaElementID) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Signal)
	{
		par_Signal->getOwnedAttribute()->push_back(element);
	}
	
	element->setThisPropertyPtr(element);
	return element;
	
}
std::shared_ptr<Property> umlFactoryImpl::createProperty_as_ownedAttribute_in_StructuredClassifier(std::shared_ptr<StructuredClassifier> par_StructuredClassifier, const int metaElementID) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_StructuredClassifier)
	{
		par_StructuredClassifier->getOwnedAttribute()->push_back(element);
	}
	
	element->setThisPropertyPtr(element);
	return element;
	
}
std::shared_ptr<Property> umlFactoryImpl::createProperty_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisPropertyPtr(element);
	return element;
	
}
std::shared_ptr<Property> umlFactoryImpl::createProperty_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisPropertyPtr(element);
	return element;
	
}
std::shared_ptr<Property> umlFactoryImpl::createProperty_as_ownedEnd_in_Association(std::weak_ptr<uml::Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl(par_Association));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Association.lock())
	{
		wp->getOwnedEnd()->push_back(element);
	}
	
	element->setThisPropertyPtr(element);
	return element;
	
}
std::shared_ptr<Property> umlFactoryImpl::createProperty_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisPropertyPtr(element);
	return element;
	
}
std::shared_ptr<Property> umlFactoryImpl::createProperty_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisPropertyPtr(element);
	return element;
	
}
std::shared_ptr<Property> umlFactoryImpl::createProperty_as_qualifier_in_Property(std::weak_ptr<uml::Property> par_Property, const int metaElementID) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl(par_Property));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Property.lock())
	{
		wp->getQualifier()->push_back(element);
	}
	
	element->setThisPropertyPtr(element);
	return element;
	
}
std::shared_ptr<Property> umlFactoryImpl::createProperty_as_redefinedProperty_in_Property(std::shared_ptr<Property> par_Property, const int metaElementID) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Property)
	{
		par_Property->getRedefinedProperty()->push_back(element);
	}
	
	element->setThisPropertyPtr(element);
	return element;
	
}
std::shared_ptr<Property> umlFactoryImpl::createProperty_as_role_in_StructuredClassifier(std::shared_ptr<StructuredClassifier> par_StructuredClassifier, const int metaElementID) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_StructuredClassifier)
	{
		par_StructuredClassifier->getRole()->push_back(element);
	}
	
	element->setThisPropertyPtr(element);
	return element;
	
}
std::shared_ptr<Property> umlFactoryImpl::createProperty_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisPropertyPtr(element);
	return element;
	
}
std::shared_ptr<Property> umlFactoryImpl::createProperty_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisPropertyPtr(element);
	return element;
	
}
std::shared_ptr<Property> umlFactoryImpl::createProperty_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<PropertyImpl> element(new PropertyImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisPropertyPtr(element);
	return element;
	
}
std::shared_ptr<ProtocolConformance> umlFactoryImpl::createProtocolConformance(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ProtocolConformanceImpl> element(new ProtocolConformanceImpl());
	element->setMetaElementID(metaElementID);
	element->setThisProtocolConformancePtr(element);
	return element;
}
std::shared_ptr<ProtocolConformance> umlFactoryImpl::createProtocolConformance_as_conformance_in_ProtocolStateMachine(std::weak_ptr<uml::ProtocolStateMachine> par_ProtocolStateMachine, const int metaElementID) const
{
	std::shared_ptr<ProtocolConformanceImpl> element(new ProtocolConformanceImpl(par_ProtocolStateMachine));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ProtocolStateMachine.lock())
	{
		wp->getConformance()->push_back(element);
	}
	
	element->setThisProtocolConformancePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolConformance> umlFactoryImpl::createProtocolConformance_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ProtocolConformanceImpl> element(new ProtocolConformanceImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisProtocolConformancePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolConformance> umlFactoryImpl::createProtocolConformance_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ProtocolConformanceImpl> element(new ProtocolConformanceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisProtocolConformancePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolConformance> umlFactoryImpl::createProtocolConformance_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ProtocolConformanceImpl> element(new ProtocolConformanceImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisProtocolConformancePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	element->setThisProtocolStateMachinePtr(element);
	return element;
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_classifier_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->setClassifier(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_classifierBehavior_in_BehavioredClassifier(std::shared_ptr<BehavioredClassifier> par_BehavioredClassifier, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_BehavioredClassifier)
	{
		par_BehavioredClassifier->setClassifierBehavior(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_context_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->setContext(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_contract_in_Substitution(std::shared_ptr<Substitution> par_Substitution, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Substitution)
	{
		par_Substitution->setContract(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_doActivity_in_State(std::shared_ptr<State> par_State, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_State)
	{
		par_State->setDoActivity(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_effect_in_Transition(std::shared_ptr<Transition> par_Transition, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Transition)
	{
		par_Transition->setEffect(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_endType_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getEndType()->push_back(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_entry_in_State(std::shared_ptr<State> par_State, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_State)
	{
		par_State->setEntry(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_exit_in_State(std::shared_ptr<State> par_State, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_State)
	{
		par_State->setExit(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_general_in_Generalization(std::shared_ptr<Generalization> par_Generalization, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Generalization)
	{
		par_Generalization->setGeneral(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_generalMachine_in_ProtocolConformance(std::shared_ptr<ProtocolConformance> par_ProtocolConformance, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ProtocolConformance)
	{
		par_ProtocolConformance->setGeneralMachine(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_nestedClassifier_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getNestedClassifier()->push_back(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_nestedClassifier_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getNestedClassifier()->push_back(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_ownedBehavior_in_BehavioredClassifier(std::weak_ptr<uml::BehavioredClassifier> par_BehavioredClassifier, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl(par_BehavioredClassifier));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_BehavioredClassifier.lock())
	{
		wp->getOwnedBehavior()->push_back(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_ownedType_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl(par_Package, uml::umlPackage::TYPE_ATTRIBUTE_PACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getOwnedType()->push_back(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_protocol_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->setProtocol(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_realizingClassifier_in_ComponentRealization(std::shared_ptr<ComponentRealization> par_ComponentRealization, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ComponentRealization)
	{
		par_ComponentRealization->getRealizingClassifier()->push_back(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_redefinedBehavior_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->getRedefinedBehavior()->push_back(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_redefinedClassifier_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getRedefinedClassifier()->push_back(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolStateMachine> umlFactoryImpl::createProtocolStateMachine_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<ProtocolStateMachineImpl> element(new ProtocolStateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisProtocolStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<ProtocolTransition> umlFactoryImpl::createProtocolTransition(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ProtocolTransitionImpl> element(new ProtocolTransitionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisProtocolTransitionPtr(element);
	return element;
}
std::shared_ptr<ProtocolTransition> umlFactoryImpl::createProtocolTransition_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ProtocolTransitionImpl> element(new ProtocolTransitionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisProtocolTransitionPtr(element);
	return element;
	
}
std::shared_ptr<ProtocolTransition> umlFactoryImpl::createProtocolTransition_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ProtocolTransitionImpl> element(new ProtocolTransitionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisProtocolTransitionPtr(element);
	return element;
	
}
std::shared_ptr<ProtocolTransition> umlFactoryImpl::createProtocolTransition_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ProtocolTransitionImpl> element(new ProtocolTransitionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisProtocolTransitionPtr(element);
	return element;
	
}
std::shared_ptr<ProtocolTransition> umlFactoryImpl::createProtocolTransition_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ProtocolTransitionImpl> element(new ProtocolTransitionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisProtocolTransitionPtr(element);
	return element;
	
}
std::shared_ptr<ProtocolTransition> umlFactoryImpl::createProtocolTransition_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ProtocolTransitionImpl> element(new ProtocolTransitionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisProtocolTransitionPtr(element);
	return element;
	
}
std::shared_ptr<ProtocolTransition> umlFactoryImpl::createProtocolTransition_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ProtocolTransitionImpl> element(new ProtocolTransitionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisProtocolTransitionPtr(element);
	return element;
	
}
std::shared_ptr<ProtocolTransition> umlFactoryImpl::createProtocolTransition_as_redefinedTransition_in_Transition(std::shared_ptr<Transition> par_Transition, const int metaElementID) const
{
	std::shared_ptr<ProtocolTransitionImpl> element(new ProtocolTransitionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Transition)
	{
		par_Transition->setRedefinedTransition(element);
	}
	
	element->setThisProtocolTransitionPtr(element);
	return element;
	
}
std::shared_ptr<ProtocolTransition> umlFactoryImpl::createProtocolTransition_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ProtocolTransitionImpl> element(new ProtocolTransitionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisProtocolTransitionPtr(element);
	return element;
	
}
std::shared_ptr<ProtocolTransition> umlFactoryImpl::createProtocolTransition_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ProtocolTransitionImpl> element(new ProtocolTransitionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisProtocolTransitionPtr(element);
	return element;
	
}
std::shared_ptr<ProtocolTransition> umlFactoryImpl::createProtocolTransition_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ProtocolTransitionImpl> element(new ProtocolTransitionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisProtocolTransitionPtr(element);
	return element;
	
}
std::shared_ptr<ProtocolTransition> umlFactoryImpl::createProtocolTransition_as_transition_in_Region(std::weak_ptr<uml::Region> par_Region, const int metaElementID) const
{
	std::shared_ptr<ProtocolTransitionImpl> element(new ProtocolTransitionImpl(par_Region));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Region.lock())
	{
		wp->getTransition()->push_back(element);
	}
	
	element->setThisProtocolTransitionPtr(element);
	return element;
	
}
std::shared_ptr<Pseudostate> umlFactoryImpl::createPseudostate(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<PseudostateImpl> element(new PseudostateImpl());
	element->setMetaElementID(metaElementID);
	element->setThisPseudostatePtr(element);
	return element;
}
std::shared_ptr<Pseudostate> umlFactoryImpl::createPseudostate_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<PseudostateImpl> element(new PseudostateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisPseudostatePtr(element);
	return element;
	
}
std::shared_ptr<Pseudostate> umlFactoryImpl::createPseudostate_as_connectionPoint_in_StateMachine(std::weak_ptr<uml::StateMachine> par_StateMachine, const int metaElementID) const
{
	std::shared_ptr<PseudostateImpl> element(new PseudostateImpl(par_StateMachine));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StateMachine.lock())
	{
		wp->getConnectionPoint()->push_back(element);
	}
	
	element->setThisPseudostatePtr(element);
	return element;
	
}
std::shared_ptr<Pseudostate> umlFactoryImpl::createPseudostate_as_connectionPoint_in_State(std::weak_ptr<uml::State> par_State, const int metaElementID) const
{
	std::shared_ptr<PseudostateImpl> element(new PseudostateImpl(par_State));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_State.lock())
	{
		wp->getConnectionPoint()->push_back(element);
	}
	
	element->setThisPseudostatePtr(element);
	return element;
	
}
std::shared_ptr<Pseudostate> umlFactoryImpl::createPseudostate_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<PseudostateImpl> element(new PseudostateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisPseudostatePtr(element);
	return element;
	
}
std::shared_ptr<Pseudostate> umlFactoryImpl::createPseudostate_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<PseudostateImpl> element(new PseudostateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisPseudostatePtr(element);
	return element;
	
}
std::shared_ptr<Pseudostate> umlFactoryImpl::createPseudostate_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<PseudostateImpl> element(new PseudostateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisPseudostatePtr(element);
	return element;
	
}
std::shared_ptr<Pseudostate> umlFactoryImpl::createPseudostate_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<PseudostateImpl> element(new PseudostateImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisPseudostatePtr(element);
	return element;
	
}
std::shared_ptr<Pseudostate> umlFactoryImpl::createPseudostate_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<PseudostateImpl> element(new PseudostateImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisPseudostatePtr(element);
	return element;
	
}
std::shared_ptr<Pseudostate> umlFactoryImpl::createPseudostate_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<PseudostateImpl> element(new PseudostateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisPseudostatePtr(element);
	return element;
	
}
std::shared_ptr<Pseudostate> umlFactoryImpl::createPseudostate_as_subvertex_in_Region(std::weak_ptr<uml::Region> par_Region, const int metaElementID) const
{
	std::shared_ptr<PseudostateImpl> element(new PseudostateImpl(par_Region));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Region.lock())
	{
		wp->getSubvertex()->push_back(element);
	}
	
	element->setThisPseudostatePtr(element);
	return element;
	
}
std::shared_ptr<Pseudostate> umlFactoryImpl::createPseudostate_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<PseudostateImpl> element(new PseudostateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisPseudostatePtr(element);
	return element;
	
}
std::shared_ptr<Pseudostate> umlFactoryImpl::createPseudostate_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<PseudostateImpl> element(new PseudostateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisPseudostatePtr(element);
	return element;
	
}
std::shared_ptr<QualifierValue> umlFactoryImpl::createQualifierValue(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<QualifierValueImpl> element(new QualifierValueImpl());
	element->setMetaElementID(metaElementID);
	element->setThisQualifierValuePtr(element);
	return element;
}
std::shared_ptr<QualifierValue> umlFactoryImpl::createQualifierValue_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<QualifierValueImpl> element(new QualifierValueImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisQualifierValuePtr(element);
	return element;
	
}
std::shared_ptr<QualifierValue> umlFactoryImpl::createQualifierValue_as_qualifier_in_LinkEndData(std::shared_ptr<LinkEndData> par_LinkEndData, const int metaElementID) const
{
	std::shared_ptr<QualifierValueImpl> element(new QualifierValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_LinkEndData)
	{
		par_LinkEndData->getQualifier()->push_back(element);
	}
	
	element->setThisQualifierValuePtr(element);
	return element;
	
}
std::shared_ptr<QualifierValue> umlFactoryImpl::createQualifierValue_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<QualifierValueImpl> element(new QualifierValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisQualifierValuePtr(element);
	return element;
	
}
std::shared_ptr<QualifierValue> umlFactoryImpl::createQualifierValue_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<QualifierValueImpl> element(new QualifierValueImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisQualifierValuePtr(element);
	return element;
	
}
std::shared_ptr<RaiseExceptionAction> umlFactoryImpl::createRaiseExceptionAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<RaiseExceptionActionImpl> element(new RaiseExceptionActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisRaiseExceptionActionPtr(element);
	return element;
}
std::shared_ptr<RaiseExceptionAction> umlFactoryImpl::createRaiseExceptionAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<RaiseExceptionActionImpl> element(new RaiseExceptionActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisRaiseExceptionActionPtr(element);
	return element;
	
}
std::shared_ptr<RaiseExceptionAction> umlFactoryImpl::createRaiseExceptionAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<RaiseExceptionActionImpl> element(new RaiseExceptionActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisRaiseExceptionActionPtr(element);
	return element;
	
}
std::shared_ptr<RaiseExceptionAction> umlFactoryImpl::createRaiseExceptionAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<RaiseExceptionActionImpl> element(new RaiseExceptionActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisRaiseExceptionActionPtr(element);
	return element;
	
}
std::shared_ptr<RaiseExceptionAction> umlFactoryImpl::createRaiseExceptionAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<RaiseExceptionActionImpl> element(new RaiseExceptionActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisRaiseExceptionActionPtr(element);
	return element;
	
}
std::shared_ptr<RaiseExceptionAction> umlFactoryImpl::createRaiseExceptionAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<RaiseExceptionActionImpl> element(new RaiseExceptionActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisRaiseExceptionActionPtr(element);
	return element;
	
}
std::shared_ptr<RaiseExceptionAction> umlFactoryImpl::createRaiseExceptionAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<RaiseExceptionActionImpl> element(new RaiseExceptionActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisRaiseExceptionActionPtr(element);
	return element;
	
}
std::shared_ptr<RaiseExceptionAction> umlFactoryImpl::createRaiseExceptionAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<RaiseExceptionActionImpl> element(new RaiseExceptionActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisRaiseExceptionActionPtr(element);
	return element;
	
}
std::shared_ptr<RaiseExceptionAction> umlFactoryImpl::createRaiseExceptionAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<RaiseExceptionActionImpl> element(new RaiseExceptionActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisRaiseExceptionActionPtr(element);
	return element;
	
}
std::shared_ptr<RaiseExceptionAction> umlFactoryImpl::createRaiseExceptionAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<RaiseExceptionActionImpl> element(new RaiseExceptionActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisRaiseExceptionActionPtr(element);
	return element;
	
}
std::shared_ptr<RaiseExceptionAction> umlFactoryImpl::createRaiseExceptionAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<RaiseExceptionActionImpl> element(new RaiseExceptionActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisRaiseExceptionActionPtr(element);
	return element;
	
}
std::shared_ptr<RaiseExceptionAction> umlFactoryImpl::createRaiseExceptionAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<RaiseExceptionActionImpl> element(new RaiseExceptionActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisRaiseExceptionActionPtr(element);
	return element;
	
}
std::shared_ptr<RaiseExceptionAction> umlFactoryImpl::createRaiseExceptionAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<RaiseExceptionActionImpl> element(new RaiseExceptionActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisRaiseExceptionActionPtr(element);
	return element;
	
}
std::shared_ptr<RaiseExceptionAction> umlFactoryImpl::createRaiseExceptionAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<RaiseExceptionActionImpl> element(new RaiseExceptionActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisRaiseExceptionActionPtr(element);
	return element;
	
}
std::shared_ptr<RaiseExceptionAction> umlFactoryImpl::createRaiseExceptionAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<RaiseExceptionActionImpl> element(new RaiseExceptionActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisRaiseExceptionActionPtr(element);
	return element;
	
}
std::shared_ptr<RaiseExceptionAction> umlFactoryImpl::createRaiseExceptionAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<RaiseExceptionActionImpl> element(new RaiseExceptionActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisRaiseExceptionActionPtr(element);
	return element;
	
}
std::shared_ptr<RaiseExceptionAction> umlFactoryImpl::createRaiseExceptionAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<RaiseExceptionActionImpl> element(new RaiseExceptionActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisRaiseExceptionActionPtr(element);
	return element;
	
}
std::shared_ptr<RaiseExceptionAction> umlFactoryImpl::createRaiseExceptionAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<RaiseExceptionActionImpl> element(new RaiseExceptionActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisRaiseExceptionActionPtr(element);
	return element;
	
}
std::shared_ptr<RaiseExceptionAction> umlFactoryImpl::createRaiseExceptionAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<RaiseExceptionActionImpl> element(new RaiseExceptionActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisRaiseExceptionActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadExtentAction> umlFactoryImpl::createReadExtentAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ReadExtentActionImpl> element(new ReadExtentActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisReadExtentActionPtr(element);
	return element;
}
std::shared_ptr<ReadExtentAction> umlFactoryImpl::createReadExtentAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<ReadExtentActionImpl> element(new ReadExtentActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisReadExtentActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadExtentAction> umlFactoryImpl::createReadExtentAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ReadExtentActionImpl> element(new ReadExtentActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisReadExtentActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadExtentAction> umlFactoryImpl::createReadExtentAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<ReadExtentActionImpl> element(new ReadExtentActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisReadExtentActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadExtentAction> umlFactoryImpl::createReadExtentAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<ReadExtentActionImpl> element(new ReadExtentActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisReadExtentActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadExtentAction> umlFactoryImpl::createReadExtentAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ReadExtentActionImpl> element(new ReadExtentActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisReadExtentActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadExtentAction> umlFactoryImpl::createReadExtentAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ReadExtentActionImpl> element(new ReadExtentActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisReadExtentActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadExtentAction> umlFactoryImpl::createReadExtentAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ReadExtentActionImpl> element(new ReadExtentActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisReadExtentActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadExtentAction> umlFactoryImpl::createReadExtentAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ReadExtentActionImpl> element(new ReadExtentActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisReadExtentActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadExtentAction> umlFactoryImpl::createReadExtentAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<ReadExtentActionImpl> element(new ReadExtentActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisReadExtentActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadExtentAction> umlFactoryImpl::createReadExtentAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<ReadExtentActionImpl> element(new ReadExtentActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisReadExtentActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadExtentAction> umlFactoryImpl::createReadExtentAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<ReadExtentActionImpl> element(new ReadExtentActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisReadExtentActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadExtentAction> umlFactoryImpl::createReadExtentAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ReadExtentActionImpl> element(new ReadExtentActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisReadExtentActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadExtentAction> umlFactoryImpl::createReadExtentAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ReadExtentActionImpl> element(new ReadExtentActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisReadExtentActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadExtentAction> umlFactoryImpl::createReadExtentAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ReadExtentActionImpl> element(new ReadExtentActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisReadExtentActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadExtentAction> umlFactoryImpl::createReadExtentAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<ReadExtentActionImpl> element(new ReadExtentActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisReadExtentActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadExtentAction> umlFactoryImpl::createReadExtentAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ReadExtentActionImpl> element(new ReadExtentActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisReadExtentActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadExtentAction> umlFactoryImpl::createReadExtentAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ReadExtentActionImpl> element(new ReadExtentActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisReadExtentActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadExtentAction> umlFactoryImpl::createReadExtentAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ReadExtentActionImpl> element(new ReadExtentActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisReadExtentActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadIsClassifiedObjectAction> umlFactoryImpl::createReadIsClassifiedObjectAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ReadIsClassifiedObjectActionImpl> element(new ReadIsClassifiedObjectActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisReadIsClassifiedObjectActionPtr(element);
	return element;
}
std::shared_ptr<ReadIsClassifiedObjectAction> umlFactoryImpl::createReadIsClassifiedObjectAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<ReadIsClassifiedObjectActionImpl> element(new ReadIsClassifiedObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisReadIsClassifiedObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadIsClassifiedObjectAction> umlFactoryImpl::createReadIsClassifiedObjectAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ReadIsClassifiedObjectActionImpl> element(new ReadIsClassifiedObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisReadIsClassifiedObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadIsClassifiedObjectAction> umlFactoryImpl::createReadIsClassifiedObjectAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<ReadIsClassifiedObjectActionImpl> element(new ReadIsClassifiedObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisReadIsClassifiedObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadIsClassifiedObjectAction> umlFactoryImpl::createReadIsClassifiedObjectAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<ReadIsClassifiedObjectActionImpl> element(new ReadIsClassifiedObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisReadIsClassifiedObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadIsClassifiedObjectAction> umlFactoryImpl::createReadIsClassifiedObjectAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ReadIsClassifiedObjectActionImpl> element(new ReadIsClassifiedObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisReadIsClassifiedObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadIsClassifiedObjectAction> umlFactoryImpl::createReadIsClassifiedObjectAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ReadIsClassifiedObjectActionImpl> element(new ReadIsClassifiedObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisReadIsClassifiedObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadIsClassifiedObjectAction> umlFactoryImpl::createReadIsClassifiedObjectAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ReadIsClassifiedObjectActionImpl> element(new ReadIsClassifiedObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisReadIsClassifiedObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadIsClassifiedObjectAction> umlFactoryImpl::createReadIsClassifiedObjectAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ReadIsClassifiedObjectActionImpl> element(new ReadIsClassifiedObjectActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisReadIsClassifiedObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadIsClassifiedObjectAction> umlFactoryImpl::createReadIsClassifiedObjectAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<ReadIsClassifiedObjectActionImpl> element(new ReadIsClassifiedObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisReadIsClassifiedObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadIsClassifiedObjectAction> umlFactoryImpl::createReadIsClassifiedObjectAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<ReadIsClassifiedObjectActionImpl> element(new ReadIsClassifiedObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisReadIsClassifiedObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadIsClassifiedObjectAction> umlFactoryImpl::createReadIsClassifiedObjectAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<ReadIsClassifiedObjectActionImpl> element(new ReadIsClassifiedObjectActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisReadIsClassifiedObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadIsClassifiedObjectAction> umlFactoryImpl::createReadIsClassifiedObjectAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ReadIsClassifiedObjectActionImpl> element(new ReadIsClassifiedObjectActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisReadIsClassifiedObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadIsClassifiedObjectAction> umlFactoryImpl::createReadIsClassifiedObjectAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ReadIsClassifiedObjectActionImpl> element(new ReadIsClassifiedObjectActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisReadIsClassifiedObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadIsClassifiedObjectAction> umlFactoryImpl::createReadIsClassifiedObjectAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ReadIsClassifiedObjectActionImpl> element(new ReadIsClassifiedObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisReadIsClassifiedObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadIsClassifiedObjectAction> umlFactoryImpl::createReadIsClassifiedObjectAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<ReadIsClassifiedObjectActionImpl> element(new ReadIsClassifiedObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisReadIsClassifiedObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadIsClassifiedObjectAction> umlFactoryImpl::createReadIsClassifiedObjectAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ReadIsClassifiedObjectActionImpl> element(new ReadIsClassifiedObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisReadIsClassifiedObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadIsClassifiedObjectAction> umlFactoryImpl::createReadIsClassifiedObjectAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ReadIsClassifiedObjectActionImpl> element(new ReadIsClassifiedObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisReadIsClassifiedObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadIsClassifiedObjectAction> umlFactoryImpl::createReadIsClassifiedObjectAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ReadIsClassifiedObjectActionImpl> element(new ReadIsClassifiedObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisReadIsClassifiedObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkAction> umlFactoryImpl::createReadLinkAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ReadLinkActionImpl> element(new ReadLinkActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisReadLinkActionPtr(element);
	return element;
}
std::shared_ptr<ReadLinkAction> umlFactoryImpl::createReadLinkAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<ReadLinkActionImpl> element(new ReadLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisReadLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkAction> umlFactoryImpl::createReadLinkAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ReadLinkActionImpl> element(new ReadLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisReadLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkAction> umlFactoryImpl::createReadLinkAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<ReadLinkActionImpl> element(new ReadLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisReadLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkAction> umlFactoryImpl::createReadLinkAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<ReadLinkActionImpl> element(new ReadLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisReadLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkAction> umlFactoryImpl::createReadLinkAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ReadLinkActionImpl> element(new ReadLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisReadLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkAction> umlFactoryImpl::createReadLinkAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ReadLinkActionImpl> element(new ReadLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisReadLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkAction> umlFactoryImpl::createReadLinkAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ReadLinkActionImpl> element(new ReadLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisReadLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkAction> umlFactoryImpl::createReadLinkAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ReadLinkActionImpl> element(new ReadLinkActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisReadLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkAction> umlFactoryImpl::createReadLinkAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<ReadLinkActionImpl> element(new ReadLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisReadLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkAction> umlFactoryImpl::createReadLinkAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<ReadLinkActionImpl> element(new ReadLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisReadLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkAction> umlFactoryImpl::createReadLinkAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<ReadLinkActionImpl> element(new ReadLinkActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisReadLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkAction> umlFactoryImpl::createReadLinkAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ReadLinkActionImpl> element(new ReadLinkActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisReadLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkAction> umlFactoryImpl::createReadLinkAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ReadLinkActionImpl> element(new ReadLinkActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisReadLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkAction> umlFactoryImpl::createReadLinkAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ReadLinkActionImpl> element(new ReadLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisReadLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkAction> umlFactoryImpl::createReadLinkAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<ReadLinkActionImpl> element(new ReadLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisReadLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkAction> umlFactoryImpl::createReadLinkAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ReadLinkActionImpl> element(new ReadLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisReadLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkAction> umlFactoryImpl::createReadLinkAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ReadLinkActionImpl> element(new ReadLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisReadLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkAction> umlFactoryImpl::createReadLinkAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ReadLinkActionImpl> element(new ReadLinkActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisReadLinkActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndAction> umlFactoryImpl::createReadLinkObjectEndAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ReadLinkObjectEndActionImpl> element(new ReadLinkObjectEndActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisReadLinkObjectEndActionPtr(element);
	return element;
}
std::shared_ptr<ReadLinkObjectEndAction> umlFactoryImpl::createReadLinkObjectEndAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndActionImpl> element(new ReadLinkObjectEndActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndAction> umlFactoryImpl::createReadLinkObjectEndAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndActionImpl> element(new ReadLinkObjectEndActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndAction> umlFactoryImpl::createReadLinkObjectEndAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndActionImpl> element(new ReadLinkObjectEndActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndAction> umlFactoryImpl::createReadLinkObjectEndAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndActionImpl> element(new ReadLinkObjectEndActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisReadLinkObjectEndActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndAction> umlFactoryImpl::createReadLinkObjectEndAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndActionImpl> element(new ReadLinkObjectEndActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndAction> umlFactoryImpl::createReadLinkObjectEndAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndActionImpl> element(new ReadLinkObjectEndActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndAction> umlFactoryImpl::createReadLinkObjectEndAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndActionImpl> element(new ReadLinkObjectEndActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndAction> umlFactoryImpl::createReadLinkObjectEndAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndActionImpl> element(new ReadLinkObjectEndActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndAction> umlFactoryImpl::createReadLinkObjectEndAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndActionImpl> element(new ReadLinkObjectEndActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndAction> umlFactoryImpl::createReadLinkObjectEndAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndActionImpl> element(new ReadLinkObjectEndActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndAction> umlFactoryImpl::createReadLinkObjectEndAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndActionImpl> element(new ReadLinkObjectEndActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndAction> umlFactoryImpl::createReadLinkObjectEndAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndActionImpl> element(new ReadLinkObjectEndActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndAction> umlFactoryImpl::createReadLinkObjectEndAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndActionImpl> element(new ReadLinkObjectEndActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndAction> umlFactoryImpl::createReadLinkObjectEndAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndActionImpl> element(new ReadLinkObjectEndActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndAction> umlFactoryImpl::createReadLinkObjectEndAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndActionImpl> element(new ReadLinkObjectEndActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndAction> umlFactoryImpl::createReadLinkObjectEndAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndActionImpl> element(new ReadLinkObjectEndActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndAction> umlFactoryImpl::createReadLinkObjectEndAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndActionImpl> element(new ReadLinkObjectEndActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndAction> umlFactoryImpl::createReadLinkObjectEndAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndActionImpl> element(new ReadLinkObjectEndActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndQualifierAction> umlFactoryImpl::createReadLinkObjectEndQualifierAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ReadLinkObjectEndQualifierActionImpl> element(new ReadLinkObjectEndQualifierActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisReadLinkObjectEndQualifierActionPtr(element);
	return element;
}
std::shared_ptr<ReadLinkObjectEndQualifierAction> umlFactoryImpl::createReadLinkObjectEndQualifierAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndQualifierActionImpl> element(new ReadLinkObjectEndQualifierActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndQualifierActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndQualifierAction> umlFactoryImpl::createReadLinkObjectEndQualifierAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndQualifierActionImpl> element(new ReadLinkObjectEndQualifierActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndQualifierActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndQualifierAction> umlFactoryImpl::createReadLinkObjectEndQualifierAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndQualifierActionImpl> element(new ReadLinkObjectEndQualifierActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndQualifierActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndQualifierAction> umlFactoryImpl::createReadLinkObjectEndQualifierAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndQualifierActionImpl> element(new ReadLinkObjectEndQualifierActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisReadLinkObjectEndQualifierActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndQualifierAction> umlFactoryImpl::createReadLinkObjectEndQualifierAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndQualifierActionImpl> element(new ReadLinkObjectEndQualifierActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndQualifierActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndQualifierAction> umlFactoryImpl::createReadLinkObjectEndQualifierAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndQualifierActionImpl> element(new ReadLinkObjectEndQualifierActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndQualifierActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndQualifierAction> umlFactoryImpl::createReadLinkObjectEndQualifierAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndQualifierActionImpl> element(new ReadLinkObjectEndQualifierActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndQualifierActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndQualifierAction> umlFactoryImpl::createReadLinkObjectEndQualifierAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndQualifierActionImpl> element(new ReadLinkObjectEndQualifierActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndQualifierActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndQualifierAction> umlFactoryImpl::createReadLinkObjectEndQualifierAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndQualifierActionImpl> element(new ReadLinkObjectEndQualifierActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndQualifierActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndQualifierAction> umlFactoryImpl::createReadLinkObjectEndQualifierAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndQualifierActionImpl> element(new ReadLinkObjectEndQualifierActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndQualifierActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndQualifierAction> umlFactoryImpl::createReadLinkObjectEndQualifierAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndQualifierActionImpl> element(new ReadLinkObjectEndQualifierActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndQualifierActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndQualifierAction> umlFactoryImpl::createReadLinkObjectEndQualifierAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndQualifierActionImpl> element(new ReadLinkObjectEndQualifierActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndQualifierActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndQualifierAction> umlFactoryImpl::createReadLinkObjectEndQualifierAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndQualifierActionImpl> element(new ReadLinkObjectEndQualifierActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndQualifierActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndQualifierAction> umlFactoryImpl::createReadLinkObjectEndQualifierAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndQualifierActionImpl> element(new ReadLinkObjectEndQualifierActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndQualifierActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndQualifierAction> umlFactoryImpl::createReadLinkObjectEndQualifierAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndQualifierActionImpl> element(new ReadLinkObjectEndQualifierActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndQualifierActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndQualifierAction> umlFactoryImpl::createReadLinkObjectEndQualifierAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndQualifierActionImpl> element(new ReadLinkObjectEndQualifierActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndQualifierActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndQualifierAction> umlFactoryImpl::createReadLinkObjectEndQualifierAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndQualifierActionImpl> element(new ReadLinkObjectEndQualifierActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndQualifierActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadLinkObjectEndQualifierAction> umlFactoryImpl::createReadLinkObjectEndQualifierAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ReadLinkObjectEndQualifierActionImpl> element(new ReadLinkObjectEndQualifierActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisReadLinkObjectEndQualifierActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadSelfAction> umlFactoryImpl::createReadSelfAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ReadSelfActionImpl> element(new ReadSelfActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisReadSelfActionPtr(element);
	return element;
}
std::shared_ptr<ReadSelfAction> umlFactoryImpl::createReadSelfAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<ReadSelfActionImpl> element(new ReadSelfActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisReadSelfActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadSelfAction> umlFactoryImpl::createReadSelfAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ReadSelfActionImpl> element(new ReadSelfActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisReadSelfActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadSelfAction> umlFactoryImpl::createReadSelfAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<ReadSelfActionImpl> element(new ReadSelfActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisReadSelfActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadSelfAction> umlFactoryImpl::createReadSelfAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<ReadSelfActionImpl> element(new ReadSelfActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisReadSelfActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadSelfAction> umlFactoryImpl::createReadSelfAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ReadSelfActionImpl> element(new ReadSelfActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisReadSelfActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadSelfAction> umlFactoryImpl::createReadSelfAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ReadSelfActionImpl> element(new ReadSelfActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisReadSelfActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadSelfAction> umlFactoryImpl::createReadSelfAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ReadSelfActionImpl> element(new ReadSelfActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisReadSelfActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadSelfAction> umlFactoryImpl::createReadSelfAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ReadSelfActionImpl> element(new ReadSelfActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisReadSelfActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadSelfAction> umlFactoryImpl::createReadSelfAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<ReadSelfActionImpl> element(new ReadSelfActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisReadSelfActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadSelfAction> umlFactoryImpl::createReadSelfAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<ReadSelfActionImpl> element(new ReadSelfActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisReadSelfActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadSelfAction> umlFactoryImpl::createReadSelfAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<ReadSelfActionImpl> element(new ReadSelfActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisReadSelfActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadSelfAction> umlFactoryImpl::createReadSelfAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ReadSelfActionImpl> element(new ReadSelfActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisReadSelfActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadSelfAction> umlFactoryImpl::createReadSelfAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ReadSelfActionImpl> element(new ReadSelfActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisReadSelfActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadSelfAction> umlFactoryImpl::createReadSelfAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ReadSelfActionImpl> element(new ReadSelfActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisReadSelfActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadSelfAction> umlFactoryImpl::createReadSelfAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<ReadSelfActionImpl> element(new ReadSelfActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisReadSelfActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadSelfAction> umlFactoryImpl::createReadSelfAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ReadSelfActionImpl> element(new ReadSelfActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisReadSelfActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadSelfAction> umlFactoryImpl::createReadSelfAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ReadSelfActionImpl> element(new ReadSelfActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisReadSelfActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadSelfAction> umlFactoryImpl::createReadSelfAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ReadSelfActionImpl> element(new ReadSelfActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisReadSelfActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadStructuralFeatureAction> umlFactoryImpl::createReadStructuralFeatureAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ReadStructuralFeatureActionImpl> element(new ReadStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisReadStructuralFeatureActionPtr(element);
	return element;
}
std::shared_ptr<ReadStructuralFeatureAction> umlFactoryImpl::createReadStructuralFeatureAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<ReadStructuralFeatureActionImpl> element(new ReadStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisReadStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadStructuralFeatureAction> umlFactoryImpl::createReadStructuralFeatureAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ReadStructuralFeatureActionImpl> element(new ReadStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisReadStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadStructuralFeatureAction> umlFactoryImpl::createReadStructuralFeatureAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<ReadStructuralFeatureActionImpl> element(new ReadStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisReadStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadStructuralFeatureAction> umlFactoryImpl::createReadStructuralFeatureAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<ReadStructuralFeatureActionImpl> element(new ReadStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisReadStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadStructuralFeatureAction> umlFactoryImpl::createReadStructuralFeatureAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ReadStructuralFeatureActionImpl> element(new ReadStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisReadStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadStructuralFeatureAction> umlFactoryImpl::createReadStructuralFeatureAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ReadStructuralFeatureActionImpl> element(new ReadStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisReadStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadStructuralFeatureAction> umlFactoryImpl::createReadStructuralFeatureAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ReadStructuralFeatureActionImpl> element(new ReadStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisReadStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadStructuralFeatureAction> umlFactoryImpl::createReadStructuralFeatureAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ReadStructuralFeatureActionImpl> element(new ReadStructuralFeatureActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisReadStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadStructuralFeatureAction> umlFactoryImpl::createReadStructuralFeatureAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<ReadStructuralFeatureActionImpl> element(new ReadStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisReadStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadStructuralFeatureAction> umlFactoryImpl::createReadStructuralFeatureAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<ReadStructuralFeatureActionImpl> element(new ReadStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisReadStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadStructuralFeatureAction> umlFactoryImpl::createReadStructuralFeatureAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<ReadStructuralFeatureActionImpl> element(new ReadStructuralFeatureActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisReadStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadStructuralFeatureAction> umlFactoryImpl::createReadStructuralFeatureAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ReadStructuralFeatureActionImpl> element(new ReadStructuralFeatureActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisReadStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadStructuralFeatureAction> umlFactoryImpl::createReadStructuralFeatureAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ReadStructuralFeatureActionImpl> element(new ReadStructuralFeatureActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisReadStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadStructuralFeatureAction> umlFactoryImpl::createReadStructuralFeatureAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ReadStructuralFeatureActionImpl> element(new ReadStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisReadStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadStructuralFeatureAction> umlFactoryImpl::createReadStructuralFeatureAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<ReadStructuralFeatureActionImpl> element(new ReadStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisReadStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadStructuralFeatureAction> umlFactoryImpl::createReadStructuralFeatureAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ReadStructuralFeatureActionImpl> element(new ReadStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisReadStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadStructuralFeatureAction> umlFactoryImpl::createReadStructuralFeatureAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ReadStructuralFeatureActionImpl> element(new ReadStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisReadStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadStructuralFeatureAction> umlFactoryImpl::createReadStructuralFeatureAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ReadStructuralFeatureActionImpl> element(new ReadStructuralFeatureActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisReadStructuralFeatureActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadVariableAction> umlFactoryImpl::createReadVariableAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ReadVariableActionImpl> element(new ReadVariableActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisReadVariableActionPtr(element);
	return element;
}
std::shared_ptr<ReadVariableAction> umlFactoryImpl::createReadVariableAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<ReadVariableActionImpl> element(new ReadVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisReadVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadVariableAction> umlFactoryImpl::createReadVariableAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ReadVariableActionImpl> element(new ReadVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisReadVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadVariableAction> umlFactoryImpl::createReadVariableAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<ReadVariableActionImpl> element(new ReadVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisReadVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadVariableAction> umlFactoryImpl::createReadVariableAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<ReadVariableActionImpl> element(new ReadVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisReadVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadVariableAction> umlFactoryImpl::createReadVariableAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ReadVariableActionImpl> element(new ReadVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisReadVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadVariableAction> umlFactoryImpl::createReadVariableAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ReadVariableActionImpl> element(new ReadVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisReadVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadVariableAction> umlFactoryImpl::createReadVariableAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ReadVariableActionImpl> element(new ReadVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisReadVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadVariableAction> umlFactoryImpl::createReadVariableAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ReadVariableActionImpl> element(new ReadVariableActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisReadVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadVariableAction> umlFactoryImpl::createReadVariableAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<ReadVariableActionImpl> element(new ReadVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisReadVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadVariableAction> umlFactoryImpl::createReadVariableAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<ReadVariableActionImpl> element(new ReadVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisReadVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadVariableAction> umlFactoryImpl::createReadVariableAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<ReadVariableActionImpl> element(new ReadVariableActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisReadVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadVariableAction> umlFactoryImpl::createReadVariableAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ReadVariableActionImpl> element(new ReadVariableActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisReadVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadVariableAction> umlFactoryImpl::createReadVariableAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ReadVariableActionImpl> element(new ReadVariableActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisReadVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadVariableAction> umlFactoryImpl::createReadVariableAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ReadVariableActionImpl> element(new ReadVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisReadVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadVariableAction> umlFactoryImpl::createReadVariableAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<ReadVariableActionImpl> element(new ReadVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisReadVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadVariableAction> umlFactoryImpl::createReadVariableAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ReadVariableActionImpl> element(new ReadVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisReadVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadVariableAction> umlFactoryImpl::createReadVariableAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ReadVariableActionImpl> element(new ReadVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisReadVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<ReadVariableAction> umlFactoryImpl::createReadVariableAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ReadVariableActionImpl> element(new ReadVariableActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisReadVariableActionPtr(element);
	return element;
	
}
std::shared_ptr<Realization> umlFactoryImpl::createRealization(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<RealizationImpl> element(new RealizationImpl());
	element->setMetaElementID(metaElementID);
	element->setThisRealizationPtr(element);
	return element;
}
std::shared_ptr<Realization> umlFactoryImpl::createRealization_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<RealizationImpl> element(new RealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisRealizationPtr(element);
	return element;
	
}
std::shared_ptr<Realization> umlFactoryImpl::createRealization_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<RealizationImpl> element(new RealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisRealizationPtr(element);
	return element;
	
}
std::shared_ptr<Realization> umlFactoryImpl::createRealization_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<RealizationImpl> element(new RealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisRealizationPtr(element);
	return element;
	
}
std::shared_ptr<Realization> umlFactoryImpl::createRealization_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<RealizationImpl> element(new RealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisRealizationPtr(element);
	return element;
	
}
std::shared_ptr<Realization> umlFactoryImpl::createRealization_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<RealizationImpl> element(new RealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisRealizationPtr(element);
	return element;
	
}
std::shared_ptr<Realization> umlFactoryImpl::createRealization_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<RealizationImpl> element(new RealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisRealizationPtr(element);
	return element;
	
}
std::shared_ptr<Realization> umlFactoryImpl::createRealization_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<RealizationImpl> element(new RealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisRealizationPtr(element);
	return element;
	
}
std::shared_ptr<Realization> umlFactoryImpl::createRealization_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<RealizationImpl> element(new RealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisRealizationPtr(element);
	return element;
	
}
std::shared_ptr<Realization> umlFactoryImpl::createRealization_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<RealizationImpl> element(new RealizationImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisRealizationPtr(element);
	return element;
	
}
std::shared_ptr<Realization> umlFactoryImpl::createRealization_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<RealizationImpl> element(new RealizationImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisRealizationPtr(element);
	return element;
	
}
std::shared_ptr<Realization> umlFactoryImpl::createRealization_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<RealizationImpl> element(new RealizationImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisRealizationPtr(element);
	return element;
	
}
std::shared_ptr<Realization> umlFactoryImpl::createRealization_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<RealizationImpl> element(new RealizationImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisRealizationPtr(element);
	return element;
	
}
std::shared_ptr<Realization> umlFactoryImpl::createRealization_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<RealizationImpl> element(new RealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisRealizationPtr(element);
	return element;
	
}
std::shared_ptr<Realization> umlFactoryImpl::createRealization_as_roleBinding_in_CollaborationUse(std::shared_ptr<CollaborationUse> par_CollaborationUse, const int metaElementID) const
{
	std::shared_ptr<RealizationImpl> element(new RealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_CollaborationUse)
	{
		par_CollaborationUse->getRoleBinding()->push_back(element);
	}
	
	element->setThisRealizationPtr(element);
	return element;
	
}
std::shared_ptr<Realization> umlFactoryImpl::createRealization_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<RealizationImpl> element(new RealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisRealizationPtr(element);
	return element;
	
}
std::shared_ptr<Realization> umlFactoryImpl::createRealization_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<RealizationImpl> element(new RealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisRealizationPtr(element);
	return element;
	
}
std::shared_ptr<Realization> umlFactoryImpl::createRealization_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<RealizationImpl> element(new RealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisRealizationPtr(element);
	return element;
	
}
std::shared_ptr<Realization> umlFactoryImpl::createRealization_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<RealizationImpl> element(new RealizationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisRealizationPtr(element);
	return element;
	
}
std::shared_ptr<Reception> umlFactoryImpl::createReception(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ReceptionImpl> element(new ReceptionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisReceptionPtr(element);
	return element;
}
std::shared_ptr<Reception> umlFactoryImpl::createReception_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ReceptionImpl> element(new ReceptionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisReceptionPtr(element);
	return element;
	
}
std::shared_ptr<Reception> umlFactoryImpl::createReception_as_feature_in_Classifier(std::shared_ptr<uml::Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ReceptionImpl> element(new ReceptionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getFeature()->push_back(element);
	}
	
	element->setThisReceptionPtr(element);
	return element;
	
}
std::shared_ptr<Reception> umlFactoryImpl::createReception_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ReceptionImpl> element(new ReceptionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisReceptionPtr(element);
	return element;
	
}
std::shared_ptr<Reception> umlFactoryImpl::createReception_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ReceptionImpl> element(new ReceptionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisReceptionPtr(element);
	return element;
	
}
std::shared_ptr<Reception> umlFactoryImpl::createReception_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ReceptionImpl> element(new ReceptionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisReceptionPtr(element);
	return element;
	
}
std::shared_ptr<Reception> umlFactoryImpl::createReception_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ReceptionImpl> element(new ReceptionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisReceptionPtr(element);
	return element;
	
}
std::shared_ptr<Reception> umlFactoryImpl::createReception_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ReceptionImpl> element(new ReceptionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisReceptionPtr(element);
	return element;
	
}
std::shared_ptr<Reception> umlFactoryImpl::createReception_as_ownedReception_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<ReceptionImpl> element(new ReceptionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getOwnedReception()->push_back(element);
	}
	
	element->setThisReceptionPtr(element);
	return element;
	
}
std::shared_ptr<Reception> umlFactoryImpl::createReception_as_ownedReception_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<ReceptionImpl> element(new ReceptionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getOwnedReception()->push_back(element);
	}
	
	element->setThisReceptionPtr(element);
	return element;
	
}
std::shared_ptr<Reception> umlFactoryImpl::createReception_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ReceptionImpl> element(new ReceptionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisReceptionPtr(element);
	return element;
	
}
std::shared_ptr<Reception> umlFactoryImpl::createReception_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ReceptionImpl> element(new ReceptionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisReceptionPtr(element);
	return element;
	
}
std::shared_ptr<Reception> umlFactoryImpl::createReception_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ReceptionImpl> element(new ReceptionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisReceptionPtr(element);
	return element;
	
}
std::shared_ptr<ReclassifyObjectAction> umlFactoryImpl::createReclassifyObjectAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ReclassifyObjectActionImpl> element(new ReclassifyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisReclassifyObjectActionPtr(element);
	return element;
}
std::shared_ptr<ReclassifyObjectAction> umlFactoryImpl::createReclassifyObjectAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<ReclassifyObjectActionImpl> element(new ReclassifyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisReclassifyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReclassifyObjectAction> umlFactoryImpl::createReclassifyObjectAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ReclassifyObjectActionImpl> element(new ReclassifyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisReclassifyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReclassifyObjectAction> umlFactoryImpl::createReclassifyObjectAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<ReclassifyObjectActionImpl> element(new ReclassifyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisReclassifyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReclassifyObjectAction> umlFactoryImpl::createReclassifyObjectAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<ReclassifyObjectActionImpl> element(new ReclassifyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisReclassifyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReclassifyObjectAction> umlFactoryImpl::createReclassifyObjectAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ReclassifyObjectActionImpl> element(new ReclassifyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisReclassifyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReclassifyObjectAction> umlFactoryImpl::createReclassifyObjectAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ReclassifyObjectActionImpl> element(new ReclassifyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisReclassifyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReclassifyObjectAction> umlFactoryImpl::createReclassifyObjectAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ReclassifyObjectActionImpl> element(new ReclassifyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisReclassifyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReclassifyObjectAction> umlFactoryImpl::createReclassifyObjectAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ReclassifyObjectActionImpl> element(new ReclassifyObjectActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisReclassifyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReclassifyObjectAction> umlFactoryImpl::createReclassifyObjectAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<ReclassifyObjectActionImpl> element(new ReclassifyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisReclassifyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReclassifyObjectAction> umlFactoryImpl::createReclassifyObjectAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<ReclassifyObjectActionImpl> element(new ReclassifyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisReclassifyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReclassifyObjectAction> umlFactoryImpl::createReclassifyObjectAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<ReclassifyObjectActionImpl> element(new ReclassifyObjectActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisReclassifyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReclassifyObjectAction> umlFactoryImpl::createReclassifyObjectAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ReclassifyObjectActionImpl> element(new ReclassifyObjectActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisReclassifyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReclassifyObjectAction> umlFactoryImpl::createReclassifyObjectAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ReclassifyObjectActionImpl> element(new ReclassifyObjectActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisReclassifyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReclassifyObjectAction> umlFactoryImpl::createReclassifyObjectAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ReclassifyObjectActionImpl> element(new ReclassifyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisReclassifyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReclassifyObjectAction> umlFactoryImpl::createReclassifyObjectAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<ReclassifyObjectActionImpl> element(new ReclassifyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisReclassifyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReclassifyObjectAction> umlFactoryImpl::createReclassifyObjectAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ReclassifyObjectActionImpl> element(new ReclassifyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisReclassifyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReclassifyObjectAction> umlFactoryImpl::createReclassifyObjectAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ReclassifyObjectActionImpl> element(new ReclassifyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisReclassifyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<ReclassifyObjectAction> umlFactoryImpl::createReclassifyObjectAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ReclassifyObjectActionImpl> element(new ReclassifyObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisReclassifyObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<RedefinableTemplateSignature> umlFactoryImpl::createRedefinableTemplateSignature(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<RedefinableTemplateSignatureImpl> element(new RedefinableTemplateSignatureImpl());
	element->setMetaElementID(metaElementID);
	element->setThisRedefinableTemplateSignaturePtr(element);
	return element;
}
std::shared_ptr<RedefinableTemplateSignature> umlFactoryImpl::createRedefinableTemplateSignature_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<RedefinableTemplateSignatureImpl> element(new RedefinableTemplateSignatureImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisRedefinableTemplateSignaturePtr(element);
	return element;
	
}
std::shared_ptr<RedefinableTemplateSignature> umlFactoryImpl::createRedefinableTemplateSignature_as_extendedSignature_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<RedefinableTemplateSignatureImpl> element(new RedefinableTemplateSignatureImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->getExtendedSignature()->push_back(element);
	}
	
	element->setThisRedefinableTemplateSignaturePtr(element);
	return element;
	
}
std::shared_ptr<RedefinableTemplateSignature> umlFactoryImpl::createRedefinableTemplateSignature_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<RedefinableTemplateSignatureImpl> element(new RedefinableTemplateSignatureImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisRedefinableTemplateSignaturePtr(element);
	return element;
	
}
std::shared_ptr<RedefinableTemplateSignature> umlFactoryImpl::createRedefinableTemplateSignature_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<RedefinableTemplateSignatureImpl> element(new RedefinableTemplateSignatureImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisRedefinableTemplateSignaturePtr(element);
	return element;
	
}
std::shared_ptr<RedefinableTemplateSignature> umlFactoryImpl::createRedefinableTemplateSignature_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<RedefinableTemplateSignatureImpl> element(new RedefinableTemplateSignatureImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisRedefinableTemplateSignaturePtr(element);
	return element;
	
}
std::shared_ptr<RedefinableTemplateSignature> umlFactoryImpl::createRedefinableTemplateSignature_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<RedefinableTemplateSignatureImpl> element(new RedefinableTemplateSignatureImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisRedefinableTemplateSignaturePtr(element);
	return element;
	
}
std::shared_ptr<RedefinableTemplateSignature> umlFactoryImpl::createRedefinableTemplateSignature_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<RedefinableTemplateSignatureImpl> element(new RedefinableTemplateSignatureImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisRedefinableTemplateSignaturePtr(element);
	return element;
	
}
std::shared_ptr<RedefinableTemplateSignature> umlFactoryImpl::createRedefinableTemplateSignature_as_ownedTemplateSignature_in_TemplateableElement(std::weak_ptr<uml::TemplateableElement> par_TemplateableElement, const int metaElementID) const
{
	std::shared_ptr<RedefinableTemplateSignatureImpl> element(new RedefinableTemplateSignatureImpl(par_TemplateableElement));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateableElement.lock())
	{
		wp->setOwnedTemplateSignature(element);
	}
	
	element->setThisRedefinableTemplateSignaturePtr(element);
	return element;
	
}
std::shared_ptr<RedefinableTemplateSignature> umlFactoryImpl::createRedefinableTemplateSignature_as_signature_in_TemplateBinding(std::shared_ptr<TemplateBinding> par_TemplateBinding, const int metaElementID) const
{
	std::shared_ptr<RedefinableTemplateSignatureImpl> element(new RedefinableTemplateSignatureImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateBinding)
	{
		par_TemplateBinding->setSignature(element);
	}
	
	element->setThisRedefinableTemplateSignaturePtr(element);
	return element;
	
}
std::shared_ptr<RedefinableTemplateSignature> umlFactoryImpl::createRedefinableTemplateSignature_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<RedefinableTemplateSignatureImpl> element(new RedefinableTemplateSignatureImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisRedefinableTemplateSignaturePtr(element);
	return element;
	
}
std::shared_ptr<RedefinableTemplateSignature> umlFactoryImpl::createRedefinableTemplateSignature_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<RedefinableTemplateSignatureImpl> element(new RedefinableTemplateSignatureImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisRedefinableTemplateSignaturePtr(element);
	return element;
	
}
std::shared_ptr<RedefinableTemplateSignature> umlFactoryImpl::createRedefinableTemplateSignature_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<RedefinableTemplateSignatureImpl> element(new RedefinableTemplateSignatureImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisRedefinableTemplateSignaturePtr(element);
	return element;
	
}
std::shared_ptr<ReduceAction> umlFactoryImpl::createReduceAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ReduceActionImpl> element(new ReduceActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisReduceActionPtr(element);
	return element;
}
std::shared_ptr<ReduceAction> umlFactoryImpl::createReduceAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<ReduceActionImpl> element(new ReduceActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisReduceActionPtr(element);
	return element;
	
}
std::shared_ptr<ReduceAction> umlFactoryImpl::createReduceAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ReduceActionImpl> element(new ReduceActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisReduceActionPtr(element);
	return element;
	
}
std::shared_ptr<ReduceAction> umlFactoryImpl::createReduceAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<ReduceActionImpl> element(new ReduceActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisReduceActionPtr(element);
	return element;
	
}
std::shared_ptr<ReduceAction> umlFactoryImpl::createReduceAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<ReduceActionImpl> element(new ReduceActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisReduceActionPtr(element);
	return element;
	
}
std::shared_ptr<ReduceAction> umlFactoryImpl::createReduceAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ReduceActionImpl> element(new ReduceActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisReduceActionPtr(element);
	return element;
	
}
std::shared_ptr<ReduceAction> umlFactoryImpl::createReduceAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ReduceActionImpl> element(new ReduceActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisReduceActionPtr(element);
	return element;
	
}
std::shared_ptr<ReduceAction> umlFactoryImpl::createReduceAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ReduceActionImpl> element(new ReduceActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisReduceActionPtr(element);
	return element;
	
}
std::shared_ptr<ReduceAction> umlFactoryImpl::createReduceAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ReduceActionImpl> element(new ReduceActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisReduceActionPtr(element);
	return element;
	
}
std::shared_ptr<ReduceAction> umlFactoryImpl::createReduceAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<ReduceActionImpl> element(new ReduceActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisReduceActionPtr(element);
	return element;
	
}
std::shared_ptr<ReduceAction> umlFactoryImpl::createReduceAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<ReduceActionImpl> element(new ReduceActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisReduceActionPtr(element);
	return element;
	
}
std::shared_ptr<ReduceAction> umlFactoryImpl::createReduceAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<ReduceActionImpl> element(new ReduceActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisReduceActionPtr(element);
	return element;
	
}
std::shared_ptr<ReduceAction> umlFactoryImpl::createReduceAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ReduceActionImpl> element(new ReduceActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisReduceActionPtr(element);
	return element;
	
}
std::shared_ptr<ReduceAction> umlFactoryImpl::createReduceAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ReduceActionImpl> element(new ReduceActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisReduceActionPtr(element);
	return element;
	
}
std::shared_ptr<ReduceAction> umlFactoryImpl::createReduceAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ReduceActionImpl> element(new ReduceActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisReduceActionPtr(element);
	return element;
	
}
std::shared_ptr<ReduceAction> umlFactoryImpl::createReduceAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<ReduceActionImpl> element(new ReduceActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisReduceActionPtr(element);
	return element;
	
}
std::shared_ptr<ReduceAction> umlFactoryImpl::createReduceAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ReduceActionImpl> element(new ReduceActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisReduceActionPtr(element);
	return element;
	
}
std::shared_ptr<ReduceAction> umlFactoryImpl::createReduceAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ReduceActionImpl> element(new ReduceActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisReduceActionPtr(element);
	return element;
	
}
std::shared_ptr<ReduceAction> umlFactoryImpl::createReduceAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ReduceActionImpl> element(new ReduceActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisReduceActionPtr(element);
	return element;
	
}
std::shared_ptr<Region> umlFactoryImpl::createRegion(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<RegionImpl> element(new RegionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisRegionPtr(element);
	return element;
}
std::shared_ptr<Region> umlFactoryImpl::createRegion_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<RegionImpl> element(new RegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisRegionPtr(element);
	return element;
	
}
std::shared_ptr<Region> umlFactoryImpl::createRegion_as_extendedRegion_in_Region(std::shared_ptr<Region> par_Region, const int metaElementID) const
{
	std::shared_ptr<RegionImpl> element(new RegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Region)
	{
		par_Region->setExtendedRegion(element);
	}
	
	element->setThisRegionPtr(element);
	return element;
	
}
std::shared_ptr<Region> umlFactoryImpl::createRegion_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<RegionImpl> element(new RegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisRegionPtr(element);
	return element;
	
}
std::shared_ptr<Region> umlFactoryImpl::createRegion_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<RegionImpl> element(new RegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisRegionPtr(element);
	return element;
	
}
std::shared_ptr<Region> umlFactoryImpl::createRegion_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<RegionImpl> element(new RegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisRegionPtr(element);
	return element;
	
}
std::shared_ptr<Region> umlFactoryImpl::createRegion_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<RegionImpl> element(new RegionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisRegionPtr(element);
	return element;
	
}
std::shared_ptr<Region> umlFactoryImpl::createRegion_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<RegionImpl> element(new RegionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisRegionPtr(element);
	return element;
	
}
std::shared_ptr<Region> umlFactoryImpl::createRegion_as_region_in_StateMachine(std::weak_ptr<uml::StateMachine> par_StateMachine, const int metaElementID) const
{
	std::shared_ptr<RegionImpl> element(new RegionImpl(par_StateMachine));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StateMachine.lock())
	{
		wp->getRegion()->push_back(element);
	}
	
	element->setThisRegionPtr(element);
	return element;
	
}
std::shared_ptr<Region> umlFactoryImpl::createRegion_as_region_in_State(std::weak_ptr<uml::State> par_State, const int metaElementID) const
{
	std::shared_ptr<RegionImpl> element(new RegionImpl(par_State));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_State.lock())
	{
		wp->getRegion()->push_back(element);
	}
	
	element->setThisRegionPtr(element);
	return element;
	
}
std::shared_ptr<Region> umlFactoryImpl::createRegion_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<RegionImpl> element(new RegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisRegionPtr(element);
	return element;
	
}
std::shared_ptr<Region> umlFactoryImpl::createRegion_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<RegionImpl> element(new RegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisRegionPtr(element);
	return element;
	
}
std::shared_ptr<Region> umlFactoryImpl::createRegion_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<RegionImpl> element(new RegionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisRegionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveStructuralFeatureValueAction> umlFactoryImpl::createRemoveStructuralFeatureValueAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<RemoveStructuralFeatureValueActionImpl> element(new RemoveStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisRemoveStructuralFeatureValueActionPtr(element);
	return element;
}
std::shared_ptr<RemoveStructuralFeatureValueAction> umlFactoryImpl::createRemoveStructuralFeatureValueAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<RemoveStructuralFeatureValueActionImpl> element(new RemoveStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisRemoveStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveStructuralFeatureValueAction> umlFactoryImpl::createRemoveStructuralFeatureValueAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<RemoveStructuralFeatureValueActionImpl> element(new RemoveStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisRemoveStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveStructuralFeatureValueAction> umlFactoryImpl::createRemoveStructuralFeatureValueAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<RemoveStructuralFeatureValueActionImpl> element(new RemoveStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisRemoveStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveStructuralFeatureValueAction> umlFactoryImpl::createRemoveStructuralFeatureValueAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<RemoveStructuralFeatureValueActionImpl> element(new RemoveStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisRemoveStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveStructuralFeatureValueAction> umlFactoryImpl::createRemoveStructuralFeatureValueAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<RemoveStructuralFeatureValueActionImpl> element(new RemoveStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisRemoveStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveStructuralFeatureValueAction> umlFactoryImpl::createRemoveStructuralFeatureValueAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<RemoveStructuralFeatureValueActionImpl> element(new RemoveStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisRemoveStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveStructuralFeatureValueAction> umlFactoryImpl::createRemoveStructuralFeatureValueAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<RemoveStructuralFeatureValueActionImpl> element(new RemoveStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisRemoveStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveStructuralFeatureValueAction> umlFactoryImpl::createRemoveStructuralFeatureValueAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<RemoveStructuralFeatureValueActionImpl> element(new RemoveStructuralFeatureValueActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisRemoveStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveStructuralFeatureValueAction> umlFactoryImpl::createRemoveStructuralFeatureValueAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<RemoveStructuralFeatureValueActionImpl> element(new RemoveStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisRemoveStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveStructuralFeatureValueAction> umlFactoryImpl::createRemoveStructuralFeatureValueAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<RemoveStructuralFeatureValueActionImpl> element(new RemoveStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisRemoveStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveStructuralFeatureValueAction> umlFactoryImpl::createRemoveStructuralFeatureValueAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<RemoveStructuralFeatureValueActionImpl> element(new RemoveStructuralFeatureValueActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisRemoveStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveStructuralFeatureValueAction> umlFactoryImpl::createRemoveStructuralFeatureValueAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<RemoveStructuralFeatureValueActionImpl> element(new RemoveStructuralFeatureValueActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisRemoveStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveStructuralFeatureValueAction> umlFactoryImpl::createRemoveStructuralFeatureValueAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<RemoveStructuralFeatureValueActionImpl> element(new RemoveStructuralFeatureValueActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisRemoveStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveStructuralFeatureValueAction> umlFactoryImpl::createRemoveStructuralFeatureValueAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<RemoveStructuralFeatureValueActionImpl> element(new RemoveStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisRemoveStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveStructuralFeatureValueAction> umlFactoryImpl::createRemoveStructuralFeatureValueAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<RemoveStructuralFeatureValueActionImpl> element(new RemoveStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisRemoveStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveStructuralFeatureValueAction> umlFactoryImpl::createRemoveStructuralFeatureValueAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<RemoveStructuralFeatureValueActionImpl> element(new RemoveStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisRemoveStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveStructuralFeatureValueAction> umlFactoryImpl::createRemoveStructuralFeatureValueAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<RemoveStructuralFeatureValueActionImpl> element(new RemoveStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisRemoveStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveStructuralFeatureValueAction> umlFactoryImpl::createRemoveStructuralFeatureValueAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<RemoveStructuralFeatureValueActionImpl> element(new RemoveStructuralFeatureValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisRemoveStructuralFeatureValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveVariableValueAction> umlFactoryImpl::createRemoveVariableValueAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<RemoveVariableValueActionImpl> element(new RemoveVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisRemoveVariableValueActionPtr(element);
	return element;
}
std::shared_ptr<RemoveVariableValueAction> umlFactoryImpl::createRemoveVariableValueAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<RemoveVariableValueActionImpl> element(new RemoveVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisRemoveVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveVariableValueAction> umlFactoryImpl::createRemoveVariableValueAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<RemoveVariableValueActionImpl> element(new RemoveVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisRemoveVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveVariableValueAction> umlFactoryImpl::createRemoveVariableValueAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<RemoveVariableValueActionImpl> element(new RemoveVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisRemoveVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveVariableValueAction> umlFactoryImpl::createRemoveVariableValueAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<RemoveVariableValueActionImpl> element(new RemoveVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisRemoveVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveVariableValueAction> umlFactoryImpl::createRemoveVariableValueAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<RemoveVariableValueActionImpl> element(new RemoveVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisRemoveVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveVariableValueAction> umlFactoryImpl::createRemoveVariableValueAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<RemoveVariableValueActionImpl> element(new RemoveVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisRemoveVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveVariableValueAction> umlFactoryImpl::createRemoveVariableValueAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<RemoveVariableValueActionImpl> element(new RemoveVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisRemoveVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveVariableValueAction> umlFactoryImpl::createRemoveVariableValueAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<RemoveVariableValueActionImpl> element(new RemoveVariableValueActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisRemoveVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveVariableValueAction> umlFactoryImpl::createRemoveVariableValueAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<RemoveVariableValueActionImpl> element(new RemoveVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisRemoveVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveVariableValueAction> umlFactoryImpl::createRemoveVariableValueAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<RemoveVariableValueActionImpl> element(new RemoveVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisRemoveVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveVariableValueAction> umlFactoryImpl::createRemoveVariableValueAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<RemoveVariableValueActionImpl> element(new RemoveVariableValueActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisRemoveVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveVariableValueAction> umlFactoryImpl::createRemoveVariableValueAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<RemoveVariableValueActionImpl> element(new RemoveVariableValueActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisRemoveVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveVariableValueAction> umlFactoryImpl::createRemoveVariableValueAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<RemoveVariableValueActionImpl> element(new RemoveVariableValueActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisRemoveVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveVariableValueAction> umlFactoryImpl::createRemoveVariableValueAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<RemoveVariableValueActionImpl> element(new RemoveVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisRemoveVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveVariableValueAction> umlFactoryImpl::createRemoveVariableValueAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<RemoveVariableValueActionImpl> element(new RemoveVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisRemoveVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveVariableValueAction> umlFactoryImpl::createRemoveVariableValueAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<RemoveVariableValueActionImpl> element(new RemoveVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisRemoveVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveVariableValueAction> umlFactoryImpl::createRemoveVariableValueAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<RemoveVariableValueActionImpl> element(new RemoveVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisRemoveVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<RemoveVariableValueAction> umlFactoryImpl::createRemoveVariableValueAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<RemoveVariableValueActionImpl> element(new RemoveVariableValueActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisRemoveVariableValueActionPtr(element);
	return element;
	
}
std::shared_ptr<ReplyAction> umlFactoryImpl::createReplyAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ReplyActionImpl> element(new ReplyActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisReplyActionPtr(element);
	return element;
}
std::shared_ptr<ReplyAction> umlFactoryImpl::createReplyAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<ReplyActionImpl> element(new ReplyActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisReplyActionPtr(element);
	return element;
	
}
std::shared_ptr<ReplyAction> umlFactoryImpl::createReplyAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ReplyActionImpl> element(new ReplyActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisReplyActionPtr(element);
	return element;
	
}
std::shared_ptr<ReplyAction> umlFactoryImpl::createReplyAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<ReplyActionImpl> element(new ReplyActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisReplyActionPtr(element);
	return element;
	
}
std::shared_ptr<ReplyAction> umlFactoryImpl::createReplyAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<ReplyActionImpl> element(new ReplyActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisReplyActionPtr(element);
	return element;
	
}
std::shared_ptr<ReplyAction> umlFactoryImpl::createReplyAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ReplyActionImpl> element(new ReplyActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisReplyActionPtr(element);
	return element;
	
}
std::shared_ptr<ReplyAction> umlFactoryImpl::createReplyAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ReplyActionImpl> element(new ReplyActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisReplyActionPtr(element);
	return element;
	
}
std::shared_ptr<ReplyAction> umlFactoryImpl::createReplyAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ReplyActionImpl> element(new ReplyActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisReplyActionPtr(element);
	return element;
	
}
std::shared_ptr<ReplyAction> umlFactoryImpl::createReplyAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ReplyActionImpl> element(new ReplyActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisReplyActionPtr(element);
	return element;
	
}
std::shared_ptr<ReplyAction> umlFactoryImpl::createReplyAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<ReplyActionImpl> element(new ReplyActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisReplyActionPtr(element);
	return element;
	
}
std::shared_ptr<ReplyAction> umlFactoryImpl::createReplyAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<ReplyActionImpl> element(new ReplyActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisReplyActionPtr(element);
	return element;
	
}
std::shared_ptr<ReplyAction> umlFactoryImpl::createReplyAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<ReplyActionImpl> element(new ReplyActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisReplyActionPtr(element);
	return element;
	
}
std::shared_ptr<ReplyAction> umlFactoryImpl::createReplyAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ReplyActionImpl> element(new ReplyActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisReplyActionPtr(element);
	return element;
	
}
std::shared_ptr<ReplyAction> umlFactoryImpl::createReplyAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ReplyActionImpl> element(new ReplyActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisReplyActionPtr(element);
	return element;
	
}
std::shared_ptr<ReplyAction> umlFactoryImpl::createReplyAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ReplyActionImpl> element(new ReplyActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisReplyActionPtr(element);
	return element;
	
}
std::shared_ptr<ReplyAction> umlFactoryImpl::createReplyAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<ReplyActionImpl> element(new ReplyActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisReplyActionPtr(element);
	return element;
	
}
std::shared_ptr<ReplyAction> umlFactoryImpl::createReplyAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ReplyActionImpl> element(new ReplyActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisReplyActionPtr(element);
	return element;
	
}
std::shared_ptr<ReplyAction> umlFactoryImpl::createReplyAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ReplyActionImpl> element(new ReplyActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisReplyActionPtr(element);
	return element;
	
}
std::shared_ptr<ReplyAction> umlFactoryImpl::createReplyAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ReplyActionImpl> element(new ReplyActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisReplyActionPtr(element);
	return element;
	
}
std::shared_ptr<SendObjectAction> umlFactoryImpl::createSendObjectAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<SendObjectActionImpl> element(new SendObjectActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisSendObjectActionPtr(element);
	return element;
}
std::shared_ptr<SendObjectAction> umlFactoryImpl::createSendObjectAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<SendObjectActionImpl> element(new SendObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisSendObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<SendObjectAction> umlFactoryImpl::createSendObjectAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<SendObjectActionImpl> element(new SendObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisSendObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<SendObjectAction> umlFactoryImpl::createSendObjectAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<SendObjectActionImpl> element(new SendObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisSendObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<SendObjectAction> umlFactoryImpl::createSendObjectAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<SendObjectActionImpl> element(new SendObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisSendObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<SendObjectAction> umlFactoryImpl::createSendObjectAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<SendObjectActionImpl> element(new SendObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisSendObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<SendObjectAction> umlFactoryImpl::createSendObjectAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<SendObjectActionImpl> element(new SendObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisSendObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<SendObjectAction> umlFactoryImpl::createSendObjectAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<SendObjectActionImpl> element(new SendObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisSendObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<SendObjectAction> umlFactoryImpl::createSendObjectAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<SendObjectActionImpl> element(new SendObjectActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisSendObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<SendObjectAction> umlFactoryImpl::createSendObjectAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<SendObjectActionImpl> element(new SendObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisSendObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<SendObjectAction> umlFactoryImpl::createSendObjectAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<SendObjectActionImpl> element(new SendObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisSendObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<SendObjectAction> umlFactoryImpl::createSendObjectAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<SendObjectActionImpl> element(new SendObjectActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisSendObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<SendObjectAction> umlFactoryImpl::createSendObjectAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<SendObjectActionImpl> element(new SendObjectActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisSendObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<SendObjectAction> umlFactoryImpl::createSendObjectAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<SendObjectActionImpl> element(new SendObjectActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisSendObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<SendObjectAction> umlFactoryImpl::createSendObjectAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<SendObjectActionImpl> element(new SendObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisSendObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<SendObjectAction> umlFactoryImpl::createSendObjectAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<SendObjectActionImpl> element(new SendObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisSendObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<SendObjectAction> umlFactoryImpl::createSendObjectAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<SendObjectActionImpl> element(new SendObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisSendObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<SendObjectAction> umlFactoryImpl::createSendObjectAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<SendObjectActionImpl> element(new SendObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisSendObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<SendObjectAction> umlFactoryImpl::createSendObjectAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<SendObjectActionImpl> element(new SendObjectActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisSendObjectActionPtr(element);
	return element;
	
}
std::shared_ptr<SendSignalAction> umlFactoryImpl::createSendSignalAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<SendSignalActionImpl> element(new SendSignalActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisSendSignalActionPtr(element);
	return element;
}
std::shared_ptr<SendSignalAction> umlFactoryImpl::createSendSignalAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<SendSignalActionImpl> element(new SendSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisSendSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<SendSignalAction> umlFactoryImpl::createSendSignalAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<SendSignalActionImpl> element(new SendSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisSendSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<SendSignalAction> umlFactoryImpl::createSendSignalAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<SendSignalActionImpl> element(new SendSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisSendSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<SendSignalAction> umlFactoryImpl::createSendSignalAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<SendSignalActionImpl> element(new SendSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisSendSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<SendSignalAction> umlFactoryImpl::createSendSignalAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<SendSignalActionImpl> element(new SendSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisSendSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<SendSignalAction> umlFactoryImpl::createSendSignalAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<SendSignalActionImpl> element(new SendSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisSendSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<SendSignalAction> umlFactoryImpl::createSendSignalAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<SendSignalActionImpl> element(new SendSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisSendSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<SendSignalAction> umlFactoryImpl::createSendSignalAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<SendSignalActionImpl> element(new SendSignalActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisSendSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<SendSignalAction> umlFactoryImpl::createSendSignalAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<SendSignalActionImpl> element(new SendSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisSendSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<SendSignalAction> umlFactoryImpl::createSendSignalAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<SendSignalActionImpl> element(new SendSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisSendSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<SendSignalAction> umlFactoryImpl::createSendSignalAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<SendSignalActionImpl> element(new SendSignalActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisSendSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<SendSignalAction> umlFactoryImpl::createSendSignalAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<SendSignalActionImpl> element(new SendSignalActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisSendSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<SendSignalAction> umlFactoryImpl::createSendSignalAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<SendSignalActionImpl> element(new SendSignalActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisSendSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<SendSignalAction> umlFactoryImpl::createSendSignalAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<SendSignalActionImpl> element(new SendSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisSendSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<SendSignalAction> umlFactoryImpl::createSendSignalAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<SendSignalActionImpl> element(new SendSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisSendSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<SendSignalAction> umlFactoryImpl::createSendSignalAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<SendSignalActionImpl> element(new SendSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisSendSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<SendSignalAction> umlFactoryImpl::createSendSignalAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<SendSignalActionImpl> element(new SendSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisSendSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<SendSignalAction> umlFactoryImpl::createSendSignalAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<SendSignalActionImpl> element(new SendSignalActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisSendSignalActionPtr(element);
	return element;
	
}
std::shared_ptr<SequenceNode> umlFactoryImpl::createSequenceNode(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<SequenceNodeImpl> element(new SequenceNodeImpl());
	element->setMetaElementID(metaElementID);
	element->setThisSequenceNodePtr(element);
	return element;
}
std::shared_ptr<SequenceNode> umlFactoryImpl::createSequenceNode_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<SequenceNodeImpl> element(new SequenceNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisSequenceNodePtr(element);
	return element;
	
}
std::shared_ptr<SequenceNode> umlFactoryImpl::createSequenceNode_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<SequenceNodeImpl> element(new SequenceNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisSequenceNodePtr(element);
	return element;
	
}
std::shared_ptr<SequenceNode> umlFactoryImpl::createSequenceNode_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<SequenceNodeImpl> element(new SequenceNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisSequenceNodePtr(element);
	return element;
	
}
std::shared_ptr<SequenceNode> umlFactoryImpl::createSequenceNode_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<SequenceNodeImpl> element(new SequenceNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisSequenceNodePtr(element);
	return element;
	
}
std::shared_ptr<SequenceNode> umlFactoryImpl::createSequenceNode_as_group_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<SequenceNodeImpl> element(new SequenceNodeImpl(par_Activity, uml::umlPackage::ACTIVITYGROUP_ATTRIBUTE_INACTIVITY));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getGroup()->push_back(element);
	}
	
	element->setThisSequenceNodePtr(element);
	return element;
	
}
std::shared_ptr<SequenceNode> umlFactoryImpl::createSequenceNode_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<SequenceNodeImpl> element(new SequenceNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisSequenceNodePtr(element);
	return element;
	
}
std::shared_ptr<SequenceNode> umlFactoryImpl::createSequenceNode_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<SequenceNodeImpl> element(new SequenceNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisSequenceNodePtr(element);
	return element;
	
}
std::shared_ptr<SequenceNode> umlFactoryImpl::createSequenceNode_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<SequenceNodeImpl> element(new SequenceNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisSequenceNodePtr(element);
	return element;
	
}
std::shared_ptr<SequenceNode> umlFactoryImpl::createSequenceNode_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<SequenceNodeImpl> element(new SequenceNodeImpl(par_Activity, uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_ACTIVITY));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisSequenceNodePtr(element);
	return element;
	
}
std::shared_ptr<SequenceNode> umlFactoryImpl::createSequenceNode_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<SequenceNodeImpl> element(new SequenceNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisSequenceNodePtr(element);
	return element;
	
}
std::shared_ptr<SequenceNode> umlFactoryImpl::createSequenceNode_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<SequenceNodeImpl> element(new SequenceNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisSequenceNodePtr(element);
	return element;
	
}
std::shared_ptr<SequenceNode> umlFactoryImpl::createSequenceNode_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<SequenceNodeImpl> element(new SequenceNodeImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisSequenceNodePtr(element);
	return element;
	
}
std::shared_ptr<SequenceNode> umlFactoryImpl::createSequenceNode_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<SequenceNodeImpl> element(new SequenceNodeImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisSequenceNodePtr(element);
	return element;
	
}
std::shared_ptr<SequenceNode> umlFactoryImpl::createSequenceNode_as_ownedGroup_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<SequenceNodeImpl> element(new SequenceNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedGroup()->push_back(element);
	}
	
	element->setThisSequenceNodePtr(element);
	return element;
	
}
std::shared_ptr<SequenceNode> umlFactoryImpl::createSequenceNode_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<SequenceNodeImpl> element(new SequenceNodeImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisSequenceNodePtr(element);
	return element;
	
}
std::shared_ptr<SequenceNode> umlFactoryImpl::createSequenceNode_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<SequenceNodeImpl> element(new SequenceNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisSequenceNodePtr(element);
	return element;
	
}
std::shared_ptr<SequenceNode> umlFactoryImpl::createSequenceNode_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<SequenceNodeImpl> element(new SequenceNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisSequenceNodePtr(element);
	return element;
	
}
std::shared_ptr<SequenceNode> umlFactoryImpl::createSequenceNode_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<SequenceNodeImpl> element(new SequenceNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisSequenceNodePtr(element);
	return element;
	
}
std::shared_ptr<SequenceNode> umlFactoryImpl::createSequenceNode_as_structuredNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<SequenceNodeImpl> element(new SequenceNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getStructuredNode()->push_back(element);
	}
	
	element->setThisSequenceNodePtr(element);
	return element;
	
}
std::shared_ptr<SequenceNode> umlFactoryImpl::createSequenceNode_as_subgroup_in_ActivityGroup(std::weak_ptr<uml::ActivityGroup> par_ActivityGroup, const int metaElementID) const
{
	std::shared_ptr<SequenceNodeImpl> element(new SequenceNodeImpl(par_ActivityGroup));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ActivityGroup.lock())
	{
		wp->getSubgroup()->push_back(element);
	}
	
	element->setThisSequenceNodePtr(element);
	return element;
	
}
std::shared_ptr<SequenceNode> umlFactoryImpl::createSequenceNode_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<SequenceNodeImpl> element(new SequenceNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisSequenceNodePtr(element);
	return element;
	
}
std::shared_ptr<SequenceNode> umlFactoryImpl::createSequenceNode_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<SequenceNodeImpl> element(new SequenceNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisSequenceNodePtr(element);
	return element;
	
}
std::shared_ptr<Signal> umlFactoryImpl::createSignal(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<SignalImpl> element(new SignalImpl());
	element->setMetaElementID(metaElementID);
	element->setThisSignalPtr(element);
	return element;
}
std::shared_ptr<Signal> umlFactoryImpl::createSignal_as_classifier_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<SignalImpl> element(new SignalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->setClassifier(element);
	}
	
	element->setThisSignalPtr(element);
	return element;
	
}
std::shared_ptr<Signal> umlFactoryImpl::createSignal_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<SignalImpl> element(new SignalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisSignalPtr(element);
	return element;
	
}
std::shared_ptr<Signal> umlFactoryImpl::createSignal_as_contract_in_Substitution(std::shared_ptr<Substitution> par_Substitution, const int metaElementID) const
{
	std::shared_ptr<SignalImpl> element(new SignalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Substitution)
	{
		par_Substitution->setContract(element);
	}
	
	element->setThisSignalPtr(element);
	return element;
	
}
std::shared_ptr<Signal> umlFactoryImpl::createSignal_as_endType_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<SignalImpl> element(new SignalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getEndType()->push_back(element);
	}
	
	element->setThisSignalPtr(element);
	return element;
	
}
std::shared_ptr<Signal> umlFactoryImpl::createSignal_as_general_in_Generalization(std::shared_ptr<Generalization> par_Generalization, const int metaElementID) const
{
	std::shared_ptr<SignalImpl> element(new SignalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Generalization)
	{
		par_Generalization->setGeneral(element);
	}
	
	element->setThisSignalPtr(element);
	return element;
	
}
std::shared_ptr<Signal> umlFactoryImpl::createSignal_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<SignalImpl> element(new SignalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisSignalPtr(element);
	return element;
	
}
std::shared_ptr<Signal> umlFactoryImpl::createSignal_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<SignalImpl> element(new SignalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisSignalPtr(element);
	return element;
	
}
std::shared_ptr<Signal> umlFactoryImpl::createSignal_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<SignalImpl> element(new SignalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisSignalPtr(element);
	return element;
	
}
std::shared_ptr<Signal> umlFactoryImpl::createSignal_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<SignalImpl> element(new SignalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisSignalPtr(element);
	return element;
	
}
std::shared_ptr<Signal> umlFactoryImpl::createSignal_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<SignalImpl> element(new SignalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisSignalPtr(element);
	return element;
	
}
std::shared_ptr<Signal> umlFactoryImpl::createSignal_as_nestedClassifier_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<SignalImpl> element(new SignalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getNestedClassifier()->push_back(element);
	}
	
	element->setThisSignalPtr(element);
	return element;
	
}
std::shared_ptr<Signal> umlFactoryImpl::createSignal_as_nestedClassifier_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<SignalImpl> element(new SignalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getNestedClassifier()->push_back(element);
	}
	
	element->setThisSignalPtr(element);
	return element;
	
}
std::shared_ptr<Signal> umlFactoryImpl::createSignal_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<SignalImpl> element(new SignalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisSignalPtr(element);
	return element;
	
}
std::shared_ptr<Signal> umlFactoryImpl::createSignal_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<SignalImpl> element(new SignalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisSignalPtr(element);
	return element;
	
}
std::shared_ptr<Signal> umlFactoryImpl::createSignal_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<SignalImpl> element(new SignalImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisSignalPtr(element);
	return element;
	
}
std::shared_ptr<Signal> umlFactoryImpl::createSignal_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<SignalImpl> element(new SignalImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisSignalPtr(element);
	return element;
	
}
std::shared_ptr<Signal> umlFactoryImpl::createSignal_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<SignalImpl> element(new SignalImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisSignalPtr(element);
	return element;
	
}
std::shared_ptr<Signal> umlFactoryImpl::createSignal_as_ownedType_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<SignalImpl> element(new SignalImpl(par_Package, uml::umlPackage::TYPE_ATTRIBUTE_PACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getOwnedType()->push_back(element);
	}
	
	element->setThisSignalPtr(element);
	return element;
	
}
std::shared_ptr<Signal> umlFactoryImpl::createSignal_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<SignalImpl> element(new SignalImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisSignalPtr(element);
	return element;
	
}
std::shared_ptr<Signal> umlFactoryImpl::createSignal_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<SignalImpl> element(new SignalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisSignalPtr(element);
	return element;
	
}
std::shared_ptr<Signal> umlFactoryImpl::createSignal_as_realizingClassifier_in_ComponentRealization(std::shared_ptr<ComponentRealization> par_ComponentRealization, const int metaElementID) const
{
	std::shared_ptr<SignalImpl> element(new SignalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ComponentRealization)
	{
		par_ComponentRealization->getRealizingClassifier()->push_back(element);
	}
	
	element->setThisSignalPtr(element);
	return element;
	
}
std::shared_ptr<Signal> umlFactoryImpl::createSignal_as_redefinedClassifier_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<SignalImpl> element(new SignalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getRedefinedClassifier()->push_back(element);
	}
	
	element->setThisSignalPtr(element);
	return element;
	
}
std::shared_ptr<Signal> umlFactoryImpl::createSignal_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<SignalImpl> element(new SignalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisSignalPtr(element);
	return element;
	
}
std::shared_ptr<Signal> umlFactoryImpl::createSignal_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<SignalImpl> element(new SignalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisSignalPtr(element);
	return element;
	
}
std::shared_ptr<Signal> umlFactoryImpl::createSignal_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<SignalImpl> element(new SignalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisSignalPtr(element);
	return element;
	
}
std::shared_ptr<Signal> umlFactoryImpl::createSignal_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<SignalImpl> element(new SignalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisSignalPtr(element);
	return element;
	
}
std::shared_ptr<SignalEvent> umlFactoryImpl::createSignalEvent(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<SignalEventImpl> element(new SignalEventImpl());
	element->setMetaElementID(metaElementID);
	element->setThisSignalEventPtr(element);
	return element;
}
std::shared_ptr<SignalEvent> umlFactoryImpl::createSignalEvent_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<SignalEventImpl> element(new SignalEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisSignalEventPtr(element);
	return element;
	
}
std::shared_ptr<SignalEvent> umlFactoryImpl::createSignalEvent_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<SignalEventImpl> element(new SignalEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisSignalEventPtr(element);
	return element;
	
}
std::shared_ptr<SignalEvent> umlFactoryImpl::createSignalEvent_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<SignalEventImpl> element(new SignalEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisSignalEventPtr(element);
	return element;
	
}
std::shared_ptr<SignalEvent> umlFactoryImpl::createSignalEvent_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<SignalEventImpl> element(new SignalEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisSignalEventPtr(element);
	return element;
	
}
std::shared_ptr<SignalEvent> umlFactoryImpl::createSignalEvent_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<SignalEventImpl> element(new SignalEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisSignalEventPtr(element);
	return element;
	
}
std::shared_ptr<SignalEvent> umlFactoryImpl::createSignalEvent_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<SignalEventImpl> element(new SignalEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisSignalEventPtr(element);
	return element;
	
}
std::shared_ptr<SignalEvent> umlFactoryImpl::createSignalEvent_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<SignalEventImpl> element(new SignalEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisSignalEventPtr(element);
	return element;
	
}
std::shared_ptr<SignalEvent> umlFactoryImpl::createSignalEvent_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<SignalEventImpl> element(new SignalEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisSignalEventPtr(element);
	return element;
	
}
std::shared_ptr<SignalEvent> umlFactoryImpl::createSignalEvent_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<SignalEventImpl> element(new SignalEventImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisSignalEventPtr(element);
	return element;
	
}
std::shared_ptr<SignalEvent> umlFactoryImpl::createSignalEvent_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<SignalEventImpl> element(new SignalEventImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisSignalEventPtr(element);
	return element;
	
}
std::shared_ptr<SignalEvent> umlFactoryImpl::createSignalEvent_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<SignalEventImpl> element(new SignalEventImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisSignalEventPtr(element);
	return element;
	
}
std::shared_ptr<SignalEvent> umlFactoryImpl::createSignalEvent_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<SignalEventImpl> element(new SignalEventImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisSignalEventPtr(element);
	return element;
	
}
std::shared_ptr<SignalEvent> umlFactoryImpl::createSignalEvent_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<SignalEventImpl> element(new SignalEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisSignalEventPtr(element);
	return element;
	
}
std::shared_ptr<SignalEvent> umlFactoryImpl::createSignalEvent_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<SignalEventImpl> element(new SignalEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisSignalEventPtr(element);
	return element;
	
}
std::shared_ptr<SignalEvent> umlFactoryImpl::createSignalEvent_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<SignalEventImpl> element(new SignalEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisSignalEventPtr(element);
	return element;
	
}
std::shared_ptr<SignalEvent> umlFactoryImpl::createSignalEvent_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<SignalEventImpl> element(new SignalEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisSignalEventPtr(element);
	return element;
	
}
std::shared_ptr<SignalEvent> umlFactoryImpl::createSignalEvent_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<SignalEventImpl> element(new SignalEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisSignalEventPtr(element);
	return element;
	
}
std::shared_ptr<Slot> umlFactoryImpl::createSlot(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<SlotImpl> element(new SlotImpl());
	element->setMetaElementID(metaElementID);
	element->setThisSlotPtr(element);
	return element;
}
std::shared_ptr<Slot> umlFactoryImpl::createSlot_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<SlotImpl> element(new SlotImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisSlotPtr(element);
	return element;
	
}
std::shared_ptr<Slot> umlFactoryImpl::createSlot_as_slot_in_InstanceSpecification(std::weak_ptr<uml::InstanceSpecification> par_InstanceSpecification, const int metaElementID) const
{
	std::shared_ptr<SlotImpl> element(new SlotImpl(par_InstanceSpecification));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_InstanceSpecification.lock())
	{
		wp->getSlot()->push_back(element);
	}
	
	element->setThisSlotPtr(element);
	return element;
	
}
std::shared_ptr<Slot> umlFactoryImpl::createSlot_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<SlotImpl> element(new SlotImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisSlotPtr(element);
	return element;
	
}
std::shared_ptr<Slot> umlFactoryImpl::createSlot_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<SlotImpl> element(new SlotImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisSlotPtr(element);
	return element;
	
}
std::shared_ptr<StartClassifierBehaviorAction> umlFactoryImpl::createStartClassifierBehaviorAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<StartClassifierBehaviorActionImpl> element(new StartClassifierBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisStartClassifierBehaviorActionPtr(element);
	return element;
}
std::shared_ptr<StartClassifierBehaviorAction> umlFactoryImpl::createStartClassifierBehaviorAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<StartClassifierBehaviorActionImpl> element(new StartClassifierBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisStartClassifierBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartClassifierBehaviorAction> umlFactoryImpl::createStartClassifierBehaviorAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<StartClassifierBehaviorActionImpl> element(new StartClassifierBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisStartClassifierBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartClassifierBehaviorAction> umlFactoryImpl::createStartClassifierBehaviorAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<StartClassifierBehaviorActionImpl> element(new StartClassifierBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisStartClassifierBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartClassifierBehaviorAction> umlFactoryImpl::createStartClassifierBehaviorAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<StartClassifierBehaviorActionImpl> element(new StartClassifierBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisStartClassifierBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartClassifierBehaviorAction> umlFactoryImpl::createStartClassifierBehaviorAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<StartClassifierBehaviorActionImpl> element(new StartClassifierBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisStartClassifierBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartClassifierBehaviorAction> umlFactoryImpl::createStartClassifierBehaviorAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<StartClassifierBehaviorActionImpl> element(new StartClassifierBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisStartClassifierBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartClassifierBehaviorAction> umlFactoryImpl::createStartClassifierBehaviorAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<StartClassifierBehaviorActionImpl> element(new StartClassifierBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisStartClassifierBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartClassifierBehaviorAction> umlFactoryImpl::createStartClassifierBehaviorAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<StartClassifierBehaviorActionImpl> element(new StartClassifierBehaviorActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisStartClassifierBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartClassifierBehaviorAction> umlFactoryImpl::createStartClassifierBehaviorAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<StartClassifierBehaviorActionImpl> element(new StartClassifierBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisStartClassifierBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartClassifierBehaviorAction> umlFactoryImpl::createStartClassifierBehaviorAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<StartClassifierBehaviorActionImpl> element(new StartClassifierBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisStartClassifierBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartClassifierBehaviorAction> umlFactoryImpl::createStartClassifierBehaviorAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<StartClassifierBehaviorActionImpl> element(new StartClassifierBehaviorActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisStartClassifierBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartClassifierBehaviorAction> umlFactoryImpl::createStartClassifierBehaviorAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<StartClassifierBehaviorActionImpl> element(new StartClassifierBehaviorActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisStartClassifierBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartClassifierBehaviorAction> umlFactoryImpl::createStartClassifierBehaviorAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<StartClassifierBehaviorActionImpl> element(new StartClassifierBehaviorActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisStartClassifierBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartClassifierBehaviorAction> umlFactoryImpl::createStartClassifierBehaviorAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<StartClassifierBehaviorActionImpl> element(new StartClassifierBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisStartClassifierBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartClassifierBehaviorAction> umlFactoryImpl::createStartClassifierBehaviorAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<StartClassifierBehaviorActionImpl> element(new StartClassifierBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisStartClassifierBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartClassifierBehaviorAction> umlFactoryImpl::createStartClassifierBehaviorAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<StartClassifierBehaviorActionImpl> element(new StartClassifierBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisStartClassifierBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartClassifierBehaviorAction> umlFactoryImpl::createStartClassifierBehaviorAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<StartClassifierBehaviorActionImpl> element(new StartClassifierBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisStartClassifierBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartClassifierBehaviorAction> umlFactoryImpl::createStartClassifierBehaviorAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<StartClassifierBehaviorActionImpl> element(new StartClassifierBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisStartClassifierBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartObjectBehaviorAction> umlFactoryImpl::createStartObjectBehaviorAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<StartObjectBehaviorActionImpl> element(new StartObjectBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisStartObjectBehaviorActionPtr(element);
	return element;
}
std::shared_ptr<StartObjectBehaviorAction> umlFactoryImpl::createStartObjectBehaviorAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<StartObjectBehaviorActionImpl> element(new StartObjectBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisStartObjectBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartObjectBehaviorAction> umlFactoryImpl::createStartObjectBehaviorAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<StartObjectBehaviorActionImpl> element(new StartObjectBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisStartObjectBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartObjectBehaviorAction> umlFactoryImpl::createStartObjectBehaviorAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<StartObjectBehaviorActionImpl> element(new StartObjectBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisStartObjectBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartObjectBehaviorAction> umlFactoryImpl::createStartObjectBehaviorAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<StartObjectBehaviorActionImpl> element(new StartObjectBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisStartObjectBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartObjectBehaviorAction> umlFactoryImpl::createStartObjectBehaviorAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<StartObjectBehaviorActionImpl> element(new StartObjectBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisStartObjectBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartObjectBehaviorAction> umlFactoryImpl::createStartObjectBehaviorAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<StartObjectBehaviorActionImpl> element(new StartObjectBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisStartObjectBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartObjectBehaviorAction> umlFactoryImpl::createStartObjectBehaviorAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<StartObjectBehaviorActionImpl> element(new StartObjectBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisStartObjectBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartObjectBehaviorAction> umlFactoryImpl::createStartObjectBehaviorAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<StartObjectBehaviorActionImpl> element(new StartObjectBehaviorActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisStartObjectBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartObjectBehaviorAction> umlFactoryImpl::createStartObjectBehaviorAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<StartObjectBehaviorActionImpl> element(new StartObjectBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisStartObjectBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartObjectBehaviorAction> umlFactoryImpl::createStartObjectBehaviorAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<StartObjectBehaviorActionImpl> element(new StartObjectBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisStartObjectBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartObjectBehaviorAction> umlFactoryImpl::createStartObjectBehaviorAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<StartObjectBehaviorActionImpl> element(new StartObjectBehaviorActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisStartObjectBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartObjectBehaviorAction> umlFactoryImpl::createStartObjectBehaviorAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<StartObjectBehaviorActionImpl> element(new StartObjectBehaviorActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisStartObjectBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartObjectBehaviorAction> umlFactoryImpl::createStartObjectBehaviorAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<StartObjectBehaviorActionImpl> element(new StartObjectBehaviorActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisStartObjectBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartObjectBehaviorAction> umlFactoryImpl::createStartObjectBehaviorAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<StartObjectBehaviorActionImpl> element(new StartObjectBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisStartObjectBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartObjectBehaviorAction> umlFactoryImpl::createStartObjectBehaviorAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<StartObjectBehaviorActionImpl> element(new StartObjectBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisStartObjectBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartObjectBehaviorAction> umlFactoryImpl::createStartObjectBehaviorAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<StartObjectBehaviorActionImpl> element(new StartObjectBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisStartObjectBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartObjectBehaviorAction> umlFactoryImpl::createStartObjectBehaviorAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<StartObjectBehaviorActionImpl> element(new StartObjectBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisStartObjectBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<StartObjectBehaviorAction> umlFactoryImpl::createStartObjectBehaviorAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<StartObjectBehaviorActionImpl> element(new StartObjectBehaviorActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisStartObjectBehaviorActionPtr(element);
	return element;
	
}
std::shared_ptr<State> umlFactoryImpl::createState(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<StateImpl> element(new StateImpl());
	element->setMetaElementID(metaElementID);
	element->setThisStatePtr(element);
	return element;
}
std::shared_ptr<State> umlFactoryImpl::createState_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<StateImpl> element(new StateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisStatePtr(element);
	return element;
	
}
std::shared_ptr<State> umlFactoryImpl::createState_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<StateImpl> element(new StateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisStatePtr(element);
	return element;
	
}
std::shared_ptr<State> umlFactoryImpl::createState_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<StateImpl> element(new StateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisStatePtr(element);
	return element;
	
}
std::shared_ptr<State> umlFactoryImpl::createState_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<StateImpl> element(new StateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisStatePtr(element);
	return element;
	
}
std::shared_ptr<State> umlFactoryImpl::createState_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<StateImpl> element(new StateImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisStatePtr(element);
	return element;
	
}
std::shared_ptr<State> umlFactoryImpl::createState_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<StateImpl> element(new StateImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisStatePtr(element);
	return element;
	
}
std::shared_ptr<State> umlFactoryImpl::createState_as_redefinedState_in_State(std::shared_ptr<State> par_State, const int metaElementID) const
{
	std::shared_ptr<StateImpl> element(new StateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_State)
	{
		par_State->setRedefinedState(element);
	}
	
	element->setThisStatePtr(element);
	return element;
	
}
std::shared_ptr<State> umlFactoryImpl::createState_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<StateImpl> element(new StateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisStatePtr(element);
	return element;
	
}
std::shared_ptr<State> umlFactoryImpl::createState_as_subvertex_in_Region(std::weak_ptr<uml::Region> par_Region, const int metaElementID) const
{
	std::shared_ptr<StateImpl> element(new StateImpl(par_Region));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Region.lock())
	{
		wp->getSubvertex()->push_back(element);
	}
	
	element->setThisStatePtr(element);
	return element;
	
}
std::shared_ptr<State> umlFactoryImpl::createState_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<StateImpl> element(new StateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisStatePtr(element);
	return element;
	
}
std::shared_ptr<State> umlFactoryImpl::createState_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<StateImpl> element(new StateImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisStatePtr(element);
	return element;
	
}
std::shared_ptr<StateInvariant> umlFactoryImpl::createStateInvariant(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<StateInvariantImpl> element(new StateInvariantImpl());
	element->setMetaElementID(metaElementID);
	element->setThisStateInvariantPtr(element);
	return element;
}
std::shared_ptr<StateInvariant> umlFactoryImpl::createStateInvariant_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<StateInvariantImpl> element(new StateInvariantImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisStateInvariantPtr(element);
	return element;
	
}
std::shared_ptr<StateInvariant> umlFactoryImpl::createStateInvariant_as_fragment_in_Interaction(std::weak_ptr<uml::Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<StateInvariantImpl> element(new StateInvariantImpl(par_Interaction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Interaction.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisStateInvariantPtr(element);
	return element;
	
}
std::shared_ptr<StateInvariant> umlFactoryImpl::createStateInvariant_as_fragment_in_InteractionOperand(std::weak_ptr<uml::InteractionOperand> par_InteractionOperand, const int metaElementID) const
{
	std::shared_ptr<StateInvariantImpl> element(new StateInvariantImpl(par_InteractionOperand));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_InteractionOperand.lock())
	{
		wp->getFragment()->push_back(element);
	}
	
	element->setThisStateInvariantPtr(element);
	return element;
	
}
std::shared_ptr<StateInvariant> umlFactoryImpl::createStateInvariant_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<StateInvariantImpl> element(new StateInvariantImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisStateInvariantPtr(element);
	return element;
	
}
std::shared_ptr<StateInvariant> umlFactoryImpl::createStateInvariant_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<StateInvariantImpl> element(new StateInvariantImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisStateInvariantPtr(element);
	return element;
	
}
std::shared_ptr<StateInvariant> umlFactoryImpl::createStateInvariant_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<StateInvariantImpl> element(new StateInvariantImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisStateInvariantPtr(element);
	return element;
	
}
std::shared_ptr<StateInvariant> umlFactoryImpl::createStateInvariant_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<StateInvariantImpl> element(new StateInvariantImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisStateInvariantPtr(element);
	return element;
	
}
std::shared_ptr<StateInvariant> umlFactoryImpl::createStateInvariant_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<StateInvariantImpl> element(new StateInvariantImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisStateInvariantPtr(element);
	return element;
	
}
std::shared_ptr<StateInvariant> umlFactoryImpl::createStateInvariant_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<StateInvariantImpl> element(new StateInvariantImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisStateInvariantPtr(element);
	return element;
	
}
std::shared_ptr<StateInvariant> umlFactoryImpl::createStateInvariant_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<StateInvariantImpl> element(new StateInvariantImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisStateInvariantPtr(element);
	return element;
	
}
std::shared_ptr<StateInvariant> umlFactoryImpl::createStateInvariant_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<StateInvariantImpl> element(new StateInvariantImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisStateInvariantPtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	element->setThisStateMachinePtr(element);
	return element;
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_classifier_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->setClassifier(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_classifierBehavior_in_BehavioredClassifier(std::shared_ptr<BehavioredClassifier> par_BehavioredClassifier, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_BehavioredClassifier)
	{
		par_BehavioredClassifier->setClassifierBehavior(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_context_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->setContext(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_contract_in_Substitution(std::shared_ptr<Substitution> par_Substitution, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Substitution)
	{
		par_Substitution->setContract(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_doActivity_in_State(std::shared_ptr<State> par_State, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_State)
	{
		par_State->setDoActivity(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_effect_in_Transition(std::shared_ptr<Transition> par_Transition, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Transition)
	{
		par_Transition->setEffect(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_endType_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getEndType()->push_back(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_entry_in_State(std::shared_ptr<State> par_State, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_State)
	{
		par_State->setEntry(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_exit_in_State(std::shared_ptr<State> par_State, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_State)
	{
		par_State->setExit(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_general_in_Generalization(std::shared_ptr<Generalization> par_Generalization, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Generalization)
	{
		par_Generalization->setGeneral(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_nestedClassifier_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getNestedClassifier()->push_back(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_nestedClassifier_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getNestedClassifier()->push_back(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_ownedBehavior_in_BehavioredClassifier(std::weak_ptr<uml::BehavioredClassifier> par_BehavioredClassifier, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl(par_BehavioredClassifier));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_BehavioredClassifier.lock())
	{
		wp->getOwnedBehavior()->push_back(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_ownedType_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl(par_Package, uml::umlPackage::TYPE_ATTRIBUTE_PACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getOwnedType()->push_back(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_realizingClassifier_in_ComponentRealization(std::shared_ptr<ComponentRealization> par_ComponentRealization, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ComponentRealization)
	{
		par_ComponentRealization->getRealizingClassifier()->push_back(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_redefinedBehavior_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->getRedefinedBehavior()->push_back(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_redefinedClassifier_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getRedefinedClassifier()->push_back(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<StateMachine> umlFactoryImpl::createStateMachine_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<StateMachineImpl> element(new StateMachineImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisStateMachinePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl());
	element->setMetaElementID(metaElementID);
	element->setThisStereotypePtr(element);
	return element;
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_classifier_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->setClassifier(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_context_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->setContext(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_contract_in_Substitution(std::shared_ptr<Substitution> par_Substitution, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Substitution)
	{
		par_Substitution->setContract(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_endType_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getEndType()->push_back(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_general_in_Generalization(std::shared_ptr<Generalization> par_Generalization, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Generalization)
	{
		par_Generalization->setGeneral(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_nestedClassifier_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getNestedClassifier()->push_back(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_nestedClassifier_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getNestedClassifier()->push_back(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_ownedStereotype_in_Package(std::shared_ptr<Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Package)
	{
		par_Package->getOwnedStereotype()->push_back(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_ownedType_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl(par_Package, uml::umlPackage::TYPE_ATTRIBUTE_PACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getOwnedType()->push_back(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_realizingClassifier_in_ComponentRealization(std::shared_ptr<ComponentRealization> par_ComponentRealization, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ComponentRealization)
	{
		par_ComponentRealization->getRealizingClassifier()->push_back(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_redefinedClassifier_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getRedefinedClassifier()->push_back(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<Stereotype> umlFactoryImpl::createStereotype_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<StereotypeImpl> element(new StereotypeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisStereotypePtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisStringExpressionPtr(element);
	return element;
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_argument_in_Message(std::shared_ptr<Message> par_Message, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Message)
	{
		par_Message->getArgument()->push_back(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_argument_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->getArgument()->push_back(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_changeExpression_in_ChangeEvent(std::shared_ptr<ChangeEvent> par_ChangeEvent, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ChangeEvent)
	{
		par_ChangeEvent->setChangeExpression(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_defaultValue_in_Property(std::shared_ptr<Property> par_Property, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Property)
	{
		par_Property->setDefaultValue(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_defaultValue_in_Parameter(std::shared_ptr<Parameter> par_Parameter, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Parameter)
	{
		par_Parameter->setDefaultValue(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_expr_in_TimeExpression(std::shared_ptr<TimeExpression> par_TimeExpression, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TimeExpression)
	{
		par_TimeExpression->setExpr(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_expr_in_Duration(std::shared_ptr<Duration> par_Duration, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Duration)
	{
		par_Duration->setExpr(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_guard_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setGuard(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_joinSpec_in_JoinNode(std::shared_ptr<JoinNode> par_JoinNode, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_JoinNode)
	{
		par_JoinNode->setJoinSpec(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_lowerValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setLowerValue(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_maxint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMaxint(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_minint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMinint(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_nameExpression_in_NamedElement(std::shared_ptr<NamedElement> par_NamedElement, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_NamedElement)
	{
		par_NamedElement->setNameExpression(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_operand_in_Expression(std::shared_ptr<Expression> par_Expression, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Expression)
	{
		par_Expression->getOperand()->push_back(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_returnValue_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->setReturnValue(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_selector_in_Lifeline(std::shared_ptr<Lifeline> par_Lifeline, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Lifeline)
	{
		par_Lifeline->setSelector(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_specification_in_Constraint(std::shared_ptr<Constraint> par_Constraint, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Constraint)
	{
		par_Constraint->setSpecification(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_specification_in_InstanceSpecification(std::shared_ptr<InstanceSpecification> par_InstanceSpecification, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InstanceSpecification)
	{
		par_InstanceSpecification->setSpecification(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_subExpression_in_StringExpression(std::weak_ptr<uml::StringExpression> par_StringExpression, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl(par_StringExpression));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StringExpression.lock())
	{
		wp->getSubExpression()->push_back(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_upperBound_in_ObjectNode(std::shared_ptr<ObjectNode> par_ObjectNode, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ObjectNode)
	{
		par_ObjectNode->setUpperBound(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_upperValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setUpperValue(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_value_in_Slot(std::weak_ptr<uml::Slot> par_Slot, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl(par_Slot));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Slot.lock())
	{
		wp->getValue()->push_back(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_value_in_ValueSpecificationAction(std::weak_ptr<uml::ValueSpecificationAction> par_ValueSpecificationAction, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl(par_ValueSpecificationAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ValueSpecificationAction.lock())
	{
		wp->setValue(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_value_in_ValuePin(std::shared_ptr<ValuePin> par_ValuePin, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ValuePin)
	{
		par_ValuePin->setValue(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StringExpression> umlFactoryImpl::createStringExpression_as_weight_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<StringExpressionImpl> element(new StringExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setWeight(element);
	}
	
	element->setThisStringExpressionPtr(element);
	return element;
	
}
std::shared_ptr<StructuredActivityNode> umlFactoryImpl::createStructuredActivityNode(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<StructuredActivityNodeImpl> element(new StructuredActivityNodeImpl());
	element->setMetaElementID(metaElementID);
	element->setThisStructuredActivityNodePtr(element);
	return element;
}
std::shared_ptr<StructuredActivityNode> umlFactoryImpl::createStructuredActivityNode_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<StructuredActivityNodeImpl> element(new StructuredActivityNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisStructuredActivityNodePtr(element);
	return element;
	
}
std::shared_ptr<StructuredActivityNode> umlFactoryImpl::createStructuredActivityNode_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<StructuredActivityNodeImpl> element(new StructuredActivityNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisStructuredActivityNodePtr(element);
	return element;
	
}
std::shared_ptr<StructuredActivityNode> umlFactoryImpl::createStructuredActivityNode_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<StructuredActivityNodeImpl> element(new StructuredActivityNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisStructuredActivityNodePtr(element);
	return element;
	
}
std::shared_ptr<StructuredActivityNode> umlFactoryImpl::createStructuredActivityNode_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<StructuredActivityNodeImpl> element(new StructuredActivityNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisStructuredActivityNodePtr(element);
	return element;
	
}
std::shared_ptr<StructuredActivityNode> umlFactoryImpl::createStructuredActivityNode_as_group_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<StructuredActivityNodeImpl> element(new StructuredActivityNodeImpl(par_Activity, uml::umlPackage::ACTIVITYGROUP_ATTRIBUTE_INACTIVITY));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getGroup()->push_back(element);
	}
	
	element->setThisStructuredActivityNodePtr(element);
	return element;
	
}
std::shared_ptr<StructuredActivityNode> umlFactoryImpl::createStructuredActivityNode_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<StructuredActivityNodeImpl> element(new StructuredActivityNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisStructuredActivityNodePtr(element);
	return element;
	
}
std::shared_ptr<StructuredActivityNode> umlFactoryImpl::createStructuredActivityNode_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<StructuredActivityNodeImpl> element(new StructuredActivityNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisStructuredActivityNodePtr(element);
	return element;
	
}
std::shared_ptr<StructuredActivityNode> umlFactoryImpl::createStructuredActivityNode_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<StructuredActivityNodeImpl> element(new StructuredActivityNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisStructuredActivityNodePtr(element);
	return element;
	
}
std::shared_ptr<StructuredActivityNode> umlFactoryImpl::createStructuredActivityNode_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<StructuredActivityNodeImpl> element(new StructuredActivityNodeImpl(par_Activity, uml::umlPackage::ACTIVITYNODE_ATTRIBUTE_ACTIVITY));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisStructuredActivityNodePtr(element);
	return element;
	
}
std::shared_ptr<StructuredActivityNode> umlFactoryImpl::createStructuredActivityNode_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<StructuredActivityNodeImpl> element(new StructuredActivityNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisStructuredActivityNodePtr(element);
	return element;
	
}
std::shared_ptr<StructuredActivityNode> umlFactoryImpl::createStructuredActivityNode_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<StructuredActivityNodeImpl> element(new StructuredActivityNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisStructuredActivityNodePtr(element);
	return element;
	
}
std::shared_ptr<StructuredActivityNode> umlFactoryImpl::createStructuredActivityNode_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<StructuredActivityNodeImpl> element(new StructuredActivityNodeImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisStructuredActivityNodePtr(element);
	return element;
	
}
std::shared_ptr<StructuredActivityNode> umlFactoryImpl::createStructuredActivityNode_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<StructuredActivityNodeImpl> element(new StructuredActivityNodeImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisStructuredActivityNodePtr(element);
	return element;
	
}
std::shared_ptr<StructuredActivityNode> umlFactoryImpl::createStructuredActivityNode_as_ownedGroup_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<StructuredActivityNodeImpl> element(new StructuredActivityNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedGroup()->push_back(element);
	}
	
	element->setThisStructuredActivityNodePtr(element);
	return element;
	
}
std::shared_ptr<StructuredActivityNode> umlFactoryImpl::createStructuredActivityNode_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<StructuredActivityNodeImpl> element(new StructuredActivityNodeImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisStructuredActivityNodePtr(element);
	return element;
	
}
std::shared_ptr<StructuredActivityNode> umlFactoryImpl::createStructuredActivityNode_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<StructuredActivityNodeImpl> element(new StructuredActivityNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisStructuredActivityNodePtr(element);
	return element;
	
}
std::shared_ptr<StructuredActivityNode> umlFactoryImpl::createStructuredActivityNode_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<StructuredActivityNodeImpl> element(new StructuredActivityNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisStructuredActivityNodePtr(element);
	return element;
	
}
std::shared_ptr<StructuredActivityNode> umlFactoryImpl::createStructuredActivityNode_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<StructuredActivityNodeImpl> element(new StructuredActivityNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisStructuredActivityNodePtr(element);
	return element;
	
}
std::shared_ptr<StructuredActivityNode> umlFactoryImpl::createStructuredActivityNode_as_structuredNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<StructuredActivityNodeImpl> element(new StructuredActivityNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getStructuredNode()->push_back(element);
	}
	
	element->setThisStructuredActivityNodePtr(element);
	return element;
	
}
std::shared_ptr<StructuredActivityNode> umlFactoryImpl::createStructuredActivityNode_as_subgroup_in_ActivityGroup(std::weak_ptr<uml::ActivityGroup> par_ActivityGroup, const int metaElementID) const
{
	std::shared_ptr<StructuredActivityNodeImpl> element(new StructuredActivityNodeImpl(par_ActivityGroup));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ActivityGroup.lock())
	{
		wp->getSubgroup()->push_back(element);
	}
	
	element->setThisStructuredActivityNodePtr(element);
	return element;
	
}
std::shared_ptr<StructuredActivityNode> umlFactoryImpl::createStructuredActivityNode_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<StructuredActivityNodeImpl> element(new StructuredActivityNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisStructuredActivityNodePtr(element);
	return element;
	
}
std::shared_ptr<StructuredActivityNode> umlFactoryImpl::createStructuredActivityNode_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<StructuredActivityNodeImpl> element(new StructuredActivityNodeImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisStructuredActivityNodePtr(element);
	return element;
	
}
std::shared_ptr<Substitution> umlFactoryImpl::createSubstitution(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<SubstitutionImpl> element(new SubstitutionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisSubstitutionPtr(element);
	return element;
}
std::shared_ptr<Substitution> umlFactoryImpl::createSubstitution_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<SubstitutionImpl> element(new SubstitutionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisSubstitutionPtr(element);
	return element;
	
}
std::shared_ptr<Substitution> umlFactoryImpl::createSubstitution_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<SubstitutionImpl> element(new SubstitutionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisSubstitutionPtr(element);
	return element;
	
}
std::shared_ptr<Substitution> umlFactoryImpl::createSubstitution_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<SubstitutionImpl> element(new SubstitutionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisSubstitutionPtr(element);
	return element;
	
}
std::shared_ptr<Substitution> umlFactoryImpl::createSubstitution_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<SubstitutionImpl> element(new SubstitutionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisSubstitutionPtr(element);
	return element;
	
}
std::shared_ptr<Substitution> umlFactoryImpl::createSubstitution_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<SubstitutionImpl> element(new SubstitutionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisSubstitutionPtr(element);
	return element;
	
}
std::shared_ptr<Substitution> umlFactoryImpl::createSubstitution_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<SubstitutionImpl> element(new SubstitutionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisSubstitutionPtr(element);
	return element;
	
}
std::shared_ptr<Substitution> umlFactoryImpl::createSubstitution_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<SubstitutionImpl> element(new SubstitutionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisSubstitutionPtr(element);
	return element;
	
}
std::shared_ptr<Substitution> umlFactoryImpl::createSubstitution_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<SubstitutionImpl> element(new SubstitutionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisSubstitutionPtr(element);
	return element;
	
}
std::shared_ptr<Substitution> umlFactoryImpl::createSubstitution_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<SubstitutionImpl> element(new SubstitutionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisSubstitutionPtr(element);
	return element;
	
}
std::shared_ptr<Substitution> umlFactoryImpl::createSubstitution_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<SubstitutionImpl> element(new SubstitutionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisSubstitutionPtr(element);
	return element;
	
}
std::shared_ptr<Substitution> umlFactoryImpl::createSubstitution_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<SubstitutionImpl> element(new SubstitutionImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisSubstitutionPtr(element);
	return element;
	
}
std::shared_ptr<Substitution> umlFactoryImpl::createSubstitution_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<SubstitutionImpl> element(new SubstitutionImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisSubstitutionPtr(element);
	return element;
	
}
std::shared_ptr<Substitution> umlFactoryImpl::createSubstitution_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<SubstitutionImpl> element(new SubstitutionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisSubstitutionPtr(element);
	return element;
	
}
std::shared_ptr<Substitution> umlFactoryImpl::createSubstitution_as_roleBinding_in_CollaborationUse(std::shared_ptr<CollaborationUse> par_CollaborationUse, const int metaElementID) const
{
	std::shared_ptr<SubstitutionImpl> element(new SubstitutionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_CollaborationUse)
	{
		par_CollaborationUse->getRoleBinding()->push_back(element);
	}
	
	element->setThisSubstitutionPtr(element);
	return element;
	
}
std::shared_ptr<Substitution> umlFactoryImpl::createSubstitution_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<SubstitutionImpl> element(new SubstitutionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisSubstitutionPtr(element);
	return element;
	
}
std::shared_ptr<Substitution> umlFactoryImpl::createSubstitution_as_substitution_in_Classifier(std::weak_ptr<uml::Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<SubstitutionImpl> element(new SubstitutionImpl(par_Classifier));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Classifier.lock())
	{
		wp->getSubstitution()->push_back(element);
	}
	
	element->setThisSubstitutionPtr(element);
	return element;
	
}
std::shared_ptr<Substitution> umlFactoryImpl::createSubstitution_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<SubstitutionImpl> element(new SubstitutionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisSubstitutionPtr(element);
	return element;
	
}
std::shared_ptr<Substitution> umlFactoryImpl::createSubstitution_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<SubstitutionImpl> element(new SubstitutionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisSubstitutionPtr(element);
	return element;
	
}
std::shared_ptr<Substitution> umlFactoryImpl::createSubstitution_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<SubstitutionImpl> element(new SubstitutionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisSubstitutionPtr(element);
	return element;
	
}
std::shared_ptr<TemplateBinding> umlFactoryImpl::createTemplateBinding(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<TemplateBindingImpl> element(new TemplateBindingImpl());
	element->setMetaElementID(metaElementID);
	element->setThisTemplateBindingPtr(element);
	return element;
}
std::shared_ptr<TemplateBinding> umlFactoryImpl::createTemplateBinding_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<TemplateBindingImpl> element(new TemplateBindingImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisTemplateBindingPtr(element);
	return element;
	
}
std::shared_ptr<TemplateBinding> umlFactoryImpl::createTemplateBinding_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<TemplateBindingImpl> element(new TemplateBindingImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisTemplateBindingPtr(element);
	return element;
	
}
std::shared_ptr<TemplateBinding> umlFactoryImpl::createTemplateBinding_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<TemplateBindingImpl> element(new TemplateBindingImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisTemplateBindingPtr(element);
	return element;
	
}
std::shared_ptr<TemplateBinding> umlFactoryImpl::createTemplateBinding_as_templateBinding_in_TemplateableElement(std::weak_ptr<uml::TemplateableElement> par_TemplateableElement, const int metaElementID) const
{
	std::shared_ptr<TemplateBindingImpl> element(new TemplateBindingImpl(par_TemplateableElement));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateableElement.lock())
	{
		wp->getTemplateBinding()->push_back(element);
	}
	
	element->setThisTemplateBindingPtr(element);
	return element;
	
}
std::shared_ptr<TemplateParameter> umlFactoryImpl::createTemplateParameter(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<TemplateParameterImpl> element(new TemplateParameterImpl());
	element->setMetaElementID(metaElementID);
	element->setThisTemplateParameterPtr(element);
	return element;
}
std::shared_ptr<TemplateParameter> umlFactoryImpl::createTemplateParameter_as_inheritedParameter_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<TemplateParameterImpl> element(new TemplateParameterImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->getInheritedParameter()->push_back(element);
	}
	
	element->setThisTemplateParameterPtr(element);
	return element;
	
}
std::shared_ptr<TemplateParameter> umlFactoryImpl::createTemplateParameter_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<TemplateParameterImpl> element(new TemplateParameterImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisTemplateParameterPtr(element);
	return element;
	
}
std::shared_ptr<TemplateParameter> umlFactoryImpl::createTemplateParameter_as_ownedParameter_in_TemplateSignature(std::weak_ptr<uml::TemplateSignature> par_TemplateSignature, const int metaElementID) const
{
	std::shared_ptr<TemplateParameterImpl> element(new TemplateParameterImpl(par_TemplateSignature));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateSignature.lock())
	{
		wp->getOwnedParameter()->push_back(element);
	}
	
	element->setThisTemplateParameterPtr(element);
	return element;
	
}
std::shared_ptr<TemplateParameter> umlFactoryImpl::createTemplateParameter_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<TemplateParameterImpl> element(new TemplateParameterImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisTemplateParameterPtr(element);
	return element;
	
}
std::shared_ptr<TemplateParameter> umlFactoryImpl::createTemplateParameter_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<TemplateParameterImpl> element(new TemplateParameterImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisTemplateParameterPtr(element);
	return element;
	
}
std::shared_ptr<TemplateParameterSubstitution> umlFactoryImpl::createTemplateParameterSubstitution(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<TemplateParameterSubstitutionImpl> element(new TemplateParameterSubstitutionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisTemplateParameterSubstitutionPtr(element);
	return element;
}
std::shared_ptr<TemplateParameterSubstitution> umlFactoryImpl::createTemplateParameterSubstitution_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<TemplateParameterSubstitutionImpl> element(new TemplateParameterSubstitutionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisTemplateParameterSubstitutionPtr(element);
	return element;
	
}
std::shared_ptr<TemplateParameterSubstitution> umlFactoryImpl::createTemplateParameterSubstitution_as_parameterSubstitution_in_TemplateBinding(std::weak_ptr<uml::TemplateBinding> par_TemplateBinding, const int metaElementID) const
{
	std::shared_ptr<TemplateParameterSubstitutionImpl> element(new TemplateParameterSubstitutionImpl(par_TemplateBinding));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateBinding.lock())
	{
		wp->getParameterSubstitution()->push_back(element);
	}
	
	element->setThisTemplateParameterSubstitutionPtr(element);
	return element;
	
}
std::shared_ptr<TemplateParameterSubstitution> umlFactoryImpl::createTemplateParameterSubstitution_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<TemplateParameterSubstitutionImpl> element(new TemplateParameterSubstitutionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisTemplateParameterSubstitutionPtr(element);
	return element;
	
}
std::shared_ptr<TemplateParameterSubstitution> umlFactoryImpl::createTemplateParameterSubstitution_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<TemplateParameterSubstitutionImpl> element(new TemplateParameterSubstitutionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisTemplateParameterSubstitutionPtr(element);
	return element;
	
}
std::shared_ptr<TemplateSignature> umlFactoryImpl::createTemplateSignature(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<TemplateSignatureImpl> element(new TemplateSignatureImpl());
	element->setMetaElementID(metaElementID);
	element->setThisTemplateSignaturePtr(element);
	return element;
}
std::shared_ptr<TemplateSignature> umlFactoryImpl::createTemplateSignature_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<TemplateSignatureImpl> element(new TemplateSignatureImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisTemplateSignaturePtr(element);
	return element;
	
}
std::shared_ptr<TemplateSignature> umlFactoryImpl::createTemplateSignature_as_ownedTemplateSignature_in_TemplateableElement(std::weak_ptr<uml::TemplateableElement> par_TemplateableElement, const int metaElementID) const
{
	std::shared_ptr<TemplateSignatureImpl> element(new TemplateSignatureImpl(par_TemplateableElement));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateableElement.lock())
	{
		wp->setOwnedTemplateSignature(element);
	}
	
	element->setThisTemplateSignaturePtr(element);
	return element;
	
}
std::shared_ptr<TemplateSignature> umlFactoryImpl::createTemplateSignature_as_signature_in_TemplateBinding(std::shared_ptr<TemplateBinding> par_TemplateBinding, const int metaElementID) const
{
	std::shared_ptr<TemplateSignatureImpl> element(new TemplateSignatureImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateBinding)
	{
		par_TemplateBinding->setSignature(element);
	}
	
	element->setThisTemplateSignaturePtr(element);
	return element;
	
}
std::shared_ptr<TemplateSignature> umlFactoryImpl::createTemplateSignature_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<TemplateSignatureImpl> element(new TemplateSignatureImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisTemplateSignaturePtr(element);
	return element;
	
}
std::shared_ptr<TemplateSignature> umlFactoryImpl::createTemplateSignature_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<TemplateSignatureImpl> element(new TemplateSignatureImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisTemplateSignaturePtr(element);
	return element;
	
}
std::shared_ptr<TestIdentityAction> umlFactoryImpl::createTestIdentityAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<TestIdentityActionImpl> element(new TestIdentityActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisTestIdentityActionPtr(element);
	return element;
}
std::shared_ptr<TestIdentityAction> umlFactoryImpl::createTestIdentityAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<TestIdentityActionImpl> element(new TestIdentityActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisTestIdentityActionPtr(element);
	return element;
	
}
std::shared_ptr<TestIdentityAction> umlFactoryImpl::createTestIdentityAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<TestIdentityActionImpl> element(new TestIdentityActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisTestIdentityActionPtr(element);
	return element;
	
}
std::shared_ptr<TestIdentityAction> umlFactoryImpl::createTestIdentityAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<TestIdentityActionImpl> element(new TestIdentityActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisTestIdentityActionPtr(element);
	return element;
	
}
std::shared_ptr<TestIdentityAction> umlFactoryImpl::createTestIdentityAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<TestIdentityActionImpl> element(new TestIdentityActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisTestIdentityActionPtr(element);
	return element;
	
}
std::shared_ptr<TestIdentityAction> umlFactoryImpl::createTestIdentityAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<TestIdentityActionImpl> element(new TestIdentityActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisTestIdentityActionPtr(element);
	return element;
	
}
std::shared_ptr<TestIdentityAction> umlFactoryImpl::createTestIdentityAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<TestIdentityActionImpl> element(new TestIdentityActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisTestIdentityActionPtr(element);
	return element;
	
}
std::shared_ptr<TestIdentityAction> umlFactoryImpl::createTestIdentityAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<TestIdentityActionImpl> element(new TestIdentityActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisTestIdentityActionPtr(element);
	return element;
	
}
std::shared_ptr<TestIdentityAction> umlFactoryImpl::createTestIdentityAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<TestIdentityActionImpl> element(new TestIdentityActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisTestIdentityActionPtr(element);
	return element;
	
}
std::shared_ptr<TestIdentityAction> umlFactoryImpl::createTestIdentityAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<TestIdentityActionImpl> element(new TestIdentityActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisTestIdentityActionPtr(element);
	return element;
	
}
std::shared_ptr<TestIdentityAction> umlFactoryImpl::createTestIdentityAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<TestIdentityActionImpl> element(new TestIdentityActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisTestIdentityActionPtr(element);
	return element;
	
}
std::shared_ptr<TestIdentityAction> umlFactoryImpl::createTestIdentityAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<TestIdentityActionImpl> element(new TestIdentityActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisTestIdentityActionPtr(element);
	return element;
	
}
std::shared_ptr<TestIdentityAction> umlFactoryImpl::createTestIdentityAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<TestIdentityActionImpl> element(new TestIdentityActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisTestIdentityActionPtr(element);
	return element;
	
}
std::shared_ptr<TestIdentityAction> umlFactoryImpl::createTestIdentityAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<TestIdentityActionImpl> element(new TestIdentityActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisTestIdentityActionPtr(element);
	return element;
	
}
std::shared_ptr<TestIdentityAction> umlFactoryImpl::createTestIdentityAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<TestIdentityActionImpl> element(new TestIdentityActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisTestIdentityActionPtr(element);
	return element;
	
}
std::shared_ptr<TestIdentityAction> umlFactoryImpl::createTestIdentityAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<TestIdentityActionImpl> element(new TestIdentityActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisTestIdentityActionPtr(element);
	return element;
	
}
std::shared_ptr<TestIdentityAction> umlFactoryImpl::createTestIdentityAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<TestIdentityActionImpl> element(new TestIdentityActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisTestIdentityActionPtr(element);
	return element;
	
}
std::shared_ptr<TestIdentityAction> umlFactoryImpl::createTestIdentityAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<TestIdentityActionImpl> element(new TestIdentityActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisTestIdentityActionPtr(element);
	return element;
	
}
std::shared_ptr<TestIdentityAction> umlFactoryImpl::createTestIdentityAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<TestIdentityActionImpl> element(new TestIdentityActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisTestIdentityActionPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	element->setThisTimeConstraintPtr(element);
	return element;
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_bodyCondition_in_Operation(std::shared_ptr<Operation> par_Operation, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Operation)
	{
		par_Operation->setBodyCondition(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_condition_in_ParameterSet(std::shared_ptr<ParameterSet> par_ParameterSet, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ParameterSet)
	{
		par_ParameterSet->getCondition()->push_back(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_condition_in_Extend(std::shared_ptr<Extend> par_Extend, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Extend)
	{
		par_Extend->setCondition(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_guard_in_Transition(std::shared_ptr<Transition> par_Transition, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Transition)
	{
		par_Transition->setGuard(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_invariant_in_StateInvariant(std::shared_ptr<StateInvariant> par_StateInvariant, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_StateInvariant)
	{
		par_StateInvariant->setInvariant(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_localPostcondition_in_Action(std::shared_ptr<Action> par_Action, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Action)
	{
		par_Action->getLocalPostcondition()->push_back(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_localPrecondition_in_Action(std::shared_ptr<Action> par_Action, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Action)
	{
		par_Action->getLocalPrecondition()->push_back(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl(par_Namespace, uml::umlPackage::NAMEDELEMENT_ATTRIBUTE_NAMESPACE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_ownedRule_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl(par_Namespace, uml::umlPackage::CONSTRAINT_ATTRIBUTE_CONTEXT));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedRule()->push_back(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_postCondition_in_ProtocolTransition(std::shared_ptr<ProtocolTransition> par_ProtocolTransition, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ProtocolTransition)
	{
		par_ProtocolTransition->setPostCondition(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_postcondition_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->getPostcondition()->push_back(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_postcondition_in_Operation(std::shared_ptr<Operation> par_Operation, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Operation)
	{
		par_Operation->getPostcondition()->push_back(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_preCondition_in_ProtocolTransition(std::shared_ptr<ProtocolTransition> par_ProtocolTransition, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ProtocolTransition)
	{
		par_ProtocolTransition->setPreCondition(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_precondition_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->getPrecondition()->push_back(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_precondition_in_Operation(std::shared_ptr<Operation> par_Operation, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Operation)
	{
		par_Operation->getPrecondition()->push_back(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_stateInvariant_in_State(std::shared_ptr<State> par_State, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_State)
	{
		par_State->setStateInvariant(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeConstraint> umlFactoryImpl::createTimeConstraint_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<TimeConstraintImpl> element(new TimeConstraintImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisTimeConstraintPtr(element);
	return element;
	
}
std::shared_ptr<TimeEvent> umlFactoryImpl::createTimeEvent(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<TimeEventImpl> element(new TimeEventImpl());
	element->setMetaElementID(metaElementID);
	element->setThisTimeEventPtr(element);
	return element;
}
std::shared_ptr<TimeEvent> umlFactoryImpl::createTimeEvent_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<TimeEventImpl> element(new TimeEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisTimeEventPtr(element);
	return element;
	
}
std::shared_ptr<TimeEvent> umlFactoryImpl::createTimeEvent_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<TimeEventImpl> element(new TimeEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisTimeEventPtr(element);
	return element;
	
}
std::shared_ptr<TimeEvent> umlFactoryImpl::createTimeEvent_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<TimeEventImpl> element(new TimeEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisTimeEventPtr(element);
	return element;
	
}
std::shared_ptr<TimeEvent> umlFactoryImpl::createTimeEvent_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<TimeEventImpl> element(new TimeEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisTimeEventPtr(element);
	return element;
	
}
std::shared_ptr<TimeEvent> umlFactoryImpl::createTimeEvent_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<TimeEventImpl> element(new TimeEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisTimeEventPtr(element);
	return element;
	
}
std::shared_ptr<TimeEvent> umlFactoryImpl::createTimeEvent_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<TimeEventImpl> element(new TimeEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisTimeEventPtr(element);
	return element;
	
}
std::shared_ptr<TimeEvent> umlFactoryImpl::createTimeEvent_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<TimeEventImpl> element(new TimeEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisTimeEventPtr(element);
	return element;
	
}
std::shared_ptr<TimeEvent> umlFactoryImpl::createTimeEvent_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<TimeEventImpl> element(new TimeEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisTimeEventPtr(element);
	return element;
	
}
std::shared_ptr<TimeEvent> umlFactoryImpl::createTimeEvent_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<TimeEventImpl> element(new TimeEventImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisTimeEventPtr(element);
	return element;
	
}
std::shared_ptr<TimeEvent> umlFactoryImpl::createTimeEvent_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<TimeEventImpl> element(new TimeEventImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisTimeEventPtr(element);
	return element;
	
}
std::shared_ptr<TimeEvent> umlFactoryImpl::createTimeEvent_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<TimeEventImpl> element(new TimeEventImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisTimeEventPtr(element);
	return element;
	
}
std::shared_ptr<TimeEvent> umlFactoryImpl::createTimeEvent_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<TimeEventImpl> element(new TimeEventImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisTimeEventPtr(element);
	return element;
	
}
std::shared_ptr<TimeEvent> umlFactoryImpl::createTimeEvent_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<TimeEventImpl> element(new TimeEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisTimeEventPtr(element);
	return element;
	
}
std::shared_ptr<TimeEvent> umlFactoryImpl::createTimeEvent_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<TimeEventImpl> element(new TimeEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisTimeEventPtr(element);
	return element;
	
}
std::shared_ptr<TimeEvent> umlFactoryImpl::createTimeEvent_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<TimeEventImpl> element(new TimeEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisTimeEventPtr(element);
	return element;
	
}
std::shared_ptr<TimeEvent> umlFactoryImpl::createTimeEvent_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<TimeEventImpl> element(new TimeEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisTimeEventPtr(element);
	return element;
	
}
std::shared_ptr<TimeEvent> umlFactoryImpl::createTimeEvent_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<TimeEventImpl> element(new TimeEventImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisTimeEventPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisTimeExpressionPtr(element);
	return element;
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_argument_in_Message(std::shared_ptr<Message> par_Message, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Message)
	{
		par_Message->getArgument()->push_back(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_argument_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->getArgument()->push_back(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_changeExpression_in_ChangeEvent(std::shared_ptr<ChangeEvent> par_ChangeEvent, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ChangeEvent)
	{
		par_ChangeEvent->setChangeExpression(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_defaultValue_in_Property(std::shared_ptr<Property> par_Property, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Property)
	{
		par_Property->setDefaultValue(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_defaultValue_in_Parameter(std::shared_ptr<Parameter> par_Parameter, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Parameter)
	{
		par_Parameter->setDefaultValue(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_expr_in_TimeExpression(std::shared_ptr<TimeExpression> par_TimeExpression, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TimeExpression)
	{
		par_TimeExpression->setExpr(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_expr_in_Duration(std::shared_ptr<Duration> par_Duration, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Duration)
	{
		par_Duration->setExpr(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_guard_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setGuard(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_joinSpec_in_JoinNode(std::shared_ptr<JoinNode> par_JoinNode, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_JoinNode)
	{
		par_JoinNode->setJoinSpec(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_lowerValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setLowerValue(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_maxint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMaxint(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_minint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMinint(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_operand_in_Expression(std::shared_ptr<Expression> par_Expression, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Expression)
	{
		par_Expression->getOperand()->push_back(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_returnValue_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->setReturnValue(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_selector_in_Lifeline(std::shared_ptr<Lifeline> par_Lifeline, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Lifeline)
	{
		par_Lifeline->setSelector(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_specification_in_Constraint(std::shared_ptr<Constraint> par_Constraint, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Constraint)
	{
		par_Constraint->setSpecification(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_specification_in_InstanceSpecification(std::shared_ptr<InstanceSpecification> par_InstanceSpecification, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InstanceSpecification)
	{
		par_InstanceSpecification->setSpecification(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_upperBound_in_ObjectNode(std::shared_ptr<ObjectNode> par_ObjectNode, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ObjectNode)
	{
		par_ObjectNode->setUpperBound(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_upperValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setUpperValue(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_value_in_Slot(std::weak_ptr<uml::Slot> par_Slot, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl(par_Slot));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Slot.lock())
	{
		wp->getValue()->push_back(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_value_in_ValueSpecificationAction(std::weak_ptr<uml::ValueSpecificationAction> par_ValueSpecificationAction, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl(par_ValueSpecificationAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ValueSpecificationAction.lock())
	{
		wp->setValue(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_value_in_ValuePin(std::shared_ptr<ValuePin> par_ValuePin, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ValuePin)
	{
		par_ValuePin->setValue(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_weight_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setWeight(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeExpression> umlFactoryImpl::createTimeExpression_as_when_in_TimeEvent(std::shared_ptr<TimeEvent> par_TimeEvent, const int metaElementID) const
{
	std::shared_ptr<TimeExpressionImpl> element(new TimeExpressionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TimeEvent)
	{
		par_TimeEvent->setWhen(element);
	}
	
	element->setThisTimeExpressionPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	element->setThisTimeIntervalPtr(element);
	return element;
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_argument_in_Message(std::shared_ptr<Message> par_Message, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Message)
	{
		par_Message->getArgument()->push_back(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_argument_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->getArgument()->push_back(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_changeExpression_in_ChangeEvent(std::shared_ptr<ChangeEvent> par_ChangeEvent, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ChangeEvent)
	{
		par_ChangeEvent->setChangeExpression(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_defaultValue_in_Property(std::shared_ptr<Property> par_Property, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Property)
	{
		par_Property->setDefaultValue(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_defaultValue_in_Parameter(std::shared_ptr<Parameter> par_Parameter, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Parameter)
	{
		par_Parameter->setDefaultValue(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_expr_in_TimeExpression(std::shared_ptr<TimeExpression> par_TimeExpression, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TimeExpression)
	{
		par_TimeExpression->setExpr(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_expr_in_Duration(std::shared_ptr<Duration> par_Duration, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Duration)
	{
		par_Duration->setExpr(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_guard_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setGuard(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_joinSpec_in_JoinNode(std::shared_ptr<JoinNode> par_JoinNode, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_JoinNode)
	{
		par_JoinNode->setJoinSpec(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_lowerValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setLowerValue(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_maxint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMaxint(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_minint_in_InteractionConstraint(std::shared_ptr<InteractionConstraint> par_InteractionConstraint, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionConstraint)
	{
		par_InteractionConstraint->setMinint(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_operand_in_Expression(std::shared_ptr<Expression> par_Expression, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Expression)
	{
		par_Expression->getOperand()->push_back(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_returnValue_in_InteractionUse(std::shared_ptr<InteractionUse> par_InteractionUse, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InteractionUse)
	{
		par_InteractionUse->setReturnValue(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_selector_in_Lifeline(std::shared_ptr<Lifeline> par_Lifeline, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Lifeline)
	{
		par_Lifeline->setSelector(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_specification_in_Constraint(std::shared_ptr<Constraint> par_Constraint, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Constraint)
	{
		par_Constraint->setSpecification(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_specification_in_InstanceSpecification(std::shared_ptr<InstanceSpecification> par_InstanceSpecification, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InstanceSpecification)
	{
		par_InstanceSpecification->setSpecification(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_upperBound_in_ObjectNode(std::shared_ptr<ObjectNode> par_ObjectNode, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ObjectNode)
	{
		par_ObjectNode->setUpperBound(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_upperValue_in_MultiplicityElement(std::shared_ptr<MultiplicityElement> par_MultiplicityElement, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_MultiplicityElement)
	{
		par_MultiplicityElement->setUpperValue(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_value_in_Slot(std::weak_ptr<uml::Slot> par_Slot, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl(par_Slot));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Slot.lock())
	{
		wp->getValue()->push_back(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_value_in_ValueSpecificationAction(std::weak_ptr<uml::ValueSpecificationAction> par_ValueSpecificationAction, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl(par_ValueSpecificationAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_ValueSpecificationAction.lock())
	{
		wp->setValue(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_value_in_ValuePin(std::shared_ptr<ValuePin> par_ValuePin, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ValuePin)
	{
		par_ValuePin->setValue(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeInterval> umlFactoryImpl::createTimeInterval_as_weight_in_ActivityEdge(std::shared_ptr<ActivityEdge> par_ActivityEdge, const int metaElementID) const
{
	std::shared_ptr<TimeIntervalImpl> element(new TimeIntervalImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityEdge)
	{
		par_ActivityEdge->setWeight(element);
	}
	
	element->setThisTimeIntervalPtr(element);
	return element;
	
}
std::shared_ptr<TimeObservation> umlFactoryImpl::createTimeObservation(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<TimeObservationImpl> element(new TimeObservationImpl());
	element->setMetaElementID(metaElementID);
	element->setThisTimeObservationPtr(element);
	return element;
}
std::shared_ptr<TimeObservation> umlFactoryImpl::createTimeObservation_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<TimeObservationImpl> element(new TimeObservationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisTimeObservationPtr(element);
	return element;
	
}
std::shared_ptr<TimeObservation> umlFactoryImpl::createTimeObservation_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<TimeObservationImpl> element(new TimeObservationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisTimeObservationPtr(element);
	return element;
	
}
std::shared_ptr<TimeObservation> umlFactoryImpl::createTimeObservation_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<TimeObservationImpl> element(new TimeObservationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisTimeObservationPtr(element);
	return element;
	
}
std::shared_ptr<TimeObservation> umlFactoryImpl::createTimeObservation_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<TimeObservationImpl> element(new TimeObservationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisTimeObservationPtr(element);
	return element;
	
}
std::shared_ptr<TimeObservation> umlFactoryImpl::createTimeObservation_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<TimeObservationImpl> element(new TimeObservationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisTimeObservationPtr(element);
	return element;
	
}
std::shared_ptr<TimeObservation> umlFactoryImpl::createTimeObservation_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<TimeObservationImpl> element(new TimeObservationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisTimeObservationPtr(element);
	return element;
	
}
std::shared_ptr<TimeObservation> umlFactoryImpl::createTimeObservation_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<TimeObservationImpl> element(new TimeObservationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisTimeObservationPtr(element);
	return element;
	
}
std::shared_ptr<TimeObservation> umlFactoryImpl::createTimeObservation_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<TimeObservationImpl> element(new TimeObservationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisTimeObservationPtr(element);
	return element;
	
}
std::shared_ptr<TimeObservation> umlFactoryImpl::createTimeObservation_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<TimeObservationImpl> element(new TimeObservationImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisTimeObservationPtr(element);
	return element;
	
}
std::shared_ptr<TimeObservation> umlFactoryImpl::createTimeObservation_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<TimeObservationImpl> element(new TimeObservationImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisTimeObservationPtr(element);
	return element;
	
}
std::shared_ptr<TimeObservation> umlFactoryImpl::createTimeObservation_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<TimeObservationImpl> element(new TimeObservationImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisTimeObservationPtr(element);
	return element;
	
}
std::shared_ptr<TimeObservation> umlFactoryImpl::createTimeObservation_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<TimeObservationImpl> element(new TimeObservationImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisTimeObservationPtr(element);
	return element;
	
}
std::shared_ptr<TimeObservation> umlFactoryImpl::createTimeObservation_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<TimeObservationImpl> element(new TimeObservationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisTimeObservationPtr(element);
	return element;
	
}
std::shared_ptr<TimeObservation> umlFactoryImpl::createTimeObservation_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<TimeObservationImpl> element(new TimeObservationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisTimeObservationPtr(element);
	return element;
	
}
std::shared_ptr<TimeObservation> umlFactoryImpl::createTimeObservation_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<TimeObservationImpl> element(new TimeObservationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisTimeObservationPtr(element);
	return element;
	
}
std::shared_ptr<TimeObservation> umlFactoryImpl::createTimeObservation_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<TimeObservationImpl> element(new TimeObservationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisTimeObservationPtr(element);
	return element;
	
}
std::shared_ptr<TimeObservation> umlFactoryImpl::createTimeObservation_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<TimeObservationImpl> element(new TimeObservationImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisTimeObservationPtr(element);
	return element;
	
}
std::shared_ptr<Transition> umlFactoryImpl::createTransition(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<TransitionImpl> element(new TransitionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisTransitionPtr(element);
	return element;
}
std::shared_ptr<Transition> umlFactoryImpl::createTransition_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<TransitionImpl> element(new TransitionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisTransitionPtr(element);
	return element;
	
}
std::shared_ptr<Transition> umlFactoryImpl::createTransition_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<TransitionImpl> element(new TransitionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisTransitionPtr(element);
	return element;
	
}
std::shared_ptr<Transition> umlFactoryImpl::createTransition_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<TransitionImpl> element(new TransitionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisTransitionPtr(element);
	return element;
	
}
std::shared_ptr<Transition> umlFactoryImpl::createTransition_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<TransitionImpl> element(new TransitionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisTransitionPtr(element);
	return element;
	
}
std::shared_ptr<Transition> umlFactoryImpl::createTransition_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<TransitionImpl> element(new TransitionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisTransitionPtr(element);
	return element;
	
}
std::shared_ptr<Transition> umlFactoryImpl::createTransition_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<TransitionImpl> element(new TransitionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisTransitionPtr(element);
	return element;
	
}
std::shared_ptr<Transition> umlFactoryImpl::createTransition_as_redefinedTransition_in_Transition(std::shared_ptr<Transition> par_Transition, const int metaElementID) const
{
	std::shared_ptr<TransitionImpl> element(new TransitionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Transition)
	{
		par_Transition->setRedefinedTransition(element);
	}
	
	element->setThisTransitionPtr(element);
	return element;
	
}
std::shared_ptr<Transition> umlFactoryImpl::createTransition_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<TransitionImpl> element(new TransitionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisTransitionPtr(element);
	return element;
	
}
std::shared_ptr<Transition> umlFactoryImpl::createTransition_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<TransitionImpl> element(new TransitionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisTransitionPtr(element);
	return element;
	
}
std::shared_ptr<Transition> umlFactoryImpl::createTransition_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<TransitionImpl> element(new TransitionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisTransitionPtr(element);
	return element;
	
}
std::shared_ptr<Transition> umlFactoryImpl::createTransition_as_transition_in_Region(std::weak_ptr<uml::Region> par_Region, const int metaElementID) const
{
	std::shared_ptr<TransitionImpl> element(new TransitionImpl(par_Region));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Region.lock())
	{
		wp->getTransition()->push_back(element);
	}
	
	element->setThisTransitionPtr(element);
	return element;
	
}
std::shared_ptr<Trigger> umlFactoryImpl::createTrigger(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<TriggerImpl> element(new TriggerImpl());
	element->setMetaElementID(metaElementID);
	element->setThisTriggerPtr(element);
	return element;
}
std::shared_ptr<Trigger> umlFactoryImpl::createTrigger_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<TriggerImpl> element(new TriggerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisTriggerPtr(element);
	return element;
	
}
std::shared_ptr<Trigger> umlFactoryImpl::createTrigger_as_deferrableTrigger_in_State(std::shared_ptr<State> par_State, const int metaElementID) const
{
	std::shared_ptr<TriggerImpl> element(new TriggerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_State)
	{
		par_State->getDeferrableTrigger()->push_back(element);
	}
	
	element->setThisTriggerPtr(element);
	return element;
	
}
std::shared_ptr<Trigger> umlFactoryImpl::createTrigger_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<TriggerImpl> element(new TriggerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisTriggerPtr(element);
	return element;
	
}
std::shared_ptr<Trigger> umlFactoryImpl::createTrigger_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<TriggerImpl> element(new TriggerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisTriggerPtr(element);
	return element;
	
}
std::shared_ptr<Trigger> umlFactoryImpl::createTrigger_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<TriggerImpl> element(new TriggerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisTriggerPtr(element);
	return element;
	
}
std::shared_ptr<Trigger> umlFactoryImpl::createTrigger_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<TriggerImpl> element(new TriggerImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisTriggerPtr(element);
	return element;
	
}
std::shared_ptr<Trigger> umlFactoryImpl::createTrigger_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<TriggerImpl> element(new TriggerImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisTriggerPtr(element);
	return element;
	
}
std::shared_ptr<Trigger> umlFactoryImpl::createTrigger_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<TriggerImpl> element(new TriggerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisTriggerPtr(element);
	return element;
	
}
std::shared_ptr<Trigger> umlFactoryImpl::createTrigger_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<TriggerImpl> element(new TriggerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisTriggerPtr(element);
	return element;
	
}
std::shared_ptr<Trigger> umlFactoryImpl::createTrigger_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<TriggerImpl> element(new TriggerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisTriggerPtr(element);
	return element;
	
}
std::shared_ptr<Trigger> umlFactoryImpl::createTrigger_as_trigger_in_Transition(std::shared_ptr<Transition> par_Transition, const int metaElementID) const
{
	std::shared_ptr<TriggerImpl> element(new TriggerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Transition)
	{
		par_Transition->getTrigger()->push_back(element);
	}
	
	element->setThisTriggerPtr(element);
	return element;
	
}
std::shared_ptr<Trigger> umlFactoryImpl::createTrigger_as_trigger_in_AcceptEventAction(std::shared_ptr<AcceptEventAction> par_AcceptEventAction, const int metaElementID) const
{
	std::shared_ptr<TriggerImpl> element(new TriggerImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_AcceptEventAction)
	{
		par_AcceptEventAction->getTrigger()->push_back(element);
	}
	
	element->setThisTriggerPtr(element);
	return element;
	
}
std::shared_ptr<UnmarshallAction> umlFactoryImpl::createUnmarshallAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<UnmarshallActionImpl> element(new UnmarshallActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisUnmarshallActionPtr(element);
	return element;
}
std::shared_ptr<UnmarshallAction> umlFactoryImpl::createUnmarshallAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<UnmarshallActionImpl> element(new UnmarshallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisUnmarshallActionPtr(element);
	return element;
	
}
std::shared_ptr<UnmarshallAction> umlFactoryImpl::createUnmarshallAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<UnmarshallActionImpl> element(new UnmarshallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisUnmarshallActionPtr(element);
	return element;
	
}
std::shared_ptr<UnmarshallAction> umlFactoryImpl::createUnmarshallAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<UnmarshallActionImpl> element(new UnmarshallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisUnmarshallActionPtr(element);
	return element;
	
}
std::shared_ptr<UnmarshallAction> umlFactoryImpl::createUnmarshallAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<UnmarshallActionImpl> element(new UnmarshallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisUnmarshallActionPtr(element);
	return element;
	
}
std::shared_ptr<UnmarshallAction> umlFactoryImpl::createUnmarshallAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<UnmarshallActionImpl> element(new UnmarshallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisUnmarshallActionPtr(element);
	return element;
	
}
std::shared_ptr<UnmarshallAction> umlFactoryImpl::createUnmarshallAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<UnmarshallActionImpl> element(new UnmarshallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisUnmarshallActionPtr(element);
	return element;
	
}
std::shared_ptr<UnmarshallAction> umlFactoryImpl::createUnmarshallAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<UnmarshallActionImpl> element(new UnmarshallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisUnmarshallActionPtr(element);
	return element;
	
}
std::shared_ptr<UnmarshallAction> umlFactoryImpl::createUnmarshallAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<UnmarshallActionImpl> element(new UnmarshallActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisUnmarshallActionPtr(element);
	return element;
	
}
std::shared_ptr<UnmarshallAction> umlFactoryImpl::createUnmarshallAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<UnmarshallActionImpl> element(new UnmarshallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisUnmarshallActionPtr(element);
	return element;
	
}
std::shared_ptr<UnmarshallAction> umlFactoryImpl::createUnmarshallAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<UnmarshallActionImpl> element(new UnmarshallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisUnmarshallActionPtr(element);
	return element;
	
}
std::shared_ptr<UnmarshallAction> umlFactoryImpl::createUnmarshallAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<UnmarshallActionImpl> element(new UnmarshallActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisUnmarshallActionPtr(element);
	return element;
	
}
std::shared_ptr<UnmarshallAction> umlFactoryImpl::createUnmarshallAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<UnmarshallActionImpl> element(new UnmarshallActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisUnmarshallActionPtr(element);
	return element;
	
}
std::shared_ptr<UnmarshallAction> umlFactoryImpl::createUnmarshallAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<UnmarshallActionImpl> element(new UnmarshallActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisUnmarshallActionPtr(element);
	return element;
	
}
std::shared_ptr<UnmarshallAction> umlFactoryImpl::createUnmarshallAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<UnmarshallActionImpl> element(new UnmarshallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisUnmarshallActionPtr(element);
	return element;
	
}
std::shared_ptr<UnmarshallAction> umlFactoryImpl::createUnmarshallAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<UnmarshallActionImpl> element(new UnmarshallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisUnmarshallActionPtr(element);
	return element;
	
}
std::shared_ptr<UnmarshallAction> umlFactoryImpl::createUnmarshallAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<UnmarshallActionImpl> element(new UnmarshallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisUnmarshallActionPtr(element);
	return element;
	
}
std::shared_ptr<UnmarshallAction> umlFactoryImpl::createUnmarshallAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<UnmarshallActionImpl> element(new UnmarshallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisUnmarshallActionPtr(element);
	return element;
	
}
std::shared_ptr<UnmarshallAction> umlFactoryImpl::createUnmarshallAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<UnmarshallActionImpl> element(new UnmarshallActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisUnmarshallActionPtr(element);
	return element;
	
}
std::shared_ptr<Usage> umlFactoryImpl::createUsage(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<UsageImpl> element(new UsageImpl());
	element->setMetaElementID(metaElementID);
	element->setThisUsagePtr(element);
	return element;
}
std::shared_ptr<Usage> umlFactoryImpl::createUsage_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<UsageImpl> element(new UsageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisUsagePtr(element);
	return element;
	
}
std::shared_ptr<Usage> umlFactoryImpl::createUsage_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<UsageImpl> element(new UsageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisUsagePtr(element);
	return element;
	
}
std::shared_ptr<Usage> umlFactoryImpl::createUsage_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<UsageImpl> element(new UsageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisUsagePtr(element);
	return element;
	
}
std::shared_ptr<Usage> umlFactoryImpl::createUsage_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<UsageImpl> element(new UsageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisUsagePtr(element);
	return element;
	
}
std::shared_ptr<Usage> umlFactoryImpl::createUsage_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<UsageImpl> element(new UsageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisUsagePtr(element);
	return element;
	
}
std::shared_ptr<Usage> umlFactoryImpl::createUsage_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<UsageImpl> element(new UsageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisUsagePtr(element);
	return element;
	
}
std::shared_ptr<Usage> umlFactoryImpl::createUsage_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<UsageImpl> element(new UsageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisUsagePtr(element);
	return element;
	
}
std::shared_ptr<Usage> umlFactoryImpl::createUsage_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<UsageImpl> element(new UsageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisUsagePtr(element);
	return element;
	
}
std::shared_ptr<Usage> umlFactoryImpl::createUsage_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<UsageImpl> element(new UsageImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisUsagePtr(element);
	return element;
	
}
std::shared_ptr<Usage> umlFactoryImpl::createUsage_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<UsageImpl> element(new UsageImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisUsagePtr(element);
	return element;
	
}
std::shared_ptr<Usage> umlFactoryImpl::createUsage_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<UsageImpl> element(new UsageImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisUsagePtr(element);
	return element;
	
}
std::shared_ptr<Usage> umlFactoryImpl::createUsage_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<UsageImpl> element(new UsageImpl(par_Package));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisUsagePtr(element);
	return element;
	
}
std::shared_ptr<Usage> umlFactoryImpl::createUsage_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<UsageImpl> element(new UsageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisUsagePtr(element);
	return element;
	
}
std::shared_ptr<Usage> umlFactoryImpl::createUsage_as_roleBinding_in_CollaborationUse(std::shared_ptr<CollaborationUse> par_CollaborationUse, const int metaElementID) const
{
	std::shared_ptr<UsageImpl> element(new UsageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_CollaborationUse)
	{
		par_CollaborationUse->getRoleBinding()->push_back(element);
	}
	
	element->setThisUsagePtr(element);
	return element;
	
}
std::shared_ptr<Usage> umlFactoryImpl::createUsage_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<UsageImpl> element(new UsageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisUsagePtr(element);
	return element;
	
}
std::shared_ptr<Usage> umlFactoryImpl::createUsage_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<UsageImpl> element(new UsageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisUsagePtr(element);
	return element;
	
}
std::shared_ptr<Usage> umlFactoryImpl::createUsage_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<UsageImpl> element(new UsageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisUsagePtr(element);
	return element;
	
}
std::shared_ptr<Usage> umlFactoryImpl::createUsage_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<UsageImpl> element(new UsageImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisUsagePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl());
	element->setMetaElementID(metaElementID);
	element->setThisUseCasePtr(element);
	return element;
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_addition_in_Include(std::shared_ptr<Include> par_Include, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Include)
	{
		par_Include->setAddition(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_classifier_in_RedefinableTemplateSignature(std::shared_ptr<RedefinableTemplateSignature> par_RedefinableTemplateSignature, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RedefinableTemplateSignature)
	{
		par_RedefinableTemplateSignature->setClassifier(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_context_in_Behavior(std::shared_ptr<Behavior> par_Behavior, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Behavior)
	{
		par_Behavior->setContext(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_contract_in_Substitution(std::shared_ptr<Substitution> par_Substitution, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Substitution)
	{
		par_Substitution->setContract(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_endType_in_Association(std::shared_ptr<Association> par_Association, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Association)
	{
		par_Association->getEndType()->push_back(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_extendedCase_in_Extend(std::shared_ptr<Extend> par_Extend, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Extend)
	{
		par_Extend->setExtendedCase(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_general_in_Generalization(std::shared_ptr<Generalization> par_Generalization, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Generalization)
	{
		par_Generalization->setGeneral(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_importedElement_in_ElementImport(std::shared_ptr<ElementImport> par_ElementImport, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ElementImport)
	{
		par_ElementImport->setImportedElement(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_importedMember_in_Namespace(std::shared_ptr<Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Namespace)
	{
		par_Namespace->getImportedMember()->push_back(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_nestedClassifier_in_Class(std::shared_ptr<Class> par_Class, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Class)
	{
		par_Class->getNestedClassifier()->push_back(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_nestedClassifier_in_Interface(std::shared_ptr<Interface> par_Interface, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interface)
	{
		par_Interface->getNestedClassifier()->push_back(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_ownedType_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl(par_Package, uml::umlPackage::TYPE_ATTRIBUTE_PACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getOwnedType()->push_back(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_ownedUseCase_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getOwnedUseCase()->push_back(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_packagedElement_in_Package(std::weak_ptr<uml::Package> par_Package, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl(par_Package, uml::umlPackage::PACKAGEABLEELEMENT_ATTRIBUTE_OWNINGPACKAGE));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Package.lock())
	{
		wp->getPackagedElement()->push_back(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_packagedElement_in_Component(std::shared_ptr<Component> par_Component, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Component)
	{
		par_Component->getPackagedElement()->push_back(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_realizingClassifier_in_ComponentRealization(std::shared_ptr<ComponentRealization> par_ComponentRealization, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ComponentRealization)
	{
		par_ComponentRealization->getRealizingClassifier()->push_back(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_redefinedClassifier_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getRedefinedClassifier()->push_back(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<UseCase> umlFactoryImpl::createUseCase_as_utilizedElement_in_Manifestation(std::shared_ptr<Manifestation> par_Manifestation, const int metaElementID) const
{
	std::shared_ptr<UseCaseImpl> element(new UseCaseImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Manifestation)
	{
		par_Manifestation->setUtilizedElement(element);
	}
	
	element->setThisUseCasePtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	element->setThisValuePinPtr(element);
	return element;
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_argument_in_InvocationAction(std::weak_ptr<uml::InvocationAction> par_InvocationAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl(par_InvocationAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_InvocationAction.lock())
	{
		wp->getArgument()->push_back(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_collection_in_ReduceAction(std::shared_ptr<ReduceAction> par_ReduceAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReduceAction)
	{
		par_ReduceAction->setCollection(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_exception_in_RaiseExceptionAction(std::shared_ptr<RaiseExceptionAction> par_RaiseExceptionAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RaiseExceptionAction)
	{
		par_RaiseExceptionAction->setException(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_first_in_TestIdentityAction(std::shared_ptr<TestIdentityAction> par_TestIdentityAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TestIdentityAction)
	{
		par_TestIdentityAction->setFirst(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_input_in_Action(std::weak_ptr<uml::Action> par_Action, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl(par_Action));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Action.lock())
	{
		wp->getInput()->push_back(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_inputValue_in_LinkAction(std::shared_ptr<LinkAction> par_LinkAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_LinkAction)
	{
		par_LinkAction->getInputValue()->push_back(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_inputValue_in_OpaqueAction(std::shared_ptr<OpaqueAction> par_OpaqueAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_OpaqueAction)
	{
		par_OpaqueAction->getInputValue()->push_back(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_insertAt_in_AddStructuralFeatureValueAction(std::weak_ptr<uml::AddStructuralFeatureValueAction> par_AddStructuralFeatureValueAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl(par_AddStructuralFeatureValueAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_AddStructuralFeatureValueAction.lock())
	{
		wp->setInsertAt(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_insertAt_in_AddVariableValueAction(std::shared_ptr<AddVariableValueAction> par_AddVariableValueAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_AddVariableValueAction)
	{
		par_AddVariableValueAction->setInsertAt(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_loopVariableInput_in_LoopNode(std::shared_ptr<LoopNode> par_LoopNode, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_LoopNode)
	{
		par_LoopNode->getLoopVariableInput()->push_back(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_object_in_StructuralFeatureAction(std::weak_ptr<uml::StructuralFeatureAction> par_StructuralFeatureAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl(par_StructuralFeatureAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuralFeatureAction.lock())
	{
		wp->setObject(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_object_in_ClearAssociationAction(std::shared_ptr<ClearAssociationAction> par_ClearAssociationAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ClearAssociationAction)
	{
		par_ClearAssociationAction->setObject(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_object_in_ReadIsClassifiedObjectAction(std::shared_ptr<ReadIsClassifiedObjectAction> par_ReadIsClassifiedObjectAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReadIsClassifiedObjectAction)
	{
		par_ReadIsClassifiedObjectAction->setObject(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_object_in_ReadLinkObjectEndAction(std::shared_ptr<ReadLinkObjectEndAction> par_ReadLinkObjectEndAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReadLinkObjectEndAction)
	{
		par_ReadLinkObjectEndAction->setObject(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_object_in_ReadLinkObjectEndQualifierAction(std::shared_ptr<ReadLinkObjectEndQualifierAction> par_ReadLinkObjectEndQualifierAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReadLinkObjectEndQualifierAction)
	{
		par_ReadLinkObjectEndQualifierAction->setObject(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_object_in_ReclassifyObjectAction(std::shared_ptr<ReclassifyObjectAction> par_ReclassifyObjectAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReclassifyObjectAction)
	{
		par_ReclassifyObjectAction->setObject(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_object_in_StartClassifierBehaviorAction(std::shared_ptr<StartClassifierBehaviorAction> par_StartClassifierBehaviorAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_StartClassifierBehaviorAction)
	{
		par_StartClassifierBehaviorAction->setObject(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_object_in_StartObjectBehaviorAction(std::shared_ptr<StartObjectBehaviorAction> par_StartObjectBehaviorAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_StartObjectBehaviorAction)
	{
		par_StartObjectBehaviorAction->setObject(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_object_in_UnmarshallAction(std::shared_ptr<UnmarshallAction> par_UnmarshallAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_UnmarshallAction)
	{
		par_UnmarshallAction->setObject(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_removeAt_in_RemoveStructuralFeatureValueAction(std::weak_ptr<uml::RemoveStructuralFeatureValueAction> par_RemoveStructuralFeatureValueAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl(par_RemoveStructuralFeatureValueAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_RemoveStructuralFeatureValueAction.lock())
	{
		wp->setRemoveAt(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_removeAt_in_RemoveVariableValueAction(std::shared_ptr<RemoveVariableValueAction> par_RemoveVariableValueAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_RemoveVariableValueAction)
	{
		par_RemoveVariableValueAction->setRemoveAt(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_replyValue_in_ReplyAction(std::shared_ptr<ReplyAction> par_ReplyAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReplyAction)
	{
		par_ReplyAction->getReplyValue()->push_back(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_request_in_SendObjectAction(std::shared_ptr<SendObjectAction> par_SendObjectAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SendObjectAction)
	{
		par_SendObjectAction->setRequest(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_returnInformation_in_ReplyAction(std::shared_ptr<ReplyAction> par_ReplyAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ReplyAction)
	{
		par_ReplyAction->setReturnInformation(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_second_in_TestIdentityAction(std::shared_ptr<TestIdentityAction> par_TestIdentityAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TestIdentityAction)
	{
		par_TestIdentityAction->setSecond(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_structuredNodeInput_in_StructuredActivityNode(std::shared_ptr<StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_StructuredActivityNode)
	{
		par_StructuredActivityNode->getStructuredNodeInput()->push_back(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_target_in_CallOperationAction(std::weak_ptr<uml::CallOperationAction> par_CallOperationAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl(par_CallOperationAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_CallOperationAction.lock())
	{
		wp->setTarget(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_target_in_DestroyObjectAction(std::weak_ptr<uml::DestroyObjectAction> par_DestroyObjectAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl(par_DestroyObjectAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_DestroyObjectAction.lock())
	{
		wp->setTarget(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_target_in_SendObjectAction(std::shared_ptr<SendObjectAction> par_SendObjectAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SendObjectAction)
	{
		par_SendObjectAction->setTarget(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_target_in_SendSignalAction(std::shared_ptr<SendSignalAction> par_SendSignalAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SendSignalAction)
	{
		par_SendSignalAction->setTarget(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_value_in_WriteStructuralFeatureAction(std::weak_ptr<uml::WriteStructuralFeatureAction> par_WriteStructuralFeatureAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl(par_WriteStructuralFeatureAction));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_WriteStructuralFeatureAction.lock())
	{
		wp->setValue(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValuePin> umlFactoryImpl::createValuePin_as_value_in_WriteVariableAction(std::shared_ptr<WriteVariableAction> par_WriteVariableAction, const int metaElementID) const
{
	std::shared_ptr<ValuePinImpl> element(new ValuePinImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_WriteVariableAction)
	{
		par_WriteVariableAction->setValue(element);
	}
	
	element->setThisValuePinPtr(element);
	return element;
	
}
std::shared_ptr<ValueSpecificationAction> umlFactoryImpl::createValueSpecificationAction(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<ValueSpecificationActionImpl> element(new ValueSpecificationActionImpl());
	element->setMetaElementID(metaElementID);
	element->setThisValueSpecificationActionPtr(element);
	return element;
}
std::shared_ptr<ValueSpecificationAction> umlFactoryImpl::createValueSpecificationAction_as_action_in_Interaction(std::shared_ptr<Interaction> par_Interaction, const int metaElementID) const
{
	std::shared_ptr<ValueSpecificationActionImpl> element(new ValueSpecificationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Interaction)
	{
		par_Interaction->getAction()->push_back(element);
	}
	
	element->setThisValueSpecificationActionPtr(element);
	return element;
	
}
std::shared_ptr<ValueSpecificationAction> umlFactoryImpl::createValueSpecificationAction_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ValueSpecificationActionImpl> element(new ValueSpecificationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisValueSpecificationActionPtr(element);
	return element;
	
}
std::shared_ptr<ValueSpecificationAction> umlFactoryImpl::createValueSpecificationAction_as_executableNode_in_SequenceNode(std::shared_ptr<SequenceNode> par_SequenceNode, const int metaElementID) const
{
	std::shared_ptr<ValueSpecificationActionImpl> element(new ValueSpecificationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_SequenceNode)
	{
		par_SequenceNode->getExecutableNode()->push_back(element);
	}
	
	element->setThisValueSpecificationActionPtr(element);
	return element;
	
}
std::shared_ptr<ValueSpecificationAction> umlFactoryImpl::createValueSpecificationAction_as_fromAction_in_ActionInputPin(std::shared_ptr<ActionInputPin> par_ActionInputPin, const int metaElementID) const
{
	std::shared_ptr<ValueSpecificationActionImpl> element(new ValueSpecificationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActionInputPin)
	{
		par_ActionInputPin->setFromAction(element);
	}
	
	element->setThisValueSpecificationActionPtr(element);
	return element;
	
}
std::shared_ptr<ValueSpecificationAction> umlFactoryImpl::createValueSpecificationAction_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ValueSpecificationActionImpl> element(new ValueSpecificationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisValueSpecificationActionPtr(element);
	return element;
	
}
std::shared_ptr<ValueSpecificationAction> umlFactoryImpl::createValueSpecificationAction_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<ValueSpecificationActionImpl> element(new ValueSpecificationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisValueSpecificationActionPtr(element);
	return element;
	
}
std::shared_ptr<ValueSpecificationAction> umlFactoryImpl::createValueSpecificationAction_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<ValueSpecificationActionImpl> element(new ValueSpecificationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisValueSpecificationActionPtr(element);
	return element;
	
}
std::shared_ptr<ValueSpecificationAction> umlFactoryImpl::createValueSpecificationAction_as_node_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ValueSpecificationActionImpl> element(new ValueSpecificationActionImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisValueSpecificationActionPtr(element);
	return element;
	
}
std::shared_ptr<ValueSpecificationAction> umlFactoryImpl::createValueSpecificationAction_as_node_in_ActivityPartition(std::shared_ptr<uml::ActivityPartition> par_ActivityPartition, const int metaElementID) const
{
	std::shared_ptr<ValueSpecificationActionImpl> element(new ValueSpecificationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityPartition)
	{
		par_ActivityPartition->getNode()->push_back(element);
	}
	
	element->setThisValueSpecificationActionPtr(element);
	return element;
	
}
std::shared_ptr<ValueSpecificationAction> umlFactoryImpl::createValueSpecificationAction_as_node_in_InterruptibleActivityRegion(std::shared_ptr<uml::InterruptibleActivityRegion> par_InterruptibleActivityRegion, const int metaElementID) const
{
	std::shared_ptr<ValueSpecificationActionImpl> element(new ValueSpecificationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InterruptibleActivityRegion)
	{
		par_InterruptibleActivityRegion->getNode()->push_back(element);
	}
	
	element->setThisValueSpecificationActionPtr(element);
	return element;
	
}
std::shared_ptr<ValueSpecificationAction> umlFactoryImpl::createValueSpecificationAction_as_node_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<ValueSpecificationActionImpl> element(new ValueSpecificationActionImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getNode()->push_back(element);
	}
	
	element->setThisValueSpecificationActionPtr(element);
	return element;
	
}
std::shared_ptr<ValueSpecificationAction> umlFactoryImpl::createValueSpecificationAction_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<ValueSpecificationActionImpl> element(new ValueSpecificationActionImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisValueSpecificationActionPtr(element);
	return element;
	
}
std::shared_ptr<ValueSpecificationAction> umlFactoryImpl::createValueSpecificationAction_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<ValueSpecificationActionImpl> element(new ValueSpecificationActionImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisValueSpecificationActionPtr(element);
	return element;
	
}
std::shared_ptr<ValueSpecificationAction> umlFactoryImpl::createValueSpecificationAction_as_ownedNode_in_Activity(std::shared_ptr<Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<ValueSpecificationActionImpl> element(new ValueSpecificationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Activity)
	{
		par_Activity->getOwnedNode()->push_back(element);
	}
	
	element->setThisValueSpecificationActionPtr(element);
	return element;
	
}
std::shared_ptr<ValueSpecificationAction> umlFactoryImpl::createValueSpecificationAction_as_redefinedNode_in_ActivityNode(std::shared_ptr<ActivityNode> par_ActivityNode, const int metaElementID) const
{
	std::shared_ptr<ValueSpecificationActionImpl> element(new ValueSpecificationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_ActivityNode)
	{
		par_ActivityNode->getRedefinedNode()->push_back(element);
	}
	
	element->setThisValueSpecificationActionPtr(element);
	return element;
	
}
std::shared_ptr<ValueSpecificationAction> umlFactoryImpl::createValueSpecificationAction_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ValueSpecificationActionImpl> element(new ValueSpecificationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisValueSpecificationActionPtr(element);
	return element;
	
}
std::shared_ptr<ValueSpecificationAction> umlFactoryImpl::createValueSpecificationAction_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<ValueSpecificationActionImpl> element(new ValueSpecificationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisValueSpecificationActionPtr(element);
	return element;
	
}
std::shared_ptr<ValueSpecificationAction> umlFactoryImpl::createValueSpecificationAction_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<ValueSpecificationActionImpl> element(new ValueSpecificationActionImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisValueSpecificationActionPtr(element);
	return element;
	
}
std::shared_ptr<Variable> umlFactoryImpl::createVariable(const int metaElementID/*=-1*/) const
{
	std::shared_ptr<VariableImpl> element(new VariableImpl());
	element->setMetaElementID(metaElementID);
	element->setThisVariablePtr(element);
	return element;
}
std::shared_ptr<Variable> umlFactoryImpl::createVariable_as_client_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<VariableImpl> element(new VariableImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getClient()->push_back(element);
	}
	
	element->setThisVariablePtr(element);
	return element;
	
}
std::shared_ptr<Variable> umlFactoryImpl::createVariable_as_collaborationRole_in_Collaboration(std::shared_ptr<Collaboration> par_Collaboration, const int metaElementID) const
{
	std::shared_ptr<VariableImpl> element(new VariableImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Collaboration)
	{
		par_Collaboration->getCollaborationRole()->push_back(element);
	}
	
	element->setThisVariablePtr(element);
	return element;
	
}
std::shared_ptr<Variable> umlFactoryImpl::createVariable_as_informationSource_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<VariableImpl> element(new VariableImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationSource()->push_back(element);
	}
	
	element->setThisVariablePtr(element);
	return element;
	
}
std::shared_ptr<Variable> umlFactoryImpl::createVariable_as_informationTarget_in_InformationFlow(std::shared_ptr<InformationFlow> par_InformationFlow, const int metaElementID) const
{
	std::shared_ptr<VariableImpl> element(new VariableImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_InformationFlow)
	{
		par_InformationFlow->getInformationTarget()->push_back(element);
	}
	
	element->setThisVariablePtr(element);
	return element;
	
}
std::shared_ptr<Variable> umlFactoryImpl::createVariable_as_inheritedMember_in_Classifier(std::shared_ptr<Classifier> par_Classifier, const int metaElementID) const
{
	std::shared_ptr<VariableImpl> element(new VariableImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Classifier)
	{
		par_Classifier->getInheritedMember()->push_back(element);
	}
	
	element->setThisVariablePtr(element);
	return element;
	
}
std::shared_ptr<Variable> umlFactoryImpl::createVariable_as_ownedActual_in_TemplateParameterSubstitution(std::shared_ptr<TemplateParameterSubstitution> par_TemplateParameterSubstitution, const int metaElementID) const
{
	std::shared_ptr<VariableImpl> element(new VariableImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameterSubstitution)
	{
		par_TemplateParameterSubstitution->setOwnedActual(element);
	}
	
	element->setThisVariablePtr(element);
	return element;
	
}
std::shared_ptr<Variable> umlFactoryImpl::createVariable_as_ownedDefault_in_TemplateParameter(std::shared_ptr<TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<VariableImpl> element(new VariableImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_TemplateParameter)
	{
		par_TemplateParameter->setOwnedDefault(element);
	}
	
	element->setThisVariablePtr(element);
	return element;
	
}
std::shared_ptr<Variable> umlFactoryImpl::createVariable_as_ownedElement_in_Element(std::weak_ptr<uml::Element> par_Element, const int metaElementID) const
{
	std::shared_ptr<VariableImpl> element(new VariableImpl(par_Element));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Element.lock())
	{
		wp->getOwnedElement()->push_back(element);
	}
	
	element->setThisVariablePtr(element);
	return element;
	
}
std::shared_ptr<Variable> umlFactoryImpl::createVariable_as_ownedMember_in_Namespace(std::weak_ptr<uml::Namespace> par_Namespace, const int metaElementID) const
{
	std::shared_ptr<VariableImpl> element(new VariableImpl(par_Namespace));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Namespace.lock())
	{
		wp->getOwnedMember()->push_back(element);
	}
	
	element->setThisVariablePtr(element);
	return element;
	
}
std::shared_ptr<Variable> umlFactoryImpl::createVariable_as_ownedParameteredElement_in_TemplateParameter(std::weak_ptr<uml::TemplateParameter> par_TemplateParameter, const int metaElementID) const
{
	std::shared_ptr<VariableImpl> element(new VariableImpl(par_TemplateParameter));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_TemplateParameter.lock())
	{
		wp->setOwnedParameteredElement(element);
	}
	
	element->setThisVariablePtr(element);
	return element;
	
}
std::shared_ptr<Variable> umlFactoryImpl::createVariable_as_role_in_StructuredClassifier(std::shared_ptr<StructuredClassifier> par_StructuredClassifier, const int metaElementID) const
{
	std::shared_ptr<VariableImpl> element(new VariableImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_StructuredClassifier)
	{
		par_StructuredClassifier->getRole()->push_back(element);
	}
	
	element->setThisVariablePtr(element);
	return element;
	
}
std::shared_ptr<Variable> umlFactoryImpl::createVariable_as_source_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<VariableImpl> element(new VariableImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getSource()->push_back(element);
	}
	
	element->setThisVariablePtr(element);
	return element;
	
}
std::shared_ptr<Variable> umlFactoryImpl::createVariable_as_supplier_in_Dependency(std::shared_ptr<Dependency> par_Dependency, const int metaElementID) const
{
	std::shared_ptr<VariableImpl> element(new VariableImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_Dependency)
	{
		par_Dependency->getSupplier()->push_back(element);
	}
	
	element->setThisVariablePtr(element);
	return element;
	
}
std::shared_ptr<Variable> umlFactoryImpl::createVariable_as_target_in_DirectedRelationship(std::shared_ptr<DirectedRelationship> par_DirectedRelationship, const int metaElementID) const
{
	std::shared_ptr<VariableImpl> element(new VariableImpl());
	element->setMetaElementID(metaElementID);
	if(nullptr != par_DirectedRelationship)
	{
		par_DirectedRelationship->getTarget()->push_back(element);
	}
	
	element->setThisVariablePtr(element);
	return element;
	
}
std::shared_ptr<Variable> umlFactoryImpl::createVariable_as_variable_in_Activity(std::weak_ptr<uml::Activity> par_Activity, const int metaElementID) const
{
	std::shared_ptr<VariableImpl> element(new VariableImpl(par_Activity));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_Activity.lock())
	{
		wp->getVariable()->push_back(element);
	}
	
	element->setThisVariablePtr(element);
	return element;
	
}
std::shared_ptr<Variable> umlFactoryImpl::createVariable_as_variable_in_StructuredActivityNode(std::weak_ptr<uml::StructuredActivityNode> par_StructuredActivityNode, const int metaElementID) const
{
	std::shared_ptr<VariableImpl> element(new VariableImpl(par_StructuredActivityNode));
	element->setMetaElementID(metaElementID);
	if(auto wp = par_StructuredActivityNode.lock())
	{
		wp->getVariable()->push_back(element);
	}
	
	element->setThisVariablePtr(element);
	return element;
	
}

