<?xml version="1.0" encoding="UTF-8"?>
<xmi:XMI xmi:version="20131001" xmlns:xmi="http://www.omg.org/spec/XMI/20131001" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:UML4CPPProfile="http://www.tu-ilmenau.de/sse/UML4CPPProfile" xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore" xmlns:uml="http://www.eclipse.org/uml2/5.0.0/UML" xsi:schemaLocation="http://www.tu-ilmenau.de/sse/UML4CPPProfile ../../../../../common/UML4CPPProfile/model/UML4CPPProfile.uml#_v75nIfp7EeuavpF89IQaUg">
  <uml:Model xmi:id="_PmmP8LAqEeert7O7oCVCsA" name="AssemblyConnectors_PWP_PWP">
    <ownedComment xmi:id="_BipcoKGVEeq_jPVfGA6A8w">
      <body>This test case addresses instantiation semantics in the case of an assembly connector between a part with port and a part with port.</body>
    </ownedComment>
    <packageImport xmi:id="_rgWIkLArEeert7O7oCVCsA">
      <importedPackage xmi:type="uml:Model" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#_0"/>
    </packageImport>
    <packagedElement xmi:type="uml:Class" xmi:id="_z6HwQO9BEemWP7t7cfH8xA" name="A_Empty_Pattern">
      <ownedComment xmi:id="_6GtOUO9BEemWP7t7cfH8xA">
        <body>Empty pattern:
lower bound of part b and c is 0</body>
      </ownedComment>
      <ownedAttribute xmi:id="_u8DPkO9IEemWP7t7cfH8xA" name="partB" type="_Mk9kQO9AEemWP7t7cfH8xA" aggregation="composite">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_yr6zkO9IEemWP7t7cfH8xA"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_0CIYkO9IEemWP7t7cfH8xA" value="*"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="_-MG5QO9IEemWP7t7cfH8xA" name="partC" type="_PMiDcO9AEemWP7t7cfH8xA" aggregation="composite">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="__HrwsO9IEemWP7t7cfH8xA"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="__ffMsO9IEemWP7t7cfH8xA" value="*"/>
      </ownedAttribute>
      <ownedConnector xmi:id="_5Dm2APEXEem6OrjQXRieKQ" name="r" type="_kQiBsO9AEemWP7t7cfH8xA">
        <end xmi:id="_ASU0kPEaEem6OrjQXRieKQ" partWithPort="_u8DPkO9IEemWP7t7cfH8xA" role="_Ffym0FiHEeq745ruafyE3Q">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_HAZPEPEaEem6OrjQXRieKQ" name="connectorEnd_1_Lower" value="1"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_H5WQUPEaEem6OrjQXRieKQ" name="connectorEnd_1_Upper" value="*"/>
        </end>
        <end xmi:id="_AzlHgPEaEem6OrjQXRieKQ" partWithPort="_-MG5QO9IEemWP7t7cfH8xA" role="_FDEGMFiVEeq745ruafyE3Q">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_I81GkPEaEem6OrjQXRieKQ" name="connectorEnd_2_Lower" value="1"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_KKi24PEaEem6OrjQXRieKQ" name="connectorEnd_2_Upper" value="*"/>
        </end>
      </ownedConnector>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_bfcP8FIvEeq4WpdDJnu9kg" name="A_Unconnected_Pattern">
      <ownedComment xmi:id="_bfcP8VIvEeq4WpdDJnu9kg">
        <body>Unconnected pattern:
lower bound on ends of connector r is 0</body>
      </ownedComment>
      <ownedAttribute xmi:id="_bfcP8lIvEeq4WpdDJnu9kg" name="partB" type="_Mk9kQO9AEemWP7t7cfH8xA" aggregation="composite">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_bfcP81IvEeq4WpdDJnu9kg" value="2"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_bfcP9FIvEeq4WpdDJnu9kg" value="*"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="_bfcP9VIvEeq4WpdDJnu9kg" name="partC" type="_PMiDcO9AEemWP7t7cfH8xA" aggregation="composite">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_bfcP9lIvEeq4WpdDJnu9kg" value="3"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_bfcP91IvEeq4WpdDJnu9kg" value="*"/>
      </ownedAttribute>
      <ownedConnector xmi:id="_bfcP-FIvEeq4WpdDJnu9kg" name="r" type="_kQiBsO9AEemWP7t7cfH8xA">
        <end xmi:id="_bfcP-VIvEeq4WpdDJnu9kg" partWithPort="_bfcP8lIvEeq4WpdDJnu9kg" role="_Ffym0FiHEeq745ruafyE3Q">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_bfcP-lIvEeq4WpdDJnu9kg" name="connectorEnd_1_Lower"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_bfcP-1IvEeq4WpdDJnu9kg" name="connectorEnd_1_Upper" value="*"/>
        </end>
        <end xmi:id="_bfcP_FIvEeq4WpdDJnu9kg" partWithPort="_bfcP9VIvEeq4WpdDJnu9kg" role="_FDEGMFiVEeq745ruafyE3Q">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_bfcP_VIvEeq4WpdDJnu9kg" name="connectorEnd_2_Lower"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_bfcP_lIvEeq4WpdDJnu9kg" name="connectorEnd_2_Upper" value="*"/>
        </end>
      </ownedConnector>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_rZJ6oFIvEeq4WpdDJnu9kg" name="A_Array_Pattern">
      <ownedComment xmi:id="_rZJ6oVIvEeq4WpdDJnu9kg">
        <body>Array pattern:
lower bound of b and c are equals
lower bound on ends of connector r is 1</body>
      </ownedComment>
      <ownedAttribute xmi:id="_rZJ6olIvEeq4WpdDJnu9kg" name="partB" type="_Mk9kQO9AEemWP7t7cfH8xA" aggregation="composite">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_rZJ6o1IvEeq4WpdDJnu9kg" value="2"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_rZJ6pFIvEeq4WpdDJnu9kg" value="*"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="_rZJ6pVIvEeq4WpdDJnu9kg" name="partC" type="_PMiDcO9AEemWP7t7cfH8xA" aggregation="composite">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_rZJ6plIvEeq4WpdDJnu9kg" value="4"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_rZJ6p1IvEeq4WpdDJnu9kg" value="*"/>
      </ownedAttribute>
      <ownedConnector xmi:id="_rZJ6qFIvEeq4WpdDJnu9kg" name="r" type="_kQiBsO9AEemWP7t7cfH8xA">
        <end xmi:id="_rZJ6qVIvEeq4WpdDJnu9kg" partWithPort="_rZJ6olIvEeq4WpdDJnu9kg" role="_Ffym0FiHEeq745ruafyE3Q">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_rZJ6qlIvEeq4WpdDJnu9kg" name="connectorEnd_1_Lower" value="1"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_rZJ6q1IvEeq4WpdDJnu9kg" name="connectorEnd_1_Upper" value="*"/>
        </end>
        <end xmi:id="_rZJ6rFIvEeq4WpdDJnu9kg" partWithPort="_rZJ6pVIvEeq4WpdDJnu9kg" role="_FDEGMFiVEeq745ruafyE3Q">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_rZJ6rVIvEeq4WpdDJnu9kg" name="connectorEnd_2_Lower" value="1"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_rZJ6rlIvEeq4WpdDJnu9kg" name="connectorEnd_2_Upper" value="*"/>
        </end>
      </ownedConnector>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="__fogsFIvEeq4WpdDJnu9kg" name="A_Star_Pattern">
      <ownedComment xmi:id="__fogsVIvEeq4WpdDJnu9kg">
        <body>Star pattern:
lower bound on ends of connector r equal
lower bound of connected parts</body>
      </ownedComment>
      <ownedAttribute xmi:id="__fogslIvEeq4WpdDJnu9kg" name="partB" type="_Mk9kQO9AEemWP7t7cfH8xA" aggregation="composite">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="__fogs1IvEeq4WpdDJnu9kg" value="2"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="__fogtFIvEeq4WpdDJnu9kg" value="*"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="__fogtVIvEeq4WpdDJnu9kg" name="partC" type="_PMiDcO9AEemWP7t7cfH8xA" aggregation="composite">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="__fogtlIvEeq4WpdDJnu9kg" value="5"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="__fogt1IvEeq4WpdDJnu9kg" value="*"/>
      </ownedAttribute>
      <ownedConnector xmi:id="__foguFIvEeq4WpdDJnu9kg" name="r" type="_kQiBsO9AEemWP7t7cfH8xA">
        <end xmi:id="__foguVIvEeq4WpdDJnu9kg" partWithPort="__fogslIvEeq4WpdDJnu9kg" role="_Ffym0FiHEeq745ruafyE3Q">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="__fogulIvEeq4WpdDJnu9kg" name="connectorEnd_1_Lower" value="4"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="__fogu1IvEeq4WpdDJnu9kg" name="connectorEnd_1_Upper" value="*"/>
        </end>
        <end xmi:id="__fogvFIvEeq4WpdDJnu9kg" partWithPort="__fogtVIvEeq4WpdDJnu9kg" role="_FDEGMFiVEeq745ruafyE3Q">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="__fogvVIvEeq4WpdDJnu9kg" name="connectorEnd_2_Lower" value="5"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="__fogvlIvEeq4WpdDJnu9kg" name="connectorEnd_2_Upper" value="*"/>
        </end>
      </ownedConnector>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_Mk9kQO9AEemWP7t7cfH8xA" name="B">
      <ownedAttribute xmi:type="uml:Port" xmi:id="_Ffym0FiHEeq745ruafyE3Q" name="p" type="_WQgAYFiGEeq745ruafyE3Q" aggregation="composite">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_G1iRwFiHEeq745ruafyE3Q" value="2"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_HMk4wFiHEeq745ruafyE3Q" value="*"/>
      </ownedAttribute>
    </packagedElement>
    <packagedElement xmi:type="uml:Interface" xmi:id="_SaxE8FiGEeq745ruafyE3Q" name="I"/>
    <packagedElement xmi:type="uml:Class" xmi:id="_WQgAYFiGEeq745ruafyE3Q" name="IImplementation">
      <ownedAttribute xmi:id="_1rdqEFiUEeq745ruafyE3Q" name="x" type="_WQgAYFiGEeq745ruafyE3Q" association="_kQiBsO9AEemWP7t7cfH8xA">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_24NKAFiUEeq745ruafyE3Q"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_3FKn8FiUEeq745ruafyE3Q" value="*"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="_7Bt9EFiUEeq745ruafyE3Q" name="y" type="_WQgAYFiGEeq745ruafyE3Q" association="_kQiBsO9AEemWP7t7cfH8xA">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_7Bt9EViUEeq745ruafyE3Q"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_7Bt9EliUEeq745ruafyE3Q" value="*"/>
      </ownedAttribute>
      <interfaceRealization xmi:id="_ds0oAFiGEeq745ruafyE3Q" name="IInterfaceRealization" client="_WQgAYFiGEeq745ruafyE3Q" supplier="_SaxE8FiGEeq745ruafyE3Q" contract="_SaxE8FiGEeq745ruafyE3Q"/>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_PMiDcO9AEemWP7t7cfH8xA" name="C">
      <ownedAttribute xmi:type="uml:Port" xmi:id="_FDEGMFiVEeq745ruafyE3Q" name="q" type="_WQgAYFiGEeq745ruafyE3Q" aggregation="composite">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_OEu7AFiVEeq745ruafyE3Q" value="1"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_GX_40FiVEeq745ruafyE3Q" value="*"/>
      </ownedAttribute>
    </packagedElement>
    <packagedElement xmi:type="uml:Association" xmi:id="_kQiBsO9AEemWP7t7cfH8xA" name="R" memberEnd="_1rdqEFiUEeq745ruafyE3Q _7Bt9EFiUEeq745ruafyE3Q"/>
    <packagedElement xmi:type="uml:Class" xmi:id="_AX6AEFgQEeqZPe2oHCHy2Q" name="Tester">
      <ownedBehavior xmi:type="uml:FunctionBehavior" xmi:id="_6vTt8FgREeqZPe2oHCHy2Q" name="fbTestAEmptyPattern" specification="_N16ycFgSEeqZPe2oHCHy2Q">
        <ownedParameter xmi:id="_sRiF8ERXEeupAptt1hjWPg" name="aEmptyPattern" type="_z6HwQO9BEemWP7t7cfH8xA"/>
        <language>CPP</language>
        <language>INCLUDE</language>
        <body>std::cout&lt;&lt;&quot;-- Instantiation of A_Empty_Pattern --&quot;&lt;&lt;std::endl;&#xD;
&#xD;
unsigned int leftPartCardinality=0, leftPortCardinality=2, rightPartCardinality=0, rightPortCardinality=1, rightEndCardinality=1, leftEndCardinality=1;&#xD;
&#xD;
bool successful = ((aEmptyPattern->getPartB()->size()) == leftPartCardinality);&#xD;
std::cout&lt;&lt;&quot;b->size = &quot;&lt;&lt;leftPartCardinality&lt;&lt;&quot; : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
for(unsigned int i = 0; i &lt; aEmptyPattern->getPartB()->size(); i++)&#xD;
{&#xD;
	successful = (aEmptyPattern->getPartB()->at(i)->getP()->size() == leftPortCardinality);&#xD;
	std::cout&lt;&lt;&quot;b[&quot;&lt;&lt;i&lt;&lt;&quot;]->p->size = &quot;&lt;&lt;leftPortCardinality&lt;&lt;&quot; : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
	&#xD;
	for(unsigned int j = 0; j &lt; aEmptyPattern->getPartB()->at(i)->getP()->size(); j++)&#xD;
	{&#xD;
		successful = ((aEmptyPattern->getPartB()->at(i)->getP()->at(j)->getY()->size()) == rightEndCardinality);&#xD;
		std::cout&lt;&lt;&quot;	b[&quot;&lt;&lt;i&lt;&lt;&quot;]->p[&quot;&lt;&lt;j&lt;&lt;&quot;]->c->size = &quot;&lt;&lt;rightEndCardinality&lt;&lt;&quot; : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
	}&#xD;
}&#xD;
std::cout&lt;&lt;std::endl;&#xD;
&#xD;
successful = ((aEmptyPattern->getPartC()->size()) == rightPartCardinality);&#xD;
std::cout&lt;&lt;&quot;c->size = &quot;&lt;&lt;rightPartCardinality&lt;&lt;&quot; : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
for(unsigned int i = 0; i &lt; aEmptyPattern->getPartC()->size(); i++)&#xD;
{&#xD;
	successful = (aEmptyPattern->getPartC()->at(i)->getQ()->size() == rightPortCardinality);&#xD;
	std::cout&lt;&lt;&quot;c[&quot;&lt;&lt;i&lt;&lt;&quot;]->q->size = &quot;&lt;&lt;rightPortCardinality&lt;&lt;&quot; : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
	&#xD;
	for(unsigned int j = 0; j &lt; aEmptyPattern->getPartC()->at(i)->getQ()->size(); j++)&#xD;
	{&#xD;
		successful = ((aEmptyPattern->getPartC()->at(i)->getQ()->at(j)->getX()->size()) == leftEndCardinality);&#xD;
		std::cout&lt;&lt;&quot;	c[&quot;&lt;&lt;i&lt;&lt;&quot;]->q[&quot;&lt;&lt;j&lt;&lt;&quot;]->x->size = &quot;&lt;&lt;leftEndCardinality&lt;&lt;&quot; : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
	}&#xD;
}&#xD;
std::cout&lt;&lt;std::endl;&#xD;
&#xD;
std::cout&lt;&lt;&quot;Instantiation was successful : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
std::cout&lt;&lt;&quot;-- Instantiation of A_Empty_Pattern --&quot;&lt;&lt;std::endl;&#xD;
std::cout&lt;&lt;&quot;Press Enter for next pattern...&quot;;&#xD;
getchar();</body>
        <body>#include &quot;AssemblyConnectors_PWP_PWP/B.hpp&quot;&#xD;
#include &quot;AssemblyConnectors_PWP_PWP/C.hpp&quot;&#xD;
#include &quot;AssemblyConnectors_PWP_PWP/IImplementation.hpp&quot;</body>
      </ownedBehavior>
      <ownedBehavior xmi:type="uml:FunctionBehavior" xmi:id="_-aF9oFgREeqZPe2oHCHy2Q" name="fbTestAUnconnectedPattern" specification="_1_Kt0FgTEeqZPe2oHCHy2Q">
        <ownedParameter xmi:id="_tA8wsERXEeupAptt1hjWPg" name="aUnconnectedPattern" type="_bfcP8FIvEeq4WpdDJnu9kg"/>
        <language>CPP</language>
        <language>INCLUDE</language>
        <body>std::string compareString = &quot;\tpartB[0]->p[0]   partC[0]->q[0]\n\tpartB[0]->p[0]   partC[1]->q[0]\n\tpartB[0]->p[0]   partC[2]->q[0]\n\n\tpartB[0]->p[1]   partC[0]->q[0]\n\tpartB[0]->p[1]   partC[1]->q[0]\n\tpartB[0]->p[1]   partC[2]->q[0]\n\n\n\tpartB[1]->p[0]   partC[0]->q[0]\n\tpartB[1]->p[0]   partC[1]->q[0]\n\tpartB[1]->p[0]   partC[2]->q[0]\n\n\tpartB[1]->p[1]   partC[0]->q[0]\n\tpartB[1]->p[1]   partC[1]->q[0]\n\tpartB[1]->p[1]   partC[2]->q[0]\n\n\n&quot;;&#xD;
&#xD;
std::cout&lt;&lt;&quot;-- Instantiation of A_Unconnected_Pattern --&quot;&lt;&lt;std::endl;&#xD;
&#xD;
unsigned int leftPartCardinality=2, leftPortCardinality=2, rightPartCardinality=3, rightPortCardinality=1, rightEndCardinality=0, leftEndCardinality=0;&#xD;
&#xD;
bool successful = ((aUnconnectedPattern->getPartB()->size()) == leftPartCardinality);&#xD;
std::cout&lt;&lt;&quot;b->size = &quot;&lt;&lt;leftPartCardinality&lt;&lt;&quot; : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
for(unsigned int i = 0; i &lt; aUnconnectedPattern->getPartB()->size(); i++)&#xD;
{&#xD;
	successful = (aUnconnectedPattern->getPartB()->at(i)->getP()->size() == leftPortCardinality);&#xD;
	std::cout&lt;&lt;&quot;b[&quot;&lt;&lt;i&lt;&lt;&quot;]->p->size = &quot;&lt;&lt;leftPortCardinality&lt;&lt;&quot; : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
	&#xD;
	for(unsigned int j = 0; j &lt; aUnconnectedPattern->getPartB()->at(i)->getP()->size(); j++)&#xD;
	{&#xD;
		successful = ((aUnconnectedPattern->getPartB()->at(i)->getP()->at(j)->getY()->size()) == rightEndCardinality);&#xD;
		std::cout&lt;&lt;&quot;	b[&quot;&lt;&lt;i&lt;&lt;&quot;]->p[&quot;&lt;&lt;j&lt;&lt;&quot;]->c->size = &quot;&lt;&lt;rightEndCardinality&lt;&lt;&quot; : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
	}&#xD;
}&#xD;
std::cout&lt;&lt;std::endl;&#xD;
&#xD;
successful = ((aUnconnectedPattern->getPartC()->size()) == rightPartCardinality);&#xD;
std::cout&lt;&lt;&quot;c->size = &quot;&lt;&lt;rightPartCardinality&lt;&lt;&quot; : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
for(unsigned int i = 0; i &lt; aUnconnectedPattern->getPartC()->size(); i++)&#xD;
{&#xD;
	successful = (aUnconnectedPattern->getPartC()->at(i)->getQ()->size() == rightPortCardinality);&#xD;
	std::cout&lt;&lt;&quot;c[&quot;&lt;&lt;i&lt;&lt;&quot;]->q->size = &quot;&lt;&lt;rightPortCardinality&lt;&lt;&quot; : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
	&#xD;
	for(unsigned int j = 0; j &lt; aUnconnectedPattern->getPartC()->at(i)->getQ()->size(); j++)&#xD;
	{&#xD;
		successful = ((aUnconnectedPattern->getPartC()->at(i)->getQ()->at(j)->getX()->size()) == leftEndCardinality);&#xD;
		std::cout&lt;&lt;&quot;	c[&quot;&lt;&lt;i&lt;&lt;&quot;]->q[&quot;&lt;&lt;j&lt;&lt;&quot;]->x->size = &quot;&lt;&lt;leftEndCardinality&lt;&lt;&quot; : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
	}&#xD;
}&#xD;
std::cout&lt;&lt;std::endl;&#xD;
&#xD;
std::string connectionsString = &quot;&quot;;&#xD;
&#xD;
for(unsigned int i = 0; i &lt; aUnconnectedPattern->getPartB()->size(); i++){&#xD;
&#xD;
	std::shared_ptr&lt;B> currentPartEnd1 = aUnconnectedPattern->getPartB()->at(i);&#xD;
&#xD;
	for(unsigned int j = 0; j &lt; currentPartEnd1->getP()->size(); j++)&#xD;
	{&#xD;
		std::shared_ptr&lt;IImplementation> currentPortOfPartEnd1 = currentPartEnd1->getP()->at(j);&#xD;
		&#xD;
		for(unsigned int k = 0; k &lt; aUnconnectedPattern->getPartC()->size(); k++)&#xD;
		{&#xD;
			std::shared_ptr&lt;C> currentPartEnd2 = aUnconnectedPattern->getPartC()->at(k);&#xD;
			&#xD;
			for(unsigned int l = 0; l &lt; currentPartEnd2->getQ()->size(); l++)&#xD;
				{&#xD;
				std::shared_ptr&lt;IImplementation> currentPortOfPartEnd2 = currentPartEnd2->getQ()->at(l);&#xD;
				bool connected = false;&#xD;
				&#xD;
				for(unsigned int m = 0; m &lt; currentPortOfPartEnd1->getY()->size(); m++)&#xD;
				{&#xD;
					std::shared_ptr&lt;IImplementation> currentYOfPortOfPartEnd1 = currentPortOfPartEnd1->getY()->at(m);&#xD;
					if(currentPortOfPartEnd2  == currentYOfPortOfPartEnd1)&#xD;
					{	&#xD;
						for(unsigned int h=0; h &lt; currentPortOfPartEnd2->getX()->size() &amp;&amp; !connected; h++)&#xD;
						{&#xD;
							std::shared_ptr&lt;IImplementation> currentXOfPortOfPartEnd2 = currentPortOfPartEnd2->getX()->at(h);&#xD;
							if(!connected &amp;&amp; (currentXOfPortOfPartEnd2 == currentPortOfPartEnd1)) connected = true;&#xD;
						}&#xD;
					}&#xD;
				}	&#xD;
				std::string connectedString = connected ? &quot;&lt;->&quot; : &quot;   &quot;;&#xD;
				connectionsString += &quot;\tpartB[&quot;+std::to_string(i)+&quot;]->p[&quot;+std::to_string(j)+&quot;]&quot;+connectedString+&quot;partC[&quot;+std::to_string(k)+&quot;]->q[&quot;+std::to_string(l)+&quot;]\n&quot;;&#xD;
			}&#xD;
		}&#xD;
		connectionsString+=&quot;\n&quot;;&#xD;
	}&#xD;
	connectionsString+=&quot;\n&quot;;&#xD;
}&#xD;
&#xD;
if(successful){&#xD;
	std::cout&lt;&lt;&quot;Links creation successful : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
	&#xD;
	std::cout&lt;&lt;connectionsString&lt;&lt;std::endl;&#xD;
}&#xD;
else{&#xD;
	std::cout&lt;&lt;&quot;Links creation successful : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
	std::cout&lt;&lt;&quot;Created links are:&quot;&lt;&lt;std::endl;&#xD;
	std::cout&lt;&lt;connectionsString&lt;&lt;std::endl;&#xD;
	std::cout&lt;&lt;&quot;Created links should be:&quot;&lt;&lt;std::endl;&#xD;
	std::cout&lt;&lt;compareString&lt;&lt;std::endl;&#xD;
}&#xD;
&#xD;
std::cout&lt;&lt;&quot;Instantiation was successful : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
std::cout&lt;&lt;&quot;-- Instantiation of A_Unconnected_Pattern --&quot;&lt;&lt;std::endl;&#xD;
std::cout&lt;&lt;&quot;Press Enter for next pattern...&quot;;&#xD;
getchar();</body>
        <body>#include &quot;AssemblyConnectors_PWP_PWP/B.hpp&quot;&#xD;
#include &quot;AssemblyConnectors_PWP_PWP/C.hpp&quot;&#xD;
#include &quot;AssemblyConnectors_PWP_PWP/IImplementation.hpp&quot;</body>
      </ownedBehavior>
      <ownedBehavior xmi:type="uml:FunctionBehavior" xmi:id="_CeMFMFgSEeqZPe2oHCHy2Q" name="fbTestAArrayPattern" specification="_-PQ7wFgTEeqZPe2oHCHy2Q">
        <ownedParameter xmi:id="_t0NZoERXEeupAptt1hjWPg" name="aArrayPattern" type="_rZJ6oFIvEeq4WpdDJnu9kg"/>
        <language>CPP</language>
        <language>INCLUDE</language>
        <body>std::string compareString = &quot;\tpartB[0]->p[0]&lt;->partC[0]->q[0]\n\tpartB[0]->p[0]   partC[1]->q[0]\n\tpartB[0]->p[0]   partC[2]->q[0]\n\tpartB[0]->p[0]   partC[3]->q[0]\n\n\tpartB[0]->p[1]   partC[0]->q[0]\n\tpartB[0]->p[1]&lt;->partC[1]->q[0]\n\tpartB[0]->p[1]   partC[2]->q[0]\n\tpartB[0]->p[1]   partC[3]->q[0]\n\n\n\tpartB[1]->p[0]   partC[0]->q[0]\n\tpartB[1]->p[0]   partC[1]->q[0]\n\tpartB[1]->p[0]&lt;->partC[2]->q[0]\n\tpartB[1]->p[0]   partC[3]->q[0]\n\n\tpartB[1]->p[1]   partC[0]->q[0]\n\tpartB[1]->p[1]   partC[1]->q[0]\n\tpartB[1]->p[1]   partC[2]->q[0]\n\tpartB[1]->p[1]&lt;->partC[3]->q[0]\n\n&quot;;&#xD;
&#xD;
std::cout&lt;&lt;&quot;-- Instantiation of A_Array_Pattern --&quot;&lt;&lt;std::endl;&#xD;
&#xD;
unsigned int leftPartCardinality=2, leftPortCardinality=2, rightPartCardinality=4, rightPortCardinality=1, rightEndCardinality=1, leftEndCardinality=1;&#xD;
&#xD;
bool successful = ((aArrayPattern->getPartB()->size()) == leftPartCardinality);&#xD;
std::cout&lt;&lt;&quot;b->size = &quot;&lt;&lt;leftPartCardinality&lt;&lt;&quot; : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
for(unsigned int i = 0; i &lt; aArrayPattern->getPartB()->size(); i++)&#xD;
{&#xD;
	successful = (aArrayPattern->getPartB()->at(i)->getP()->size() == leftPortCardinality);&#xD;
	std::cout&lt;&lt;&quot;b[&quot;&lt;&lt;i&lt;&lt;&quot;]->p->size = &quot;&lt;&lt;leftPortCardinality&lt;&lt;&quot; : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
	&#xD;
	for(unsigned int j = 0; j &lt; aArrayPattern->getPartB()->at(i)->getP()->size(); j++)&#xD;
	{&#xD;
		successful = ((aArrayPattern->getPartB()->at(i)->getP()->at(j)->getY()->size()) == rightEndCardinality);&#xD;
		std::cout&lt;&lt;&quot;	b[&quot;&lt;&lt;i&lt;&lt;&quot;]->p[&quot;&lt;&lt;j&lt;&lt;&quot;]->c->size = &quot;&lt;&lt;rightEndCardinality&lt;&lt;&quot; : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
	}&#xD;
}&#xD;
std::cout&lt;&lt;std::endl;&#xD;
&#xD;
successful = ((aArrayPattern->getPartC()->size()) == rightPartCardinality);&#xD;
std::cout&lt;&lt;&quot;c->size = &quot;&lt;&lt;rightPartCardinality&lt;&lt;&quot; : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
for(unsigned int i = 0; i &lt; aArrayPattern->getPartC()->size(); i++)&#xD;
{&#xD;
	successful = (aArrayPattern->getPartC()->at(i)->getQ()->size() == rightPortCardinality);&#xD;
	std::cout&lt;&lt;&quot;c[&quot;&lt;&lt;i&lt;&lt;&quot;]->q->size = &quot;&lt;&lt;rightPortCardinality&lt;&lt;&quot; : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
	&#xD;
	for(unsigned int j = 0; j &lt; aArrayPattern->getPartC()->at(i)->getQ()->size(); j++)&#xD;
	{&#xD;
		successful = ((aArrayPattern->getPartC()->at(i)->getQ()->at(j)->getX()->size()) == leftEndCardinality);&#xD;
		std::cout&lt;&lt;&quot;	c[&quot;&lt;&lt;i&lt;&lt;&quot;]->q[&quot;&lt;&lt;j&lt;&lt;&quot;]->x->size = &quot;&lt;&lt;leftEndCardinality&lt;&lt;&quot; : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
	}&#xD;
}&#xD;
std::cout&lt;&lt;std::endl;&#xD;
&#xD;
std::string connectionsString = &quot;&quot;;&#xD;
&#xD;
for(unsigned int i = 0; i &lt; aArrayPattern->getPartB()->size(); i++){&#xD;
&#xD;
	std::shared_ptr&lt;B> currentPartEnd1 = aArrayPattern->getPartB()->at(i);&#xD;
&#xD;
	for(unsigned int j = 0; j &lt; currentPartEnd1->getP()->size(); j++)&#xD;
	{&#xD;
		std::shared_ptr&lt;IImplementation> currentPortOfPartEnd1 = currentPartEnd1->getP()->at(j);&#xD;
		&#xD;
		for(unsigned int k = 0; k &lt; aArrayPattern->getPartC()->size(); k++)&#xD;
		{&#xD;
			std::shared_ptr&lt;C> currentPartEnd2 = aArrayPattern->getPartC()->at(k);&#xD;
			&#xD;
			for(unsigned int l = 0; l &lt; currentPartEnd2->getQ()->size(); l++)&#xD;
				{&#xD;
				std::shared_ptr&lt;IImplementation> currentPortOfPartEnd2 = currentPartEnd2->getQ()->at(l);&#xD;
				bool connected = false;&#xD;
				&#xD;
				for(unsigned int m = 0; m &lt; currentPortOfPartEnd1->getY()->size(); m++)&#xD;
				{&#xD;
					std::shared_ptr&lt;IImplementation> currentYOfPortOfPartEnd1 = currentPortOfPartEnd1->getY()->at(m);&#xD;
					if(currentPortOfPartEnd2  == currentYOfPortOfPartEnd1)&#xD;
					{	&#xD;
						for(unsigned int h=0; h &lt; currentPortOfPartEnd2->getX()->size() &amp;&amp; !connected; h++)&#xD;
						{&#xD;
							std::shared_ptr&lt;IImplementation> currentXOfPortOfPartEnd2 = currentPortOfPartEnd2->getX()->at(h);&#xD;
							if(!connected &amp;&amp; (currentXOfPortOfPartEnd2 == currentPortOfPartEnd1)) connected = true;&#xD;
						}&#xD;
					}&#xD;
				}	&#xD;
				std::string connectedString = connected ? &quot;&lt;->&quot; : &quot;   &quot;;&#xD;
				connectionsString += &quot;\tpartB[&quot;+std::to_string(i)+&quot;]->p[&quot;+std::to_string(j)+&quot;]&quot;+connectedString+&quot;partC[&quot;+std::to_string(k)+&quot;]->q[&quot;+std::to_string(l)+&quot;]\n&quot;;&#xD;
			}&#xD;
		}&#xD;
		connectionsString+=&quot;\n&quot;;&#xD;
	}&#xD;
	connectionsString+=&quot;\n&quot;;&#xD;
}&#xD;
&#xD;
if(successful){&#xD;
	std::cout&lt;&lt;&quot;Links creation successful : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
	&#xD;
	std::cout&lt;&lt;connectionsString&lt;&lt;std::endl;&#xD;
}&#xD;
else{&#xD;
	std::cout&lt;&lt;&quot;Links creation successful : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
	std::cout&lt;&lt;&quot;Created links are:&quot;&lt;&lt;std::endl;&#xD;
	std::cout&lt;&lt;connectionsString&lt;&lt;std::endl;&#xD;
	std::cout&lt;&lt;&quot;Created links should be:&quot;&lt;&lt;std::endl;&#xD;
	std::cout&lt;&lt;compareString&lt;&lt;std::endl;&#xD;
}&#xD;
&#xD;
std::cout&lt;&lt;&quot;Instantiation was successful : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
std::cout&lt;&lt;&quot;-- Instantiation of A_Array_Pattern --&quot;&lt;&lt;std::endl;&#xD;
std::cout&lt;&lt;&quot;Press Enter for next pattern...&quot;;&#xD;
getchar();</body>
        <body>#include &quot;AssemblyConnectors_PWP_PWP/B.hpp&quot;&#xD;
#include &quot;AssemblyConnectors_PWP_PWP/C.hpp&quot;&#xD;
#include &quot;AssemblyConnectors_PWP_PWP/IImplementation.hpp&quot;</body>
      </ownedBehavior>
      <ownedBehavior xmi:type="uml:FunctionBehavior" xmi:id="_EXuZsFgSEeqZPe2oHCHy2Q" name="fbTestAStarPattern" specification="_HVXkoFgUEeqZPe2oHCHy2Q">
        <ownedParameter xmi:id="_uduQsERXEeupAptt1hjWPg" name="aStarPattern" type="__fogsFIvEeq4WpdDJnu9kg"/>
        <language>CPP</language>
        <language>INCLUDE</language>
        <body>std::string compareString = &quot;\tpartB[0]->p[0]&lt;->partC[0]->q[0]\n\tpartB[0]->p[0]&lt;->partC[1]->q[0]\n\tpartB[0]->p[0]&lt;->partC[2]->q[0]\n\tpartB[0]->p[0]&lt;->partC[3]->q[0]\n\tpartB[0]->p[0]&lt;->partC[4]->q[0]\n\n\tpartB[0]->p[1]&lt;->partC[0]->q[0]\n\tpartB[0]->p[1]&lt;->partC[1]->q[0]\n\tpartB[0]->p[1]&lt;->partC[2]->q[0]\n\tpartB[0]->p[1]&lt;->partC[3]->q[0]\n\tpartB[0]->p[1]&lt;->partC[4]->q[0]\n\n\n\tpartB[1]->p[0]&lt;->partC[0]->q[0]\n\tpartB[1]->p[0]&lt;->partC[1]->q[0]\n\tpartB[1]->p[0]&lt;->partC[2]->q[0]\n\tpartB[1]->p[0]&lt;->partC[3]->q[0]\n\tpartB[1]->p[0]&lt;->partC[4]->q[0]\n\n\tpartB[1]->p[1]&lt;->partC[0]->q[0]\n\tpartB[1]->p[1]&lt;->partC[1]->q[0]\n\tpartB[1]->p[1]&lt;->partC[2]->q[0]\n\tpartB[1]->p[1]&lt;->partC[3]->q[0]\n\tpartB[1]->p[1]&lt;->partC[4]->q[0]\n\n&quot;;&#xD;
&#xD;
std::cout&lt;&lt;&quot;-- Instantiation of A_Star_Pattern --&quot;&lt;&lt;std::endl;&#xD;
&#xD;
unsigned int leftPartCardinality=2, leftPortCardinality=2, rightPartCardinality=5, rightPortCardinality=1, rightEndCardinality=5, leftEndCardinality=4;&#xD;
&#xD;
bool successful = ((aStarPattern->getPartB()->size()) == leftPartCardinality);&#xD;
std::cout&lt;&lt;&quot;b->size = &quot;&lt;&lt;leftPartCardinality&lt;&lt;&quot; : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
for(unsigned int i = 0; i &lt; aStarPattern->getPartB()->size(); i++)&#xD;
{&#xD;
	successful = (aStarPattern->getPartB()->at(i)->getP()->size() == leftPortCardinality);&#xD;
	std::cout&lt;&lt;&quot;b[&quot;&lt;&lt;i&lt;&lt;&quot;]->p->size = &quot;&lt;&lt;leftPortCardinality&lt;&lt;&quot; : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
	&#xD;
	for(unsigned int j = 0; j &lt; aStarPattern->getPartB()->at(i)->getP()->size(); j++)&#xD;
	{&#xD;
		successful = ((aStarPattern->getPartB()->at(i)->getP()->at(j)->getY()->size()) == rightEndCardinality);&#xD;
		std::cout&lt;&lt;&quot;	b[&quot;&lt;&lt;i&lt;&lt;&quot;]->p[&quot;&lt;&lt;j&lt;&lt;&quot;]->c->size = &quot;&lt;&lt;rightEndCardinality&lt;&lt;&quot; : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
	}&#xD;
}&#xD;
std::cout&lt;&lt;std::endl;&#xD;
&#xD;
successful = ((aStarPattern->getPartC()->size()) == rightPartCardinality);&#xD;
std::cout&lt;&lt;&quot;c->size = &quot;&lt;&lt;rightPartCardinality&lt;&lt;&quot; : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
for(unsigned int i = 0; i &lt; aStarPattern->getPartC()->size(); i++)&#xD;
{&#xD;
	successful = (aStarPattern->getPartC()->at(i)->getQ()->size() == rightPortCardinality);&#xD;
	std::cout&lt;&lt;&quot;c[&quot;&lt;&lt;i&lt;&lt;&quot;]->q->size = &quot;&lt;&lt;rightPortCardinality&lt;&lt;&quot; : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
	&#xD;
	for(unsigned int j = 0; j &lt; aStarPattern->getPartC()->at(i)->getQ()->size(); j++)&#xD;
	{&#xD;
		successful = ((aStarPattern->getPartC()->at(i)->getQ()->at(j)->getX()->size()) == leftEndCardinality);&#xD;
		std::cout&lt;&lt;&quot;	c[&quot;&lt;&lt;i&lt;&lt;&quot;]->q[&quot;&lt;&lt;j&lt;&lt;&quot;]->x->size = &quot;&lt;&lt;leftEndCardinality&lt;&lt;&quot; : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
	}&#xD;
}&#xD;
std::cout&lt;&lt;std::endl;&#xD;
&#xD;
std::string connectionsString = &quot;&quot;;&#xD;
&#xD;
for(unsigned int i = 0; i &lt; aStarPattern->getPartB()->size(); i++){&#xD;
&#xD;
	std::shared_ptr&lt;B> currentPartEnd1 = aStarPattern->getPartB()->at(i);&#xD;
&#xD;
	for(unsigned int j = 0; j &lt; currentPartEnd1->getP()->size(); j++)&#xD;
	{&#xD;
		std::shared_ptr&lt;IImplementation> currentPortOfPartEnd1 = currentPartEnd1->getP()->at(j);&#xD;
		&#xD;
		for(unsigned int k = 0; k &lt; aStarPattern->getPartC()->size(); k++)&#xD;
		{&#xD;
			std::shared_ptr&lt;C> currentPartEnd2 = aStarPattern->getPartC()->at(k);&#xD;
			&#xD;
			for(unsigned int l = 0; l &lt; currentPartEnd2->getQ()->size(); l++)&#xD;
				{&#xD;
				std::shared_ptr&lt;IImplementation> currentPortOfPartEnd2 = currentPartEnd2->getQ()->at(l);&#xD;
				bool connected = false;&#xD;
				&#xD;
				for(unsigned int m = 0; m &lt; currentPortOfPartEnd1->getY()->size(); m++)&#xD;
				{&#xD;
					std::shared_ptr&lt;IImplementation> currentYOfPortOfPartEnd1 = currentPortOfPartEnd1->getY()->at(m);&#xD;
					if(currentPortOfPartEnd2  == currentYOfPortOfPartEnd1)&#xD;
					{	&#xD;
						for(unsigned int h=0; h &lt; currentPortOfPartEnd2->getX()->size() &amp;&amp; !connected; h++)&#xD;
						{&#xD;
							std::shared_ptr&lt;IImplementation> currentXOfPortOfPartEnd2 = currentPortOfPartEnd2->getX()->at(h);&#xD;
							if(!connected &amp;&amp; (currentXOfPortOfPartEnd2 == currentPortOfPartEnd1)) connected = true;&#xD;
						}&#xD;
					}&#xD;
				}	&#xD;
				std::string connectedString = connected ? &quot;&lt;->&quot; : &quot;   &quot;;&#xD;
				connectionsString += &quot;\tpartB[&quot;+std::to_string(i)+&quot;]->p[&quot;+std::to_string(j)+&quot;]&quot;+connectedString+&quot;partC[&quot;+std::to_string(k)+&quot;]->q[&quot;+std::to_string(l)+&quot;]\n&quot;;&#xD;
			}&#xD;
		}&#xD;
		connectionsString+=&quot;\n&quot;;&#xD;
	}&#xD;
	connectionsString+=&quot;\n&quot;;&#xD;
}&#xD;
&#xD;
if(successful){&#xD;
	std::cout&lt;&lt;&quot;Links creation successful : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
	&#xD;
	std::cout&lt;&lt;connectionsString&lt;&lt;std::endl;&#xD;
}&#xD;
else{&#xD;
	std::cout&lt;&lt;&quot;Links creation successful : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
	std::cout&lt;&lt;&quot;Created links are:&quot;&lt;&lt;std::endl;&#xD;
	std::cout&lt;&lt;connectionsString&lt;&lt;std::endl;&#xD;
	std::cout&lt;&lt;&quot;Created links should be:&quot;&lt;&lt;std::endl;&#xD;
	std::cout&lt;&lt;compareString&lt;&lt;std::endl;&#xD;
}&#xD;
&#xD;
std::cout&lt;&lt;&quot;Instantiation was successful : &quot;&lt;&lt;std::boolalpha&lt;&lt;successful&lt;&lt;std::endl;&#xD;
std::cout&lt;&lt;&quot;-- Instantiation of A_Star_Pattern --&quot;&lt;&lt;std::endl;&#xD;
std::cout&lt;&lt;&quot;Press Enter for next pattern...&quot;;&#xD;
getchar();</body>
        <body>#include &quot;AssemblyConnectors_PWP_PWP/B.hpp&quot;&#xD;
#include &quot;AssemblyConnectors_PWP_PWP/C.hpp&quot;&#xD;
#include &quot;AssemblyConnectors_PWP_PWP/IImplementation.hpp&quot;</body>
      </ownedBehavior>
      <ownedBehavior xmi:type="uml:Activity" xmi:id="_UUUpkI4mEeqm_eVeNYUZww" name="actRunTestCase" specification="_SmTokI4mEeqm_eVeNYUZww" node="_MWHncI4nEeqm_eVeNYUZww _Nx0JYI4nEeqm_eVeNYUZww _S8h6wI4nEeqm_eVeNYUZww _YZLJoI4nEeqm_eVeNYUZww _e4SiII4nEeqm_eVeNYUZww _nYEK0I4nEeqm_eVeNYUZww _sVJI0I4nEeqm_eVeNYUZww _101WYI4nEeqm_eVeNYUZww _9Yi_cI4nEeqm_eVeNYUZww _FayXkI4oEeqm_eVeNYUZww">
        <edge xmi:type="uml:ControlFlow" xmi:id="_QQhAcI4nEeqm_eVeNYUZww" target="_Nx0JYI4nEeqm_eVeNYUZww" source="_MWHncI4nEeqm_eVeNYUZww">
          <guard xmi:type="uml:LiteralBoolean" xmi:id="_QQhAcY4nEeqm_eVeNYUZww" name="Initial1_To_Fork1_guard" value="true"/>
          <weight xmi:type="uml:LiteralInteger" xmi:id="_QQhngI4nEeqm_eVeNYUZww" name="Initial1_To_Fork1_weight"/>
        </edge>
        <edge xmi:type="uml:ControlFlow" xmi:id="_L5ijsI4oEeqm_eVeNYUZww" target="_101WYI4nEeqm_eVeNYUZww" source="_sVJI0I4nEeqm_eVeNYUZww">
          <guard xmi:type="uml:LiteralBoolean" xmi:id="_L5jKwI4oEeqm_eVeNYUZww" name="callTestAEmptyPattern_To_cattTestAUnconnectedPattern_guard" value="true"/>
          <weight xmi:type="uml:LiteralInteger" xmi:id="_L5jKwY4oEeqm_eVeNYUZww" name="callTestAEmptyPattern_To_cattTestAUnconnectedPattern_weight"/>
        </edge>
        <edge xmi:type="uml:ControlFlow" xmi:id="_Moi-wI4oEeqm_eVeNYUZww" target="_9Yi_cI4nEeqm_eVeNYUZww" source="_101WYI4nEeqm_eVeNYUZww">
          <guard xmi:type="uml:LiteralBoolean" xmi:id="_Moi-wY4oEeqm_eVeNYUZww" name="cattTestAUnconnectedPattern_To_callTestAArrayPattern_guard" value="true"/>
          <weight xmi:type="uml:LiteralInteger" xmi:id="_Mojl0I4oEeqm_eVeNYUZww" name="cattTestAUnconnectedPattern_To_callTestAArrayPattern_weight"/>
        </edge>
        <edge xmi:type="uml:ControlFlow" xmi:id="_NRSZwI4oEeqm_eVeNYUZww" target="_FayXkI4oEeqm_eVeNYUZww" source="_9Yi_cI4nEeqm_eVeNYUZww">
          <guard xmi:type="uml:LiteralBoolean" xmi:id="_NRSZwY4oEeqm_eVeNYUZww" name="callTestAArrayPattern_To_callTestAStarPattern_guard" value="true"/>
          <weight xmi:type="uml:LiteralInteger" xmi:id="_NRTA0I4oEeqm_eVeNYUZww" name="callTestAArrayPattern_To_callTestAStarPattern_weight"/>
        </edge>
        <edge xmi:type="uml:ObjectFlow" xmi:id="_QTAeUI4oEeqm_eVeNYUZww" target="_v87H0I4nEeqm_eVeNYUZww" source="_S8h6wY4nEeqm_eVeNYUZww"/>
        <edge xmi:type="uml:ObjectFlow" xmi:id="_Qy5fUI4oEeqm_eVeNYUZww" target="_4-yJ4I4nEeqm_eVeNYUZww" source="_YZLJoY4nEeqm_eVeNYUZww"/>
        <edge xmi:type="uml:ObjectFlow" xmi:id="_RSkd4I4oEeqm_eVeNYUZww" target="_AAerAI4oEeqm_eVeNYUZww" source="_e4SiIY4nEeqm_eVeNYUZww"/>
        <edge xmi:type="uml:ObjectFlow" xmi:id="_RuPtQI4oEeqm_eVeNYUZww" target="_H1EBoI4oEeqm_eVeNYUZww" source="_nYEx4I4nEeqm_eVeNYUZww"/>
        <node xmi:type="uml:InitialNode" xmi:id="_MWHncI4nEeqm_eVeNYUZww" name="Initial1" outgoing="_QQhAcI4nEeqm_eVeNYUZww"/>
        <node xmi:type="uml:ForkNode" xmi:id="_Nx0JYI4nEeqm_eVeNYUZww" name="Fork1" incoming="_QQhAcI4nEeqm_eVeNYUZww"/>
        <node xmi:type="uml:CreateObjectAction" xmi:id="_S8h6wI4nEeqm_eVeNYUZww" name="CreateAEmptyPattern" classifier="_z6HwQO9BEemWP7t7cfH8xA">
          <result xmi:id="_S8h6wY4nEeqm_eVeNYUZww" name="aEmptyPattern" outgoing="_QTAeUI4oEeqm_eVeNYUZww" type="_z6HwQO9BEemWP7t7cfH8xA"/>
        </node>
        <node xmi:type="uml:CreateObjectAction" xmi:id="_YZLJoI4nEeqm_eVeNYUZww" name="CreateAUnconnectedPattern" classifier="_bfcP8FIvEeq4WpdDJnu9kg">
          <result xmi:id="_YZLJoY4nEeqm_eVeNYUZww" name="aUnconnectedPattern" outgoing="_Qy5fUI4oEeqm_eVeNYUZww" type="_bfcP8FIvEeq4WpdDJnu9kg"/>
        </node>
        <node xmi:type="uml:CreateObjectAction" xmi:id="_e4SiII4nEeqm_eVeNYUZww" name="CreateAArrayPattern" classifier="_rZJ6oFIvEeq4WpdDJnu9kg">
          <result xmi:id="_e4SiIY4nEeqm_eVeNYUZww" name="aArrayPattern" outgoing="_RSkd4I4oEeqm_eVeNYUZww" type="_rZJ6oFIvEeq4WpdDJnu9kg"/>
        </node>
        <node xmi:type="uml:CreateObjectAction" xmi:id="_nYEK0I4nEeqm_eVeNYUZww" name="CreateAStarPattern" classifier="__fogsFIvEeq4WpdDJnu9kg">
          <result xmi:id="_nYEx4I4nEeqm_eVeNYUZww" name="aStarPattern" outgoing="_RuPtQI4oEeqm_eVeNYUZww" type="__fogsFIvEeq4WpdDJnu9kg"/>
        </node>
        <node xmi:type="uml:CallOperationAction" xmi:id="_sVJI0I4nEeqm_eVeNYUZww" name="callTestAEmptyPattern" outgoing="_L5ijsI4oEeqm_eVeNYUZww" operation="_N16ycFgSEeqZPe2oHCHy2Q">
          <argument xmi:id="_v87H0I4nEeqm_eVeNYUZww" name="aEmptyPattern" incoming="_QTAeUI4oEeqm_eVeNYUZww" type="_z6HwQO9BEemWP7t7cfH8xA"/>
          <target xmi:id="_sVJI0Y4nEeqm_eVeNYUZww" name="self" type="_AX6AEFgQEeqZPe2oHCHy2Q"/>
        </node>
        <node xmi:type="uml:CallOperationAction" xmi:id="_101WYI4nEeqm_eVeNYUZww" name="callTestAUnconnectedPattern" incoming="_L5ijsI4oEeqm_eVeNYUZww" outgoing="_Moi-wI4oEeqm_eVeNYUZww" operation="_1_Kt0FgTEeqZPe2oHCHy2Q">
          <argument xmi:id="_4-yJ4I4nEeqm_eVeNYUZww" name="aUnconnectedPattern" incoming="_Qy5fUI4oEeqm_eVeNYUZww" type="_bfcP8FIvEeq4WpdDJnu9kg"/>
          <target xmi:id="_101WYY4nEeqm_eVeNYUZww" name="self" type="_AX6AEFgQEeqZPe2oHCHy2Q"/>
        </node>
        <node xmi:type="uml:CallOperationAction" xmi:id="_9Yi_cI4nEeqm_eVeNYUZww" name="callTestAArrayPattern" incoming="_Moi-wI4oEeqm_eVeNYUZww" outgoing="_NRSZwI4oEeqm_eVeNYUZww" operation="_-PQ7wFgTEeqZPe2oHCHy2Q">
          <argument xmi:id="_AAerAI4oEeqm_eVeNYUZww" name="aArrayPattern" incoming="_RSkd4I4oEeqm_eVeNYUZww" type="_rZJ6oFIvEeq4WpdDJnu9kg"/>
          <target xmi:id="_9Yi_cY4nEeqm_eVeNYUZww" name="self" type="_AX6AEFgQEeqZPe2oHCHy2Q"/>
        </node>
        <node xmi:type="uml:CallOperationAction" xmi:id="_FayXkI4oEeqm_eVeNYUZww" name="callTestAStarPattern" incoming="_NRSZwI4oEeqm_eVeNYUZww" operation="_HVXkoFgUEeqZPe2oHCHy2Q">
          <argument xmi:id="_H1EBoI4oEeqm_eVeNYUZww" name="aStarPattern" incoming="_RuPtQI4oEeqm_eVeNYUZww" type="__fogsFIvEeq4WpdDJnu9kg"/>
          <target xmi:id="_Fay-oI4oEeqm_eVeNYUZww" name="self" type="_AX6AEFgQEeqZPe2oHCHy2Q"/>
        </node>
      </ownedBehavior>
      <ownedOperation xmi:id="_N16ycFgSEeqZPe2oHCHy2Q" name="testAEmptyPattern" method="_6vTt8FgREeqZPe2oHCHy2Q">
        <ownedParameter xmi:id="_TUYmQFgSEeqZPe2oHCHy2Q" name="aEmptyPattern" type="_z6HwQO9BEemWP7t7cfH8xA"/>
      </ownedOperation>
      <ownedOperation xmi:id="_1_Kt0FgTEeqZPe2oHCHy2Q" name="testAUnconnectedPattern" method="_-aF9oFgREeqZPe2oHCHy2Q">
        <ownedParameter xmi:id="_7GFkUFgTEeqZPe2oHCHy2Q" name="aUnconnectedPattern" type="_bfcP8FIvEeq4WpdDJnu9kg"/>
      </ownedOperation>
      <ownedOperation xmi:id="_-PQ7wFgTEeqZPe2oHCHy2Q" name="testAArrayPattern" method="_CeMFMFgSEeqZPe2oHCHy2Q">
        <ownedParameter xmi:id="_-PQ7wVgTEeqZPe2oHCHy2Q" name="aArrayPattern" type="_rZJ6oFIvEeq4WpdDJnu9kg"/>
      </ownedOperation>
      <ownedOperation xmi:id="_HVXkoFgUEeqZPe2oHCHy2Q" name="testAStarPattern" method="_EXuZsFgSEeqZPe2oHCHy2Q">
        <ownedParameter xmi:id="_HVXkoVgUEeqZPe2oHCHy2Q" name="aStarPattern" type="__fogsFIvEeq4WpdDJnu9kg"/>
      </ownedOperation>
      <ownedOperation xmi:id="_SmTokI4mEeqm_eVeNYUZww" name="runTestCase" method="_UUUpkI4mEeqm_eVeNYUZww"/>
    </packagedElement>
    <packagedElement xmi:type="uml:OpaqueBehavior" xmi:id="_MNw7kOMVEeur7cjoMTUC9A" name="main">
      <language>CPP</language>
      <body>std::cout&lt;&lt;&quot;-- Test model : Assembly connector between a part with port and a part with port&quot;&lt;&lt;std::endl;&#xD;
&#xD;
std::shared_ptr&lt;AssemblyConnectors_PWP_PWP::Tester> tester = factory->createTester();&#xD;
&#xD;
std::cout&lt;&lt;&quot;-- Running test case: Assembly connector between a part with port and a part with port --&quot;&lt;&lt;std::endl;&#xD;
std::cout&lt;&lt;std::endl;&#xD;
&#xD;
tester->runTestCase();&#xD;
&#xD;
std::cout&lt;&lt;std::endl;&#xD;
std::cout&lt;&lt;&quot;-- End of test case --&quot;&lt;&lt;std::endl;</body>
    </packagedElement>
    <profileApplication xmi:id="_TnuoMOMUEeur7cjoMTUC9A">
      <eAnnotations xmi:id="_TnuoMeMUEeur7cjoMTUC9A" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="../../../../../common/UML4CPPProfile/model/UML4CPPProfile.uml#_v75nIfp7EeuavpF89IQaUg"/>
      </eAnnotations>
      <appliedProfile href="../../../../../common/UML4CPPProfile/model/UML4CPPProfile.uml#_0"/>
    </profileApplication>
  </uml:Model>
  <UML4CPPProfile:MainBehavior xmi:id="_RnUaMOMVEeur7cjoMTUC9A" base_Behavior="_MNw7kOMVEeur7cjoMTUC9A"/>
  <UML4CPPProfile:NonExecutable xmi:id="_RnUaMeMVEeur7cjoMTUC9A" base_NamedElement="_MNw7kOMVEeur7cjoMTUC9A"/>
</xmi:XMI>
