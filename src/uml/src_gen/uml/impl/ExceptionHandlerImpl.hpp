//********************************************************************
//*    
//* Warning: This file was generated by ecore4CPP Generator
//*
//********************************************************************

#ifndef UML_EXCEPTIONHANDLEREXCEPTIONHANDLERIMPL_HPP
#define UML_EXCEPTIONHANDLEREXCEPTIONHANDLERIMPL_HPP

//*********************************
// generated Includes

//Model includes
#include "../ExceptionHandler.hpp"

#include "uml/impl/ElementImpl.hpp"

//*********************************
namespace uml 
{
	class ExceptionHandlerImpl :virtual public ElementImpl, virtual public ExceptionHandler 
	{
		public: 
			ExceptionHandlerImpl(const ExceptionHandlerImpl & obj);
			virtual std::shared_ptr<ecore::EObject> copy() const;

		private:    
			ExceptionHandlerImpl& operator=(ExceptionHandlerImpl const&) = delete;

		protected:
			friend class UmlFactoryImpl;
			ExceptionHandlerImpl();
			virtual std::shared_ptr<ExceptionHandler> getThisExceptionHandlerPtr() const;
			virtual void setThisExceptionHandlerPtr(std::weak_ptr<ExceptionHandler> thisExceptionHandlerPtr);

			//Additional constructors for the containments back reference
			ExceptionHandlerImpl(std::weak_ptr<uml::Element > par_owner);


			//Additional constructors for the containments back reference
			ExceptionHandlerImpl(std::weak_ptr<uml::ExecutableNode > par_protectedNode);




		public:
			//destructor
			virtual ~ExceptionHandlerImpl();
			
			//*********************************
			// Operations
			//*********************************
			/*!
			 An ActivityEdge that has a source within the handlerBody of an ExceptionHandler must have its target in the handlerBody also, and vice versa.
			let nodes:Set(ActivityNode) = handlerBody.oclAsType(Action).allOwnedNodes() in
			nodes.outgoing->forAll(nodes->includes(target)) and
			nodes.incoming->forAll(nodes->includes(source)) */ 
			virtual bool edge_source_target(Any diagnostics,std::map <   Any, Any >  context) ;
			
			/*!
			 The exceptionInput must either have no type or every exceptionType must conform to the exceptionInput type.
			exceptionInput.type=null or 
			exceptionType->forAll(conformsTo(exceptionInput.type.oclAsType(Classifier))) */ 
			virtual bool exception_input_type(Any diagnostics,std::map <   Any, Any >  context) ;
			
			/*!
			 The handlerBody has no incoming or outgoing ActivityEdges and the exceptionInput has no incoming ActivityEdges.
			handlerBody.incoming->isEmpty() and handlerBody.outgoing->isEmpty() and exceptionInput.incoming->isEmpty() */ 
			virtual bool handler_body_edges(Any diagnostics,std::map <   Any, Any >  context) ;
			
			/*!
			 The handlerBody must have the same owner as the protectedNode.
			handlerBody.owner=protectedNode.owner */ 
			virtual bool handler_body_owner(Any diagnostics,std::map <   Any, Any >  context) ;
			
			/*!
			 The handlerBody is an Action with one InputPin, and that InputPin is the same as the exceptionInput.
			handlerBody.oclIsKindOf(Action) and
			let inputs: OrderedSet(InputPin) = handlerBody.oclAsType(Action).input in
			inputs->size()=1 and inputs->first()=exceptionInput */ 
			virtual bool one_input(Any diagnostics,std::map <   Any, Any >  context) ;
			
			/*!
			 If the protectedNode is an Action with OutputPins, then the handlerBody must also be an Action with the same number of OutputPins, which are compatible in type, ordering, and multiplicity to those of the protectedNode.
			(protectedNode.oclIsKindOf(Action) and protectedNode.oclAsType(Action).output->notEmpty()) implies
			(
			  handlerBody.oclIsKindOf(Action) and 
			  let protectedNodeOutput : OrderedSet(OutputPin) = protectedNode.oclAsType(Action).output,
			        handlerBodyOutput : OrderedSet(OutputPin) =  handlerBody.oclAsType(Action).output in
			    protectedNodeOutput->size() = handlerBodyOutput->size() and
			    Sequence{1..protectedNodeOutput->size()}->forAll(i |
			    	handlerBodyOutput->at(i).type.conformsTo(protectedNodeOutput->at(i).type) and
			    	handlerBodyOutput->at(i).isOrdered=protectedNodeOutput->at(i).isOrdered and
			    	handlerBodyOutput->at(i).compatibleWith(protectedNodeOutput->at(i)))
			) */ 
			virtual bool output_pins(Any diagnostics,std::map <   Any, Any >  context) ;
			
			
			
			//*********************************
			// Attributes Getter Setter
			//*********************************
			
			
			//*********************************
			// Reference
			//*********************************
			/*!
			 An ObjectNode within the handlerBody. When the ExceptionHandler catches an exception, the exception token is placed on this ObjectNode, causing the handlerBody to execute.
			<p>From package UML::Activities.</p> */
			virtual std::shared_ptr<uml::ObjectNode > getExceptionInput() const ;
			
			/*!
			 An ObjectNode within the handlerBody. When the ExceptionHandler catches an exception, the exception token is placed on this ObjectNode, causing the handlerBody to execute.
			<p>From package UML::Activities.</p> */
			virtual void setExceptionInput(std::shared_ptr<uml::ObjectNode> _exceptionInput_exceptionInput) ;
			/*!
			 The Classifiers whose instances the ExceptionHandler catches as exceptions. If an exception occurs whose type is any exceptionType, the ExceptionHandler catches the exception and executes the handlerBody.
			<p>From package UML::Activities.</p> */
			virtual std::shared_ptr<Bag<uml::Classifier>> getExceptionType() const ;
			
			/*!
			 An ExecutableNode that is executed if the ExceptionHandler catches an exception.
			<p>From package UML::Activities.</p> */
			virtual std::shared_ptr<uml::ExecutableNode > getHandlerBody() const ;
			
			/*!
			 An ExecutableNode that is executed if the ExceptionHandler catches an exception.
			<p>From package UML::Activities.</p> */
			virtual void setHandlerBody(std::shared_ptr<uml::ExecutableNode> _handlerBody_handlerBody) ;
			/*!
			 The ExecutableNode protected by the ExceptionHandler. If an exception propagates out of the protectedNode and has a type matching one of the exceptionTypes, then it is caught by this ExceptionHandler.
			<p>From package UML::Activities.</p> */
			virtual std::weak_ptr<uml::ExecutableNode > getProtectedNode() const ;
			
			/*!
			 The ExecutableNode protected by the ExceptionHandler. If an exception propagates out of the protectedNode and has a type matching one of the exceptionTypes, then it is caught by this ExceptionHandler.
			<p>From package UML::Activities.</p> */
			virtual void setProtectedNode(std::shared_ptr<uml::ExecutableNode> _protectedNode_protectedNode) ;
							
			
			//*********************************
			// Union Getter
			//*********************************
			/*!
			 The Elements owned by this Element.
			<p>From package UML::CommonStructure.</p> */
			virtual std::shared_ptr<Union<uml::Element>> getOwnedElement() const ;/*!
			 The Element that owns this Element.
			<p>From package UML::CommonStructure.</p> */
			virtual std::weak_ptr<uml::Element > getOwner() const ; 
			 
			//*********************************
			// Structural Feature Getter/Setter
			//*********************************

			virtual std::shared_ptr<ecore::EObject> eContainer() const ; 
			
			//*********************************
			// Persistence Functions
			//*********************************
			virtual void load(std::shared_ptr<persistence::interfaces::XLoadHandler> loadHandler) ;
			virtual void loadAttributes(std::shared_ptr<persistence::interfaces::XLoadHandler> loadHandler, std::map<std::string, std::string> attr_list);
			virtual void loadNode(std::string nodeName, std::shared_ptr<persistence::interfaces::XLoadHandler> loadHandler);
			
			virtual void resolveReferences(const int featureID, std::list<std::shared_ptr<ecore::EObject> > references) ;
			virtual void save(std::shared_ptr<persistence::interfaces::XSaveHandler> saveHandler) const ;
			virtual void saveContent(std::shared_ptr<persistence::interfaces::XSaveHandler> saveHandler) const;
			

		protected:
			virtual std::shared_ptr<ecore::EClass> eStaticClass() const;
			virtual Any eGet(int featureID, bool resolve, bool coreType) const ;
			virtual bool internalEIsSet(int featureID) const ;
			virtual bool eSet(int featureID, Any newValue) ;

		private:
			std::weak_ptr<ExceptionHandler> m_thisExceptionHandlerPtr;
	};
}
#endif /* end of include guard: UML_EXCEPTIONHANDLEREXCEPTIONHANDLERIMPL_HPP */
