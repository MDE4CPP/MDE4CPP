[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 ****************************************************************************************************************************************************************
 * 
 * module for generation of eSet/ eGet artefacts
 * 
 */]
[module setGetHelper('http://www.eclipse.org/uml2/5.0.0/UML')]

[import UML4CPP::generator::main::components::generateProperty /]
[import UML4CPP::generator::main::components::generateOperation /]
[import UML4CPP::generator::main::components::generateType /]
[import UML4CPP::generator::main::components::generateClass /]
[import UML4CPP::generator::main::helpers::generalHelper /]
[import UML4CPP::generator::main::helpers::nameHelper /]
[import UML4CPP::generator::main::helpers::IDHelper /]
[import UML4CPP::generator::main::profiles::uml4CPPProfileHelper /]

[**
 * checks if setter for a StructuralFeature should be generated
 * 
 * setter should not exist for:
 * - feature with upper bound > 1 (realized by list and getter)
 * - feature is read only
*/]
[query public hasSetter(aFeature : StructuralFeature) : Boolean = not (( not (aFeature.upper = 1) ) and (not aFeature.oclAsType(Property).isReadOnly)) /]

[**
 * generate get, set and unset function declaration
*/]
[template public generateeGetSetDel(aClass : Class,impl : Boolean)]
//Get
virtual std::shared_ptr<Any> get(std::shared_ptr<uml::Property> _property) const [abstractSuffix(impl)/];
virtual std::shared_ptr<Any> get(std::string _qualifiedName) const [abstractSuffix(impl)/];
virtual std::shared_ptr<Any> get(unsigned long _uID) const [abstractSuffix(impl)/];
//Set
virtual void set(std::shared_ptr<uml::Property> _property, std::shared_ptr<Any> value) [abstractSuffix(impl)/];
virtual void set(std::string _qualifiedName, std::shared_ptr<Any> value) [abstractSuffix(impl)/];
virtual void set(unsigned long _uID, std::shared_ptr<Any> value) [abstractSuffix(impl)/];
//Add
virtual void add(std::shared_ptr<uml::Property> _property, std::shared_ptr<Any> value, int insertAt = -1) [abstractSuffix(impl)/];
virtual void add(std::string _qualifiedName, std::shared_ptr<Any> value, int insertAt = -1) [abstractSuffix(impl)/];
virtual void add(unsigned long _uID, std::shared_ptr<Any> value, int insertAt = -1) [abstractSuffix(impl)/];
//Unset
virtual void unset(std::shared_ptr<uml::Property> _property) [abstractSuffix(impl)/];
virtual void unset(std::string _qualifiedName) [abstractSuffix(impl)/];
virtual void unset(unsigned long _uID) [abstractSuffix(impl)/];
[/template]

[**
 * generate get, set and unset function declaration
*/]
[template public generateInvoke(aClass : Class,impl : Boolean)]
//Invoke
virtual std::shared_ptr<Any> invoke(std::shared_ptr<uml::Operation> _operation, std::shared_ptr<Bag<Any>> _arguments) [abstractSuffix(impl)/];
virtual std::shared_ptr<Any> invoke(std::string _qualifiedName, std::shared_ptr<Bag<Any>> _arguments) [abstractSuffix(impl)/];
virtual std::shared_ptr<Any> invoke(unsigned long _uID, std::shared_ptr<Bag<Any>> _arguments) [abstractSuffix(impl)/];
[/template]

[query private getPropertiesForGetAndSet(aClass : Class) : OrderedSet(Property) = aClass.attribute->addAll(aClass.interfaceRealization.contract.attribute)->reject(isDoNotGenerateElement())->sortedBy(myQualifiedName())/]
[query private getOperationsForInvoke(aClass : Class) : OrderedSet(Operation) = aClass.ownedOperation->addAll(aClass.interfaceRealization.contract.ownedOperation)->reject(isDoNotGenerateElement())->sortedBy(myQualifiedName())/]

[**
 * generate get, set and unset function implementation
*/]
[template public generateeGetSetImpl(aClass : Class)]
//Get
[aClass.generateGetImplementation()/]

//Set
[aClass.generateSetImplementation()/]

//Add
[aClass.generateAddImplementation()/]

//Unset
[aClass.generateUnSetImplementation()/]
[/template]

[template private generateGetImplementation(aClass : Class)]
std::shared_ptr<Any> [aClass.name.toUpperFirst().concat('Impl')/]::get(std::shared_ptr<uml::Property> _property) const
{
	std::string qualifiedName = _property->getQualifiedName();
	return this->get(qualifiedName);
}

std::shared_ptr<Any> [aClass.name.toUpperFirst().concat('Impl')/]::get(std::string _qualifiedName) const
{
	unsigned long uID = util::Util::polynomialRollingHash(_qualifiedName);
	return this->get(uID);
}

std::shared_ptr<Any> [aClass.name.toUpperFirst().concat('Impl')/]::get(unsigned long _uID) const
{
[if (not aClass.getPropertiesForGetAndSet()->isEmpty())]
	switch(_uID)
	{
		[for (aProperty : Property | aClass.getPropertiesForGetAndSet())]
			[let anyBagRequired : Boolean = ((aProperty.upper <> 1) and not(aProperty.type.oclIsKindOf(PrimitiveType) or aProperty.type.oclIsKindOf(Enumeration)))]
		case [aClass.generateNamespace(true)/]::[aClass._package.getPackageName()/]Package::[aProperty.getMemberName().toUpperCase()/]:
			return [if(anyBagRequired)]eAnyBag[else]eAny[/if](this->[aProperty.getterName()/](), [aProperty.type.oclAsType(Classifier).generateStaticClassifierIDAccess()/][if(not anyBagRequired)], [if(aProperty.upper = 1)]false[else]true[/if][/if]);
			[/let]
		[/for]
		[for (compositeOwnerClass : Class | aClass.getImplicitCompositeOwners()) before('//Composite owner properties\n')]
		case [aClass.generateNamespace(true)/]::[aClass._package.getPackageName()/]Package::[aClass.name.toUpperCase()/]_ATTRIBUTE_[compositeOwnerClass.name.toUpperCase()/]:
			return eAny(this->get[compositeOwnerClass.name.toUpperFirst()/](), [compositeOwnerClass.generateStaticClassifierIDAccess()/], false);
		[/for]
	}

[/if]
[let classList : OrderedSet(Class) = aClass.superClass->reject(oclIsUndefined() and name.oclIsUndefined())->sortedBy(name)]
[if (classList->size() > 0)]
	std::shared_ptr<Any> result;
	[for (sClass : Class | aClass.superClass->reject(oclIsUndefined() and name.oclIsUndefined()))]
	//Call get() for base class [sClass.name/]
	result = [sClass.generateNamespaceName(true)/]Impl::get(_uID);
	if (result != nullptr)
	{
		return result;
	}
	[/for]
	return result;
[else]
	return eAny(nullptr, -1, false);
[/if]
[/let]
}
[/template]

[template private generateSetImplementation(aClass : Class)]
void [aClass.name.toUpperFirst().concat('Impl')/]::set(std::shared_ptr<uml::Property> _property, std::shared_ptr<Any> value)
{
	std::string qualifiedName = _property->getQualifiedName();
	this->set(qualifiedName, value);
}

void [aClass.name.toUpperFirst().concat('Impl')/]::set(std::string _qualifiedName, std::shared_ptr<Any> value)
{
	unsigned long uID = util::Util::polynomialRollingHash(_qualifiedName);
	this->set(uID, value);
}

void [aClass.name.toUpperFirst().concat('Impl')/]::set(unsigned long _uID, std::shared_ptr<Any> value)
{
[if (not aClass.getPropertiesForGetAndSet()->select(hasSetter())->isEmpty())]
	switch(_uID)
	{
		[for (aProperty : Property | aClass.getPropertiesForGetAndSet()->select(hasSetter()))]
		case [aClass.generateNamespace(true)/]::[aClass._package.getPackageName()/]Package::[aProperty.getMemberName().toUpperCase()/]:
		{
			if(value->isContainer())
			{
				std::shared_ptr<Bag<[aProperty.type.generateCppType(true)/]>> container = value->get<std::shared_ptr<Bag<[aProperty.type.generateCppType(true)/]>>>();
				if(container)
				{
					if(!(container->empty()))
					{
						// If a non-empty container is passed, the property will be set to the first value of the container
						this->[aProperty.setterName()/]([if(aProperty.type.isPrimitive() or aProperty.type.oclIsKindOf(Enumeration))]*([/if]container->at(0)[if(aProperty.type.isPrimitive() or aProperty.type.oclIsKindOf(Enumeration))])[/if]);
					}
				}
			}
			else
			{
				this->[aProperty.setterName()/](value->get<[aProperty.type.generateCppType(false)/]>());
			}
			return;
		}
		[/for]
		[for (compositeOwnerClass : Class | aClass.getImplicitCompositeOwners()) before('//Composite owner properties\n')]
		case [aClass.generateNamespace(true)/]::[aClass._package.getPackageName()/]Package::[aClass.name.toUpperCase()/]_ATTRIBUTE_[compositeOwnerClass.name.toUpperCase()/]:
		{
			this->set[compositeOwnerClass.name.toUpperFirst()/](object->get<[compositeOwnerClass.generateCppType(false)/]>());
			//TODO also set back reference?
			return;
		}
		[/for]
	}

[/if]
[for (sClass : Class | aClass.superClass->reject(oclIsUndefined() and name.oclIsUndefined()))]
	//Call set() for base class [sClass.name/]
	[sClass.generateNamespaceName(true)/]Impl::set(_uID, value);
[/for]
}
[/template]

[template private generateAddImplementation(aClass : Class)]
void [aClass.name.toUpperFirst().concat('Impl')/]::add(std::shared_ptr<uml::Property> _property, std::shared_ptr<Any> value, int insertAt /*= -1*/)
{
	std::string qualifiedName = _property->getQualifiedName();
	this->set(qualifiedName, value);
}

void [aClass.name.toUpperFirst().concat('Impl')/]::add(std::string _qualifiedName, std::shared_ptr<Any> value, int insertAt /*= -1*/)
{
	unsigned long uID = util::Util::polynomialRollingHash(_qualifiedName);
	this->set(uID, value);
}

void [aClass.name.toUpperFirst().concat('Impl')/]::add(unsigned long _uID, std::shared_ptr<Any> value, int insertAt /*= -1*/)
{
[if (not aClass.getPropertiesForGetAndSet()->select(p : Property | (not p.isReadOnly) and p.upper <> 1)->isEmpty())]
	switch(_uID)
	{
		[for (aProperty : Property | aClass.getPropertiesForGetAndSet()->select(p : Property | (not p.isReadOnly) and p.upper <> 1))]
		case [aClass.generateNamespace(true)/]::[aClass._package.getPackageName()/]Package::[aProperty.getMemberName().toUpperCase()/]:
		{
			[aProperty.type.generateCppType(false)/] valueToAdd;
			if(value->isContainer())
			{
				std::shared_ptr<Bag<[aProperty.type.generateCppType(true)/]>> container = value->get<std::shared_ptr<Bag<[aProperty.type.generateCppType(true)/]>>>();
				if(container)
				{
					if(!(container->empty()))
					{
						// If a non-empty container is passed, the first value of the container will be added to the property
						valueToAdd = [if(aProperty.type.isPrimitive() or aProperty.type.oclIsKindOf(Enumeration))]*([/if]container->at(0)[if(aProperty.type.isPrimitive() or aProperty.type.oclIsKindOf(Enumeration))])[/if];
					}
				}
			}
			else
			{
				valueToAdd = value->get<[aProperty.type.generateCppType(false)/]>();
			}

			[if (aProperty.isUnique)]
			// [aProperty.name/] is unique
			if(this->[aProperty.getterName()/]()->find(valueToAdd) == -1)
			{
				this->[aProperty.getterName()/]()->add(valueToAdd, insertAt);
			}
			[else]
			this->[aProperty.getterName()/]()->add(valueToAdd, insertAt);
			[/if]

			return;
		}
		[/for]
	}

[/if]
[for (sClass : Class | aClass.superClass->reject(oclIsUndefined() and name.oclIsUndefined()))]
	//Call set() for base class [sClass.name/]
	[sClass.generateNamespaceName(true)/]Impl::add(_uID, value);
[/for]
}
[/template]

[template private generateUnSetImplementation(aClass : Class)]
void [aClass.name.toUpperFirst().concat('Impl')/]::unset(std::shared_ptr<uml::Property> _property)
{
	std::string qualifiedName = _property->getQualifiedName();
	this->unset(qualifiedName);
}

void [aClass.name.toUpperFirst().concat('Impl')/]::unset(std::string _qualifiedName)
{
	unsigned long uID = util::Util::polynomialRollingHash(_qualifiedName);
	this->unset(uID);
}

void [aClass.name.toUpperFirst().concat('Impl')/]::unset(unsigned long _uID)
{
[if (not aClass.getPropertiesForGetAndSet()->reject(type.oclIsKindOf(PrimitiveType) or type.oclIsKindOf(Enumeration))->isEmpty())]
	switch(_uID)
	{
		[for (aProperty : Property | aClass.getPropertiesForGetAndSet()->reject(type.oclIsKindOf(PrimitiveType) or type.oclIsKindOf(Enumeration)))]
		case [aClass.generateNamespace(true)/]::[aClass._package.getPackageName()/]Package::[aProperty.getMemberName().toUpperCase()/]:
		{
			[if (aProperty.upper = 1)]
			m_[aProperty.name/].reset();
			[else]
			m_[aProperty.name/]->clear();
			[/if]
			return;
		}
		[/for]
		[for (compositeOwnerClass : Class | aClass.getImplicitCompositeOwners()) before('//Composite owner properties\n')]
		case [aClass.generateNamespace(true)/]::[aClass._package.getPackageName()/]Package::[aClass.name.toUpperCase()/]_ATTRIBUTE_[compositeOwnerClass.name.toUpperCase()/]:
		{
			m_[compositeOwnerClass.name/].reset();
			//TODO also unset back reference
			return;
		}
		[/for]
	}

[/if]
	[for (sClass : Class | aClass.superClass->reject(oclIsUndefined() and name.oclIsUndefined()))]
	//Call unset() for base class [sClass.name/]
	[sClass.generateNamespaceName(true)/]Impl::unset(_uID);
	[/for]
}
[/template]

[**
 * generate invoke function implementation
*/]
[template public generateInvokeImpl(aClass : Class)]
//Invoke
[aClass.generateInvokeImplementation()/]
[/template]

[template private generateInvokeImplementation(aClass : Class)]
std::shared_ptr<Any> [aClass.name.toUpperFirst().concat('Impl')/]::invoke(std::shared_ptr<uml::Operation> _operation, std::shared_ptr<Bag<Any>> _arguments)
{
	std::string qualifiedName = _operation->getQualifiedName();

	for(unsigned int i = 0; i < _operation->getOwnedParameter()->size(); i++)
	{
		qualifiedName += "_" + _operation->getOwnedParameter()->at(i)->getType()->getName();
	}

	return this->invoke(qualifiedName, _arguments);
}

std::shared_ptr<Any> [aClass.name.toUpperFirst().concat('Impl')/]::invoke(std::string _qualifiedName, std::shared_ptr<Bag<Any>> _arguments)
{
	unsigned long uID = util::Util::polynomialRollingHash(_qualifiedName);
	return this->invoke(uID, _arguments);
}

std::shared_ptr<Any> [aClass.name.toUpperFirst().concat('Impl')/]::invoke(unsigned long _uID, std::shared_ptr<Bag<Any>> _arguments)
{
[if (not aClass.getOperationsForInvoke()->isEmpty())]
	switch(_uID)
	{
		[for (anOperation : Operation | aClass.getOperationsForInvoke())]
		case [aClass.generateNamespace(true)/]::[aClass._package.getPackageName()/]Package::[anOperation.getMemberName().toUpperCase()/]:
		{
			[let inputParameterList : OrderedSet(Parameter) = anOperation.ownedParameter->select(not (direction = ParameterDirectionKind::return))]
			[for (anInputParameter : Parameter | inputParameterList) after('\n')]
			//Retrieve input parameter '[anInputParameter.name/]'
			std::shared_ptr<Any> any[anInputParameter.name.toUpperFirst()/] = *(arguments->at([inputParameterList->indexOf(anInputParameter)-1/]).get());
			[anInputParameter.generateCppType(false)/] [anInputParameter.name/] = any[anInputParameter.name.toUpperFirst()/]->get<[anInputParameter.generateCppType(false)/]>();
			[/for]
			[/let]
			[let returnParameterList : OrderedSet(Parameter) = anOperation.ownedParameter->select(p :Parameter | (p.direction = ParameterDirectionKind::return))]
				[if(not returnParameterList->isEmpty() and not returnParameterList->first().oclIsInvalid())]
				[let returnParameter : Parameter = returnParameterList->first()]
				[let anyBagRequired : Boolean = ((returnParameter.upper <> 1) and not(returnParameter.type.oclIsKindOf(PrimitiveType) or returnParameter.type.oclIsKindOf(Enumeration)))]
			[returnParameter.generateCppType(false)/] [returnParameter.name/] = this->[anOperation.name/]([for (inputParameter : Parameter | anOperation.ownedParameter->select(direction = ParameterDirectionKind::_in or direction = ParameterDirectionKind::inout)) separator (', ')][inputParameter.name/][/for]);
			return [if(anyBagRequired)]eAnyBag[else]eAny[/if]([returnParameter.name/], [returnParameter.type.oclAsType(Classifier).generateStaticClassifierIDAccess()/][if(not anyBagRequired)], [if(returnParameter.upper = 1)]false[else]true[/if][/if]);
				[/let]
				[/let]
				[else]
			this->[anOperation.name/]([for (inputParameter : Parameter | anOperation.ownedParameter->select(not (direction = ParameterDirectionKind::return))) separator (', ')][inputParameter.name/][/for]);
			return eAny(nullptr, -1, false);
				[/if]
			[/let]
		}
		[/for]
	}

[/if]	
	[let classList : OrderedSet(Class) = aClass.superClass->reject(oclIsUndefined() and name.oclIsUndefined())->sortedBy(name)]
	[if (classList->size() > 0)]
	std::shared_ptr<Any> result;
	[for (sClass : Class | aClass.superClass->reject(oclIsUndefined() and name.oclIsUndefined()))]
	//Call invoke() for base class [sClass.name/]
	result = [sClass.generateNamespaceName(true)/]Impl::invoke(_uID, _arguments);
	if (result != nullptr)
	{
		return result;
	}
	[/for]
	return result;
	[else]
	return eAny(nullptr, -1, false);
	[/if]
	[/let]
}
[/template]