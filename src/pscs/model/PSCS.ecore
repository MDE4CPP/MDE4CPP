<?xml version="1.0" encoding="UTF-8"?>
<ecore:EPackage xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore" name="PSCS" nsURI="http://www.omg.org/spec/PSCS/20180801" nsPrefix="PSCS_Semantics">
  <eSubpackages name="Semantics" nsURI="http:///PSCS_Semantics/Semantics.ecore" nsPrefix="PSCS_Semantics.Semantics">
    <eSubpackages name="Actions" nsURI="http:///PSCS_Semantics/Semantics/Actions.ecore"
        nsPrefix="PSCS_Semantics.Semantics.Actions">
      <eClassifiers xsi:type="ecore:EClass" name="CS_ReadExtentActionActivation">
        <eOperations name="doAction" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Get the extent, at the current execution locus, of the classifier&#xA;&#x9;// (which must be a class) identified in the action.&#xA;&#x9;// Place references to the resulting set of objects on the result pin.&#xA;&#x9;// Extends default fUML semantics in the sense that produced tokens contain&#xA;&#x9;// CS_References instead of References, in the case where the object is a&#xA;&#x9;// CS_Object&#xA;&#xA;&#x9;ReadExtentAction action = (ReadExtentAction) (this.node);&#xA;&#x9;ExtensionalValueList objects = this.getExecutionLocus().getExtent(&#xA;&#x9;&#x9;&#x9;action.classifier);&#xA;&#xA;&#x9;ValueList references = new ValueList();&#xA;&#x9;for (int i = 0; i &lt; objects.size(); i++) {&#xA;&#x9;&#x9;Value object = objects.getValue(i);&#xA;&#x9;&#x9;Reference reference = null ;&#xA;&#x9;&#x9;if (object instanceof CS_Object) {&#xA;&#x9;&#x9;&#x9;reference = new CS_Reference() ;&#xA;&#x9;&#x9;&#x9;((CS_Reference)reference).compositeReferent = (CS_Object)object ;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;reference = new Reference() ;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;reference.referent = (Object_) object;&#xA;&#x9;&#x9;references.addValue(reference);&#xA;&#x9;}&#xA;&#xA;&#x9;this.putTokens(action.result, references);"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_AddStructuralFeatureValueActionActivation">
        <eOperations name="doAction" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// If the feature is a port and the input value to be added is a&#xA;&#x9;// Reference,&#xA;&#x9;// Replaces this Reference by an InteractionPoint, and then behaves&#xA;&#x9;// as usual.&#xA;&#x9;// If the feature is not a port, behaves as usual&#xA;&#xA;&#x9;AddStructuralFeatureValueAction action = (AddStructuralFeatureValueAction) (this.node);&#xA;&#x9;StructuralFeature feature = action.structuralFeature;&#xA;&#xA;&#x9;if (!(feature instanceof Port)) {&#xA;&#x9;&#x9;// Behaves as usual&#xA;&#x9;&#x9;this.doActionDefault() ;&#xA;&#x9;} &#xA;&#x9;else {&#xA;&#x9;&#x9;ValueList inputValues = this.takeTokens(action.value);&#xA;&#x9;&#x9;// NOTE: Multiplicity of the value input pin is required to be 1..1.&#xA;&#x9;&#x9;Value inputValue = inputValues.getValue(0);&#xA;&#x9;&#x9;if (inputValue instanceof Reference) {&#xA;&#x9;&#x9;&#x9;// First constructs an InteractionPoint from the inputValue&#xA;&#x9;&#x9;&#x9;Reference reference = (Reference) inputValue;&#xA;&#x9;&#x9;&#x9;CS_InteractionPoint interactionPoint = new CS_InteractionPoint();&#xA;&#x9;&#x9;&#x9;interactionPoint.referent = reference.referent;&#xA;&#x9;&#x9;&#x9;interactionPoint.definingPort = (Port) feature;&#xA;&#x9;&#x9;&#x9;// The value on action.object is necessarily instanceof&#xA;&#x9;&#x9;&#x9;// ReferenceToCompositeStructure (otherwise, the feature cannot&#xA;&#x9;&#x9;&#x9;// be a port)&#xA;&#x9;&#x9;&#x9;CS_Reference owner = (CS_Reference) this.takeTokens(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;action.object).getValue(0);&#xA;&#x9;&#x9;&#x9;interactionPoint.owner = owner;&#xA;&#x9;&#x9;&#x9;// Then replaces the Reference by an InteractionPoint&#xA;&#x9;&#x9;&#x9;// in the inputValues&#xA;&#x9;&#x9;&#x9;inputValues.remove(0);&#xA;&#x9;&#x9;&#x9;inputValues.addValue(0, interactionPoint);&#xA;&#x9;&#x9;&#x9;// Finally concludes with usual fUML behavior of&#xA;&#x9;&#x9;&#x9;// AddStructuralFeatureValueAction (i.e., the usual behavior&#xA;&#x9;&#x9;&#x9;// when&#xA;&#x9;&#x9;&#x9;// the value on action.object pin is a StructuredValue)&#xA;&#x9;&#x9;&#x9;Integer insertAt = 0;&#xA;&#x9;&#x9;&#x9;if (action.insertAt != null) {&#xA;&#x9;&#x9;&#x9;&#x9;insertAt = ((UnlimitedNaturalValue) this.takeTokens(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;action.insertAt).getValue(0)).value.naturalValue;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;if (action.isReplaceAll) {&#xA;&#x9;&#x9;&#x9;&#x9;owner.setFeatureValue(feature, inputValues, 0);&#xA;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;FeatureValue featureValue = owner.getFeatureValue(feature);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (featureValue.values.size() > 0 &amp; insertAt == 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// If there is no insertAt pin, then the structural&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// feature must&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// be unordered, and the insertion position is&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// immaterial.&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;insertAt = ((ChoiceStrategy) this.getExecutionLocus().factory&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;.getStrategy(&quot;choice&quot;))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;.choose(featureValue.values.size());&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (feature.multiplicityElement.isUnique) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// Remove any existing value that duplicates the input&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// value&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Integer j = position(interactionPoint, featureValue.values, 1);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (j > 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;featureValue.values.remove(j - 1);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (insertAt > 0 &amp; j &lt; insertAt) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;insertAt = insertAt - 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (insertAt &lt;= 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// Note: insertAt = -1 indicates an unlimited value of&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// &quot;*&quot;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;featureValue.values.addValue(interactionPoint);&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;featureValue.values.addValue(insertAt - 1, interactionPoint);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;if (action.result != null) {&#xA;&#x9;&#x9;&#x9;&#x9;this.putToken(action.result, owner);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} &#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;// behaves as usual&#xA;&#x9;&#x9;&#x9;this.doActionDefault() ;&#xA;&#x9;&#x9;}&#xA;&#x9;}"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="doActionDefault" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Get the values of the object and value input pins.&#xA;&#x9;// If the given feature is an association end, then create a link&#xA;&#x9;// between the object and value inputs.&#xA;&#x9;// Otherwise, if the object input is a structural value, then add a&#xA;&#x9;// value to the values for the feature.&#xA;&#x9;// If isReplaceAll is true, first remove all current matching links or&#xA;&#x9;// feature values.&#xA;&#x9;// If isReplaceAll is false and there is an insertAt pin, insert the&#xA;&#x9;// value at the appropriate position.&#xA;&#x9;// This operation captures same semantics as fUML &#xA;&#x9;// AddStructuralFeatureValueActionActivation.doAction(), except that&#xA;&#x9;// when the feature is an association end, a CS_Link will be created instead&#xA;&#x9;// of a Link&#xA;&#xA;&#x9;AddStructuralFeatureValueAction action = (AddStructuralFeatureValueAction) (this.node);&#xA;&#x9;StructuralFeature feature = action.structuralFeature;&#xA;&#x9;Association association = this.getAssociation(feature);&#xA;&#xA;&#x9;Value value = this.takeTokens(action.object).getValue(0);&#xA;&#x9;ValueList inputValues = this.takeTokens(action.value);&#xA;&#xA;&#x9;// NOTE: Multiplicity of the value input pin is required to be 1..1.&#xA;&#x9;Value inputValue = inputValues.getValue(0);&#xA;&#xA;&#x9;int insertAt = 0;&#xA;&#x9;if (action.insertAt != null) {&#xA;&#x9;&#x9;insertAt = ((UnlimitedNaturalValue) this&#xA;&#x9;&#x9;&#x9;&#x9;.takeTokens(action.insertAt).getValue(0)).value.naturalValue;&#xA;&#x9;}&#xA;&#xA;&#x9;if (association != null) {&#xA;&#x9;&#x9;LinkList links = this.getMatchingLinks(association, feature, value);&#xA;&#xA;&#x9;&#x9;Property oppositeEnd = this.getOppositeEnd(association, feature);&#xA;&#x9;&#x9;int position = 0;&#xA;&#x9;&#x9;if (oppositeEnd.multiplicityElement.isOrdered) {&#xA;&#x9;&#x9;&#x9;position = -1;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;if (action.isReplaceAll) {&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; links.size(); i++) {&#xA;&#x9;&#x9;&#x9;&#x9;Link link = links.getValue(i);&#xA;&#x9;&#x9;&#x9;&#x9;link.destroy();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} else if (feature.multiplicityElement.isUnique) {&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; links.size(); i++) {&#xA;&#x9;&#x9;&#x9;&#x9;Link link = links.getValue(i);&#xA;&#x9;&#x9;&#x9;&#x9;FeatureValue featureValue = link.getFeatureValue(feature);&#xA;&#x9;&#x9;&#x9;&#x9;if (featureValue.values.getValue(0).equals(inputValue)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;position = link.getFeatureValue(oppositeEnd).position;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (insertAt > 0 &amp; featureValue.position &lt; insertAt) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;insertAt = insertAt - 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;link.destroy();&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;CS_Link newLink = new CS_Link();&#xA;&#x9;&#x9;newLink.type = association;&#xA;&#xA;&#x9;&#x9;// This necessary when setting a feature value with an insertAt&#xA;&#x9;&#x9;// position&#xA;&#x9;&#x9;newLink.locus = this.getExecutionLocus();&#xA;&#xA;&#x9;&#x9;newLink.setFeatureValue(feature, inputValues, insertAt);&#xA;&#xA;&#x9;&#x9;ValueList oppositeValues = new ValueList();&#xA;&#x9;&#x9;oppositeValues.addValue(value);&#xA;&#x9;&#x9;newLink.setFeatureValue(oppositeEnd, oppositeValues, position);&#xA;&#xA;&#x9;&#x9;newLink.locus.add(newLink);&#xA;&#xA;&#x9;} else if (value instanceof StructuredValue) {&#xA;&#x9;&#x9;StructuredValue structuredValue = (StructuredValue) value;&#xA;&#xA;&#x9;&#x9;if (action.isReplaceAll) {&#xA;&#x9;&#x9;&#x9;structuredValue.setFeatureValue(feature, inputValues, 0);&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;FeatureValue featureValue = structuredValue&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;.getFeatureValue(feature);&#xA;&#xA;&#x9;&#x9;&#x9;if (featureValue.values.size() > 0 &amp; insertAt == 0) {&#xA;&#x9;&#x9;&#x9;&#x9;// *** If there is no insertAt pin, then the structural&#xA;&#x9;&#x9;&#x9;&#x9;// feature must be unordered, and the insertion position is&#xA;&#x9;&#x9;&#x9;&#x9;// immaterial. ***&#xA;&#x9;&#x9;&#x9;&#x9;insertAt = ((ChoiceStrategy) this.getExecutionLocus().factory&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;.getStrategy(&quot;choice&quot;)).choose(featureValue.values&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;.size());&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;if (feature.multiplicityElement.isUnique) {&#xA;&#x9;&#x9;&#x9;&#x9;// Remove any existing value that duplicates the input value&#xA;&#x9;&#x9;&#x9;&#x9;int j = position(inputValue, featureValue.values, 1);&#xA;&#x9;&#x9;&#x9;&#x9;if (j > 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;featureValue.values.remove(j - 1);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (insertAt > 0 &amp; j &lt; insertAt) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;insertAt = insertAt - 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;if (insertAt &lt;= 0) { // Note: insertAt = -1 indicates an&#xA;&#x9;&#x9;&#x9;&#x9;// unlimited value of &quot;*&quot;&#xA;&#x9;&#x9;&#x9;&#x9;featureValue.values.addValue(inputValue);&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;featureValue.values.addValue(insertAt - 1, inputValue);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;if (action.result != null) {&#xA;&#x9;&#x9;this.putToken(action.result, value);&#xA;&#x9;}"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_ReadSelfActionActivation">
        <eOperations name="doAction" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Get the context object of the activity execution containing this&#xA;&#x9;// action activation and place a reference to it on the result output&#xA;&#x9;// pin.&#xA;&#x9;// Extends fUML semantics in the sense that the reference placed on&#xA;&#x9;// the result pin is a CS_Reference, not a Reference&#xA;&#xA;&#x9;// Debug.println(&quot;[ReadSelfActionActivation] Start...&quot;);&#xA;&#xA;&#x9;CS_Reference context = new CS_Reference();&#xA;&#x9;context.referent = this.getExecutionContext();&#xA;&#x9;if (context.referent instanceof CS_Object) {// i.e. alternatively, it can be an execution&#xA;&#x9;&#x9;context.compositeReferent = (CS_Object)context.referent ;&#xA;&#x9;}&#xA;&#xA;&#x9;// Debug.println(&quot;[ReadSelfActionActivation] context object = &quot; +&#xA;&#x9;// context.referent);&#xA;&#xA;&#x9;OutputPin resultPin = ((ReadSelfAction) (this.node)).result;&#xA;&#x9;this.putToken(resultPin, context);&#xA;"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_RemoveStructuralFeatureValueActionActivation">
        <eOperations name="doAction" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="// Get the values of the object and value input pins. &#xA;// If the given feature is an association end, then destroy any&#xA;// matching links. Otherwise, if the object input is a structural&#xA;// value, remove values from the given feature and destroy all links&#xA;// in which the removed values are involved.&#xA;// If isRemoveDuplicates is true, then destroy all current matching&#xA;// links or remove all values equal to the input value.&#xA;// If isRemoveDuplicates is false and there is no removeAt input pin,&#xA;// remove any one feature value equal to the input value (if there are&#xA;// any that are equal).&#xA;// If isRemoveDuplicates is false, and there is a removeAt input pin&#xA;// remove the feature value at that position.&#xA;&#xA;RemoveStructuralFeatureValueAction action = (RemoveStructuralFeatureValueAction) (this.node);&#xA;StructuralFeature feature = action.getStructuralFeature();&#xA;Association association = this.getAssociation(feature);&#xA;Value value = this.takeTokens(action.getObject()).get(0);&#xA;Value inputValue = null;&#xA;if (action.getValue() != null) {&#xA;// NOTE: Multiplicity of the value input pin is required to be 1..1.&#xA;inputValue = this.takeTokens(action.getValue()).get(0);&#xA;}&#xA;int removeAt = 0;&#xA;if (action.getRemoveAt() != null) {&#xA;removeAt = ((UnlimitedNaturalValue) this.takeTokens(action.getRemoveAt()).get(0)).value;&#xA;}&#xA;if (association != null) {&#xA;List&lt;Link> links = this.getMatchingLinksForEndValue(association, feature, value, inputValue);&#xA;if (action.isRemoveDuplicates()) {&#xA;&#x9;for (int i = 0; i &lt; links.size(); i++) {&#xA;&#x9;&#x9;Link link = links.get(i);&#xA;&#x9;&#x9;link.destroy();&#xA;&#x9;}&#xA;} else if (action.getRemoveAt() == null) {&#xA;&#x9;// *** If there is more than one matching link,&#xA;&#x9;// non-deterministically choose one. ***&#xA;&#x9;if (links.size() > 0) {&#xA;&#x9;&#x9;int i = ((ChoiceStrategy) this.getExecutionLocus().factory.getStrategy(&quot;choice&quot;)).choose(links.size());&#xA;&#x9;&#x9;links.get(i - 1).destroy();&#xA;&#x9;}&#xA;} else {&#xA;&#x9;boolean notFound = true;&#xA;&#x9;int i = 1;&#xA;&#x9;while (notFound &amp; i &lt;= links.size()) {&#xA;&#x9;&#x9;Link link = links.get(i - 1);&#xA;&#x9;&#x9;if (link.getFeatureValue(feature).position == removeAt) {&#xA;&#x9;&#x9;&#x9;notFound = false;&#xA;&#x9;&#x9;&#x9;link.destroy();&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;} else if (value instanceof StructuredValue) {&#xA;// If the value is a data value, then it must be copied before&#xA;// any change is made.&#xA;if (!(value instanceof Reference)) {&#xA;&#x9;value = value.copy();&#xA;}&#xA;FeatureValue featureValue = ((StructuredValue) value).getFeatureValue(action.getStructuralFeature());&#xA;List&lt;Value> removedValues = new ArrayList&lt;Value>();&#xA;if (action.isRemoveDuplicates()) {&#xA;&#x9;int j = this.position(inputValue, featureValue.values, 1);&#xA;&#x9;while (j > 0) {&#xA;&#x9;&#x9;removedValues.add(featureValue.values.get(j - 1));&#xA;&#x9;&#x9;featureValue.values.remove(j - 1);&#xA;&#x9;&#x9;j = this.position(inputValue, featureValue.values, j);&#xA;&#x9;}&#xA;} else if (action.getRemoveAt() == null) {&#xA;&#x9;List&lt;Integer> positions = new ArrayList&lt;Integer>();&#xA;&#x9;int j = this.position(inputValue, featureValue.values, 1);&#xA;&#x9;while (j > 0) {&#xA;&#x9;&#x9;positions.add(j);&#xA;&#x9;&#x9;j = this.position(inputValue, featureValue.values, j);&#xA;&#x9;}&#xA;&#x9;if (positions.size() > 0) {&#xA;&#x9;&#x9;// *** Nondeterministically choose which value to remove.&#xA;&#x9;&#x9;// ***&#xA;&#x9;&#x9;int k = ((ChoiceStrategy) this.getExecutionLocus().factory.getStrategy(&quot;choice&quot;)).choose(positions.size());&#xA;&#x9;&#x9;removedValues.add(featureValue.values.get(positions.get(k - 1) - 1));&#xA;&#x9;&#x9;featureValue.values.remove(positions.get(k - 1) - 1);&#xA;&#x9;}&#xA;} else {&#xA;&#x9;if (featureValue.values.size() >= removeAt) {&#xA;&#x9;&#x9;removedValues.add(featureValue.values.get(removeAt - 1));&#xA;&#x9;&#x9;featureValue.values.remove(removeAt - 1);&#xA;&#x9;}&#xA;}&#xA;// When values are removed from the list of values associated to the feature &#xA;// (in the context of the target), these latter may be involved in links representing&#xA;// instance of connectors. If this is the case, links in which the removed values are&#xA;// involved are destroyed.&#xA;for(int i = 0; i &lt; removedValues.size(); i++){&#xA;&#x9;List&lt;CS_Link> linkToDestroy = this.getLinksToDestroy((StructuredValue)value, feature, removedValues.get(i));&#xA;&#x9;for(int j = 0; j &lt; linkToDestroy.size(); j++){&#xA;&#x9;&#x9;linkToDestroy.get(j).destroy();&#xA;&#x9;}&#xA;}&#xA;}&#xA;if (action.getResult() != null) {&#xA;this.putToken(action.getResult(), value);&#xA;}&#xA;&#xA;Editorial Note: In order to reduce the code duplication it is required to split the semantics of RemoveStructuralFeatureActionActivation into different operations. &#xA;[2] public getLinksToDestroy (value : StructuredValue,  feature : StructuralFeature, removedValue : Value) : CS_Link[*] &#xA;&#xA;// Get all links that are required to be destroyed due to the removal of the removedValue&#xA;List&lt;CS_Link> linksToDestroy = new ArrayList&lt;CS_Link>();&#xA;if (value instanceof CS_Reference) {&#xA;CS_Reference context = (CS_Reference) value;&#xA;// Retrieves the feature values for the structural feature associated with this action,&#xA;// in the context of this reference&#xA;if (feature instanceof Port) {&#xA;&#x9;// The removed value is an interaction point.&#xA;&#x9;// All links in which this interaction is involved must be destroyed.&#xA;&#x9;CS_InteractionPoint interactionPoint = (CS_InteractionPoint) removedValue;&#xA;&#x9;List&lt;CS_Link> connectorInstances = context.compositeReferent.getLinks(interactionPoint);&#xA;&#x9;for (int j = 0; j &lt; connectorInstances.size(); j++) {&#xA;&#x9;&#x9;CS_Link link = connectorInstances.get(j);&#xA;&#x9;&#x9;linksToDestroy.add(link);&#xA;&#x9;}&#xA;} else { &#xA;&#x9;// Feature is not a Port. Search for all potential link&#xA;&#x9;// ends existing in the context of this object.&#xA;&#x9;List&lt;Value> allValuesForFeature = new ArrayList&lt;Value>();&#xA;&#x9;for (int i = 0; i &lt; context.referent.featureValues.size(); i++) {&#xA;&#x9;&#x9;StructuralFeature currentFeature = context.referent.featureValues.get(i).feature;&#xA;&#x9;&#x9;if(feature != currentFeature){&#xA;&#x9;&#x9;&#x9;List&lt;Value> values = this.getPotentialLinkEnds(context, currentFeature);&#xA;&#x9;&#x9;&#x9;for (int j = 0; j &lt; values.size(); j++) {&#xA;&#x9;&#x9;&#x9;&#x9;allValuesForFeature.add(values.get(j));&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;// Retrieves all links available at the locus&#xA;&#x9;List&lt;ExtensionalValue> extensionalValues = this.getExecutionLocus().extensionalValues;&#xA;&#x9;List&lt;CS_Link> allLinks = new ArrayList&lt;CS_Link>();&#xA;&#x9;for (int i = 0; i &lt; extensionalValues.size(); i++) {&#xA;&#x9;&#x9;ExtensionalValue extensionalValue = extensionalValues.get(i);&#xA;&#x9;&#x9;if (extensionalValue instanceof CS_Link) {&#xA;&#x9;&#x9;&#x9;allLinks.add((CS_Link) extensionalValue);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;// In the set of links involving potential link ends. Search for all&#xA;&#x9;// links that involve the removed value in other end. Any link in that&#xA;&#x9;// fulfill this condition is registered in the set of link to be destroyed.&#xA;&#x9;for (int i = 0; i &lt; allLinks.size(); i++) {&#xA;&#x9;&#x9;CS_Link link = allLinks.get(i);&#xA;&#x9;&#x9;boolean linkHasToBeDestroyed = false;&#xA;&#x9;&#x9;for (int j = 0; j &lt; allValuesForFeature.size() &amp;&amp; !linkHasToBeDestroyed; j++) {&#xA;&#x9;&#x9;&#x9;Value v = allValuesForFeature.get(j);&#xA;&#x9;&#x9;&#x9;StructuralFeature featureForV = link.getFeature(v);&#xA;&#x9;&#x9;&#x9;if (featureForV != null) {&#xA;&#x9;&#x9;&#x9;&#x9;for (int k = 0; k &lt; link.featureValues.size() &amp;&amp; !linkHasToBeDestroyed; k++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;FeatureValue otherFeatureValue = link.featureValues.get(k);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (otherFeatureValue.feature != featureForV) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (int l = 0; l &lt; otherFeatureValue.values.size() &amp;&amp; !linkHasToBeDestroyed; l++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(otherFeatureValue.values.get(l) == removedValue){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;linkHasToBeDestroyed = true;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if (linkHasToBeDestroyed) {&#xA;&#x9;&#x9;&#x9;linksToDestroy.add(link);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;}&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getLinksToDestroy" ordered="false" upperBound="-1" eType="#//Semantics/StructuredClassifiers/CS_Link">
          <eAnnotations source="http://www.eclipse.org/uml2/2.0.0/UML">
            <details key="originalName" value="getLinksToDestroy "/>
          </eAnnotations>
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="// Get all links that are required to be destroyed due to the removal of the removedValue&#xA;&#xA;List&lt;CS_Link> linksToDestroy = new ArrayList&lt;CS_Link>();&#xA;if (value instanceof CS_Reference) {&#xA;CS_Reference context = (CS_Reference) value;&#xA;// Retrieves the feature values for the structural feature associated with this action,&#xA;// in the context of this reference&#xA;if (feature instanceof Port) {&#xA;&#x9;// The removed value is an interaction point.&#xA;&#x9;// All links in which this interaction is involved must be destroyed.&#xA;&#x9;CS_InteractionPoint interactionPoint = (CS_InteractionPoint) removedValue;&#xA;&#x9;List&lt;CS_Link> connectorInstances = context.compositeReferent.getLinks(interactionPoint);&#xA;&#x9;for (int j = 0; j &lt; connectorInstances.size(); j++) {&#xA;&#x9;&#x9;CS_Link link = connectorInstances.get(j);&#xA;&#x9;&#x9;linksToDestroy.add(link);&#xA;&#x9;}&#xA;} else { &#xA;&#x9;// Feature is not a Port. Search for all potential link&#xA;&#x9;// ends existing in the context of this object.&#xA;&#x9;List&lt;Value> allValuesForFeature = new ArrayList&lt;Value>();&#xA;&#x9;for (int i = 0; i &lt; context.referent.featureValues.size(); i++) {&#xA;&#x9;&#x9;StructuralFeature currentFeature = context.referent.featureValues.get(i).feature;&#xA;&#x9;&#x9;if(feature != currentFeature){&#xA;&#x9;&#x9;&#x9;List&lt;Value> values = this.getPotentialLinkEnds(context, currentFeature);&#xA;&#x9;&#x9;&#x9;for (int j = 0; j &lt; values.size(); j++) {&#xA;&#x9;&#x9;&#x9;&#x9;allValuesForFeature.add(values.get(j));&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;// Retrieves all links available at the locus&#xA;&#x9;List&lt;ExtensionalValue> extensionalValues = this.getExecutionLocus().extensionalValues;&#xA;&#x9;List&lt;CS_Link> allLinks = new ArrayList&lt;CS_Link>();&#xA;&#x9;for (int i = 0; i &lt; extensionalValues.size(); i++) {&#xA;&#x9;&#x9;ExtensionalValue extensionalValue = extensionalValues.get(i);&#xA;&#x9;&#x9;if (extensionalValue instanceof CS_Link) {&#xA;&#x9;&#x9;&#x9;allLinks.add((CS_Link) extensionalValue);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;// In the set of links involving potential link ends. Search for all&#xA;&#x9;// links that involve the removed value in other end. Any link in that&#xA;&#x9;// fulfill this condition is registered in the set of link to be destroyed.&#xA;&#x9;for (int i = 0; i &lt; allLinks.size(); i++) {&#xA;&#x9;&#x9;CS_Link link = allLinks.get(i);&#xA;&#x9;&#x9;boolean linkHasToBeDestroyed = false;&#xA;&#x9;&#x9;for (int j = 0; j &lt; allValuesForFeature.size() &amp;&amp; !linkHasToBeDestroyed; j++) {&#xA;&#x9;&#x9;&#x9;Value v = allValuesForFeature.get(j);&#xA;&#x9;&#x9;&#x9;StructuralFeature featureForV = link.getFeature(v);&#xA;&#x9;&#x9;&#x9;if (featureForV != null) {&#xA;&#x9;&#x9;&#x9;&#x9;for (int k = 0; k &lt; link.featureValues.size() &amp;&amp; !linkHasToBeDestroyed; k++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;FeatureValue otherFeatureValue = link.featureValues.get(k);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (otherFeatureValue.feature != featureForV) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (int l = 0; l &lt; otherFeatureValue.values.size() &amp;&amp; !linkHasToBeDestroyed; l++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(otherFeatureValue.values.get(l) == removedValue){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;linkHasToBeDestroyed = true;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if (linkHasToBeDestroyed) {&#xA;&#x9;&#x9;&#x9;linksToDestroy.add(link);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;}&#xA;return linksToDestroy&#xA;"/>
          </eAnnotations>
          <eParameters name="value" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EJavaObject"/>
          <eParameters name="feature" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//StructuralFeature"/>
          <eParameters name="removedValue" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
        </eOperations>
        <eOperations name="getPotentialLinkEnds" ordered="false" upperBound="-1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="// Retrieves all feature values for the context object for the given feature,&#xA;// as well as all interaction point for these values&#xA;&#xA;List&lt;Value> potentialLinkEnds = new ArrayList&lt;Value>();&#xA;FeatureValue featureValue = context.getFeatureValue(feature);&#xA;for (int i = 0; i &lt; featureValue.values.size(); i++) {&#xA;Value v = featureValue.values.get(i);&#xA;potentialLinkEnds.add(v);&#xA;if (v instanceof CS_Reference) {&#xA;&#x9;// add all interaction points associated with v&#xA;&#x9;for (int j = 0; j &lt; ((CS_Reference) v).referent.featureValues.size(); j++) {&#xA;&#x9;&#x9;if (((CS_Reference) v).referent.featureValues.get(j).feature instanceof Port) {&#xA;&#x9;&#x9;&#x9;List&lt;Value> interactionPoints = (((CS_Reference) v).referent.featureValues.get(j)).values;&#xA;&#x9;&#x9;&#x9;for (int k = 0; k &lt; interactionPoints.size(); k++) {&#xA;&#x9;&#x9;&#x9;&#x9;potentialLinkEnds.add(interactionPoints.get(k));&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;}&#xA;return potentialLinkEnds;&#xA;"/>
          </eAnnotations>
          <eParameters name="context" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Reference"/>
          <eParameters name="feature" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//StructuralFeature"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_ClearStructuralFeatureActionActivation">
        <eOperations name="doAction" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Get the value of the object input pin.&#xA;&#x9;// If the given feature is an association end, then&#xA;&#x9;// destroy all links that have the object input on the opposite end.&#xA;&#x9;// Otherwise, if the object input is a structured value, then&#xA;&#x9;// set the appropriate feature of the input value to be empty.&#xA;&#x9;ClearStructuralFeatureAction action = (ClearStructuralFeatureAction)(this.node);&#xA;&#x9;StructuralFeature feature = action.structuralFeature;&#xA;&#x9;Association association = this.getAssociation(feature);&#xA;&#x9;Value value = this.takeTokens(action.object).get(0);&#xA;&#x9;if(association != null) {&#xA;&#x9;&#x9;LinkList links = this.getMatchingLinks(association, feature, value);&#xA;&#x9;&#x9;for(int i = 0; i &lt; links.size(); i++) {&#xA;&#x9;&#x9;&#x9;Link link = links.get(i);&#xA;&#x9;&#x9;&#x9;link.destroy();&#xA;&#x9;&#x9;}&#xA;&#x9;} else if(value instanceof StructuredValue) {&#xA;&#x9;&#x9;// If the value is a data value, then it must be copied before&#xA;&#x9;&#x9;// any change is made.&#xA;&#x9;&#x9;if(!(value instanceof Reference)) {&#xA;&#x9;&#x9;&#x9;value = value.copy();&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;// extension to fUML&#xA;&#x9;&#x9;&#x9;CS_LinkList linksToDestroy = this.getLinksToDestroy((StructuredValue)value, feature) ;&#xA;&#x9;&#x9;&#x9;for (int i = 0 ; i &lt; linksToDestroy.size() ; i++) {&#xA;&#x9;&#x9;&#x9;&#x9;linksToDestroy.get(i).destroy() ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;//&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;((StructuredValue)value).setFeatureValue(action.structuralFeature, new ValueList(), 0);&#xA;&#x9;}&#xA;&#x9;if(action.result != null) {&#xA;&#x9;&#x9;this.putToken(action.result, value);&#xA;&#x9;}"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getLinksToDestroy" ordered="false" upperBound="-1" eType="#//Semantics/StructuredClassifiers/CS_Link">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;CS_LinkList linksToDestroy = new CS_LinkList() ;&#xA;&#x9;if (value instanceof CS_Reference) {&#xA;&#x9;&#x9;CS_Reference context = (CS_Reference)value ;&#xA;&#x9;&#x9;// Retrieves the feature values for the structural feature associated with this action,&#xA;&#x9;&#x9;// in the context of this reference &#xA;&#x9;&#x9;FeatureValue featureValue = context.getFeatureValue(feature) ;&#xA;&#x9;&#x9;if (feature instanceof Port) {&#xA;&#x9;&#x9;&#x9;// all values are interaction points&#xA;&#x9;&#x9;&#x9;// any link targeting this interaction point must be destroyed&#xA;&#x9;&#x9;&#x9;for (int i = 0 ; i &lt; featureValue.values.size() ; i++) {&#xA;&#x9;&#x9;&#x9;&#x9;CS_InteractionPoint interactionPoint = (CS_InteractionPoint)featureValue.values.get(i) ;&#xA;&#x9;&#x9;&#x9;&#x9;CS_LinkList connectorInstances = context.compositeReferent.getLinks(interactionPoint) ;&#xA;&#x9;&#x9;&#x9;&#x9;for (int j = 0 ; j &lt; connectorInstances.size() ; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;CS_Link link = connectorInstances.get(j) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;linksToDestroy.add(link) ;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else { // feature is an attribute&#xA;&#x9;&#x9;&#x9;// Retrieve all potential link ends,&#xA;&#x9;&#x9;&#x9;// separating potential link ends corresponding to the given feature,&#xA;&#x9;&#x9;&#x9;// and potential link ends corresponding to other features.&#xA;&#x9;&#x9;&#x9;// By &quot;potential link ends&quot;, we refer to the values of a given feature,&#xA;&#x9;&#x9;&#x9;// as well as interaction points associated with this value, if any.&#xA;&#x9;&#x9;&#x9;ValueList allValuesForFeature = new ValueList() ;&#xA;&#x9;&#x9;&#x9;ValueList allOtherValues = new ValueList() ;&#xA;&#x9;&#x9;&#x9;for (int i = 0 ; i &lt; context.referent.featureValues.size() ; i++) {&#xA;&#x9;&#x9;&#x9;&#x9;StructuralFeature currentFeature = context.referent.featureValues.get(i).feature ;&#xA;&#x9;&#x9;&#x9;&#x9;ValueList values = this.getPotentialLinkEnds(context, currentFeature) ;&#xA;&#x9;&#x9;&#x9;&#x9;for (int j = 0 ; j &lt; values.size() ; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Value v = values.get(j) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (currentFeature != feature) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;allOtherValues.add(v) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;allValuesForFeature.add(v) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;// Retrieves all links available at the locus&#xA;&#x9;&#x9;&#x9;ExtensionalValueList extensionalValues = this.getExecutionLocus().extensionalValues ;&#xA;&#x9;&#x9;&#x9;CS_LinkList allLinks = new CS_LinkList() ;&#xA;&#x9;&#x9;&#x9;for (int i = 0 ; i &lt; extensionalValues.size() ; i ++) {&#xA;&#x9;&#x9;&#x9;&#x9;ExtensionalValue extensionalValue = extensionalValues.get(i) ;&#xA;&#x9;&#x9;&#x9;&#x9;if (extensionalValue instanceof CS_Link) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;allLinks.add((CS_Link)extensionalValue) ;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;// Retrieves links representing connector instances in the context object &#xA;&#x9;&#x9;&#x9;for (int i = 0 ; i &lt; allLinks.size() ; i++) {&#xA;&#x9;&#x9;&#x9;&#x9;CS_Link link = allLinks.get(i) ;&#xA;&#x9;&#x9;&#x9;&#x9;boolean linkHasToBeDestroyed = false ;&#xA;&#x9;&#x9;&#x9;&#x9;for (int j = 0 ; j &lt; allValuesForFeature.size() &amp;&amp; !linkHasToBeDestroyed; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Value v = allValuesForFeature.get(j) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;StructuralFeature featureForV = link.getFeature(v) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (featureForV != null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// Check if feature values of this link for other features&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// contains elements identified in allOtherValue&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (int k = 0 ; k &lt; link.featureValues.size() &amp;&amp; !linkHasToBeDestroyed ; k++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;FeatureValue otherFeatureValue = link.featureValues.get(k) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (otherFeatureValue.feature != featureForV) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (int l = 0 ; l &lt; otherFeatureValue.values.size() &amp;&amp; !linkHasToBeDestroyed ; l++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (int m = 0 ; m &lt; allOtherValues.size() &amp;&amp; !linkHasToBeDestroyed ; m++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (otherFeatureValue.values.get(l) == allOtherValues.get(m)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;linkHasToBeDestroyed = true ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (linkHasToBeDestroyed) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;linksToDestroy.add(link) ;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return linksToDestroy ;"/>
          </eAnnotations>
          <eParameters name="value" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
          <eParameters name="feature" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//StructuralFeature"/>
        </eOperations>
        <eOperations name="getPotentialLinkEnds" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Retrieves all feature values for the context object for the given feature,&#xA;&#x9;// as well as all interaction point for these values&#xA;&#x9;ValueList potentialLinkEnds = new ValueList() ;&#xA;&#x9;FeatureValue featureValue = context.getFeatureValue(feature) ;&#xA;&#x9;for (int i = 0 ; i &lt; featureValue.values.size() ; i++) {&#xA;&#x9;&#x9;Value v = featureValue.values.get(i) ;&#xA;&#x9;&#x9;potentialLinkEnds.add(v) ;&#xA;&#x9;&#x9;if (v instanceof CS_Reference) {&#xA;&#x9;&#x9;&#x9;// add all interaction points associated with v&#xA;&#x9;&#x9;&#x9;for (int j = 0 ; j &lt; ((CS_Reference)v).referent.featureValues.size() ; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;if (((CS_Reference)v).referent.featureValues.get(j).feature instanceof Port) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ValueList interactionPoints = (((CS_Reference)v).referent.featureValues.get(j)).values ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for (int k = 0 ; k &lt; interactionPoints.size() ; k++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;potentialLinkEnds.add(interactionPoints.get(k)) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return potentialLinkEnds ;"/>
          </eAnnotations>
          <eParameters name="context" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Reference"/>
          <eParameters name="feature" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//StructuralFeature"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_CreateLinkActionActivation">
        <eOperations name="doAction" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Get the extent at the current execution locus of the association for&#xA;&#x9;// which a link is being created.&#xA;&#x9;// Destroy all links that have a value for any end for which&#xA;&#x9;// isReplaceAll is true.&#xA;&#x9;// Create a new link for the association, at the current locus, with the&#xA;&#x9;// given end data values,&#xA;&#x9;// inserted at the given insertAt position (for ordered ends).&#xA;&#x9;// fUML semantics is extended in the sense that a CS_Link is created instead of&#xA;&#x9;// a Link&#xA;&#xA;&#x9;CreateLinkAction action = (CreateLinkAction) (this.node);&#xA;&#x9;LinkEndCreationDataList endDataList = action.endData;&#xA;&#xA;&#x9;Association linkAssociation = this.getAssociation();&#xA;&#x9;ExtensionalValueList extent = this.getExecutionLocus().getExtent(&#xA;&#x9;&#x9;&#x9;linkAssociation);&#xA;&#xA;&#x9;Link oldLink = null;&#xA;&#x9;for (int i = 0; i &lt; extent.size(); i++) {&#xA;&#x9;&#x9;ExtensionalValue value = extent.getValue(i);&#xA;&#x9;&#x9;Link link = (Link) value;&#xA;&#xA;&#x9;&#x9;boolean noMatch = true;&#xA;&#x9;&#x9;int j = 1;&#xA;&#x9;&#x9;while (noMatch &amp; j &lt;= endDataList.size()) {&#xA;&#x9;&#x9;&#x9;LinkEndCreationData endData = endDataList.getValue(j - 1);&#xA;&#x9;&#x9;&#x9;if (endData.isReplaceAll&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&amp; this.endMatchesEndData(link, endData)) {&#xA;&#x9;&#x9;&#x9;&#x9;oldLink = link;&#xA;&#x9;&#x9;&#x9;&#x9;link.destroy();&#xA;&#x9;&#x9;&#x9;&#x9;noMatch = false;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;j = j + 1;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;CS_Link newLink = new CS_Link();&#xA;&#x9;newLink.type = linkAssociation;&#xA;&#xA;&#x9;// This necessary when setting a feature value with an insertAt position&#xA;&#x9;newLink.locus = this.getExecutionLocus();&#xA;&#xA;&#x9;for (int i = 0; i &lt; endDataList.size(); i++) {&#xA;&#x9;&#x9;LinkEndCreationData endData = endDataList.getValue(i);&#xA;&#xA;&#x9;&#x9;int insertAt;&#xA;&#x9;&#x9;if (endData.insertAt == null) {&#xA;&#x9;&#x9;&#x9;insertAt = 0;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;insertAt = ((UnlimitedNaturalValue) (this&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;.takeTokens(endData.insertAt).getValue(0))).value.naturalValue;&#xA;&#x9;&#x9;&#x9;if (oldLink != null) {&#xA;&#x9;&#x9;&#x9;&#x9;if (oldLink.getFeatureValue(endData.end).position &lt; insertAt) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;insertAt = insertAt - 1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;newLink.setFeatureValue(endData.end,&#xA;&#x9;&#x9;&#x9;&#x9;this.takeTokens(endData.value), insertAt);&#xA;&#x9;}&#xA;&#xA;&#x9;this.getExecutionLocus().add(newLink);"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_CreateObjectActionActivation">
        <eOperations name="doAction" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Create an object with the given classifier (which must be a class) as&#xA;&#x9;// its type, at the same locus as the action activation.&#xA;&#x9;// Place a reference to the object on the result pin of the action.&#xA;&#x9;// Extends fUML semantics in the sense that the reference placed&#xA;&#x9;// on the result pin is a CS_Reference (in the case where the instantiated object&#xA;&#x9;// is a CS_Object) not a Reference&#xA;&#x9;// Note that Locus.instantiate(Class) is extended in this specification&#xA;&#x9;// to produce a CS_Object instead of an Object in the case where the class&#xA;&#x9;// to be instantiated is not a behavior&#xA;&#xA;&#x9;CreateObjectAction action = (CreateObjectAction) (this.node);&#xA;&#xA;&#x9;Reference reference ;&#xA;&#x9;Object_ referent =  this.getExecutionLocus().instantiate((Class_) (action.classifier));&#xA;&#x9;if (referent instanceof CS_Object) {&#xA;&#x9;&#x9;reference = new CS_Reference() ;&#xA;&#x9;&#x9;((CS_Reference)reference).compositeReferent = (CS_Object)referent ;&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;reference = new Reference() ;&#xA;&#x9;}&#xA;&#x9;reference.referent = referent ;&#xA;&#xA;&#x9;this.putToken(action.result, reference);"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_CallOperationActionActivation">
        <eOperations name="getCallExecution" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// If onPort is not specified, behaves like in fUML&#xA;&#x9;// If onPort is specified, and if the value on the target input pin is a &#xA;&#x9;// reference, dispatch the operation &#xA;&#x9;// to it and return the resulting execution object.&#xA;&#x9;// As compared to fUML, instead of dispatching directly to target reference &#xA;&#x9;// by calling operation dispatch:&#xA;&#x9;// - If the invoked BehavioralFeature is on a provided Interface but not on any required Interface, &#xA;&#x9;// then, when the InvocationAction is executed, the invocation is made into the object given on &#xA;&#x9;// the target InputPin through the given Port&#xA;&#x9;// - If the invoked BehavioralFeature is on a required Interface but not on any provided Interface, &#xA;&#x9;// then, if the InvocationAction is being executed inside the object given on the target InputPin, &#xA;&#x9;// the invocation is forwarded out of the target object through the given Port.&#xA;&#x9;// - If the invoked BehavioralFeature is on both a provided and a required Interface, &#xA;&#x9;// then, if the InvocationAction is being executed inside the object given on the target InputPin, &#xA;&#x9;// the invocation is made out of the target object through the given Port. &#xA;&#x9;// Otherwise the invocation is made into the target object through the given Port.&#xA;&#xA;&#x9;CallOperationAction action = (CallOperationAction)(this.node);&#xA;&#x9;Execution execution = null ; &#xA;&#x9;if (action.onPort == null ) {&#xA;&#x9;&#x9;execution = super.getCallExecution() ;&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;Value target = this.takeTokens(action.target).get(0);&#xA;&#x9;&#x9;if (target instanceof CS_Reference) {&#xA;&#x9;&#x9;&#x9;// Tries to determine if the operation call has to be&#xA;&#x9;&#x9;&#x9;// dispatched to the environment or to the internals of&#xA;&#x9;&#x9;&#x9;// target, through onPort&#xA;&#x9;&#x9;&#x9;CS_Reference targetReference = (CS_Reference)target ;&#xA;&#x9;&#x9;&#x9;Object_ executionContext = this.getActivityExecution().context;&#xA;&#x9;&#x9;&#x9;boolean operationIsOnProvidedInterface = this.isOperationProvided(action.onPort, action.operation) ;&#xA;&#x9;&#x9;&#x9;boolean operationIsOnRequiredInterface = this.isOperationRequired(action.onPort, action.operation) ;&#xA;&#x9;&#x9;&#x9;// Operation on a provided interface only&#xA;&#x9;&#x9;&#x9;if (operationIsOnProvidedInterface &amp;&amp; !operationIsOnRequiredInterface) {&#xA;&#x9;&#x9;&#x9;&#x9;execution = targetReference.dispatchIn(action.operation, action.onPort);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;// Operation is on a required interface only&#xA;&#x9;&#x9;&#x9;else if (!operationIsOnProvidedInterface &amp;&amp; operationIsOnRequiredInterface){&#xA;&#x9;&#x9;&#x9;&#x9;// If not executing in the context of the target,&#xA;&#x9;&#x9;&#x9;&#x9;// Semantics are undefined.&#xA;&#x9;&#x9;&#x9;&#x9;// Otherwise, dispatch outside.&#xA;&#x9;&#x9;&#x9;&#x9;if (executionContext == targetReference.referent &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;|| targetReference.compositeReferent.contains(executionContext)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;execution = targetReference.dispatchOut(action.operation, action.onPort);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;// Operation is both on a provided and a required interface&#xA;&#x9;&#x9;&#x9;else if (operationIsOnProvidedInterface &amp;&amp; operationIsOnRequiredInterface) {&#xA;&#x9;&#x9;&#x9;&#x9;if (executionContext == targetReference.referent &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;|| targetReference.compositeReferent.contains(executionContext)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;execution = targetReference.dispatchOut(action.operation, action.onPort);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;execution = targetReference.dispatchIn(action.operation, action.onPort);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return execution;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="doAction" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;CallOperationAction action = (CallOperationAction)(this.node);&#xA;&#x9;// First determines if this is a call to a constructor and if a default &#xA;&#x9;// construction strategy needs to be applied.&#xA;&#x9;// This is a call to a constructor if the called operation has &#xA;&#x9;// stereotype &lt;&lt;Create>> applied. &#xA;&#x9;// The default construction strategy is used if no method is associated with the &#xA;&#x9;// &lt;&lt;Create>> operation.&#xA;&#x9;// Otherwise, behaves like in fUML.&#xA;&#x9;if (action.onPort == null &amp;&amp; this.isCreate(action.operation) &amp;&amp; action.operation.method.size() == 0) {&#xA;&#x9;&#x9;Locus locus = this.getExecutionLocus() ;&#xA;&#x9;&#x9;CS_ConstructStrategy strategy = ((CS_ConstructStrategy)locus.factory.getStrategy(&quot;constructStrategy&quot;)) ;&#xA;&#x9;&#x9;Value target = this.takeTokens(action.target).get(0);&#xA;&#x9;&#x9;if (target instanceof CS_Reference) {&#xA;&#x9;&#x9;&#x9;strategy.construct(action.operation, ((CS_Reference)target).compositeReferent) ;&#xA;&#x9;&#x9;&#x9;ParameterList parameters = action.operation.ownedParameter ;&#xA;&#x9;&#x9;&#x9;OutputPinList resultPins = action.result ;&#xA;&#x9;&#x9;&#x9;ValueList values = new ValueList() ;&#xA;&#x9;&#x9;&#x9;values.add(target) ;&#xA;&#x9;&#x9;&#x9;int i = 1 ;&#xA;&#x9;&#x9;&#x9;while(i &lt;= parameters.size()) {&#xA;&#x9;&#x9;&#x9;&#x9;Parameter parameter = parameters.get(i - 1);&#xA;&#x9;&#x9;&#x9;&#x9;if(parameter.direction == ParameterDirectionKind.return_) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;OutputPin resultPin = resultPins.get(0);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this.putTokens(resultPin, values);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;i = i + 1;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;super.doAction();&#xA;&#x9;}"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="isOperationProvided" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//Boolean">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;boolean isProvided = false ;&#xA;&#x9;if (operation.owner instanceof Interface) {&#xA;&#x9;&#x9;// We have to look in provided interfaces of the port if &#xA;&#x9;&#x9;// they define directly or indirectly the Operation&#xA;&#x9;&#x9;Integer interfaceIndex = 1 ;&#xA;&#x9;&#x9;// Iterates on provided interfaces of the port&#xA;&#x9;&#x9;InterfaceList providedInterfaces = port.provided ;&#xA;&#x9;&#x9;while (interfaceIndex &lt;= providedInterfaces.size() &amp;&amp; !isProvided) {&#xA;&#x9;&#x9;&#x9;Interface interface_ = providedInterfaces.get(interfaceIndex-1) ;&#xA;&#x9;&#x9;&#x9;// Iterates on members of the current Interface&#xA;&#x9;&#x9;&#x9;Integer memberIndex = 1 ;&#xA;&#x9;&#x9;&#x9;while (memberIndex &lt;= interface_.member.size() &amp;&amp; !isProvided) {&#xA;&#x9;&#x9;&#x9;&#x9;NamedElement cddOperation = interface_.member.get(memberIndex-1) ;&#xA;&#x9;&#x9;&#x9;&#x9;if (cddOperation instanceof Operation) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;isProvided = operation == cddOperation ;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;memberIndex = memberIndex + 1 ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;interfaceIndex = interfaceIndex + 1 ;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return isProvided ;"/>
          </eAnnotations>
          <eParameters name="port" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
        </eOperations>
        <eOperations name="isOperationRequired" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//Boolean">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;boolean isRequired = false ;&#xA;&#x9;Integer interfaceIndex = 1 ;&#xA;&#x9;// Iterates on provided interfaces of the port&#xA;&#x9;InterfaceList requiredInterfaces = port.required ;&#xA;&#x9;while (interfaceIndex &lt;= requiredInterfaces.size() &amp;&amp; !isRequired) {&#xA;&#x9;&#x9;Interface interface_ = requiredInterfaces.get(interfaceIndex-1) ;&#xA;&#x9;&#x9;// Iterates on members of the current Interface&#xA;&#x9;&#x9;Integer memberIndex = 1 ;&#xA;&#x9;&#x9;while (memberIndex &lt;= interface_.member.size() &amp;&amp; !isRequired) {&#xA;&#x9;&#x9;&#x9;NamedElement cddOperation = interface_.member.get(memberIndex-1) ;&#xA;&#x9;&#x9;&#x9;if (cddOperation instanceof Operation) {&#xA;&#x9;&#x9;&#x9;&#x9;isRequired = operation == cddOperation ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;memberIndex = memberIndex + 1 ;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;interfaceIndex = interfaceIndex + 1 ;&#xA;&#x9;}&#xA;&#x9;return isRequired ;"/>
          </eAnnotations>
          <eParameters name="port" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
        </eOperations>
        <eOperations name="isCreate" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//Boolean">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;CS_ExecutionFactory executionFactory = (CS_ExecutionFactory)this.getExecutionLocus().factory ;&#xA;&#x9;Class_ stereotypeCreate = executionFactory.getStereotypeClass(&quot;StandardProfile&quot;, &quot;Create&quot;) ;&#xA;&#x9;if (stereotypeCreate == null) {&#xA;&#x9;&#x9;// standard profile is not applied&#xA;&#x9;&#x9;return false ;&#xA;&#x9;}&#xA;&#x9;return executionFactory.getStereotypeApplication(stereotypeCreate, o) != null ;"/>
          </eAnnotations>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_ConstructStrategy" abstract="true">
        <eOperations name="getName" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//String">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// a CS_ConstructionStrategy is always named &quot;constructStrategy&quot;&#xA;&#x9;return &quot;constructStrategy&quot;;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="construct" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eParameters name="constructor" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
          <eParameters name="context" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Object"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_DefaultConstructStrategy" eSuperTypes="#//Semantics/Actions/CS_ConstructStrategy">
        <eOperations name="addStructuralFeatureValue" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;FeatureValue featureValue = context.getFeatureValue(feature) ;&#xA;&#x9;if (featureValue != null) {&#xA;&#x9;&#x9;ValueList values = featureValue.values ;&#xA;&#x9;&#x9;if (feature instanceof Port) {&#xA;&#x9;&#x9;&#x9;// insert an interaction point&#xA;&#x9;&#x9;&#x9;CS_InteractionPoint interactionPoint = new CS_InteractionPoint() ;&#xA;&#x9;&#x9;&#x9;interactionPoint.definingPort = (Port)feature ;&#xA;&#x9;&#x9;&#x9;interactionPoint.referent = (CS_Object)value ;&#xA;&#x9;&#x9;&#x9;interactionPoint.owner = context ;&#xA;&#x9;&#x9;&#x9;values.add(interactionPoint) ;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (value instanceof CS_Object) {&#xA;&#x9;&#x9;&#x9;// insert a reference&#xA;&#x9;&#x9;&#x9;CS_Reference reference = new CS_Reference() ;&#xA;&#x9;&#x9;&#x9;reference.compositeReferent = (CS_Object)value ;&#xA;&#x9;&#x9;&#x9;reference.referent = (CS_Object)value ;&#xA;&#x9;&#x9;&#x9;values.add(reference) ;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;values.add(value) ;&#xA;&#x9;&#x9;}&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="context" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Reference"/>
          <eParameters name="feature" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Property"/>
          <eParameters name="value" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
        </eOperations>
        <eOperations name="canInstantiate" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//Boolean">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Instantiate is possible if:&#xA;&#x9;// - p is composite&#xA;&#x9;// - p is typed&#xA;&#x9;// - This type is a Class and it is not abstract&#xA;&#x9;// - Or p is a Port and the type is an Interface&#xA;&#x9;if (p.isComposite) {&#xA;&#x9;&#x9;if (p.typedElement.type != null) {&#xA;&#x9;&#x9;&#x9;if (p.typedElement.type instanceof Class_) {&#xA;&#x9;&#x9;&#x9;&#x9;return ! ((Class_)p.typedElement.type).isAbstract ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (p.typedElement.type instanceof Interface) { &#xA;&#x9;&#x9;&#x9;&#x9;return p instanceof Port ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return false ;"/>
          </eAnnotations>
          <eParameters name="p" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Property"/>
        </eOperations>
        <eOperations name="constructObject" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;CS_Reference referenceToContext = new CS_Reference() ;&#xA;&#x9;referenceToContext.referent = context ;&#xA;&#x9;referenceToContext.compositeReferent = (CS_Object)context ;&#xA;&#x9;// FIXME detect infinite recursive instantiation&#xA;&#x9;PropertyList allAttributes = type.attribute ;&#xA;&#x9;int i = 1 ;&#xA;&#x9;// Instantiate ports and parts&#xA;&#x9;while (i &lt;= allAttributes.size()) {&#xA;&#x9;&#x9;Property p = allAttributes.get(i - 1) ;&#xA;&#x9;&#x9;if (p.default_ != null) {&#xA;&#x9;&#x9;&#x9;ValueSpecification defaultValueSpecification = p.default_ ;&#xA;&#x9;&#x9;&#x9;Evaluation evaluation = (Evaluation)context.locus.factory.instantiateVisitor(defaultValueSpecification) ;&#xA;&#x9;&#x9;&#x9;evaluation.specification = defaultValueSpecification ;&#xA;&#x9;&#x9;&#x9;evaluation.locus = context.locus ;&#xA;&#x9;&#x9;&#x9;if (evaluation instanceof CS_OpaqueExpressionEvaluation) {&#xA;&#x9;&#x9;&#x9;&#x9;ValueList evaluations = ((CS_OpaqueExpressionEvaluation)evaluation).executeExpressionBehavior() ;&#xA;&#x9;&#x9;&#x9;&#x9;for (int j = 0 ; j &lt; evaluations.size() ; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this.addStructuralFeatureValue(referenceToContext, p, evaluations.get(j)) ;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;Value defaultValue = evaluation.evaluate() ;&#xA;&#x9;&#x9;&#x9;&#x9;this.addStructuralFeatureValue(referenceToContext, p, defaultValue) ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else &#xA;&#x9;&#x9;&#x9;if (this.canInstantiate(p)) {&#xA;&#x9;&#x9;&#x9;&#x9;int j = 1 ;&#xA;&#x9;&#x9;&#x9;&#x9;while (j &lt;= p.multiplicityElement.lower) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Object_ value ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// if p is a Port typed by an Interface&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// creates an Object without type, but with FeatureValues corresponding to &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// structural features of the interface.&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (p instanceof Port &amp;&amp; p.typedElement.type instanceof Interface) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;value = this.instantiateInterface((Interface)p.typedElement.type, this.locus) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;this.addStructuralFeatureValue(referenceToContext, p, value);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;value = context.locus.instantiate((Class_)p.typedElement.type) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// TODO account for existing constructors&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;value = this.constructObject((CS_Object)value, (Class_)p.typedElement.type) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;this.addStructuralFeatureValue(referenceToContext, p, (CS_Object)value) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (((Class_)p.typedElement.type).isActive) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;value.startBehavior((Class_)p.typedElement.type, new ParameterValueList()) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;j = j + 1 ;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;i = i + 1 ;&#xA;&#x9;}&#xA;&#x9;// Instantiate connectors&#xA;&#x9;NamedElementList allMembers = type.member ;&#xA;&#x9;i = 1 ;&#xA;&#x9;while (i &lt;= allMembers.size()) {&#xA;&#x9;&#x9;NamedElement member = allMembers.get(i - 1) ;&#xA;&#x9;&#x9;if (member instanceof Connector) {&#xA;&#x9;&#x9;&#x9;Connector connector = (Connector)member ;&#xA;&#x9;&#x9;&#x9;if (this.isArrayPattern(connector)) {&#xA;&#x9;&#x9;&#x9;&#x9;this.generateArrayPattern(referenceToContext, connector) ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (this.isStarPattern(connector)) {&#xA;&#x9;&#x9;&#x9;&#x9;this.generateStarPattern(referenceToContext, connector) ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;i = i + 1 ;&#xA;&#x9;}&#xA;&#x9;return referenceToContext.referent ;"/>
          </eAnnotations>
          <eParameters name="context" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Object"/>
          <eParameters name="type" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class"/>
        </eOperations>
        <eOperations name="generateArrayPattern" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;ConnectorEnd end1 = connector.end.getValue(0) ;&#xA;&#x9;ConnectorEnd end2 = connector.end.getValue(1) ;&#xA;&#x9;ReferenceList end1Values = this.getValuesFromConnectorEnd(context, end1) ;&#xA;&#x9;ReferenceList end2Values = this.getValuesFromConnectorEnd(context, end2) ;&#xA;&#x9;for (int i = 0 ; i &lt; end1Values.size() ; i++) {&#xA;&#x9;&#x9;CS_Link link = new CS_Link() ;&#xA;&#x9;&#x9;if (connector.type == null) {&#xA;&#x9;&#x9;&#x9;link.type = this.getDefaultAssociation() ;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;link.type = connector.type ;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;ValueList valuesForEnd1 = new ValueList() ;&#xA;&#x9;&#x9;valuesForEnd1.add(end1Values.get(i)) ;&#xA;&#x9;&#x9;ValueList valuesForEnd2 = new ValueList() ;&#xA;&#x9;&#x9;valuesForEnd2.add(end2Values.get(i)) ;&#xA;&#x9;&#x9;link.setFeatureValue(link.type.ownedEnd.getValue(0), valuesForEnd1, -1) ;&#xA;&#x9;&#x9;link.setFeatureValue(link.type.ownedEnd.getValue(1), valuesForEnd2, -1) ;&#xA;&#x9;&#x9;link.addTo(context.referent.locus) ;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="context" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Reference"/>
          <eParameters name="connector" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Connector"/>
        </eOperations>
        <eOperations name="generateStarPattern" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;ConnectorEnd end1 = connector.end.getValue(0) ;&#xA;&#x9;ConnectorEnd end2 = connector.end.getValue(1) ;&#xA;&#x9;ReferenceList end1Values = this.getValuesFromConnectorEnd(context, end1) ;&#xA;&#x9;ReferenceList end2Values = this.getValuesFromConnectorEnd(context, end2) ;&#xA;&#x9;for (int i = 0 ; i &lt; end1Values.size() ; i++) {&#xA;&#x9;&#x9;for (int j = 0 ; j &lt; end2Values.size(); j++) {&#xA;&#x9;&#x9;&#x9;CS_Link link = new CS_Link() ;&#xA;&#x9;&#x9;&#x9;if (connector.type == null) {&#xA;&#x9;&#x9;&#x9;&#x9;link.type = this.getDefaultAssociation() ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;link.type = connector.type ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;ValueList valuesForEnd1 = new ValueList() ;&#xA;&#x9;&#x9;&#x9;valuesForEnd1.add(end1Values.get(i)) ;&#xA;&#x9;&#x9;&#x9;ValueList valuesForEnd2 = new ValueList() ;&#xA;&#x9;&#x9;&#x9;valuesForEnd2.add(end2Values.get(j)) ;&#xA;&#x9;&#x9;&#x9;link.setFeatureValue(link.type.ownedEnd.get(0), valuesForEnd1, -1) ;&#xA;&#x9;&#x9;&#x9;link.setFeatureValue(link.type.ownedEnd.get(1), valuesForEnd2, -1) ;&#xA;&#x9;&#x9;&#x9;link.addTo(context.referent.locus) ;&#xA;&#x9;&#x9;}&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="context" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Reference"/>
          <eParameters name="connector" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Connector"/>
        </eOperations>
        <eOperations name="getCardinality" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//Integer">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;int lowerOfRole = end.role.actualConnectableElement.multiplicityElement.lower ;&#xA;&#x9;if (lowerOfRole == 0) {&#xA;&#x9;&#x9;return 0 ;&#xA;&#x9;}&#xA;&#x9;else if (end.partWithPort == null) {&#xA;&#x9;&#x9;return lowerOfRole ;&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;int lowerOfPart = end.partWithPort.multiplicityElement.lower ;&#xA;&#x9;&#x9;return lowerOfRole * lowerOfPart ;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="end" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//ConnectorEnd"/>
        </eOperations>
        <eOperations name="getValuesFromConnectorEnd" ordered="false" upperBound="-1"
            eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;ReferenceList endValues = new ReferenceList() ;&#xA;&#x9;if (end.partWithPort != null) {&#xA;&#x9;&#x9;FeatureValue valueForPart = context.getFeatureValue(end.partWithPort) ;&#xA;&#x9;&#x9;if (valueForPart != null) {&#xA;&#x9;&#x9;&#x9;for (int i = 0 ; i &lt; valueForPart.values.size() ; i++) {&#xA;&#x9;&#x9;&#x9;&#x9;Reference reference = (Reference)valueForPart.values.get(i) ;&#xA;&#x9;&#x9;&#x9;&#x9;FeatureValue valueForPort = reference.getFeatureValue((Port)end.role.actualConnectableElement) ;&#xA;&#x9;&#x9;&#x9;&#x9;if (valueForPort != null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for (int j = 0 ; j &lt; valueForPort.values.size() ; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;endValues.add((Reference)valueForPort.values.get(j)) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;FeatureValue valueForRole = context.getFeatureValue((Property)end.role.actualConnectableElement) ;&#xA;&#x9;&#x9;if (valueForRole != null) {&#xA;&#x9;&#x9;&#x9;for (int i = 0 ; i &lt; valueForRole.values.size() ; i++) {&#xA;&#x9;&#x9;&#x9;&#x9;endValues.add((Reference)valueForRole.values.get(i)) ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return endValues ;"/>
          </eAnnotations>
          <eParameters name="context" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Reference"/>
          <eParameters name="end" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//ConnectorEnd"/>
        </eOperations>
        <eOperations name="isArrayPattern" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//Boolean">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// This is an array pattern if:&#xA;&#x9;// - c is binary&#xA;&#x9;// - lower bound of the two connector ends is 1&#xA;&#x9;// - Cardinality of ends are equals&#xA;&#x9;if (c.end.size() == 2) {&#xA;&#x9;&#x9;if (c.end.get(0).role.actualConnectableElement.multiplicityElement.lower == 1) {&#xA;&#x9;&#x9;&#x9;if (c.end.get(1).role.actualConnectableElement.multiplicityElement.lower == 1) {&#xA;&#x9;&#x9;&#x9;&#x9;if (this.canInstantiate(c.end.get(0).role.actualConnectableElement)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&amp;&amp; this.canInstantiate(c.end.get(1).role.actualConnectableElement)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;int cardinality1 = this.getCardinality(c.end.get(0)) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;int cardinality2 = this.getCardinality(c.end.get(1)) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return cardinality1 == cardinality2 ;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return false ;"/>
          </eAnnotations>
          <eParameters name="c" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Connector"/>
        </eOperations>
        <eOperations name="isStarPattern" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//Boolean">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// This is an array pattern if:&#xA;&#x9;// - c is binary&#xA;&#x9;// - lower bound of end1 equals cardinality of end1&#xA;&#x9;// - lower bound of end2 equals cardinality of end2&#xA;&#x9;if (c.end.size() == 2) {&#xA;&#x9;&#x9;if (this.canInstantiate(c.end.get(0).role.actualConnectableElement)&#xA;&#x9;&#x9;&#x9;&#x9;&amp;&amp; this.canInstantiate(c.end.get(1).role.actualConnectableElement)) {&#xA;&#x9;&#x9;&#x9;int cardinalityOfEnd1 = this.getCardinality(c.end.get(0)) ;&#xA;&#x9;&#x9;&#x9;int lowerBoundofEnd1 = c.end.get(0).role.actualConnectableElement.multiplicityElement.lower ;&#xA;&#x9;&#x9;&#x9;if (cardinalityOfEnd1 == lowerBoundofEnd1) {&#xA;&#x9;&#x9;&#x9;&#x9;int cardinalityOfEnd2 = this.getCardinality(c.end.get(1)) ;&#xA;&#x9;&#x9;&#x9;&#x9;int lowerBoundofEnd2 = c.end.get(1).role.actualConnectableElement.multiplicityElement.lower ;&#xA;&#x9;&#x9;&#x9;&#x9;return cardinalityOfEnd2 == lowerBoundofEnd2 ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return false ;"/>
          </eAnnotations>
          <eParameters name="c" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Connector"/>
        </eOperations>
        <eOperations name="getDefaultAssociation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Association">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Computes an returns an Association with two untyped owned ends, &#xA;&#x9;// with multiplicity [*].&#xA;&#x9;// This association can be used to type links instantiated from untyped connectors&#xA;&#x9;if (defaultAssociation == null) {&#xA;&#x9;&#x9;defaultAssociation = new Association() ;&#xA;&#x9;&#x9;defaultAssociation.name = &quot;DefaultGeneratedAssociation&quot;;&#xA;&#x9;&#x9;Property end1 = new Property() ;&#xA;&#x9;&#x9;end1.setName(&quot;x&quot;); ;&#xA;&#x9;&#x9;end1.setLower(0);&#xA;&#x9;&#x9;end1.setUpper(-1);&#xA;&#x9;&#x9;end1.setIsOrdered(true);&#xA;&#x9;&#x9;end1.setIsUnique(true);&#xA;&#x9;&#x9;defaultAssociation.addOwnedEnd(end1);&#xA;&#x9;&#x9;Property end2 = new Property() ;&#xA;&#x9;&#x9;end2.setName(&quot;y&quot;);&#xA;&#x9;&#x9;end2.setLower(0);&#xA;&#x9;&#x9;end2.setUpper(-1);&#xA;&#x9;&#x9;end2.setIsOrdered(true);&#xA;&#x9;&#x9;end2.setIsUnique(true);&#xA;&#x9;&#x9;defaultAssociation.addOwnedEnd(end2);&#xA;&#x9;}&#xA;&#x9;return defaultAssociation ;"/>
          </eAnnotations>
          <eAnnotations source="http://sse.tu-ilmenau.de/codegen">
            <details key="doNotGenerate" value="true"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="instantiateInterface" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;Class_ realizingClass = this.getRealizingClass(interface_) ;&#xA;&#x9;Object_ object = locus.instantiate(realizingClass) ;&#xA;&#x9;return object ;"/>
          </eAnnotations>
          <eParameters name="interface" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Interface"/>
          <eParameters name="locus" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
        </eOperations>
        <eOperations name="getRealizingClass" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;Class_ realizingClass = null ;&#xA;&#x9;// TODO For cached RealizingClasses, search based on InterfaceRealizations rather than name&#xA;&#x9;String realizingClassName = interface_.qualifiedName + &quot;GeneratedRealizingClass&quot; ;&#xA;&#x9;int i = 1 ;&#xA;&#x9;while (i &lt;= generatedRealizingClasses.size() &amp;&amp; realizingClass == null) {&#xA;&#x9;&#x9;Class_ cddRealizingClass = generatedRealizingClasses.getValue(i - 1) ;&#xA;&#x9;&#x9;if (cddRealizingClass.name.equals(realizingClassName)) {&#xA;&#x9;&#x9;&#x9;realizingClass = cddRealizingClass ;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;i = i + 1 ;&#xA;&#x9;}&#xA;&#x9;if (realizingClass == null) {&#xA;&#x9;&#x9;realizingClass = this.generateRealizingClass(interface_, realizingClassName) ;&#xA;&#x9;&#x9;generatedRealizingClasses.addValue(realizingClass) ;&#xA;&#x9;}&#xA;&#x9;return realizingClass ;"/>
          </eAnnotations>
          <eParameters name="interface_" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Interface"/>
        </eOperations>
        <eOperations name="generateRealizingClass" ordered="false" lowerBound="1"
            eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;Class_ realizingClass = new Class_() ;&#xA;&#x9;realizingClass.setName(className) ;&#xA;&#x9;InterfaceRealization realization = new InterfaceRealization() ;&#xA;&#x9;realization.contract = interface_ ;&#xA;&#x9;realization.implementingClassifier = realizingClass ;&#xA;&#x9;realizingClass.interfaceRealization.addValue(realization); &#xA;&#x9;// TODO Deal with structural features of the interface&#xA;&#x9;// TODO Make a test case for reading/writing structural features of an interface&#xA;&#x9;return realizingClass ;"/>
          </eAnnotations>
          <eParameters name="interface_" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Interface"/>
          <eParameters name="className" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//String"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="locus" ordered="false"
            lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Locus"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="defaultAssociation"
            ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Association"
            containment="true"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="generatedRealizingClasses"
            ordered="false" upperBound="-1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class"
            containment="true"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_AcceptCallActionActivation">
        <eOperations name="accept" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="// If the accepted event occurrence is a CS_EventOccurrence then the wrapped&#xA;// event occurrence is extracted. The acceptance process is the one define&#xA;// by AcceptCallActionActivation defined in fUML.&#xA;&#xA;if(eventOccurrence instanceof CS_EventOccurrence){&#xA;super.accept(((CS_EventOccurrence) eventOccurrence).wrappedEventOccurrence);&#xA;}else{&#xA;super.accept(eventOccurrence);&#xA;}&#xA;&#xA;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_AcceptEventActionActivation">
        <eOperations name="accept" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;// If the accepted event occurrence is a CS_EventOccurrence then the wrapped&#xA;// event occurrence is extracted. The acceptance process is the one define&#xA;// by AcceptEventActionActivation defined in fUML.&#xA;if(eventOccurrence instanceof CS_EventOccurrence){&#xA;&#x9;super.accept(((CS_EventOccurrence) eventOccurrence).wrappedEventOccurrence);&#xA;}else{&#xA;&#x9;super.accept(eventOccurrence);&#xA;}"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_SendSignalActionActivation">
        <eOperations name="doAction" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// If onPort is not specified, behaves like in fUML&#xA;&#x9;// If onPort is specified,&#xA;&#x9;// Get the value from the target pin. If the value is not a reference,&#xA;&#x9;// then do nothing.&#xA;&#x9;// Otherwise, construct a signal using the values from the argument pins&#xA;&#x9;// As compared to fUML, instead of sending directly to target reference&#xA;&#x9;// by calling operation send:&#xA;&#x9;// - if the target is to be the same as or a container of (directly or indirectly)&#xA;&#x9;// the object executing the Action, the Signal shall be related to a Reception belonging&#xA;&#x9;// to a required interface of onPort, and sendOut is called on the target reference&#xA;&#x9;// so that the signal will be sent to the environment&#xA;&#x9;// - if the target is NOT to be the same as or a container of (directly or indirectly)&#xA;&#x9;// the object executing the Action, the Signal shall be related to a Reception belonging&#xA;&#x9;// to a provided Interface of onPort, and operation sendIn is called so that the signal&#xA;&#x9;// will be sent to the internals of the target object&#xA;&#xA;&#x9;SendSignalAction action = (SendSignalAction) (this.node);&#xA;&#xA;&#x9;if (action.getOnPort() == null) {&#xA;&#x9;&#x9;// Behaves like in fUML&#xA;&#x9;&#x9;super.doAction();&#xA;&#x9;} else {&#xA;&#x9;&#x9;Value target = this.takeTokens(action.getTarget()).get(0);&#xA;&#xA;&#x9;&#x9;if (target instanceof CS_Reference) {&#xA;&#x9;&#x9;&#x9;// Constructs the signal instance&#xA;&#x9;&#x9;&#x9;Signal signal = action.getSignal();&#xA;&#x9;&#x9;&#x9;SignalInstance signalInstance = new SignalInstance();&#xA;&#x9;&#x9;&#x9;signalInstance.type = signal;&#xA;&#xA;&#x9;&#x9;&#x9;List&lt;Property> attributes = signal.getOwnedAttributes();&#xA;&#x9;&#x9;&#x9;List&lt;InputPin> argumentPins = action.getArguments();&#xA;&#x9;&#x9;&#x9;Integer i = 0;&#xA;&#x9;&#x9;&#x9;while (i &lt; attributes.size()) {&#xA;&#x9;&#x9;&#x9;&#x9;Property attribute = attributes.get(i);&#xA;&#x9;&#x9;&#x9;&#x9;InputPin argumentPin = argumentPins.get(i);&#xA;&#x9;&#x9;&#x9;&#x9;List&lt;Value> values = this.takeTokens(argumentPin);&#xA;&#x9;&#x9;&#x9;&#x9;signalInstance.setFeatureValue(attribute, values, 0);&#xA;&#x9;&#x9;&#x9;&#x9;i = i + 1;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;// Construct the signal event occurrence&#xA;&#x9;&#x9;&#x9;SignalEventOccurrence signalEventOccurrence =  new SignalEventOccurrence();&#xA;&#x9;&#x9;&#x9;signalEventOccurrence.signalInstance = (SignalInstance) signalInstance.copy();&#xA;&#x9;&#x9;&#x9;CS_EventOccurrence wrappingEventOccurrence = new CS_EventOccurrence();&#xA;&#x9;&#x9;&#x9;wrappingEventOccurrence.wrappedEventOccurrence = signalEventOccurrence;&#xA;&#x9;&#x9;&#x9;// Tries to determine if the signal has to be&#xA;&#x9;&#x9;&#x9;// sent to the environment or to the internals of&#xA;&#x9;&#x9;&#x9;// target, through onPort&#xA;&#x9;&#x9;&#x9;CS_Reference targetReference = (CS_Reference) target;&#xA;&#x9;&#x9;&#x9;Object_ executionContext = this.getActivityExecution().context;&#xA;&#x9;&#x9;&#x9;if (executionContext == targetReference.referent || targetReference.compositeReferent.contains(executionContext)) {&#xA;&#x9;&#x9;&#x9;&#x9;wrappingEventOccurrence.sendOutTo(targetReference, action.onPort);&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;wrappingEventOccurrence.sendInTo(targetReference, action.onPort);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="StructuredClassifiers" nsURI="http:///PSCS_Semantics/Semantics/StructuredClassifiers.ecore"
        nsPrefix="PSCS_Semantics.Semantics.StructuredClassifiers">
      <eClassifiers xsi:type="ecore:EClass" name="CS_DispatchOperationOfInterfaceStrategy">
        <eOperations name="operationsMatch" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//Boolean">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Override operationsMatch, in the case where baseOperation belongs &#xA;&#x9;// to an Interface.&#xA;&#x9;// In this case, ownedOperation matches baseOperation if it has the same name and signature&#xA;&#x9;// Otherwise, behaves like fUML RedefinitionBasedDispatchStrategy&#xA;&#x9;boolean matches = true ;&#xA;&#x9;if (baseOperation.namespace instanceof Interface) {&#xA;&#x9;&#x9;matches = (baseOperation.name == ownedOperation.name) ;&#xA;&#x9;&#x9;matches = matches &amp;&amp; (baseOperation.ownedParameter.size() == ownedOperation.ownedParameter.size()) ;&#xA;&#x9;&#x9;ParameterList ownedOperationParameters = ownedOperation.ownedParameter ;&#xA;&#x9;&#x9;ParameterList baseOperationParameters = baseOperation.ownedParameter ;&#xA;&#x9;&#x9;for (int i = 0 ; matches == true &amp;&amp; i &lt; ownedOperationParameters.size() ; i++) {&#xA;&#x9;&#x9;&#x9;Parameter ownedParameter = ownedOperationParameters.getValue(i) ;&#xA;&#x9;&#x9;&#x9;Parameter baseParameter = baseOperationParameters.getValue(i) ;&#xA;&#x9;&#x9;&#x9;matches = (ownedParameter.type == baseParameter.type) ;&#xA;&#x9;&#x9;&#x9;matches = matches &amp;&amp; (ownedParameter.multiplicityElement.lower == ownedParameter.multiplicityElement.lower) ;&#xA;&#x9;&#x9;&#x9;matches = matches &amp;&amp; (ownedParameter.multiplicityElement.upper == ownedParameter.multiplicityElement.upper) ;&#xA;&#x9;&#x9;&#x9;matches = matches &amp;&amp; (ownedParameter.direction == ownedParameter.direction) ;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;matches = super.operationsMatch(ownedOperation, baseOperation) ;&#xA;&#x9;}&#xA;&#xA;&#x9;return matches ;"/>
          </eAnnotations>
          <eParameters name="ownedOperation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
          <eParameters name="baseOperation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_NameBased_StructuralFeatureOfInterfaceAccessStrategy"
          eSuperTypes="#//Semantics/StructuredClassifiers/CS_StructuralFeatureOfInterfaceAccessStrategy"/>
      <eClassifiers xsi:type="ecore:EClass" name="CS_StructuralFeatureOfInterfaceAccessStrategy"
          abstract="true">
        <eOperations name="getName" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//String">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// StructuralFeatureAccessStrategy are always named &quot;structuralFeature&quot;&#xA;&#x9;return &quot;structuralFeature&quot;;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="read" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eParameters name="cs_Object" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Object"/>
          <eParameters name="feature" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//StructuralFeature"/>
        </eOperations>
        <eOperations name="write" ordered="false" lowerBound="1">
          <eParameters name="cs_Object" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Object"/>
          <eParameters name="feature" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//StructuralFeature"/>
          <eParameters name="values" ordered="false" upperBound="-1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
          <eParameters name="position" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//Integer"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_Object">
        <eOperations name="dispatchIn" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// If the interaction point refers to a behavior port, does nothing [for the moment... ?], &#xA;&#x9;// since the only kind of event supported in fUML is SignalEvent&#xA;&#x9;// If it does not refer to a behavior port, select appropriate delegation links &#xA;&#x9;// from interactionPoint, and propagates the operation call through &#xA;&#x9;// these links&#xA;&#x9;Execution execution = null ;&#xA;&#x9;if (interactionPoint.definingPort.isBehavior) {&#xA;&#x9;&#x9;execution = this.dispatch(operation);&#xA;&#x9;&#x9;if(execution instanceof CS_CallEventExecution){&#xA;&#x9;&#x9;&#x9;((CS_CallEventExecution)execution).interactionPoint = interactionPoint;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;boolean operationIsProvided = true ;&#xA;&#x9;&#x9;ReferenceList potentialTargets = new ReferenceList() ;&#xA;&#x9;&#x9;CS_LinkList cddLinks = this.getLinks(interactionPoint) ;&#xA;&#x9;&#x9;Integer linkIndex = 1 ;&#xA;&#x9;&#x9;while (linkIndex &lt;= cddLinks.size()) {&#xA;&#x9;&#x9;&#x9;ReferenceList validTargets = this.selectTargetsForDispatching(cddLinks.getValue(linkIndex - 1), &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;interactionPoint, ConnectorKind.delegation, operation, operationIsProvided) ;&#xA;&#x9;&#x9;&#x9;Integer targetIndex = 1 ;&#xA;&#x9;&#x9;&#x9;while(targetIndex &lt;= validTargets.size()) {&#xA;&#x9;&#x9;&#x9;&#x9;potentialTargets.add(validTargets.getValue(targetIndex-1)) ;&#xA;&#x9;&#x9;&#x9;&#x9;targetIndex = targetIndex + 1 ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;linkIndex = linkIndex + 1 ;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;// If potentialTargets is empty, no delegation target have been found, &#xA;&#x9;&#x9;// and the operation call will be lost&#xA;&#x9;&#x9;if (! (potentialTargets.size()==0)) {&#xA;&#x9;&#x9;&#x9;CS_RequestPropagationStrategy strategy =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;(CS_RequestPropagationStrategy)this.locus.factory.getStrategy(&quot;requestPropagation&quot;) ;&#xA;&#x9;&#x9;&#x9;// Choose one target non-deterministically&#xA;&#x9;&#x9;&#x9;ReferenceList targets = strategy.select(potentialTargets, new CallOperationActionActivation()) ;&#xA;&#x9;&#x9;&#x9;Reference target = targets.getValue(0) ;&#xA;&#x9;&#x9;&#x9;execution = target.dispatch(operation) ;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return execution ;"/>
          </eAnnotations>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
          <eParameters name="interactionPoint" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
        </eOperations>
        <eOperations name="sendIn" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// 1] If the interaction is a behavior port then sends the event occurrence to the // target object using operation send.&#xA;&#x9;// 2] If this is not a behavior port, select appropriate delegation targets from // interactionPoint and propagates the event occurrence to these targets&#xA;&#xA;&#x9;if (interactionPoint.definingPort.isBehavior) {&#xA;&#x9;&#x9;this.send(eventOccurrence);&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;boolean receptionIsProvided = true ;&#xA;&#x9;&#x9;ReferenceList potentialTargets = new ReferenceList() ;&#xA;&#x9;&#x9;CS_LinkList cddLinks = this.getLinks(interactionPoint) ;&#xA;&#x9;&#x9;Integer linkIndex = 1 ;&#xA;&#x9;&#x9;while (linkIndex &lt;= cddLinks.size()) {&#xA;&#x9;&#x9;&#x9;ReferenceList validTargets = this.selectTargetsForSending(cddLinks.getValue(linkIndex - 1), &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;interactionPoint, ConnectorKind.delegation, receptionIsProvided) ;&#xA;&#x9;&#x9;&#x9;Integer targetIndex = 1 ;&#xA;&#x9;&#x9;&#x9;while(targetIndex &lt;= validTargets.size()) {&#xA;&#x9;&#x9;&#x9;&#x9;potentialTargets.add(validTargets.getValue(targetIndex-1)) ;&#xA;&#x9;&#x9;&#x9;&#x9;targetIndex = targetIndex + 1 ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;linkIndex = linkIndex + 1 ;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;// If potential targets is empty, no delegation target has been found,&#xA;&#x9;&#x9;// and the event occurrence is lost&#xA;&#x9;&#x9;// Otherwise, do the following concurrently&#xA;&#x9;&#x9;for (int i = 0; i &lt; potentialTargets.size(); i++) {&#xA;&#x9;&#x9;&#x9;Reference target = potentialTargets.getValue(i);&#xA;&#x9;&#x9;&#x9;target.send(eventOccurrence);&#xA;&#x9;&#x9;}&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
          <eParameters name="interactionPoint" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
        </eOperations>
        <eOperations name="selectTargetsForSending" ordered="false" upperBound="-1"
            eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// From the given link, signal and interaction point, retrieves potential targets (i.e. end values of link) &#xA;&#x9;// through which request can be propagated&#xA;&#x9;// These targets are attached to interaction point through the given link, and respect the following rules:&#xA;&#x9;// - if toInternal is true, connectorKind must be Delegation, the given link has to target the internals of this CS_Object&#xA;&#x9;// - if toInternal is false, the given link has to target the environment of this CS_Object.&#xA;&#x9;ReferenceList potentialTargets = new ReferenceList() ;&#xA;&#x9;if (toInternal &amp;&amp; connectorKind == ConnectorKind.delegation) {&#xA;&#x9;&#x9;if (this.getLinkKind(link, interactionPoint) == CS_LinkKind.ToInternal) {&#xA;&#x9;&#x9;&#x9;Integer i = 1 ;&#xA;&#x9;&#x9;&#x9;while(i &lt;= link.getFeatureValues().size()) {&#xA;&#x9;&#x9;&#x9;&#x9;ValueList values = link.getFeatureValues().get(i-1).values ;&#xA;&#x9;&#x9;&#x9;&#x9;if (!values.isEmpty()) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Integer j = 1 ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;while (j &lt;= values.size()) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Reference cddTarget = (Reference)values.get(j-1) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!cddTarget.equals(interactionPoint)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;potentialTargets.add(cddTarget) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;j = j + 1 ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;i = i + 1 ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else { // to Environment&#xA;&#x9;&#x9;if (this.getLinkKind(link, interactionPoint) == CS_LinkKind.ToEnvironment) {&#xA;&#x9;&#x9;&#x9;Integer i = 1 ;&#xA;&#x9;&#x9;&#x9;while(i &lt;= link.getFeatureValues().size()) {&#xA;&#x9;&#x9;&#x9;&#x9;ValueList values = link.getFeatureValues().get(i-1).values ;&#xA;&#x9;&#x9;&#x9;&#x9;if (!values.isEmpty() &amp;&amp; values.get(0) instanceof Reference) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Reference cddTarget = (Reference)values.get(0) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (connectorKind == ConnectorKind.assembly) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (! (cddTarget instanceof CS_InteractionPoint)) { // This is an assembly link&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;potentialTargets.add(cddTarget) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// This is an assembly if the interaction point is not a feature value &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// for a container of this CS_Object&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CS_ObjectList directContainers = this.getDirectContainers() ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;boolean isAssembly = true ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Integer j = 1 ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (! this.hasValueForAFeature(cddTarget)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;while (isAssembly &amp;&amp; j &lt;= directContainers.size()) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CS_Object container = directContainers.get(j - 1) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (container.hasValueForAFeature(cddTarget)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;isAssembly = false ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;j++ ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;isAssembly = false ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (isAssembly) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;potentialTargets.add(cddTarget) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;else { // delegation&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// This is a delegation if the target is an interaction point&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// and if this interaction is a feature value for a container of this CS_Object&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (cddTarget instanceof CS_InteractionPoint) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CS_ObjectList directContainers = this.getDirectContainers() ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;boolean isDelegation = false ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Integer j = 1 ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;while (!isDelegation &amp;&amp; j &lt;= directContainers.size()) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CS_Object container = directContainers.get(j - 1) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (container.hasValueForAFeature(cddTarget)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;isDelegation = true ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;j++ ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (isDelegation) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;potentialTargets.add(cddTarget) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;i = i + 1 ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;} &#xA;&#x9;return potentialTargets ;"/>
          </eAnnotations>
          <eParameters name="link" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Link"/>
          <eParameters name="interactionPoint" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
          <eParameters name="connectorKind" ordered="false" lowerBound="1" eType="ecore:EEnum http://www.eclipse.org/uml2/5.0.0/UML#//ConnectorKind"/>
          <eParameters name="toInternal" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//Boolean"/>
        </eOperations>
        <eOperations name="selectTargetsForDispatching" ordered="false" upperBound="-1"
            eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// From the given link, operation and interaction point, retrieves potential targets (i.e. end values of link) &#xA;&#x9;// through which request can be propagated&#xA;&#x9;// These targets are attached to interaction point through the given link, and respect the following rules:&#xA;&#x9;// - if toInternal is true, connectorKind must be Delegation, the given link has to target the internals of this CS_Object, &#xA;&#x9;// and a valid target must provide the Operation &#xA;&#x9;// - if toInternal is false, the given link has to target the environment of this CS_Object.&#xA;&#x9;//&#x9;&#x9;- if connectorKind is assembly, a valid target has to provide the operation&#xA;&#x9;// &#x9;&#x9;- if connectorKind is delegation, a valid target has to require the operation&#xA;&#x9;ReferenceList potentialTargets = new ReferenceList() ;&#xA;&#x9;if (toInternal &amp;&amp; connectorKind == ConnectorKind.delegation) {&#xA;&#x9;&#x9;if (this.getLinkKind(link, interactionPoint) == CS_LinkKind.ToInternal) {&#xA;&#x9;&#x9;&#x9;Integer i = 1 ;&#xA;&#x9;&#x9;&#x9;while(i &lt;= link.getFeatureValues().size()) {&#xA;&#x9;&#x9;&#x9;&#x9;ValueList values = link.getFeatureValues().get(i-1).values ;&#xA;&#x9;&#x9;&#x9;&#x9;if (!values.isEmpty() &amp;&amp; values.get(0) instanceof Reference) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Reference cddTarget = (Reference)values.get(0) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (cddTarget != interactionPoint &amp;&amp; this.isOperationProvided(cddTarget, operation)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;potentialTargets.add(cddTarget) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;i = i + 1 ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else { // to environment&#xA;&#x9;&#x9;if (this.getLinkKind(link, interactionPoint) == CS_LinkKind.ToEnvironment) {&#xA;&#x9;&#x9;&#x9;Integer i = 1 ;&#xA;&#x9;&#x9;&#x9;while(i &lt;= link.getFeatureValues().size()) {&#xA;&#x9;&#x9;&#x9;&#x9;ValueList values = link.getFeatureValues().get(i-1).values ;&#xA;&#x9;&#x9;&#x9;&#x9;if (!values.isEmpty() &amp;&amp; values.get(0) instanceof Reference) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Reference cddTarget = (Reference)values.get(0) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (connectorKind == ConnectorKind.assembly) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (! (cddTarget instanceof CS_InteractionPoint)) { // This is an assembly link&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (this.isOperationProvided(cddTarget, operation)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;potentialTargets.add(cddTarget) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// This is an assembly if the interaction point is not a feature value &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// for a container of this CS_Object&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CS_ObjectList directContainers = this.getDirectContainers() ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;boolean isAssembly = true ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Integer j = 1 ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (! this.hasValueForAFeature(cddTarget)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;while (isAssembly &amp;&amp; j &lt;= directContainers.size()) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CS_Object container = directContainers.get(j - 1) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (container.hasValueForAFeature(cddTarget)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;isAssembly = false ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;j++ ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;isAssembly = false ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (isAssembly) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (this.isOperationProvided(cddTarget, operation)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;potentialTargets.add(cddTarget) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;else { // delegation&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// This is a delegation if the target is an interaction point&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// and if this interaction is a feature value for a container of this CS_Object&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (cddTarget instanceof CS_InteractionPoint) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CS_ObjectList directContainers = this.getDirectContainers() ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;boolean isDelegation = false ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Integer j = 1 ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;while (!isDelegation &amp;&amp; j &lt;= directContainers.size()) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CS_Object container = directContainers.get(j - 1) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (container.hasValueForAFeature(cddTarget)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;isDelegation = true ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;j++ ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (isDelegation) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (this.isOperationRequired(cddTarget, operation)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;potentialTargets.add(cddTarget) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;i = i + 1 ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return potentialTargets ;"/>
          </eAnnotations>
          <eParameters name="link" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Link"/>
          <eParameters name="interactionPoint" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
          <eParameters name="connectorKind" ordered="false" lowerBound="1" eType="ecore:EEnum http://www.eclipse.org/uml2/5.0.0/UML#//ConnectorKind"/>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
          <eParameters name="toInternal" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//Boolean"/>
        </eOperations>
        <eOperations name="sendOut" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Select appropriate delegation links from interactionPoint, &#xA;&#x9;// and propagates the event occurrence through these links&#xA;&#x9;// Appropriate links are links which target elements&#xA;&#x9;// in the environment of this CS_Object.&#xA;&#x9;// These can be delegation links (i.e, the targeted elements must&#xA;&#x9;// require a reception for the signal) or assembly links (i.e., the target elements&#xA;&#x9;// must provide a reception for the signal)&#xA;&#xA;&#x9;boolean receptionIsNotProvided = false ; // i.e. it is required&#xA;&#x9;ReferenceList allPotentialTargets = new ReferenceList() ;&#xA;&#x9;ReferenceList targetsForSendingIn = new ReferenceList() ;&#xA;&#x9;ReferenceList targetsForSendingOut = new ReferenceList() ;&#xA;&#xA;&#x9;CS_LinkList cddLinks = this.getLinks(interactionPoint) ;&#xA;&#x9;Integer linkIndex = 1 ;&#xA;&#x9;while (linkIndex &lt;= cddLinks.size()) {&#xA;&#x9;&#x9;ReferenceList validAssemblyTargets = this.selectTargetsForSending(cddLinks.getValue(linkIndex - 1), &#xA;&#x9;&#x9;&#x9;&#x9;interactionPoint, ConnectorKind.assembly, receptionIsNotProvided) ;&#xA;&#x9;&#x9;Integer targetIndex = 1 ;&#xA;&#x9;&#x9;while(targetIndex &lt;= validAssemblyTargets.size()) {&#xA;&#x9;&#x9;&#x9;allPotentialTargets.addValue(validAssemblyTargets.getValue(targetIndex-1)) ;&#xA;&#x9;&#x9;&#x9;targetsForSendingIn.addValue(validAssemblyTargets.getValue(targetIndex-1)) ;&#xA;&#x9;&#x9;&#x9;targetIndex = targetIndex + 1 ;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;ReferenceList validDelegationTargets = this.selectTargetsForSending(cddLinks.getValue(linkIndex - 1), &#xA;&#x9;&#x9;&#x9;&#x9;interactionPoint, ConnectorKind.delegation, receptionIsNotProvided) ;&#xA;&#x9;&#x9;targetIndex = 1 ;&#xA;&#x9;&#x9;while(targetIndex &lt;= validDelegationTargets.size()) {&#xA;&#x9;&#x9;&#x9;allPotentialTargets.addValue(validDelegationTargets.getValue(targetIndex-1)) ;&#xA;&#x9;&#x9;&#x9;targetsForSendingOut.addValue(validDelegationTargets.getValue(targetIndex-1)) ;&#xA;&#x9;&#x9;&#x9;targetIndex = targetIndex + 1 ;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;linkIndex = linkIndex + 1 ;&#xA;&#x9;}&#xA;&#xA;&#x9;CS_RequestPropagationStrategy strategy = (CS_RequestPropagationStrategy)this.locus.factory.getStrategy(&quot;requestPropagation&quot;) ;&#xA;&#x9;ReferenceList selectedTargets = strategy.select(allPotentialTargets, new SendSignalActionActivation()) ;&#xA;&#xA;&#x9;for (int j = 0 ; j &lt; selectedTargets.size() ; j++) {&#xA;&#x9;&#x9;Reference target = selectedTargets.getValue(j) ;&#xA;&#x9;&#x9;for (int k = 0 ; k &lt; targetsForSendingIn.size() ; k++) {&#xA;&#x9;&#x9;&#x9;Reference cddTarget = targetsForSendingIn.getValue(k) ;&#xA;&#x9;&#x9;&#x9;if (cddTarget == target) {&#xA;&#x9;&#x9;&#x9;&#x9;target.send(eventOccurrence) ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;for (int k = 0 ; k &lt; targetsForSendingOut.size() ; k++) {&#xA;&#x9;&#x9;&#x9;// The target must be an interaction point&#xA;&#x9;&#x9;&#x9;// i.e. a delegation connector for a required reception can only target a port&#xA;&#x9;&#x9;&#x9;CS_InteractionPoint cddTarget = (CS_InteractionPoint)targetsForSendingOut.getValue(k) ;&#xA;&#x9;&#x9;&#x9;if (cddTarget == target) {&#xA;&#x9;&#x9;&#x9;&#x9;CS_Reference owner = cddTarget.owner ;&#xA;&#x9;&#x9;&#x9;&#x9;owner.sendOut(eventOccurrence, cddTarget) ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
          <eParameters name="interactionPoint" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
        </eOperations>
        <eOperations name="dispatchOut" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Select appropriate delegation links from interactionPoint, &#xA;&#x9;// and propagates the operation call through these links&#xA;&#x9;// Appropriate links are either links which target elements&#xA;&#x9;// in the environment of this CS_Object.&#xA;&#x9;// These can be delegation links (i.e, the targeted elements must&#xA;&#x9;// require the operation) or assembly links (i.e., the target elements&#xA;&#x9;// must provide the operation)&#xA;&#xA;&#xA;&#x9;Execution execution = null ;&#xA;&#xA;&#x9;boolean operationIsNotProvided = false ; // i.e. it is required&#xA;&#x9;ReferenceList allPotentialTargets = new ReferenceList() ;&#xA;&#x9;ReferenceList targetsForDispatchingIn = new ReferenceList() ;&#xA;&#x9;ReferenceList targetsForDispatchingOut = new ReferenceList() ;&#xA;&#xA;&#x9;CS_LinkList cddLinks = this.getLinks(interactionPoint) ;&#xA;&#x9;Integer linkIndex = 1 ;&#xA;&#x9;while (linkIndex &lt;= cddLinks.size()) {&#xA;&#x9;&#x9;ReferenceList validAssemblyTargets = this.selectTargetsForDispatching(cddLinks.getValue(linkIndex - 1), &#xA;&#x9;&#x9;&#x9;&#x9;interactionPoint, ConnectorKind.assembly, operation, operationIsNotProvided) ;&#xA;&#x9;&#x9;Integer targetIndex = 1 ;&#xA;&#x9;&#x9;while(targetIndex &lt;= validAssemblyTargets.size()) {&#xA;&#x9;&#x9;&#x9;allPotentialTargets.addValue(validAssemblyTargets.getValue(targetIndex-1)) ;&#xA;&#x9;&#x9;&#x9;targetsForDispatchingIn.addValue(validAssemblyTargets.getValue(targetIndex-1)) ;&#xA;&#x9;&#x9;&#x9;targetIndex = targetIndex + 1 ;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;ReferenceList validDelegationTargets = this.selectTargetsForDispatching(cddLinks.getValue(linkIndex - 1), &#xA;&#x9;&#x9;&#x9;&#x9;interactionPoint, ConnectorKind.delegation, operation, operationIsNotProvided) ;&#xA;&#x9;&#x9;targetIndex = 1 ;&#xA;&#x9;&#x9;while(targetIndex &lt;= validDelegationTargets.size()) {&#xA;&#x9;&#x9;&#x9;allPotentialTargets.addValue(validDelegationTargets.getValue(targetIndex-1)) ;&#xA;&#x9;&#x9;&#x9;targetsForDispatchingOut.addValue(validDelegationTargets.getValue(targetIndex-1)) ;&#xA;&#x9;&#x9;&#x9;targetIndex = targetIndex + 1 ;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;linkIndex = linkIndex + 1 ;&#xA;&#x9;}&#xA;&#xA;&#x9;CS_RequestPropagationStrategy strategy = (CS_RequestPropagationStrategy)this.locus.factory.getStrategy(&quot;requestPropagation&quot;) ;&#xA;&#x9;ReferenceList selectedTargets = strategy.select(allPotentialTargets, new SendSignalActionActivation()) ;&#xA;&#xA;&#x9;for (int j = 0 ; j &lt; selectedTargets.size() ; j++) {&#xA;&#x9;&#x9;Reference target = selectedTargets.getValue(j) ;&#xA;&#x9;&#x9;for (int k = 0 ; k &lt; targetsForDispatchingIn.size() &amp;&amp; execution == null ; k++) {&#xA;&#x9;&#x9;&#x9;Reference cddTarget = targetsForDispatchingIn.getValue(k) ;&#xA;&#x9;&#x9;&#x9;if (cddTarget == target) {&#xA;&#x9;&#x9;&#x9;&#x9;execution = target.dispatch(operation) ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;for (int k = 0 ; k &lt; targetsForDispatchingOut.size() &amp;&amp; execution == null ; k++) {&#xA;&#x9;&#x9;&#x9;// The target must be an interaction point&#xA;&#x9;&#x9;&#x9;// i.e. a delegation connector for a required operation can only target a port&#xA;&#x9;&#x9;&#x9;CS_InteractionPoint cddTarget = (CS_InteractionPoint)targetsForDispatchingOut.getValue(k) ;&#xA;&#x9;&#x9;&#x9;if (cddTarget == target) {&#xA;&#x9;&#x9;&#x9;&#x9;CS_Reference owner = cddTarget.owner ;&#xA;&#x9;&#x9;&#x9;&#x9;execution = owner.dispatchOut(operation, cddTarget) ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return execution ;&#xA;"/>
          </eAnnotations>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
          <eParameters name="interactionPoint" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
        </eOperations>
        <eOperations name="getFeatureValue" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// In the case where the feature belongs to an Interface,&#xA;&#x9;// fUML semantics is extended in the sense that reading is &#xA;&#x9;// delegated to a CS_StructuralFeatureOfInterfaceAccessStrategy&#xA;&#x9;if (feature.namespace instanceof Interface) {&#xA;&#x9;&#x9;CS_StructuralFeatureOfInterfaceAccessStrategy readStrategy = &#xA;&#x9;&#x9;&#x9;&#x9;(CS_StructuralFeatureOfInterfaceAccessStrategy)this.locus.factory.getStrategy(&quot;structuralFeature&quot;) ;&#xA;&#x9;&#x9;return readStrategy.read(this, feature) ;&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;return super.getFeatureValue(feature);&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="feature" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//StructuralFeature"/>
        </eOperations>
        <eOperations name="setFeatureValue" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// In the case where the feature belongs to an Interface,&#xA;&#x9;// fUML semantics is extended in the sense that writing is &#xA;&#x9;// delegated to a CS_StructuralFeatureOfInterfaceAccessStrategy&#xA;&#x9;if (feature.namespace instanceof Interface) {&#xA;&#x9;&#x9;CS_StructuralFeatureOfInterfaceAccessStrategy writeStrategy = &#xA;&#x9;&#x9;&#x9;&#x9;(CS_StructuralFeatureOfInterfaceAccessStrategy)this.locus.factory.getStrategy(&quot;structuralFeature&quot;) ;&#xA;&#x9;&#x9;writeStrategy.write(this, feature, values, position) ;&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;super.setFeatureValue(feature, values, position);&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="feature" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//StructuralFeature"/>
          <eParameters name="values" ordered="false" upperBound="-1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
          <eParameters name="position" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//Integer"/>
        </eOperations>
        <eOperations name="contains" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//Boolean">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Determines if the object given as a parameter is directly&#xA;&#x9;// or indirectly contained by this CS_Object&#xA;&#x9;boolean objectIsContained = this.directlyContains(object) ;&#xA;&#x9;// if object is not directly contained, restart the research&#xA;&#x9;// recursively on the objects owned by this CS_Object&#xA;&#x9;for (int i = 0 ; i &lt; this.featureValues.size() &amp;&amp; !objectIsContained ; i++) {&#xA;&#x9;&#x9;FeatureValue featureValue = this.featureValues.getValue(i) ;&#xA;&#x9;&#x9;ValueList values = featureValue.values ;&#xA;&#x9;&#x9;for (int j = 0 ; j &lt; values.size() &amp;&amp; !objectIsContained ; j++) {&#xA;&#x9;&#x9;&#x9;Value value = values.getValue(j) ;&#xA;&#x9;&#x9;&#x9;if (value instanceof CS_Object) {&#xA;&#x9;&#x9;&#x9;&#x9;objectIsContained = ((CS_Object)value).contains(object) ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (value instanceof CS_Reference) {&#xA;&#x9;&#x9;&#x9;&#x9;CS_Object referent = ((CS_Reference)value).compositeReferent ;&#xA;&#x9;&#x9;&#x9;&#x9;objectIsContained = referent.contains(object) ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return objectIsContained;"/>
          </eAnnotations>
          <eParameters name="object" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
        </eOperations>
        <eOperations name="directlyContains" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//Boolean">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Determines if the object given as a parameter is directly&#xA;&#x9;// contained by this CS_Object&#xA;&#x9;boolean objectIsContained = false ;&#xA;&#x9;for (int i = 0 ; i &lt; this.featureValues.size() &amp;&amp; !objectIsContained ; i++) {&#xA;&#x9;&#x9;FeatureValue featureValue = this.featureValues.getValue(i) ;&#xA;&#x9;&#x9;ValueList values = featureValue.values ;&#xA;&#x9;&#x9;for (int j = 0 ; j &lt; values.size() &amp;&amp; !objectIsContained ; j++) {&#xA;&#x9;&#x9;&#x9;Value value = values.getValue(j) ;&#xA;&#x9;&#x9;&#x9;if (value == object) {&#xA;&#x9;&#x9;&#x9;&#x9;objectIsContained = true ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (value instanceof CS_Reference) {&#xA;&#x9;&#x9;&#x9;&#x9;objectIsContained = (((CS_Reference)value).referent == object) ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return objectIsContained;"/>
          </eAnnotations>
          <eParameters name="object" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
        </eOperations>
        <eOperations name="getDirectContainers" ordered="false" upperBound="-1" eType="#//Semantics/StructuredClassifiers/CS_Object">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Retrieves all the extensional values at this locus which are direct&#xA;&#x9;// containers for this CS_Object&#xA;&#x9;// An extensional value is a direct container for an object if:&#xA;&#x9;// - it is a CS_Object&#xA;&#x9;// - it directly contains this object (i.e. CS_Object.directlyContains(Object)==true)&#xA;&#x9;CS_ObjectList containers = new CS_ObjectList() ;&#xA;&#x9;for (int i = 0 ; i &lt; this.locus.extensionalValues.size() ; i++) {&#xA;&#x9;&#x9;ExtensionalValue extensionalValue = this.locus.extensionalValues.getValue(i) ;&#xA;&#x9;&#x9;if (extensionalValue != this &amp;&amp; extensionalValue instanceof CS_Object) {&#xA;&#x9;&#x9;&#x9;CS_Object cddContainer = (CS_Object)extensionalValue ;&#xA;&#x9;&#x9;&#x9;if (cddContainer.directlyContains(this)) {&#xA;&#x9;&#x9;&#x9;&#x9;containers.add(cddContainer) ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return containers ;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="isOperationProvided" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//Boolean">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Determines if the given reference provides the operation&#xA;&#x9;// If the reference is an interaction point, it provides the operation if this operation&#xA;&#x9;// is a member of one of its provided interfaces&#xA;&#x9;// If the reference is NOT an interactionPoint, it provides this operation if this operation is&#xA;&#x9;// an operation of one of its type, or one of its type provides a realization for this operation (in the case&#xA;&#x9;// where the namespace of this Operation is an interface)&#xA;&#x9;boolean isProvided = false ;&#xA;&#x9;if (reference instanceof CS_InteractionPoint) {&#xA;&#x9;&#x9;if (operation.owner instanceof Interface) {&#xA;&#x9;&#x9;&#x9;// We have to look in provided interfaces of the port if &#xA;&#x9;&#x9;&#x9;// they define directly or indirectly the Operation&#xA;&#x9;&#x9;&#x9;Integer interfaceIndex = 1 ;&#xA;&#x9;&#x9;&#x9;// Iterates on provided interfaces of the port&#xA;&#x9;&#x9;&#x9;InterfaceList providedInterfaces = ((CS_InteractionPoint)reference).definingPort.provided() ;&#xA;&#x9;&#x9;&#x9;while (interfaceIndex &lt;= providedInterfaces.size() &amp;&amp; !isProvided) {&#xA;&#x9;&#x9;&#x9;&#x9;Interface interface_ = providedInterfaces.getValue(interfaceIndex-1) ;&#xA;&#x9;&#x9;&#x9;&#x9;// Iterates on members of the current Interface&#xA;&#x9;&#x9;&#x9;&#x9;Integer memberIndex = 1 ;&#xA;&#x9;&#x9;&#x9;&#x9;while (memberIndex &lt;= interface_.member.size() &amp;&amp; !isProvided) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;NamedElement cddOperation = interface_.member.getValue(memberIndex-1) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (cddOperation instanceof Operation) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;isProvided = operation == cddOperation ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;memberIndex = memberIndex + 1 ;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;interfaceIndex = interfaceIndex + 1 ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;// We have to look if one of the Classifiers typing this reference &#xA;&#x9;&#x9;// directly or indirectly provides this operation&#xA;&#x9;&#x9;ClassifierList types = reference.getTypes() ;&#xA;&#x9;&#x9;Integer typeIndex = 1 ;&#xA;&#x9;&#x9;while (typeIndex &lt;= types.size() &amp;&amp; !isProvided) {&#xA;&#x9;&#x9;&#x9;if (types.getValue(typeIndex - 1) instanceof Class_) {&#xA;&#x9;&#x9;&#x9;&#x9;Integer memberIndex = 1 ;&#xA;&#x9;&#x9;&#x9;&#x9;NamedElementList members = ((Class_)types.getValue(typeIndex - 1)).member ; &#xA;&#x9;&#x9;&#x9;&#x9;while (memberIndex &lt;= members.size() &amp;&amp; !isProvided) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;NamedElement cddOperation = members.getValue(memberIndex-1) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (cddOperation instanceof Operation) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;CS_DispatchOperationOfInterfaceStrategy strategy = new CS_DispatchOperationOfInterfaceStrategy() ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;isProvided = strategy.operationsMatch((Operation)cddOperation, operation) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;memberIndex = memberIndex + 1 ;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;typeIndex = typeIndex + 1 ;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return isProvided ;"/>
          </eAnnotations>
          <eParameters name="reference" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
        </eOperations>
        <eOperations name="isOperationRequired" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//Boolean">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Determines if the given reference requires the operation&#xA;&#x9;// If the reference is an interaction point, it requires the operation if this operation&#xA;&#x9;// is a member of one of its required interfaces&#xA;&#x9;// If the reference is not a interaction point, it cannot require an operation&#xA;&#x9;boolean matches = false ;&#xA;&#x9;if (reference instanceof CS_InteractionPoint) {&#xA;&#x9;&#x9;Integer interfaceIndex = 1 ;&#xA;&#x9;&#x9;// Iterates on provided interfaces of the port&#xA;&#x9;&#x9;InterfaceList requiredInterfaces = ((CS_InteractionPoint)reference).definingPort.required() ;&#xA;&#x9;&#x9;while (interfaceIndex &lt;= requiredInterfaces.size() &amp;&amp; !matches) {&#xA;&#x9;&#x9;&#x9;Interface interface_ = requiredInterfaces.getValue(interfaceIndex-1) ;&#xA;&#x9;&#x9;&#x9;// Iterates on members of the current Interface&#xA;&#x9;&#x9;&#x9;Integer memberIndex = 1 ;&#xA;&#x9;&#x9;&#x9;while (memberIndex &lt;= interface_.member.size() &amp;&amp; !matches) {&#xA;&#x9;&#x9;&#x9;&#x9;NamedElement cddOperation = interface_.member.getValue(memberIndex-1) ;&#xA;&#x9;&#x9;&#x9;&#x9;if (cddOperation instanceof Operation) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;matches = operation == cddOperation ;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;memberIndex = memberIndex + 1 ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;interfaceIndex = interfaceIndex + 1 ;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return matches ;"/>
          </eAnnotations>
          <eParameters name="reference" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
        </eOperations>
        <eOperations name="getLinkKind" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_LinkKind">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// If the given interaction point belongs to the given object, and if the given interaction point is used as an end of the link, &#xA;&#x9;// then the links targets the environment of the object (enumeration literal ToEnvironment) if all the feature values of the link &#xA;&#x9;// (but one for the interaction point) refer to values which are not themselves values for features of the interaction point. &#xA;&#x9;// If all the feature values of the link refer to values which are themselves values for features of the interaction point, &#xA;&#x9;// the link targets the internals of the object (enumeration literal ToInternal). Otherwise, the link has no particular meaning &#xA;&#x9;// in the context defined by the object and the interaction point (enumeration literal None).&#xA;&#x9;if (! link.hasValueForAFeature(interactionPoint)) {&#xA;&#x9;&#x9;return CS_LinkKind.None ;&#xA;&#x9;}&#xA;&#x9;CS_LinkKind kind = CS_LinkKind.ToInternal ;&#xA;&#x9;FeatureValueList featureValues = link.getFeatureValues() ;&#xA;&#x9;Integer i = 1 ;&#xA;&#x9;while (i &lt;= featureValues.size() &amp;&amp; kind != CS_LinkKind.None) {&#xA;&#x9;&#x9;FeatureValue value = featureValues.getValue(i-1) ;&#xA;&#x9;&#x9;if (value.values.isEmpty()) {&#xA;&#x9;&#x9;&#x9;kind = CS_LinkKind.None ;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;Value v = value.values.getValue(0) ;&#xA;&#x9;&#x9;&#x9;boolean vIsAValueForAFeatureOfContext = false ;&#xA;&#x9;&#x9;&#x9;if (v.equals(interactionPoint)) {&#xA;&#x9;&#x9;&#x9;&#x9;vIsAValueForAFeatureOfContext = true ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (v instanceof CS_InteractionPoint) {&#xA;&#x9;&#x9;&#x9;&#x9;v = ((CS_InteractionPoint)v).owner ;&#xA;&#x9;&#x9;&#x9;&#x9;vIsAValueForAFeatureOfContext = this.hasValueForAFeature(v) ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;vIsAValueForAFeatureOfContext = this.hasValueForAFeature(v) ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;if (!vIsAValueForAFeatureOfContext) {&#xA;&#x9;&#x9;&#x9;&#x9;kind = CS_LinkKind.ToEnvironment ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;i = i + 1 ;&#xA;&#x9;}&#xA;&#x9;return kind ;"/>
          </eAnnotations>
          <eParameters name="link" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Link"/>
          <eParameters name="interactionPoint" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
        </eOperations>
        <eOperations name="getLinks" ordered="false" upperBound="-1" eType="#//Semantics/StructuredClassifiers/CS_Link">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Get all links (available at the locus of this object) where the given interaction point is used as a feature value&#xA;&#x9;// (i.e. the interaction is an end such links)&#xA;&#x9;ExtensionalValueList extensionalValues = this.locus.extensionalValues ;&#xA;&#x9;Integer i = 1 ;&#xA;&#x9;CS_LinkList connectorInstances = new CS_LinkList() ;&#xA;&#x9;while (i &lt;= extensionalValues.size()) {&#xA;&#x9;&#x9;ExtensionalValue value = extensionalValues.getValue(i-1) ;&#xA;&#x9;&#x9;if (value instanceof CS_Link) {&#xA;&#x9;&#x9;&#x9;CS_Link link = (CS_Link)value ;&#xA;&#x9;&#x9;&#x9;if (this.getLinkKind(link, interactionPoint) != CS_LinkKind.None) {&#xA;&#x9;&#x9;&#x9;&#x9;connectorInstances.addValue(link) ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;i = i + 1 ;&#xA;&#x9;}&#xA;&#x9;return connectorInstances ;"/>
          </eAnnotations>
          <eParameters name="interactionPoint" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
        </eOperations>
        <eOperations name="hasValueForAFeature" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//Boolean">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Returns true if the given value object is used as a value for a feature value of this object&#xA;&#x9;FeatureValueList allFeatureValues = this.getFeatureValues() ;&#xA;&#x9;Integer i = 1 ;&#xA;&#x9;boolean isAValue = false ;&#xA;&#x9;while (i &lt;= allFeatureValues.size() &amp;&amp; !isAValue) {&#xA;&#x9;&#x9;FeatureValue featureValue = allFeatureValues.getValue(i-1);&#xA;&#x9;&#x9;if (!featureValue.values.isEmpty()) {&#xA;&#x9;&#x9;&#x9;ValueList valuesForCurrentFeature = featureValue.values ;&#xA;&#x9;&#x9;&#x9;Integer j = 1 ;&#xA;&#x9;&#x9;&#x9;while (j &lt;= valuesForCurrentFeature.size() &amp;&amp; !isAValue) {&#xA;&#x9;&#x9;&#x9;&#x9;isAValue = featureValue.values.getValue(j-1).equals(value) ;&#xA;&#x9;&#x9;&#x9;&#x9;j = j + 1 ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;i = i + 1 ;&#xA;&#x9;}&#xA;&#x9;return isAValue ;"/>
          </eAnnotations>
          <eParameters name="value" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
        </eOperations>
        <eOperations name="sendOut" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Select a CS_InteractionPoint value playing onPort,&#xA;&#x9;// and send the event occurrence to this interaction point&#xA;&#x9;FeatureValue featureValue = this.getFeatureValue(onPort) ;&#xA;&#x9;ValueList values = featureValue.values ;&#xA;&#x9;ReferenceList potentialTargets = new ReferenceList() ;&#xA;&#x9;for (int i = 0 ; i &lt; values.size() ; i++) {&#xA;&#x9;&#x9;potentialTargets.addValue((Reference)values.getValue(i)) ;&#xA;&#x9;}&#xA;&#x9;CS_RequestPropagationStrategy strategy = &#xA;&#x9;&#x9;&#x9;(CS_RequestPropagationStrategy)this.locus.factory.getStrategy(&quot;requestPropagation&quot;) ;&#xA;&#x9;ReferenceList targets = strategy.select(potentialTargets, new SendSignalActionActivation()) ;&#xA;&#x9;for (int i = 0 ; i &lt; targets.size() ; i++) {&#xA;&#x9;&#x9;CS_InteractionPoint target = (CS_InteractionPoint)targets.getValue(i) ;&#xA;&#x9;&#x9;this.sendOut(eventOccurrence, target) ;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
          <eParameters name="onPort" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
        </eOperations>
        <eOperations name="dispatchOut" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Select a CS_InteractionPoint value playing onPort,&#xA;&#x9;// and dispatches the operation to this interaction point&#xA;&#x9;Execution execution = null ;&#xA;&#x9;FeatureValue featureValue = this.getFeatureValue(onPort) ;&#xA;&#x9;ValueList values = featureValue.values ;&#xA;&#x9;ReferenceList potentialTargets = new ReferenceList() ;&#xA;&#x9;for (int i = 0 ; i &lt; values.size() ; i++) {&#xA;&#x9;&#x9;potentialTargets.addValue((Reference)values.getValue(i)) ;&#xA;&#x9;}&#xA;&#x9;CS_RequestPropagationStrategy strategy = &#xA;&#x9;&#x9;&#x9;(CS_RequestPropagationStrategy)this.locus.factory.getStrategy(&quot;requestPropagation&quot;) ;&#xA;&#x9;ReferenceList targets = strategy.select(potentialTargets, new CallOperationActionActivation()) ;&#xA;&#x9;// if targets is empty, no dispatch target has been found,&#xA;&#x9;// and the operation call is lost&#xA;&#x9;if (targets.size() >= 1) {&#xA;&#x9;&#x9;CS_InteractionPoint target = (CS_InteractionPoint)targets.getValue(0) ;&#xA;&#x9;&#x9;execution = this.dispatchOut(operation, target) ;&#xA;&#x9;}&#xA;&#x9;return execution ;"/>
          </eAnnotations>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
          <eParameters name="onPort" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
        </eOperations>
        <eOperations name="dispatchIn" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// delegates dispatching to composite referent&#xA;&#x9;// Select a CS_InteractionPoint value playing onPort,&#xA;&#x9;// and dispatches the operation call to this interaction point&#xA;&#x9;FeatureValue featureValue = this.getFeatureValue(onPort) ;&#xA;&#x9;ValueList values = featureValue.values ;&#xA;&#x9;Integer choice = ((ChoiceStrategy) this.locus.factory&#xA;&#x9;&#x9;&#x9;.getStrategy(&quot;choice&quot;))&#xA;&#x9;&#x9;&#x9;.choose(featureValue.values.size()) - 1;&#xA;&#x9;CS_InteractionPoint interactionPoint = (CS_InteractionPoint)values.getValue(choice) ;&#xA;&#x9;return interactionPoint.dispatch(operation) ;&#xA;"/>
          </eAnnotations>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
          <eParameters name="onPort" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
        </eOperations>
        <eOperations name="sendIn" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Select a Reference value playing onPort,&#xA;&#x9;// and send the event occurrence to this interaction point&#xA;&#x9;FeatureValue featureValue = this.getFeatureValue(onPort) ;&#xA;&#x9;ValueList values = featureValue.values ;&#xA;&#x9;ReferenceList potentialTargets = new ReferenceList() ;&#xA;&#x9;for (int i = 0 ; i &lt; values.size() ; i++) {&#xA;&#x9;&#x9;potentialTargets.addValue((Reference)values.getValue(i)) ;&#xA;&#x9;}&#xA;&#x9;CS_RequestPropagationStrategy strategy = &#xA;&#x9;&#x9;&#x9;(CS_RequestPropagationStrategy)this.locus.factory.getStrategy(&quot;requestPropagation&quot;) ;&#xA;&#x9;ReferenceList targets = strategy.select(potentialTargets, new SendSignalActionActivation()) ;&#xA;&#x9;for (int i = 0 ; i &lt; targets.size() ; i++) {&#xA;&#x9;&#x9;Reference target = targets.getValue(i) ;&#xA;&#x9;&#x9;target.send(eventOccurrence);&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
          <eParameters name="onPort" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
        </eOperations>
        <eOperations name="checkAllParents" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//Boolean">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="// If the given classifier is not an Interface, behaves like in fUML.&#xA;// Otherwise, check if the given type (or one of its direct or indirect ancestors)&#xA;// has an InterfaceRealization relationships with the given classifier.&#xA;&#xA;boolean matched = false;&#xA;if (!(classifier instanceof Interface)) {&#xA;matched = super.checkAllParents(type, classifier);&#xA;} else if (!(type instanceof Class)) {&#xA;matched = false;&#xA;} else if (this.realizesInterface((Class) type, (Interface) classifier)) {&#xA;matched = true;&#xA;} else {&#xA;ClassifierListdirectParents = type.general;&#xA;int i = 1;&#xA;while (!matched &amp; i &lt;= directParents.size()) {&#xA;&#x9;Classifier directParent = directParents.getValue(i - 1);&#xA;&#x9;matched = this.checkAllParents(directParent, classifier);&#xA;&#x9;i = i + 1;&#xA;}&#xA;}&#xA;return matched;&#xA;"/>
          </eAnnotations>
          <eParameters name="type" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Classifier"/>
          <eParameters name="classifier" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Classifier"/>
        </eOperations>
        <eOperations name="isDescendant" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//Boolean">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="// Checks if the given contract is a descendant of the given interface_&#xA;&#xA;boolean matched = false;&#xA;ClassifierList descendants = contract.general;&#xA;int i = 1;&#xA;while (i &lt;= descendants.size() &amp; !matched) {&#xA;if (descendants.getValue(i - 1) instanceof Interface) {&#xA;&#x9;Interface descendant = (Interface) descendants.getValue(i - 1);&#xA;&#x9;if (descendant == interface_) {&#xA;&#x9;&#x9;matched = true;&#xA;&#x9;} else {&#xA;&#x9;&#x9;matched = this.isDescendant(descendant, interface_);&#xA;&#x9;}&#xA;}&#xA;i = i + 1;&#xA;}&#xA;return matched;&#xA;"/>
          </eAnnotations>
          <eParameters name="contact" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Interface"/>
          <eParameters name="interface_" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Interface"/>
        </eOperations>
        <eOperations name="realizesInterface" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//Boolean">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="// Checks if the given type has an InterfaceRealization relationship&#xA;// with the given interface or a descendant of the interface.&#xA;&#xA;InterfaceRealizationList realizations = type.interfaceRealization;&#xA;boolean realized = false;&#xA;int i = 1;&#xA;while (i &lt;= realizations.size() &amp; !realized) {&#xA;InterfaceRealization realization = realizations.getValue(i - 1);&#xA;Interface contract = realization.contract;&#xA;if (contract == interface_) {&#xA;&#x9;realized = true;&#xA;} else if (this.isDescendant(contract, interface_)) {&#xA;&#x9;realized = true;&#xA;}&#xA;i = i + 1;&#xA;}&#xA;return realized;"/>
          </eAnnotations>
          <eParameters name="type" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class"/>
          <eParameters name="interface_" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Interface"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_InteractionPoint">
        <eOperations name="startBehavior" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="// Overriden to do nothing&#xA;"/>
          </eAnnotations>
          <eParameters name="classifier" ordered="false" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class"/>
          <eParameters name="inputs" ordered="false" upperBound="-1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
        </eOperations>
        <eOperations name="dispatch" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Delegates dispatching to the owning object&#xA;&#x9;return this.owner.dispatchIn(operation, this) ;"/>
          </eAnnotations>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
        </eOperations>
        <eOperations name="send" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="// An event occurrence that passes through a CS_InteractionPoint is&#xA;// (if necessary) wrapped in a CS_EventOccurrence. This event occurrence&#xA;// is then sent to the owning object.&#xA;&#xA;CS_EventOccurrence wrappingEventOccurrence = null;&#xA;if(eventOccurrence instanceof CS_EventOccurrence){&#xA;wrappingEventOccurrence = (CS_EventOccurrence) eventOccurrence; &#xA;}else{&#xA;wrappingEventOccurrence = new CS_EventOccurrence();&#xA;wrappingEventOccurrence.wrappedEventOccurrence = eventOccurrence;&#xA;}&#xA;wrappingEventOccurrence.interactionPoint = this;&#xA;this.owner.sendIn(wrappingEventOccurrence, this);&#xA;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
        </eOperations>
        <eOperations name="checkAllParents" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//Boolean">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="// Delegates the type checking to the reference&#xA;&#xA;return this.referent.checkAllParents(type, classifier);&#xA;"/>
          </eAnnotations>
          <eParameters name="type" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Classifier"/>
          <eParameters name="classifier" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Classifier"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="owner" ordered="false"
            lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Reference"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="definingPort" ordered="false"
            lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_Reference">
        <eOperations name="copy" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="// Create a new reference with the same referent and composite referent as this reference.&#xA;CS_Reference newValue = new CS_Reference();&#xA;newValue.referent = this.referent;&#xA;newValue.compositeReferent = this.compositeReferent;&#xA;return newValue;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="dispatchIn" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;//Delegates dispatching to composite referent&#xA;&#x9;return this.compositeReferent.dispatchIn(operation, interactionPoint) ;&#xA;"/>
          </eAnnotations>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
          <eParameters name="interactionPoint" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
        </eOperations>
        <eOperations name="sendIn" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="// delegates sending to composite referent&#xA;&#xA;this.compositeReferent.sendIn(eventOccurrence, interactionPoint);"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
          <eParameters name="interactionPoint" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
        </eOperations>
        <eOperations name="sendOut" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="// delegates sending to composite referent&#xA;&#xA;this.compositeReferent.sendOut(eventOccurrence, onPort); &#xA;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
          <eParameters name="onPort" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
        </eOperations>
        <eOperations name="dispatchOut" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// delegates dispatching to composite referent&#xA;&#x9;return this.compositeReferent.dispatchOut(operation, onPort) ;"/>
          </eAnnotations>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
          <eParameters name="onPort" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
        </eOperations>
        <eOperations name="dispatchIn" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// delegates dispatching to composite referent&#xA;&#x9;return this.compositeReferent.dispatchIn(operation, onPort) ;"/>
          </eAnnotations>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
          <eParameters name="onPort" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
        </eOperations>
        <eOperations name="sendIn" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="// delegates sending to composite referent&#xA;&#xA;this.compositeReferent.sendIn(eventOccurrence, onPort);"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
          <eParameters name="onPort" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
        </eOperations>
        <eOperations name="dispatchOut" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Delegates dispatching (through the interaction point, to the environment) &#xA;&#x9;// to compositeReferent&#xA;&#x9;return this.compositeReferent.dispatchOut(operation, interactionPoint) ;"/>
          </eAnnotations>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
          <eParameters name="interactionPoint" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
        </eOperations>
        <eOperations name="sendOut" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="// Delegates sending (through the interaction point, to the environment)&#xA;// to compositeReferent&#xA;&#xA;this.compositeReferent.sendOut(eventOccurrence, interactionPoint); "/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
          <eParameters name="interactionPoint" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="compositeReferent"
            ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Object"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EEnum" name="CS_LinkKind">
        <eLiterals name="ToEnvironment"/>
        <eLiterals name="ToInternal" value="1"/>
        <eLiterals name="None" value="2"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_RequestPropagationStrategy" abstract="true">
        <eOperations name="getName" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//String">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// a CS_RequestPropagationStrategy are always named &quot;requestPropagation&quot;&#xA;&#x9;return &quot;requestPropagation&quot;;&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="select" ordered="false" upperBound="-1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eParameters name="potentialTargets" ordered="false" upperBound="-1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
          <eParameters name="context" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_DefaultRequestPropagationStrategy"
          eSuperTypes="#//Semantics/StructuredClassifiers/CS_RequestPropagationStrategy"/>
      <eClassifiers xsi:type="ecore:EClass" name="CS_Link">
        <eOperations name="hasValueForAFeature" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//Boolean">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Returns true if the given value object is used as a value for a FeatureValue of this link&#xA;&#x9;FeatureValueList allFeatureValues = this.getFeatureValues() ;&#xA;&#x9;Integer i = 1 ;&#xA;&#x9;boolean isAValue = false ;&#xA;&#x9;while (i &lt;= allFeatureValues.size() &amp;&amp; !isAValue) {&#xA;&#x9;&#x9;FeatureValue featureValue = allFeatureValues.getValue(i-1);&#xA;&#x9;&#x9;isAValue = !featureValue.values.isEmpty() &amp;&amp; featureValue.values.getValue(0).equals(value) ;&#xA;&#x9;&#x9;i = i + 1 ;&#xA;&#x9;}&#xA;&#x9;return isAValue ;&#xA;"/>
          </eAnnotations>
          <eParameters name="value" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
        </eOperations>
        <eOperations name="getFeature" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//StructuralFeature">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="FeatureValueList allFeatureValues = this.getFeatureValues() ;&#xA;&#x9;Integer i = 1 ;&#xA;&#x9;StructuralFeature feature = null ;&#xA;&#x9;while (i &lt;= allFeatureValues.size() &amp;&amp; feature == null) {&#xA;&#x9;&#x9;FeatureValue featureValue = allFeatureValues.get(i-1);&#xA;&#x9;&#x9;if (!featureValue.values.isEmpty() &amp;&amp; featureValue.values.get(0).equals(value)) {&#xA;&#x9;&#x9;&#x9;feature = featureValue.feature ;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;i = i + 1 ;&#xA;&#x9;}&#xA;&#x9;return feature ;"/>
          </eAnnotations>
          <eParameters name="value" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
        </eOperations>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="Loci" nsURI="http:///PSCS_Semantics/Semantics/Loci.ecore"
        nsPrefix="PSCS_Semantics.Semantics.Loci">
      <eClassifiers xsi:type="ecore:EClass" name="CS_Locus">
        <eOperations name="instantiate" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Extends fUML semantics by instantiating a CS_Object&#xA;&#x9;// in the case where type is not a Behavior.&#xA;&#x9;// Otherwise behaves like in fUML&#xA;&#xA;&#x9;Object_ object = null;&#xA;&#xA;&#x9;if (type instanceof Behavior) {&#xA;&#x9;&#x9;object = super.instantiate(type);&#xA;&#x9;} else {&#xA;&#x9;&#x9;object = new CS_Object() ;&#xA;&#x9;&#x9;object.types.addValue(type);&#xA;&#x9;&#x9;object.createFeatureValues();&#xA;&#x9;&#x9;this.add(object);&#xA;&#x9;}&#xA;&#xA;&#x9;return object;"/>
          </eAnnotations>
          <eParameters name="type" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_ExecutionFactory">
        <eOperations name="instantiateVisitor" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Extends fUML semantics in the sense that newly introduced &#xA;&#x9;// semantic visitors are instantiated instead of fUML visitors&#xA;&#xA;&#x9;// Extends fUML semantics in the sense that newly introduced &#xA;&#x9;// semantic visitors are instantiated instead of fUML visitors&#xA;&#xA;&#x9;SemanticVisitor visitor = null ;&#xA;&#x9;if (element instanceof ReadExtentAction) {&#xA;&#x9;&#x9;visitor =new CS_ReadExtentActionActivation() ;&#xA;&#x9;}&#xA;&#x9;else if (element instanceof AddStructuralFeatureValueAction) {&#xA;&#x9;&#x9;visitor = new CS_AddStructuralFeatureValueActionActivation() ;&#xA;&#x9;}&#xA;&#x9;else if (element instanceof ClearStructuralFeatureAction) {&#xA;&#x9;&#x9;visitor = new CS_ClearStructuralFeatureValueActionActivation() ;&#xA;&#x9;}&#xA;&#x9;else if (element instanceof CreateLinkAction) {&#xA;&#x9;&#x9;visitor = new CS_CreateLinkActionActivation() ;&#xA;&#x9;}&#xA;&#x9;else if (element instanceof CreateObjectAction) {&#xA;&#x9;&#x9;visitor = new CS_CreateObjectActionActivation() ;&#xA;&#x9;}&#xA;&#x9;else if (element instanceof ReadSelfAction) {&#xA;&#x9;&#x9;visitor = new CS_ReadSelfActionActivation() ;&#xA;&#x9;}&#xA;&#x9;else if (element instanceof AcceptCallAction) {&#xA;&#x9;&#x9;visitor = new CS_AcceptCallActionActivation();&#xA;&#x9;}&#xA;&#x9;else if (element instanceof InstanceValue) {&#xA;&#x9;&#x9;visitor = new CS_InstanceValueEvaluation() ;&#xA;&#x9;}&#xA;&#x9;else if (element instanceof AcceptEventAction) {&#xA;&#x9;&#x9;visitor = new CS_AcceptEventActionActivation() ;&#xA;&#x9;}&#xA;&#x9;else if (element instanceof CallOperationAction) {&#xA;&#x9;&#x9;visitor = new CS_CallOperationActionActivation() ;&#xA;&#x9;}&#xA;&#x9;else if (element instanceof SendSignalAction) {&#xA;&#x9;&#x9;visitor = new CS_SendSignalActionActivation() ;&#xA;&#x9;}&#xA;&#x9;else if (element instanceof OpaqueExpression) {&#xA;&#x9;&#x9;visitor = new CS_OpaqueExpressionEvaluation() ;&#xA;&#x9;}&#xA;&#x9;else if (element instanceof CallEventBehavior) {&#xA;&#x9;&#x9;visitor = new CS_CallEventExecution();&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;visitor = super.instantiateVisitor(element) ;&#xA;&#x9;}&#xA;&#x9;return visitor ;"/>
          </eAnnotations>
          <eParameters name="element" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Element"/>
        </eOperations>
        <eOperations name="getStereotypeClass" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class">
          <eParameters name="profileName" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//String"/>
          <eParameters name="stereotypeName" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//String"/>
        </eOperations>
        <eOperations name="getStereotypeApplication" ordered="false" lowerBound="1"
            eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eParameters name="stereotype" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class"/>
          <eParameters name="element" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Element"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="appliedProfiles" ordered="false"
            upperBound="-1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Package"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_Executor">
        <eOperations name="start" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Instantiate the given class and start any behavior of the resulting&#xA;&#x9;// object.&#xA;&#x9;// (The behavior of an object includes any classifier behaviors for an&#xA;&#x9;// active object or the class of the object itself, if that is a&#xA;&#x9;// behavior.)&#xA;&#x9;// fUML semantics is extended in the sense that when the instantiated object&#xA;&#x9;// is a CS_Object, a CS_Reference is returned (instead of a Reference)&#xA;&#xA;&#x9;Debug.println(&quot;[start] Starting &quot; + type.name + &quot;...&quot;);&#xA;&#xA;&#x9;Object_ object = this.locus.instantiate(type);&#xA;&#xA;&#x9;Debug.println(&quot;[start] Object = &quot; + object);&#xA;&#x9;object.startBehavior(type, inputs);&#xA;&#xA;&#x9;Reference reference ;&#xA;&#x9;if (object instanceof CS_Object) {&#xA;&#x9;&#x9;reference = new CS_Reference();&#xA;&#x9;&#x9;((CS_Reference)reference).compositeReferent = (CS_Object)object ;&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;reference = new Reference() ;&#xA;&#x9;}&#xA;&#x9;reference.referent = object;&#xA;&#xA;&#x9;return reference;&#xA;"/>
          </eAnnotations>
          <eParameters name="type" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class"/>
          <eParameters name="inputs" ordered="false" upperBound="-1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
        </eOperations>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="CommonBehavior" nsURI="http:///PSCS_Semantics/Semantics/CommonBehavior.ecore"
        nsPrefix="PSCS_Semantics.Semantics.CommonBehavior">
      <eClassifiers xsi:type="ecore:EClass" name="CS_CallEventExecution">
        <eOperations name="copy" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="// Create a new call event execution that is a copy of this execution with no&#xA;// referenced interaction point.&#xA;&#xA;CS_CallEventExecution copy = (CS_CallEventExecution) super.copy();&#xA;copy.interactionPoint = null;&#xA;&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="createEventOccurrence" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="/ Wrap the created event occurrence within a CS_EventOccurrence which&#xA;// references the behavior port on which the call was dispatched.&#xA;&#xA;CS_EventOccurrence wrappingEventOccurrence = new CS_EventOccurrence();&#xA;wrappingEventOccurrence.interactionPoint = this.interactionPoint;&#xA;wrappingEventOccurrence.wrappedEventOccurrence = super.createEventOccurrence();&#xA;return wrappingEventOccurrence;&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="new_" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="// Create a new call event execution.&#xA;&#xA;return new CS_CallEventExecution();&#xA;&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="interactionPoint" ordered="false"
            eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_EventOccurrence">
        <eOperations name="getParameterValues" ordered="false" upperBound="-1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="// Return the parametric data of the referenced event occurrence&#xA;&#xA;return this.wrappedEventOccurrence.getParameterValues();"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="match" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//Boolean">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&lt;&lt;TextualRepresentation>> public boolean match(Trigger trigger) {&#xA;// If the trigger references ports then to match this latter it is required that &#xA;// 1] the interaction point is instance of port referenced by the trigger&#xA;// 2] the referenced event occurrence match operation returns true.&#xA;// If the trigger does not reference ports then the behavior is the same than for fUML.&#xA;&#xA;boolean matches = false;&#xA;if(trigger.port.size() > 0){&#xA;&#x9;int i = 1;&#xA;&#x9;while(!matches &amp; i &lt;= trigger.port.size()){&#xA;&#x9;&#x9;if(this.interactionPoint.definingPort==trigger.port.get(i-1)){&#xA;&#x9;&#x9;&#x9;matches = true;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;i++;&#xA;&#x9;}&#xA;&#x9;if(matches){&#xA;&#x9;&#x9;matches = this.wrappedEventOccurrence.match(trigger);&#xA;&#x9;}&#xA;}else{&#xA;&#x9;matches = this.wrappedEventOccurrence.match(trigger);&#xA;}&#xA;return matches;&#xA;}&#xA;"/>
          </eAnnotations>
          <eParameters name="trigger" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Trigger"/>
        </eOperations>
        <eOperations name="doSend" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="// If the specified target is a CS_Reference and the propagation must be done&#xA;// to the environment, then the operation sendOut(EventOccurrence, Port) is called&#xA;// and make the propagation to continue.&#xA;// If the specified target is a CS_Reference but the propagation must be done to&#xA;// the internals then the operation sendIn(EventOccurrence, Port) is called.&#xA;// In the case were the target is not a CS_EventOccurrence then send(EventOccurence)&#xA;// is called.&#xA;&#xA;if(this.target instanceof CS_Reference){&#xA;if(this.propagationInward == true){&#xA;&#x9;((CS_Reference)this.target).sendIn(this, this.onPort);&#xA;&#x9;}else{&#xA;&#x9;&#x9;((CS_Reference)this.target).sendOut(this, this.onPort);&#xA;&#x9;}&#xA;}else{&#xA;&#x9;super.doSend();&#xA;}&#xA;}&#xA;&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="sendInTo" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="// Propagate the sending of the event occurrence to the internals&#xA;&#xA;this.onPort = port;&#xA;this.propagationInward = true;&#xA;this.sendTo(target);"/>
          </eAnnotations>
          <eParameters name="target" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Reference"/>
          <eParameters name="port" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
        </eOperations>
        <eOperations name="sendOutTo" ordered="false" lowerBound="1">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="// Propagate the sending of the event occurrence to the environment&#xA;&#xA;this.onPort = port;&#xA;this.propagationInward = false;&#xA;this.sendTo(target);&#xA;"/>
          </eAnnotations>
          <eParameters name="target" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Reference"/>
          <eParameters name="port" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="interactionPoint" ordered="false"
            eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="wrappedEventOccurrence"
            ordered="false" eType="ecore:EClass ../../fuml/model/fUML.ecore#//EventOccurrence"/>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="propagationInward"
            ordered="false" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//Boolean"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="onPort" ordered="false"
            eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="Values" nsURI="http:///PSCS_Semantics/Semantics/Values.ecore"
        nsPrefix="PSCS_Semantics.Semantics.Values">
      <eClassifiers xsi:type="ecore:EClass" name="CS_OpaqueExpressionEvaluation">
        <eOperations name="evaluate" ordered="false" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// Execute the behavior associated with the context OpaqueExpression, if any.&#xA;&#x9;// If multiple return values are computed, then return the first one.&#xA;&#x9;// If no value are computed, return null&#xA;&#x9;ValueList evaluation = this.executeExpressionBehavior() ;&#xA;&#x9;if (evaluation.size() > 0) {&#xA;&#x9;&#x9;return evaluation.get(0) ;&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;return null ;&#xA;&#x9;}"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="executeExpressionBehavior" ordered="false" upperBound="-1"
            eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// If a behavior is associated with the context OpaqueExpression,&#xA;&#x9;// then execute this behavior, and return computed values.&#xA;&#x9;// Otherwise, return an empty list of values.&#xA;&#x9;ValueList evaluation = new ValueList() ;&#xA;&#x9;OpaqueExpression expression = (OpaqueExpression)this.specification ;&#xA;&#x9;Behavior behavior = expression.behavior ;&#xA;&#x9;if (behavior != null) {&#xA;&#x9;&#x9;ParameterValueList inputs = new ParameterValueList() ;&#xA;&#x9;&#x9;ParameterValueList results = this.locus.executor.execute(behavior, null, inputs) ;&#xA;&#x9;&#x9;for (int i = 0 ; i &lt; results.size() ; i++) { // results.size should be 1&#xA;&#x9;&#x9;&#x9;ParameterValue parameterValue = results.get(i) ;&#xA;&#x9;&#x9;&#x9;ValueList values = parameterValue.values ;&#xA;&#x9;&#x9;&#x9;for (int j = 0 ; j &lt; values.size() ; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;evaluation.add(values.get(j)) ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return evaluation ;"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="Classification" nsURI="http:///PSCS_Semantics/Semantics/Classification.ecore"
        nsPrefix="PSCS_Semantics.Semantics.Classification">
      <eClassifiers xsi:type="ecore:EClass" name="CS_InstanceValueEvaluation">
        <eOperations name="evaluate" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
            <details key="body" value="&#x9;&#x9;// If the instance specification is for an enumeration, then return the&#xA;&#x9;// identified enumeration literal.&#xA;&#x9;// If the instance specification is for a data type (but not a primitive&#xA;&#x9;// value or an enumeration), then create a data value of the given data&#xA;&#x9;// type.&#xA;&#x9;// If the instance specification is for an object, then create an object&#xA;&#x9;// at the current locus with the specified types.&#xA;&#x9;// Set each feature of the created value to the result of evaluating the&#xA;&#x9;// value specifications for the specified slot for the feature.&#xA;&#x9;// Extends fUML semantics in the sense that when the instance specification&#xA;&#x9;// is for an object which is not typed by a Behaviore, A CS_Reference (to a &#xA;&#x9;// CS_Object) is produced instead of a Reference (to an Object)&#xA;&#xA;&#x9;// Debug.println(&quot;[evaluate] InstanceValueEvaluation...&quot;);&#xA;&#xA;&#x9;InstanceSpecification instance = ((InstanceValue) this.specification).instance;&#xA;&#x9;ClassifierList types = instance.classifier;&#xA;&#x9;Classifier myType = types.getValue(0);&#xA;&#xA;&#x9;Debug.println(&quot;[evaluate] type = &quot; + myType.name);&#xA;&#xA;&#x9;Value value;&#xA;&#x9;if (instance instanceof EnumerationLiteral) {&#xA;&#x9;&#x9;// Debug.println(&quot;[evaluate] Type is an enumeration.&quot;);&#xA;&#x9;&#x9;EnumerationValue enumerationValue = new EnumerationValue();&#xA;&#x9;&#x9;enumerationValue.type = (Enumeration) myType;&#xA;&#x9;&#x9;enumerationValue.literal = (EnumerationLiteral) instance;&#xA;&#x9;&#x9;value = enumerationValue;&#xA;&#x9;} &#xA;&#x9;else {&#xA;&#x9;&#x9;StructuredValue structuredValue = null;&#xA;&#xA;&#x9;&#x9;if (myType instanceof DataType) {&#xA;&#x9;&#x9;&#x9;// Debug.println(&quot;[evaluate] Type is a data type.&quot;);&#xA;&#x9;&#x9;&#x9;DataValue dataValue = new DataValue();&#xA;&#x9;&#x9;&#x9;dataValue.type = (DataType) myType;&#xA;&#x9;&#x9;&#x9;structuredValue = dataValue;&#xA;&#x9;&#x9;} &#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;Object_ object = null;&#xA;&#x9;&#x9;&#x9;if (myType instanceof Behavior) {&#xA;&#x9;&#x9;&#x9;&#x9;// Debug.println(&quot;[evaluate] Type is a behavior.&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;object = this.locus.factory.createExecution(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;(Behavior) myType, null);&#xA;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;// Debug.println(&quot;[evaluate] Type is a class.&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;object = new CS_Object();&#xA;&#x9;&#x9;&#x9;&#x9;for (int i = 0; i &lt; types.size(); i++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Classifier type = types.getValue(i);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;object.types.addValue((Class_) type);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;this.locus.add(object);&#xA;&#xA;&#x9;&#x9;&#x9;Reference reference ;&#xA;&#x9;&#x9;&#x9;if (object instanceof CS_Object) {&#xA;&#x9;&#x9;&#x9;&#x9;reference = new CS_Reference();&#xA;&#x9;&#x9;&#x9;&#x9;((CS_Reference)reference).compositeReferent = (CS_Object)object ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;reference = new Reference() ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;reference.referent = object;&#xA;&#x9;&#x9;&#x9;structuredValue = reference;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;structuredValue.createFeatureValues();&#xA;&#xA;&#x9;&#x9;// Debug.println(&quot;[evaluate] &quot; + instance.slot.size() +&#xA;&#x9;&#x9;// &quot; slot(s).&quot;);&#xA;&#xA;&#x9;&#x9;SlotList instanceSlots = instance.slot;&#xA;&#x9;&#x9;for (int i = 0; i &lt; instanceSlots.size(); i++) {&#xA;&#x9;&#x9;&#x9;Slot slot = instanceSlots.getValue(i);&#xA;&#x9;&#x9;&#x9;ValueList values = new ValueList();&#xA;&#xA;&#x9;&#x9;&#x9;// Debug.println(&quot;[evaluate] feature = &quot; +&#xA;&#x9;&#x9;&#x9;// slot.definingFeature.name + &quot;, &quot; + slot.value.size() +&#xA;&#x9;&#x9;&#x9;// &quot; value(s).&quot;);&#xA;&#x9;&#x9;&#x9;ValueSpecificationList slotValues = slot.value;&#xA;&#x9;&#x9;&#x9;for (int j = 0; j &lt; slotValues.size(); j++) {&#xA;&#x9;&#x9;&#x9;&#x9;ValueSpecification slotValue = slotValues.getValue(j);&#xA;&#x9;&#x9;&#x9;&#x9;// Debug.println(&quot;[evaluate] Value = &quot; +&#xA;&#x9;&#x9;&#x9;&#x9;// slotValue.getClass().getName());&#xA;&#x9;&#x9;&#x9;&#x9;values.addValue(this.locus.executor.evaluate(slotValue));&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;structuredValue.setFeatureValue(slot.definingFeature, values, 0);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;value = structuredValue;&#xA;&#x9;}&#xA;&#xA;&#x9;return value;"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
    </eSubpackages>
  </eSubpackages>
</ecore:EPackage>
