//********************************************************************
//*    
//* Warning: This file was generated by ecore4CPP Generator
//*
//********************************************************************

#ifndef UML_OBJECTNODEOBJECTNODEIMPL_HPP
#define UML_OBJECTNODEOBJECTNODEIMPL_HPP

//*********************************
// generated Includes

// namespace macro header include
#include "uml/uml.hpp" 

// model includes
#include "../ObjectNode.hpp"

#include "uml/impl/ActivityNodeImpl.hpp"
#include "uml/impl/TypedElementImpl.hpp"

//*********************************
namespace uml 
{
	class UML_API ObjectNodeImpl : virtual public ActivityNodeImpl, virtual public TypedElementImpl, virtual public ObjectNode 
	{
		public: 
			ObjectNodeImpl(const ObjectNodeImpl & obj);
			virtual std::shared_ptr<ecore::EObject> copy() const = 0;
			ObjectNodeImpl& operator=(ObjectNodeImpl const&); 

		protected:
			friend class umlFactoryImpl;
			ObjectNodeImpl();
			virtual std::shared_ptr<uml::ObjectNode> getThisObjectNodePtr() const;
			virtual void setThisObjectNodePtr(std::weak_ptr<uml::ObjectNode> thisObjectNodePtr);

			//Additional constructors for the containments back reference
			ObjectNodeImpl(std::weak_ptr<uml::Activity> par_activity);
			//Additional constructors for the containments back reference
			ObjectNodeImpl(std::weak_ptr<uml::StructuredActivityNode> par_inStructuredNode);
			//Additional constructors for the containments back reference
			ObjectNodeImpl(std::weak_ptr<uml::Namespace> par_namespace);
			//Additional constructors for the containments back reference
			ObjectNodeImpl(std::weak_ptr<uml::Element> par_owner);

		public:
			//destructor
			virtual ~ObjectNodeImpl() = 0;
			
			//*********************************
			// Operations
			//*********************************
			
			//*********************************
			// Attribute Getters & Setters
			//*********************************
			/*!
			Indicates whether the type of the ObjectNode is to be treated as representing control values that may traverse ControlFlows.
			<p>From package UML::Activities.</p>
			*/
			 
			virtual bool getIsControlType() const ;
			/*!
			Indicates whether the type of the ObjectNode is to be treated as representing control values that may traverse ControlFlows.
			<p>From package UML::Activities.</p>
			*/
			 
			virtual void setIsControlType (bool _isControlType);
			/*!
			Indicates how the tokens held by the ObjectNode are ordered for selection to traverse ActivityEdges outgoing from the ObjectNode.
			<p>From package UML::Activities.</p>
			*/
			 
			virtual uml::ObjectNodeOrderingKind getOrdering() const ;
			/*!
			Indicates how the tokens held by the ObjectNode are ordered for selection to traverse ActivityEdges outgoing from the ObjectNode.
			<p>From package UML::Activities.</p>
			*/
			 
			virtual void setOrdering (uml::ObjectNodeOrderingKind _ordering);
			
			//*********************************
			// Reference Getters & Setters
			//*********************************
			/*!
			The States required to be associated with the values held by tokens on this ObjectNode.
			<p>From package UML::Activities.</p>
			*/
			
			virtual const std::shared_ptr<Bag<uml::State>>& getInState() const ;
			/*!
			A Behavior used to select tokens to be offered on outgoing ActivityEdges.
			<p>From package UML::Activities.</p>
			*/
			
			virtual const std::shared_ptr<uml::Behavior>& getSelection() const ;
			/*!
			A Behavior used to select tokens to be offered on outgoing ActivityEdges.
			<p>From package UML::Activities.</p>
			*/
			
			virtual void setSelection(const std::shared_ptr<uml::Behavior>&) ;
			/*!
			The maximum number of tokens that may be held by this ObjectNode. Tokens cannot flow into the ObjectNode if the upperBound is reached. If no upperBound is specified, then there is no limit on how many tokens the ObjectNode can hold.
			<p>From package UML::Activities.</p>
			*/
			
			virtual const std::shared_ptr<uml::ValueSpecification>& getUpperBound() const ;
			/*!
			The maximum number of tokens that may be held by this ObjectNode. Tokens cannot flow into the ObjectNode if the upperBound is reached. If no upperBound is specified, then there is no limit on how many tokens the ObjectNode can hold.
			<p>From package UML::Activities.</p>
			*/
			
			virtual void setUpperBound(const std::shared_ptr<uml::ValueSpecification>&) ;
			
			//*********************************
			// Union Reference Getters
			//*********************************
			
			//*********************************
			// Container Getter
			//*********************************
			virtual std::shared_ptr<ecore::EObject> eContainer() const ; 

			//*********************************
			// Persistence Functions
			//*********************************
			virtual void load(std::shared_ptr<persistence::interfaces::XLoadHandler> loadHandler) ;
			virtual void loadAttributes(std::shared_ptr<persistence::interfaces::XLoadHandler> loadHandler, std::map<std::string, std::string> attr_list);
			virtual void loadNode(std::string nodeName, std::shared_ptr<persistence::interfaces::XLoadHandler> loadHandler);
			virtual void resolveReferences(const int featureID, std::vector<std::shared_ptr<ecore::EObject> > references) ;
			virtual void save(std::shared_ptr<persistence::interfaces::XSaveHandler> saveHandler) const ;
			virtual void saveContent(std::shared_ptr<persistence::interfaces::XSaveHandler> saveHandler) const;

		protected:
			virtual const std::shared_ptr<ecore::EClass>& eStaticClass() const;

			//*********************************
			// EStructuralFeature Get/Set/IsSet
			//*********************************
			virtual std::shared_ptr<Any> eGet(int featureID, bool resolve, bool coreType) const ;
			virtual bool eSet(int featureID, const std::shared_ptr<Any>& newValue) ;
			virtual bool internalEIsSet(int featureID) const ;

			//*********************************
			// EOperation Invoke
			//*********************************
			virtual std::shared_ptr<Any> eInvoke(int operationID,const std::shared_ptr<Bag<Any>>& arguments) ;

		private:
			std::weak_ptr<uml::ObjectNode> m_thisObjectNodePtr;
	};
}
#endif /* end of include guard: UML_OBJECTNODEOBJECTNODEIMPL_HPP */
