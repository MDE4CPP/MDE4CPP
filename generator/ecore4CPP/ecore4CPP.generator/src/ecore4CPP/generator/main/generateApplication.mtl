[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */]
[module generateApplication('http://www.eclipse.org/emf/2002/Ecore')]

[import ecore4CPP::generator::main::generateEClass /]
[import ecore4CPP::generator::main::generateBuildFile /]
[import ecore4CPP::generator::main::generateProjectFiles /]
[import ecore4CPP::generator::main::generateType /]
[import ecore4CPP::generator::main::helper /]
[import ecore4CPP::generator::main::validation::validation /]
[import ecore4CPP::generator::main::helpers::keywords /]

[template public generateApplication(aPackage : EPackage) { 
	packageName : String = aPackage.name; 
	fileName : String = '../application/src/main.cpp';
}]
[printInfo(fileGenerationMessage(fileName, 'main application source file'), 2)/]
[comment ------------------------------------------------------------------- /]
[comment generate main method of application                                 /]
[comment ------------------------------------------------------------------- /]
[file (fileName, false, 'UTF-8')]

#include <iostream>

#include "abstractDataTypes/SubsetUnion.hpp"
#include "[aPackage.name/]/[packageName/]Factory.hpp"
#include "[aPackage.name/]/[packageName/]Package.hpp"

[for (aEClass : EClass | aPackage.eAllContents(EClass)->reject(doNotGenerateEClassifier()))]
#include "[aPackage.name/]/[aEClass.name.toUpperFirst()/].hpp"
[/for]
[for (anEEnum : EEnum | aPackage.eAllContents(EEnum)->reject(doNotGenerateEClassifier()))]
#include "[aPackage.name/]/[anEEnum.name/].hpp"
[/for]

[if (hasMainSourceIncludes())]
[getMainSourceIncludes()/]

[/if]
// [protected ('includes')] 
// You may manually edit additional includes, won't be overwritten upon generation.

// [/protected]

using namespace [packageName/];

// [protected ('functions')] 
// You may manually edit additional functions, won't be overwritten upon generation.

// [/protected]

int main ()
{
	//Create Model Factory
	std::shared_ptr<[packageName/]Factory> factory = [packageName/]Factory::eInstance();

[if (hasMainSourceCode())]
[getMainSourceCode()/]

[/if]
// [protected ('main')]
// You may manually edit the following lines, won't be overwritten upon generation.

// [/protected]

    return 0;

}
[/file]

[comment ------------------------------------------------------------------- /]
[comment CMakeLists.txt file for application build                           /]
[comment ------------------------------------------------------------------- /]
[file ('../application/src/CMakeLists.txt', false, 'UTF-8')]
# DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN
# @generator: ecore4cpp::generator::main::generateApplication

# C++ project of application for [packageName/].ecore, generated by UML4CPP

CMAKE_MINIMUM_REQUIRED(VERSION 3.9)

# [protected ('project_name')]
# You may manually edit the project name, won't be overwritten upon generation.
PROJECT(App_[packageName/])
# [/protected]

IF(NOT CMAKE_BUILD_TYPE) 
    SET(CMAKE_BUILD_TYPE Debug)
ENDIF(NOT CMAKE_BUILD_TYPE)

SET(CMAKE_CXX_STANDARD 17)

[comment IF("${CMAKE_CXX_COMPILER_ID}" STREQUAL "AppleClang") -> not necessary after removing openmp/]
SET(CMAKE_CXX_FLAGS "-Wall -Wno-overloaded-virtual -Wdeprecated-declarations -fmax-errors=5")
IF(APPLE)
  string(APPEND CMAKE_CXX_FLAGS " -Qunused-arguments")
ENDIF(APPLE)
SET(CMAKE_CXX_FLAGS_DEBUG " -Og -ggdb -DACTIVITY_DEBUG_ON")
[if (packageName='uml')]
SET(CMAKE_CXX_FLAGS_RELEASE " -O1 -DNDEBUG")
[else]
SET(CMAKE_CXX_FLAGS_RELEASE " -O3 -DNDEBUG")
[/if]
[if hasCreateApiFlag()]
SET(BOOST_ROOT ${BOOST_ROOT})
[/if]

string(REPLACE "\\" "/" MDE4CPP_HOME $ENV{MDE4CPP_HOME})

SET(SOURCE_FILES
	main.cpp
# [protected ('cpp')]
# You may manually edit the following lines, won't be overwritten upon generation.

# [/protected]
)

[if hasCreateApiFlag()]
FIND_PACKAGE(Boost)
IF(NOT Boost_FOUND)
    	MESSAGE(FATAL_ERROR "Please define BOOST_ROOT as an environment variable!")
ENDIF()
[/if]

INCLUDE_DIRECTORIES(
	../
	${MDE4CPP_HOME}/application/include
[if hasCreateApiFlag()]
    	${Boost_INCLUDE_DIRS}
[/if]
# [protected ('includes')]
# You may manually edit the following lines, won't be overwritten upon generation.

# [/protected]
)

# Apple specific stuff
IF(APPLE)
  SET(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -undefined dynamic_lookup")
  SET(CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS} -undefined dynamic_lookup")
ENDIF(APPLE)

IF(UNIX AND NOT APPLE)
    # for Linux, BSD, Solaris, Minix
	[generateCMakeFindLibraryCommands('.so', 'bin', 'Linux')/]
ELSEIF(APPLE)
	[generateCMakeFindLibraryCommands('.dylib', 'bin', 'Apple')/]
ELSE()
	[generateCMakeFindLibraryCommands('', 'lib', 'Win')/]
ENDIF()

[if hasCreateApiFlag()]
    FILE(COPY ${MDE4CPP_HOME}/src/api/swagger DESTINATION ${PROJECT_BINARY_DIR})
[/if]

ADD_EXECUTABLE(${PROJECT_NAME} ${SOURCE_FILES})
SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES DEBUG_POSTFIX "d")

IF (CMAKE_BUILD_TYPE STREQUAL "Debug")
	[generateLibraryLinking(true)/]
ELSE()
	[generateLibraryLinking(false)/]
ENDIF()

#-----------------------------------------------------
# DELIVERING binaries and header to ${MDE4CPP_HOME}
#-----------------------------------------------------

INSTALL(TARGETS ${PROJECT_NAME} 
	RUNTIME DESTINATION ${MDE4CPP_HOME}/application/bin
)
[/file]

[comment ------------------------------------------------------------------- /]
[comment gradle file for compile command of application                      /]
[comment ------------------------------------------------------------------- /]
[file ('../application/build.gradle', false, 'UTF-8')]
// DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN
// @generator: ecore::generator::main::generateApplication
import tui.sse.mde4cpp.MDE4CPPCompile;
import org.gradle.internal.os.OperatingSystem;

description 'Compile task for project: App_[packageName/]'

task compileApplicationFor[packageName.toUpperFirst()/](type: tui.sse.mde4cpp.MDE4CPPCompile) {
	group '[packageName/]'
	description 'compile ['ApplicationFor'.concat(packageName)/]'

	projectFolder = file('.' + File.separator + 'src')

	inputs.files(fileTree('.') {
        exclude 'src/.cmake/**'
    })

	if(!file('.' + File.separator + 'src' + File.separator + '.cmake' + File.separator).exists()) {
		outputs.upToDateWhen { false }
	}

	if(OperatingSystem.current().isWindows()){
		if(project.hasProperty('RELEASE') && !project.property('RELEASE').equals('0')){outputs.file file(['['/]rootDir,'application','bin','App_' + '[packageName/]' +       '.exe'[']'/].join(File.separator))}
		if(project.hasProperty('DEBUG') && !project.property('DEBUG').equals('0'))    {outputs.file file(['['/]rootDir,'application','bin','App_' + '[packageName/]' + 'd' + '.exe'[']'/].join(File.separator))}
	}
	else if(OperatingSystem.current().isLinux() || OperatingSystem.current().isMacOsX()){
		if(project.hasProperty('RELEASE') && !project.property('RELEASE').equals('0')){outputs.file file(['['/]rootDir,'application','bin','App_' + '[packageName/]'      [']'/].join(File.separator))}
		if(project.hasProperty('DEBUG') && !project.property('DEBUG').equals('0'))    {outputs.file file(['['/]rootDir,'application','bin','App_' + '[packageName/]' + 'd'[']'/].join(File.separator))}
	}

	// dependency to model '[packageName/]'
	def [packageName/] = getRootProject().getTasksByName('compile[packageName.toUpperFirst()/]', true)
	if (![packageName/].isEmpty()){
		dependsOn [packageName/]
		inputs.files([packageName/].outputs)
	}
}

task clean {
	doFirst {
		def cmakeFolder = file('.' + File.separator + 'src' + File.separator + '.cmake/')
		if(cmakeFolder.exists()) {
    		delete cmakeFolder.absolutePath
   			println "deleting folder " + cmakeFolder.absolutePath
		}
	}
}
[/file]

[aPackage.generateProjectsFiles(true)/]
[/template]

[template private generateCMakeFindLibraryCommands(aPackage : EPackage, ending : String, folderName : String, system : String)]
IF (CMAKE_BUILD_TYPE STREQUAL "Debug")
	[generateCMakeFindLibraryCommand(aPackage, ending, folderName, true, system)/]
ELSE()
	[generateCMakeFindLibraryCommand(aPackage, ending, folderName, false, system)/]
ENDIF()
[/template]

[query private libraryVariableNameSuffix(debugMode : Boolean) : String = if (debugMode) then 'DEBUG' else 'RELEASE' endif/]
[query private libraryNameSuffix(debugMode : Boolean) : String = if (debugMode) then 'd' else '' endif/]
[query private buildModeCMakeProperty(debugMode : Boolean) : String = if (debugMode) then 'debug' else 'optimized' endif/]

[template private generateCMakeFindLibraryCommand(aPackage : EPackage, ending : String, folderName : String, debugMode : Boolean, system : String)]
[for (pack : EPackage | aPackage.metaModelLibraries()->reject(doNotGenerateEPackage())->asOrderedSet()) ? (not(pack.name = aPackage.name))]
FIND_LIBRARY([pack.name.toUpperCase()/]_[libraryVariableNameSuffix(debugMode)/] [pack.name/][libraryNameSuffix(debugMode)/][ending/] ${MDE4CPP_HOME}/application/[folderName/])
[/for]
[for (libName : String | aPackage.eAnnotations->select(source = sourceNamePrepareApplication())->first().details->select(d : EStringToStringMapEntry | d.key = keyLibrary()).value)]
[if (not (libName.oclIsUndefined() or libName = ''))]
FIND_LIBRARY([libName.toUpperCase()/]_[libraryVariableNameSuffix(debugMode)/] [libName/][libraryNameSuffix(debugMode)/][ending/] ${MDE4CPP_HOME}/application/[folderName/])
[/if]
[/for]
FIND_LIBRARY([aPackage.name.toUpperCase()/]_[libraryVariableNameSuffix(debugMode)/] [aPackage.name/][libraryNameSuffix(debugMode)/][ending/] ${MDE4CPP_HOME}/application/[folderName/])
# [protected ('library_' + system + '_' + buildModeCMakeProperty(debugMode))] 
# You may manually edit the following lines, won't be overwritten upon generation.

# [/protected]
[/template]

[template private generateLibraryLinking(aPackage : EPackage, debugMode : Boolean)]
TARGET_LINK_LIBRARIES(${PROJECT_NAME}
[for (pack : EPackage | aPackage.metaModelLibraries()->reject(doNotGenerateEPackage())->asOrderedSet()) ? (not(pack.name = aPackage.name))]
	[buildModeCMakeProperty(debugMode)/] ${[pack.name.toUpperCase()/]_[libraryVariableNameSuffix(debugMode)/]}
[/for]
[for (libName : String | aPackage.eAnnotations->select(source = sourceNamePrepareApplication())->first().details->select(d : EStringToStringMapEntry | d.key = keyLibrary()).value)]
[if (not (libName.oclIsUndefined() or libName = ''))]
	[buildModeCMakeProperty(debugMode)/] ${[libName.toUpperCase()/]_[libraryVariableNameSuffix(debugMode)/]}
[/if]
[/for]
	[buildModeCMakeProperty(debugMode)/] ${[aPackage.name.toUpperCase()/]_[libraryVariableNameSuffix(debugMode)/]}

        [if hasCreateApiFlag()]
        [buildModeCMakeProperty(debugMode)/] ${Boost_LIBRARIES}
        [buildModeCMakeProperty(debugMode)/] ws2_32
        [buildModeCMakeProperty(debugMode)/] wsock32
        [/if]

	# [protected ('library_linking_' + buildModeCMakeProperty(debugMode))] 
	# You may manually edit the following lines, won't be overwritten upon generation.

	# [/protected]
)
[/template]