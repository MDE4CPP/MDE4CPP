
#include "PSSM/Semantics/StateMachines/impl/VertexActivationImpl.hpp"
#ifdef NDEBUG
	#define DEBUG_INFO(a)		/**/
	#define DEBUG_WARNING(a)	/**/
	#define DEBUG_ERROR(a)		/**/
#else
	#define DEBUG_INFO(a) 		std::cout<<"[\e[0;32mInfo\e[0m]:\t\t"<<__PRETTY_FUNCTION__<<"\n\t\t  -- Message: "<<a<<std::endl;
	#define DEBUG_WARNING(a) 	std::cout<<"[\e[0;33mWarning\e[0m]:\t"<<__PRETTY_FUNCTION__<<"\n\t\t  -- Message: "<<a<<std::endl;
	#define DEBUG_ERROR(a)		std::cout<<"[\e[0;31mError\e[0m]:\t"<<__PRETTY_FUNCTION__<<"\n\t\t  -- Message: "<<a<<std::endl;
#endif

#ifdef ACTIVITY_DEBUG_ON
    #define ACT_DEBUG(a) a
#else
    #define ACT_DEBUG(a) /**/
#endif

//#include "util/ProfileCallCount.hpp"

#include <cassert>
#include <iostream>
#include <sstream>
#include <stdexcept>
#include "abstractDataTypes/Bag.hpp"


#include "ecore/EcoreAny.hpp"
#include "ecore/EcoreContainerAny.hpp"
#include "abstractDataTypes/SubsetUnion.hpp"
#include "ecore/EAnnotation.hpp"
#include "ecore/EClass.hpp"
#include "ecore/EAttribute.hpp"
#include "ecore/EReference.hpp"
#include "ecore/EStructuralFeature.hpp"
#include "ecore/ecorePackage.hpp"
#include "ecore/ecoreFactory.hpp"
//Includes from codegen annotation
#include "PSSM/Semantics/StateMachines/TransitionMetadata.hpp"
#include "PSSM/Semantics/StateMachines/StateMetadata.hpp"
#include "PSSM/Semantics/StateMachines/StateMachineExecution.hpp"
#include "PSSM/Semantics/StateMachines/StateActivation.hpp"
//Forward declaration includes
#include "persistence/interfaces/XLoadHandler.hpp" // used for Persistence
#include "persistence/interfaces/XSaveHandler.hpp" // used for Persistence

#include <exception> // used in Persistence
#include "fUML/Semantics/Loci/LociFactory.hpp"
#include "uml/umlFactory.hpp"
#include "PSSM/Semantics/StateMachines/StateMachinesFactory.hpp"
#include "fUML/Semantics/CommonBehavior/EventOccurrence.hpp"
#include "uml/NamedElement.hpp"
#include "PSSM/Semantics/StateMachines/RegionActivation.hpp"
#include "fUML/Semantics/Loci/SemanticVisitor.hpp"
#include "PSSM/Semantics/StateMachines/StateMachineSemanticVisitor.hpp"
#include "PSSM/Semantics/StateMachines/TransitionActivation.hpp"
#include "uml/Vertex.hpp"
#include "PSSM/Semantics/StateMachines/VertexActivation.hpp"
//Factories and Package includes
#include "PSSM/Semantics/SemanticsPackage.hpp"
#include "PSSM/PSSMPackage.hpp"
#include "fUML/Semantics/CommonBehavior/CommonBehaviorPackage.hpp"
#include "fUML/Semantics/Loci/LociPackage.hpp"
#include "PSSM/Semantics/StateMachines/StateMachinesPackage.hpp"
#include "uml/umlPackage.hpp"

using namespace PSSM::Semantics::StateMachines;

//*********************************
// Constructor / Destructor
//*********************************
VertexActivationImpl::VertexActivationImpl()
{	
	/*
	NOTE: Due to virtual inheritance, base class constrcutors may not be called correctly
	*/
	//generated from codegen annotation
	this->m_incomingTransitionActivations = std::make_shared<Bag<PSSM::Semantics::StateMachines::TransitionActivation>>();
	this->m_outgoingTransitionActivations = std::make_shared<Bag<PSSM::Semantics::StateMachines::TransitionActivation>>();
}

VertexActivationImpl::~VertexActivationImpl()
{
#ifdef SHOW_DELETION
	std::cout << "-------------------------------------------------------------------------------------------------\r\ndelete VertexActivation "<< this << "\r\n------------------------------------------------------------------------ " << std::endl;
#endif
}


VertexActivationImpl::VertexActivationImpl(const VertexActivationImpl & obj): VertexActivationImpl()
{
	*this = obj;
}

VertexActivationImpl& VertexActivationImpl::operator=(const VertexActivationImpl & obj)
{
	//call overloaded =Operator for each base class
	StateMachineSemanticVisitorImpl::operator=(obj);
	/* TODO: Find out if this call is necessary
	 * Currently, this causes an error because it calls an implicit assignment operator of VertexActivation 
	 * which is generated by the compiler (as VertexActivation is an abstract class and does not have a user-defined assignment operator).
	 * Implicit compiler-generated assignment operators however only create shallow copies of members,
	 * which implies, that not a real deep copy is created when using the copy()-method.
	 * 
	 * NOTE: Since all members are deep-copied by this assignment-operator anyway, why is it even necessary to call this implicit assignment-operator?
	 * This is only done for ecore-models, not for UML-models.
	 */
	//VertexActivation::operator=(obj);

	//create copy of all Attributes
	#ifdef SHOW_COPIES
	std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\ncopy VertexActivation "<< this << "\r\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ " << std::endl;
	#endif
	//Clone Attributes with (deep copy)
	m_status = obj.getStatus();

	//copy references with no containment (soft copy)
	m_incomingTransitionActivations  = obj.getIncomingTransitionActivations();
	m_outgoingTransitionActivations  = obj.getOutgoingTransitionActivations();
	//Clone references with containment (deep copy)
	return *this;
}

//*********************************
// Operations
//*********************************
void VertexActivationImpl::addIncomingTransition(const std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation>& transitionActivation)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	this->getIncomingTransitionActivations()->add(transitionActivation);
	//end of body
}

void VertexActivationImpl::addOutgoingTransition(const std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation>& transitionActivation)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	this->getOutgoingTransitionActivations()->add(transitionActivation);
	//end of body
}

bool VertexActivationImpl::canPropagateExecution(const std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation>& enteringTransition, const std::shared_ptr<fUML::Semantics::CommonBehavior::EventOccurrence>& eventOccurrence, const std::shared_ptr<PSSM::Semantics::StateMachines::RegionActivation>& leastCommonAncestor)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	// The common behavior of all kind of vertices is that when the propagation analysis is done.
	// If a the target is a Vertex that is nested within a hierarchy, then the analysis
	// must be recursively propagated to the parent vertices.
	bool propagate = true;
	if(leastCommonAncestor != nullptr) {
		const auto& parentRegionActivation = this->getOwningRegionActivation();
		if(leastCommonAncestor != parentRegionActivation) {
			if(const auto& vertexActivation = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::VertexActivation>(parentRegionActivation->getParent())) {
				propagate = vertexActivation->canPropagateExecution(enteringTransition, eventOccurrence, leastCommonAncestor);
			}
		}
	}
	return propagate;
	//end of body
}

void VertexActivationImpl::enter(const std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation>& enteringTransition, const std::shared_ptr<fUML::Semantics::CommonBehavior::EventOccurrence>& eventOccurrence, const std::shared_ptr<PSSM::Semantics::StateMachines::RegionActivation>& leastCommonAncestor)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	// When a vertex is entered its parent may need to be entered as well. Such situation
	// occurs when the parent is not active while there is an attempt to enter the current
	// vertex activation. What is important here is that entry rule is applied recursively
	// until the least common ancestor is reached.
	const auto& owningRegionActivation = this->getOwningRegionActivation();
	if(leastCommonAncestor != nullptr && owningRegionActivation != nullptr && leastCommonAncestor != owningRegionActivation)
	{
		const auto& vertexActivation = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::VertexActivation>(owningRegionActivation->getParent());
		if(vertexActivation != nullptr)
		{
			vertexActivation->enter(enteringTransition, eventOccurrence, leastCommonAncestor);
		}
	}
	this->setStatus(PSSM::Semantics::StateMachines::StateMetadata::ACTIVE);
	DEBUG_INFO(this->getNode()->getName() << " is now ACTIVE");
	this->tagOutgoingTransition(PSSM::Semantics::StateMachines::TransitionMetadata::REACHED, false);
	//FUMLExecutionEngine.eInstance.getControlDelegate().control(this);
	//end of body
}

void VertexActivationImpl::exit(const std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation>& exitingTransition, const std::shared_ptr<fUML::Semantics::CommonBehavior::EventOccurrence>& eventOccurrence, const std::shared_ptr<PSSM::Semantics::StateMachines::RegionActivation>& leastCommonAncestor)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	// When a vertex is exited its parent may need to be exited too. Such situation typically
	// occurs when the current vertex is exited through a transition that cross boundaries of
	// the parent state (and maybe also border its own parent). This implies that from the current
	// vertex and until the least common ancestor is reached all states are exited recursively.
	this->tagIncomingTransition(PSSM::Semantics::StateMachines::TransitionMetadata::NONE, false);
	this->setStatus(PSSM::Semantics::StateMachines::StateMetadata::IDLE);
	DEBUG_INFO(this->getNode()->getName() << " is now IDLE");
	const auto& owningRegionActivation = this->getOwningRegionActivation();
	if(leastCommonAncestor != nullptr && owningRegionActivation != nullptr && leastCommonAncestor != owningRegionActivation)
	{
		const auto& vertexActivation = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::VertexActivation>(owningRegionActivation->getParent());
		if(vertexActivation != nullptr)
		{
			vertexActivation->exit(exitingTransition, eventOccurrence, leastCommonAncestor);
		}
	}
	//end of body
}

std::shared_ptr<Bag<PSSM::Semantics::StateMachines::VertexActivation>> VertexActivationImpl::getAscendingHierarchy()
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	// Provides the hierarchy of State Activations starting from the current
	// element. This list is ordered from the innermost element to the outermost element
	std::shared_ptr<Bag<PSSM::Semantics::StateMachines::VertexActivation>> hierarchy(new Bag<PSSM::Semantics::StateMachines::VertexActivation>());
	for (const auto& element : *(this->getContextChain()))
	{
		if (std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::StateActivation>(element) != nullptr) 
		{
			hierarchy->add(std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::VertexActivation>(element));
		}
	}
	return hierarchy;
	//end of body
}

std::shared_ptr<Bag<PSSM::Semantics::StateMachines::TransitionActivation>> VertexActivationImpl::getIncomingTransitions()
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	return this->m_incomingTransitionActivations;
	//end of body
}

std::shared_ptr<PSSM::Semantics::StateMachines::RegionActivation> VertexActivationImpl::getLeastCommonAncestor(const std::shared_ptr<PSSM::Semantics::StateMachines::VertexActivation>& vertexActivation)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	// Determine the semantic visitor being the least common ancestor between
	// the current vertex activation and the target vertex activation (provided as
	// a parameter). The analysis is based on a comparative analysis vertices (source and
	// target) hierarchies.
	//RegionActivation leastCommonAncestor = null;
	//SemanticVisitor sourceHierachyNode =  null;
	//SemanticVisitor targetHierarchyNode = null;
	//List<SemanticVisitor> sourceHierarchy = this.getContextChain();
	//List<SemanticVisitor> targetHierarchy = targetVertexActivation.getContextChain();
	//int sourceHierarchyIndex = sourceHierarchy.size();
	//int targetHierarchyIndex = targetHierarchy.size();
	std::shared_ptr<PSSM::Semantics::StateMachines::RegionActivation> leastCommonAncestor = nullptr;
	std::shared_ptr<fUML::Semantics::Loci::SemanticVisitor> sourceHierarchyNode = nullptr;
	std::shared_ptr<fUML::Semantics::Loci::SemanticVisitor> targetHierarchyNode = nullptr;
	std::shared_ptr<Bag<fUML::Semantics::Loci::SemanticVisitor>> sourceHierarchy = this->getContextChain();
	std::shared_ptr<Bag<fUML::Semantics::Loci::SemanticVisitor>> targetHierarchy = vertexActivation->getContextChain();
	int sourceHierarchyIndex = sourceHierarchy->size();
	int targetHierarchyIndex = targetHierarchy->size();
	// Check if a difference can be found in between the two subsets
	// delimited by the common index. Iterate until the least common
	// ancestor is found or the two subsets have been reviewed
	//while(leastCommonAncestor == null && sourceHierarchyIndex > 0 && targetHierarchyIndex > 0){
	//	sourceHierachyNode = sourceHierarchy.get(sourceHierarchyIndex - 1);
	//	targetHierarchyNode = targetHierarchy.get(targetHierarchyIndex - 1);
	//	if(sourceHierachyNode != targetHierarchyNode){
	//		leastCommonAncestor = this.getRegionActivation(sourceHierachyNode);
	//	}else{
	//		sourceHierarchyIndex = sourceHierarchyIndex - 1;
	//		targetHierarchyIndex = targetHierarchyIndex - 1;
	//	}
	//}
	while (leastCommonAncestor == nullptr && sourceHierarchyIndex > 0 && targetHierarchyIndex > 0) 
	{
		sourceHierarchyNode = sourceHierarchy->at(sourceHierarchyIndex - 1);
		targetHierarchyNode = targetHierarchy->at(targetHierarchyIndex - 1);
		if (sourceHierarchyNode != targetHierarchyNode) 
		{
			leastCommonAncestor = this->getRegionActivation(sourceHierarchyNode);
		}
		else 
		{
			sourceHierarchyIndex = sourceHierarchyIndex -1;
			targetHierarchyIndex = targetHierarchyIndex - 1;
		}
	}
	// It may happen than no difference could found in the hierarchy subsets
	// previously reviewed. This indicate two possible situations:
	// 1. The source and the target are the same.
	// 2. There is containing / container relationship existing between
	//    the source and the target.
	//if(leastCommonAncestor == null){
	//	if(sourceHierarchyIndex == 0 && targetHierarchyIndex == 0){
	//		leastCommonAncestor = this.getRegionActivation(sourceHierarchy.get(sourceHierarchyIndex + 1));
	//	}else{
	//		if(this.getVertexActivation((Vertex)targetVertexActivation.getNode()) != null){
	//			if(transitionKind == TransitionKind.EXTERNAL_LITERAL){
	//				leastCommonAncestor = this.getRegionActivation(sourceHierarchy.get(sourceHierarchyIndex));
	//			}else{
	//				leastCommonAncestor = this.getRegionActivation(targetHierarchy.get(targetHierarchyIndex - 1));
	//			}
	//		}else{
	//			leastCommonAncestor = this.getRegionActivation(sourceHierarchy.get(sourceHierarchyIndex - 1));
	//		}
	//	}
	//}
	if (leastCommonAncestor == nullptr) 
	{
		if (sourceHierarchyIndex == 0 && targetHierarchyIndex == 0) 
		{
			leastCommonAncestor = this->getRegionActivation(sourceHierarchy->at(sourceHierarchyIndex +1));
		}
		else
		{
			if (this->getVertexActivation(std::dynamic_pointer_cast<uml::Vertex>(vertexActivation->getNode())) != nullptr) 
			{
				//transitionKind ??
				leastCommonAncestor = this->getRegionActivation(sourceHierarchy->at(sourceHierarchyIndex - 1));
			}
		}
	}
	return leastCommonAncestor;
	//end of body
}

std::shared_ptr<Bag<PSSM::Semantics::StateMachines::TransitionActivation>> VertexActivationImpl::getOutgoingTransitions()
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	return this->m_outgoingTransitionActivations;
	//end of body
}

std::shared_ptr<PSSM::Semantics::StateMachines::RegionActivation> VertexActivationImpl::getOwningRegionActivation()
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	return std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::RegionActivation>(this->m_parent);
	//end of body
}

std::shared_ptr<PSSM::Semantics::StateMachines::VertexActivation> VertexActivationImpl::getParentVertexActivation()
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	// The parent state of a vertex is either a StateMachineExecution or a StateActivation
	std::shared_ptr<PSSM::Semantics::StateMachines::RegionActivation> regionActivation = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::RegionActivation>(this->m_parent);
	if (regionActivation != nullptr) 
	{
		if (std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::StateMachineExecution>(regionActivation->getParent()) != nullptr) 
		{
			return nullptr;
		} 
		else 
		{
			return std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::VertexActivation>(regionActivation->getParent());
		}
	}

	return nullptr;
	//end of body
}

std::shared_ptr<PSSM::Semantics::StateMachines::RegionActivation> VertexActivationImpl::getRegionActivation(const std::shared_ptr<fUML::Semantics::Loci::SemanticVisitor>& semanticVisitor)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
		// If the given semantic visitor is a region activation then this activation
// is returned. Otherwise if the visitor is a vertex activation  then its
// parent region activation is returned.
//RegionActivation regionActivation = null;
//if(semanticVisitor instanceof RegionActivation){
//	regionActivation = (RegionActivation) semanticVisitor;
//}else if(semanticVisitor instanceof VertexActivation){
//	regionActivation = (RegionActivation)((VertexActivation)semanticVisitor).getParent();
//}
//return regionActivation;
	std::shared_ptr<PSSM::Semantics::StateMachines::RegionActivation> regionActivation = nullptr;
	if(std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::RegionActivation>(semanticVisitor) != nullptr) {
		regionActivation = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::RegionActivation>(semanticVisitor);
	} else if(std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::VertexActivation>(semanticVisitor) != nullptr) {
		regionActivation = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::RegionActivation>(std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::VertexActivation>(semanticVisitor)->getParent());
	}
	return regionActivation;
	//end of body
}



std::shared_ptr<PSSM::Semantics::StateMachines::VertexActivation> VertexActivationImpl::getVertexActivation(const std::shared_ptr<uml::Vertex>& vertex)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	// Returns nothing by default. Must be overridden by StateActivation;
	return nullptr;
	//end of body
}

bool VertexActivationImpl::isActive()
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	// By default is is possible to assess if a vertex is active by checking
	// if its status is ACTIVE. Note this operation is overriden in the context
	// of state activations which require a presence within the state-machine
	// configuration.
	return this->getStatus() == PSSM::Semantics::StateMachines::StateMetadata::ACTIVE;
	//end of body
}

bool VertexActivationImpl::isEnterable(const std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation>& enteringTransition, bool staticCheck)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	// By default, a Vertex has no prerequisites that need to be fullfilled
	// to be entered. Nevertheless, some Vertices (e.g., join or exit) have such
	// prerequisites. Therefore this method is intended to be overridden in the VertexActivation sub-classes. 
	return true;
	//end of body
}

bool VertexActivationImpl::isExitable(const std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation>& exitingTransition, bool staticCheck)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	// By default, a Vertex has no prerequisites that need to be fullfilled
	// to be exited. Nevertheless, some Vertices (e.g., fork) have such
	// prerequisites. Therefore this method is intended to be overridden in the VertexActivation sub-classes. 
	return true;
	//end of body
}



void VertexActivationImpl::tagIncomingTransition(PSSM::Semantics::StateMachines::TransitionMetadata status, bool staticCheck)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	// Tags all incomingTransitionActivations as the given value.
	if (m_incomingTransitionActivations != nullptr) 
	{
		if (staticCheck)
		{
			for (const auto& incomingTransitionActivation : *m_incomingTransitionActivations)
			{
				incomingTransitionActivation->setAnalyticalStatus(status);
			}
		}
		else
		{
			for (const auto& incomingTransitionActivation : *m_incomingTransitionActivations)
			{
				incomingTransitionActivation->setStatus(status);
			}
		}
	}
	//end of body
}

void VertexActivationImpl::tagOutgoingTransition(PSSM::Semantics::StateMachines::TransitionMetadata status, bool staticCheck)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	// Tags all outgoingTransitionActivations as the given value.
	if (this->m_outgoingTransitionActivations != nullptr) 
	{
		if (staticCheck)
		{
			for (const auto& outgoingTransitionActivation : *m_outgoingTransitionActivations)
			{
				outgoingTransitionActivation->setAnalyticalStatus(status);
			}
		}
		else
		{
			for (const auto& outgoingTransitionActivation : *m_outgoingTransitionActivations)
			{
				outgoingTransitionActivation->setStatus(status);
			}
		}
	}
	//end of body
}

void VertexActivationImpl::terminate()
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	// Intended to be overridden by sub-classe(s)  
	return;
	//end of body
}

//*********************************
// Attribute Getters & Setters
//*********************************
/* Getter & Setter for attribute status */
PSSM::Semantics::StateMachines::StateMetadata VertexActivationImpl::getStatus() const 
{
	return m_status;
}
void VertexActivationImpl::setStatus(PSSM::Semantics::StateMachines::StateMetadata _status)
{
	m_status = _status;
	
}

//*********************************
// Reference Getters & Setters
//*********************************
/* Getter & Setter for reference incomingTransitionActivations */
const std::shared_ptr<Bag<PSSM::Semantics::StateMachines::TransitionActivation>>& VertexActivationImpl::getIncomingTransitionActivations() const
{
	if(m_incomingTransitionActivations == nullptr)
	{
		m_incomingTransitionActivations.reset(new Bag<PSSM::Semantics::StateMachines::TransitionActivation>());
		
		
	}
    return m_incomingTransitionActivations;
}

/* Getter & Setter for reference outgoingTransitionActivations */
const std::shared_ptr<Bag<PSSM::Semantics::StateMachines::TransitionActivation>>& VertexActivationImpl::getOutgoingTransitionActivations() const
{
	if(m_outgoingTransitionActivations == nullptr)
	{
		m_outgoingTransitionActivations.reset(new Bag<PSSM::Semantics::StateMachines::TransitionActivation>());
		
		
	}
    return m_outgoingTransitionActivations;
}

//*********************************
// Union Getter
//*********************************

//*********************************
// Container Getter
//*********************************
std::shared_ptr<ecore::EObject> VertexActivationImpl::eContainer() const
{
	return nullptr;
}

//*********************************
// Persistence Functions
//*********************************
void VertexActivationImpl::load(std::shared_ptr<persistence::interfaces::XLoadHandler> loadHandler)
{
	std::map<std::string, std::string> attr_list = loadHandler->getAttributeList();
	loadAttributes(loadHandler, attr_list);

	//
	// Create new objects (from references (containment == true))
	//
	// get PSSMFactory
	int numNodes = loadHandler->getNumOfChildNodes();
	for(int ii = 0; ii < numNodes; ii++)
	{
		loadNode(loadHandler->getNextNodeName(), loadHandler);
	}
}		

void VertexActivationImpl::loadAttributes(std::shared_ptr<persistence::interfaces::XLoadHandler> loadHandler, std::map<std::string, std::string> attr_list)
{
	try
	{
		std::map<std::string, std::string>::const_iterator iter;
	
		iter = attr_list.find("status");
		if ( iter != attr_list.end() )
		{
			PSSM::Semantics::StateMachines::StateMetadata value = PSSM::Semantics::StateMachines::StateMetadata::IDLE;
			std::string literal = iter->second;
						if (literal == "idle")
			{
				value = PSSM::Semantics::StateMachines::StateMetadata::IDLE;
			}
			else 			if (literal == "active")
			{
				value = PSSM::Semantics::StateMachines::StateMetadata::ACTIVE;
			}
			this->setStatus(value);
		}
		std::shared_ptr<ecore::EClass> metaClass = this->eClass(); // get MetaClass
		iter = attr_list.find("incomingTransitionActivations");
		if ( iter != attr_list.end() )
		{
			// add unresolvedReference to loadHandler's list
			loadHandler->addUnresolvedReference(iter->second, loadHandler->getCurrentObject(), metaClass->getEStructuralFeature("incomingTransitionActivations")); // TODO use getEStructuralFeature() with id, for faster access to EStructuralFeature
		}

		iter = attr_list.find("outgoingTransitionActivations");
		if ( iter != attr_list.end() )
		{
			// add unresolvedReference to loadHandler's list
			loadHandler->addUnresolvedReference(iter->second, loadHandler->getCurrentObject(), metaClass->getEStructuralFeature("outgoingTransitionActivations")); // TODO use getEStructuralFeature() with id, for faster access to EStructuralFeature
		}
	}
	catch (std::exception& e)
	{
		std::cout << "| ERROR    | " << e.what() << std::endl;
	}
	catch (...) 
	{
		std::cout << "| ERROR    | " <<  "Exception occurred" << std::endl;
	}

	StateMachineSemanticVisitorImpl::loadAttributes(loadHandler, attr_list);
}

void VertexActivationImpl::loadNode(std::string nodeName, std::shared_ptr<persistence::interfaces::XLoadHandler> loadHandler)
{

	//load BasePackage Nodes
	StateMachineSemanticVisitorImpl::loadNode(nodeName, loadHandler);
}

void VertexActivationImpl::resolveReferences(const int featureID, std::vector<std::shared_ptr<ecore::EObject>> references)
{
	switch(featureID)
	{
		case PSSM::Semantics::StateMachines::StateMachinesPackage::VERTEXACTIVATION_ATTRIBUTE_INCOMINGTRANSITIONACTIVATIONS:
		{
			const std::shared_ptr<Bag<PSSM::Semantics::StateMachines::TransitionActivation>>& _incomingTransitionActivations = getIncomingTransitionActivations();
			for(const std::shared_ptr<ecore::EObject>& ref : references)
			{
				std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation>  _r = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::TransitionActivation>(ref);
				if (_r != nullptr)
				{
					_incomingTransitionActivations->push_back(_r);
				}
			}
			return;
		}

		case PSSM::Semantics::StateMachines::StateMachinesPackage::VERTEXACTIVATION_ATTRIBUTE_OUTGOINGTRANSITIONACTIVATIONS:
		{
			const std::shared_ptr<Bag<PSSM::Semantics::StateMachines::TransitionActivation>>& _outgoingTransitionActivations = getOutgoingTransitionActivations();
			for(const std::shared_ptr<ecore::EObject>& ref : references)
			{
				std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation>  _r = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::TransitionActivation>(ref);
				if (_r != nullptr)
				{
					_outgoingTransitionActivations->push_back(_r);
				}
			}
			return;
		}
	}
	StateMachineSemanticVisitorImpl::resolveReferences(featureID, references);
}

void VertexActivationImpl::save(std::shared_ptr<persistence::interfaces::XSaveHandler> saveHandler) const
{
	saveContent(saveHandler);

	StateMachineSemanticVisitorImpl::saveContent(saveHandler);
	
	fUML::Semantics::Loci::SemanticVisitorImpl::saveContent(saveHandler);
	
	ecore::EObjectImpl::saveContent(saveHandler);
}

void VertexActivationImpl::saveContent(std::shared_ptr<persistence::interfaces::XSaveHandler> saveHandler) const
{
	try
	{
		std::shared_ptr<PSSM::Semantics::StateMachines::StateMachinesPackage> package = PSSM::Semantics::StateMachines::StateMachinesPackage::eInstance();
		// Add attributes
          if ( this->eIsSet(package->getVertexActivation_Attribute_status()) )
          {
			PSSM::Semantics::StateMachines::StateMetadata value = this->getStatus();
			std::string literal = "";
			if (value == PSSM::Semantics::StateMachines::StateMetadata::IDLE)
			{
				literal = "idle";
			}
			else if (value == PSSM::Semantics::StateMachines::StateMetadata::ACTIVE)
			{
				literal = "active";
			}
			saveHandler->addAttribute("status", literal);
          }
	// Add references
	if ( this->eIsSet(package->getVertexActivation_Attribute_incomingTransitionActivations()) )
	{
		saveHandler->addReferences<PSSM::Semantics::StateMachines::TransitionActivation>("incomingTransitionActivations", this->getIncomingTransitionActivations());
	}
	if ( this->eIsSet(package->getVertexActivation_Attribute_outgoingTransitionActivations()) )
	{
		saveHandler->addReferences<PSSM::Semantics::StateMachines::TransitionActivation>("outgoingTransitionActivations", this->getOutgoingTransitionActivations());
	}
	}
	catch (std::exception& e)
	{
		std::cout << "| ERROR    | " << e.what() << std::endl;
	}
}

const std::shared_ptr<ecore::EClass>& VertexActivationImpl::eStaticClass() const
{
	return PSSM::Semantics::StateMachines::StateMachinesPackage::eInstance()->getVertexActivation_Class();
}

//*********************************
// EStructuralFeature Get/Set/IsSet
//*********************************
std::shared_ptr<Any> VertexActivationImpl::eGet(int featureID, bool resolve, bool coreType) const
{
	switch(featureID)
	{
		case PSSM::Semantics::StateMachines::StateMachinesPackage::VERTEXACTIVATION_ATTRIBUTE_INCOMINGTRANSITIONACTIVATIONS:
			return eEcoreContainerAny(getIncomingTransitionActivations(),PSSM::Semantics::StateMachines::StateMachinesPackage::TRANSITIONACTIVATION_CLASS); //453
		case PSSM::Semantics::StateMachines::StateMachinesPackage::VERTEXACTIVATION_ATTRIBUTE_OUTGOINGTRANSITIONACTIVATIONS:
			return eEcoreContainerAny(getOutgoingTransitionActivations(),PSSM::Semantics::StateMachines::StateMachinesPackage::TRANSITIONACTIVATION_CLASS); //454
		case PSSM::Semantics::StateMachines::StateMachinesPackage::VERTEXACTIVATION_ATTRIBUTE_STATUS:
			return eAny(getStatus(),PSSM::Semantics::StateMachines::StateMachinesPackage::STATEMETADATA_CLASS,false); //452
	}
	return StateMachineSemanticVisitorImpl::eGet(featureID, resolve, coreType);
}

bool VertexActivationImpl::internalEIsSet(int featureID) const
{
	switch(featureID)
	{
		case PSSM::Semantics::StateMachines::StateMachinesPackage::VERTEXACTIVATION_ATTRIBUTE_INCOMINGTRANSITIONACTIVATIONS:
			return getIncomingTransitionActivations() != nullptr; //453
		case PSSM::Semantics::StateMachines::StateMachinesPackage::VERTEXACTIVATION_ATTRIBUTE_OUTGOINGTRANSITIONACTIVATIONS:
			return getOutgoingTransitionActivations() != nullptr; //454
		case PSSM::Semantics::StateMachines::StateMachinesPackage::VERTEXACTIVATION_ATTRIBUTE_STATUS:
			return m_status != PSSM::Semantics::StateMachines::StateMetadata::IDLE;; //452
	}
	return StateMachineSemanticVisitorImpl::internalEIsSet(featureID);
}

bool VertexActivationImpl::eSet(int featureID,  const std::shared_ptr<Any>& newValue)
{
	switch(featureID)
	{
		case PSSM::Semantics::StateMachines::StateMachinesPackage::VERTEXACTIVATION_ATTRIBUTE_INCOMINGTRANSITIONACTIVATIONS:
		{
			std::shared_ptr<ecore::EcoreContainerAny> ecoreContainerAny = std::dynamic_pointer_cast<ecore::EcoreContainerAny>(newValue);
			if(ecoreContainerAny)
			{
				try
				{
					std::shared_ptr<Bag<ecore::EObject>> eObjectList = ecoreContainerAny->getAsEObjectContainer();
	
					if(eObjectList)
					{
						const std::shared_ptr<Bag<PSSM::Semantics::StateMachines::TransitionActivation>>& _incomingTransitionActivations = getIncomingTransitionActivations();
	
						for(const std::shared_ptr<ecore::EObject>& anEObject: *eObjectList)
						{
							std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation> valueToAdd = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::TransitionActivation>(anEObject);
	
							if (valueToAdd)
							{
								if(!(_incomingTransitionActivations->includes(valueToAdd)))
								{
									_incomingTransitionActivations->add(valueToAdd);
								}
								//else, valueToAdd is already present so it won't be added again
							}
							else
							{
								throw "Invalid argument";
							}
						}
					}
				}
				catch(...)
				{
					DEBUG_ERROR("Invalid type stored in 'ecore::ecoreContainerAny' for feature 'incomingTransitionActivations'. Failed to set feature!")
					return false;
				}
			}
			else
			{
				DEBUG_ERROR("Invalid instance of 'ecore::ecoreContainerAny' for feature 'incomingTransitionActivations'. Failed to set feature!")
				return false;
			}
		return true;
		}
		case PSSM::Semantics::StateMachines::StateMachinesPackage::VERTEXACTIVATION_ATTRIBUTE_OUTGOINGTRANSITIONACTIVATIONS:
		{
			std::shared_ptr<ecore::EcoreContainerAny> ecoreContainerAny = std::dynamic_pointer_cast<ecore::EcoreContainerAny>(newValue);
			if(ecoreContainerAny)
			{
				try
				{
					std::shared_ptr<Bag<ecore::EObject>> eObjectList = ecoreContainerAny->getAsEObjectContainer();
	
					if(eObjectList)
					{
						const std::shared_ptr<Bag<PSSM::Semantics::StateMachines::TransitionActivation>>& _outgoingTransitionActivations = getOutgoingTransitionActivations();
	
						for(const std::shared_ptr<ecore::EObject>& anEObject: *eObjectList)
						{
							std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation> valueToAdd = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::TransitionActivation>(anEObject);
	
							if (valueToAdd)
							{
								if(!(_outgoingTransitionActivations->includes(valueToAdd)))
								{
									_outgoingTransitionActivations->add(valueToAdd);
								}
								//else, valueToAdd is already present so it won't be added again
							}
							else
							{
								throw "Invalid argument";
							}
						}
					}
				}
				catch(...)
				{
					DEBUG_ERROR("Invalid type stored in 'ecore::ecoreContainerAny' for feature 'outgoingTransitionActivations'. Failed to set feature!")
					return false;
				}
			}
			else
			{
				DEBUG_ERROR("Invalid instance of 'ecore::ecoreContainerAny' for feature 'outgoingTransitionActivations'. Failed to set feature!")
				return false;
			}
		return true;
		}
		case PSSM::Semantics::StateMachines::StateMachinesPackage::VERTEXACTIVATION_ATTRIBUTE_STATUS:
		{
			try
			{
				PSSM::Semantics::StateMachines::StateMetadata _status = newValue->get<PSSM::Semantics::StateMachines::StateMetadata>();
				setStatus(_status); //452
			}
			catch(...)
			{
				DEBUG_ERROR("Invalid type stored in 'Any' for feature 'status'. Failed to set feature!")
				return false;
			}
		return true;
		}
	}

	return StateMachineSemanticVisitorImpl::eSet(featureID, newValue);
}

//*********************************
// EOperation Invoke
//*********************************
std::shared_ptr<Any> VertexActivationImpl::eInvoke(int operationID, const std::shared_ptr<Bag<Any>>& arguments)
{
	std::shared_ptr<Any> result;
 
  	switch(operationID)
	{
		// PSSM::Semantics::StateMachines::VertexActivation::addIncomingTransition(PSSM::Semantics::StateMachines::TransitionActivation): 941069300
		case StateMachinesPackage::VERTEXACTIVATION_OPERATION_ADDINCOMINGTRANSITION_TRANSITIONACTIVATION:
		{
			//Retrieve input parameter 'transitionActivation'
			//parameter 0
			std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation> incoming_param_transitionActivation;
			Bag<Any>::const_iterator incoming_param_transitionActivation_arguments_citer = std::next(arguments->begin(), 0);
			{
				std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>((*incoming_param_transitionActivation_arguments_citer));
				if(ecoreAny)
				{
					try
					{
						std::shared_ptr<ecore::EObject> _temp = ecoreAny->getAsEObject();
						incoming_param_transitionActivation = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::TransitionActivation>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreAny' for parameter 'transitionActivation'. Failed to invoke operation 'addIncomingTransition'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreAny' for parameter 'transitionActivation'. Failed to invoke operation 'addIncomingTransition'!")
					return nullptr;
				}
			}
		
			this->addIncomingTransition(incoming_param_transitionActivation);
			break;
		}
		// PSSM::Semantics::StateMachines::VertexActivation::addOutgoingTransition(PSSM::Semantics::StateMachines::TransitionActivation): 2233657952
		case StateMachinesPackage::VERTEXACTIVATION_OPERATION_ADDOUTGOINGTRANSITION_TRANSITIONACTIVATION:
		{
			//Retrieve input parameter 'transitionActivation'
			//parameter 0
			std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation> incoming_param_transitionActivation;
			Bag<Any>::const_iterator incoming_param_transitionActivation_arguments_citer = std::next(arguments->begin(), 0);
			{
				std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>((*incoming_param_transitionActivation_arguments_citer));
				if(ecoreAny)
				{
					try
					{
						std::shared_ptr<ecore::EObject> _temp = ecoreAny->getAsEObject();
						incoming_param_transitionActivation = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::TransitionActivation>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreAny' for parameter 'transitionActivation'. Failed to invoke operation 'addOutgoingTransition'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreAny' for parameter 'transitionActivation'. Failed to invoke operation 'addOutgoingTransition'!")
					return nullptr;
				}
			}
		
			this->addOutgoingTransition(incoming_param_transitionActivation);
			break;
		}
		// PSSM::Semantics::StateMachines::VertexActivation::canPropagateExecution(PSSM::Semantics::StateMachines::TransitionActivation, fUML::Semantics::CommonBehavior::EventOccurrence, PSSM::Semantics::StateMachines::RegionActivation) : bool: 924847871
		case StateMachinesPackage::VERTEXACTIVATION_OPERATION_CANPROPAGATEEXECUTION_TRANSITIONACTIVATION_REGIONACTIVATION:
		{
			//Retrieve input parameter 'enteringTransition'
			//parameter 0
			std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation> incoming_param_enteringTransition;
			Bag<Any>::const_iterator incoming_param_enteringTransition_arguments_citer = std::next(arguments->begin(), 0);
			{
				std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>((*incoming_param_enteringTransition_arguments_citer));
				if(ecoreAny)
				{
					try
					{
						std::shared_ptr<ecore::EObject> _temp = ecoreAny->getAsEObject();
						incoming_param_enteringTransition = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::TransitionActivation>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreAny' for parameter 'enteringTransition'. Failed to invoke operation 'canPropagateExecution'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreAny' for parameter 'enteringTransition'. Failed to invoke operation 'canPropagateExecution'!")
					return nullptr;
				}
			}
		
			//Retrieve input parameter 'eventOccurrence'
			//parameter 1
			std::shared_ptr<fUML::Semantics::CommonBehavior::EventOccurrence> incoming_param_eventOccurrence;
			Bag<Any>::const_iterator incoming_param_eventOccurrence_arguments_citer = std::next(arguments->begin(), 1);
			{
				std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>((*incoming_param_eventOccurrence_arguments_citer));
				if(ecoreAny)
				{
					try
					{
						std::shared_ptr<ecore::EObject> _temp = ecoreAny->getAsEObject();
						incoming_param_eventOccurrence = std::dynamic_pointer_cast<fUML::Semantics::CommonBehavior::EventOccurrence>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreAny' for parameter 'eventOccurrence'. Failed to invoke operation 'canPropagateExecution'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreAny' for parameter 'eventOccurrence'. Failed to invoke operation 'canPropagateExecution'!")
					return nullptr;
				}
			}
		
			//Retrieve input parameter 'leastCommonAncestor'
			//parameter 2
			std::shared_ptr<PSSM::Semantics::StateMachines::RegionActivation> incoming_param_leastCommonAncestor;
			Bag<Any>::const_iterator incoming_param_leastCommonAncestor_arguments_citer = std::next(arguments->begin(), 2);
			{
				std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>((*incoming_param_leastCommonAncestor_arguments_citer));
				if(ecoreAny)
				{
					try
					{
						std::shared_ptr<ecore::EObject> _temp = ecoreAny->getAsEObject();
						incoming_param_leastCommonAncestor = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::RegionActivation>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreAny' for parameter 'leastCommonAncestor'. Failed to invoke operation 'canPropagateExecution'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreAny' for parameter 'leastCommonAncestor'. Failed to invoke operation 'canPropagateExecution'!")
					return nullptr;
				}
			}
		
			result = eAny(this->canPropagateExecution(incoming_param_enteringTransition,incoming_param_eventOccurrence,incoming_param_leastCommonAncestor), 0, false);
			break;
		}
		// PSSM::Semantics::StateMachines::VertexActivation::enter(PSSM::Semantics::StateMachines::TransitionActivation, fUML::Semantics::CommonBehavior::EventOccurrence, PSSM::Semantics::StateMachines::RegionActivation): 1125310418
		case StateMachinesPackage::VERTEXACTIVATION_OPERATION_ENTER_TRANSITIONACTIVATION_REGIONACTIVATION:
		{
			//Retrieve input parameter 'enteringTransition'
			//parameter 0
			std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation> incoming_param_enteringTransition;
			Bag<Any>::const_iterator incoming_param_enteringTransition_arguments_citer = std::next(arguments->begin(), 0);
			{
				std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>((*incoming_param_enteringTransition_arguments_citer));
				if(ecoreAny)
				{
					try
					{
						std::shared_ptr<ecore::EObject> _temp = ecoreAny->getAsEObject();
						incoming_param_enteringTransition = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::TransitionActivation>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreAny' for parameter 'enteringTransition'. Failed to invoke operation 'enter'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreAny' for parameter 'enteringTransition'. Failed to invoke operation 'enter'!")
					return nullptr;
				}
			}
		
			//Retrieve input parameter 'eventOccurrence'
			//parameter 1
			std::shared_ptr<fUML::Semantics::CommonBehavior::EventOccurrence> incoming_param_eventOccurrence;
			Bag<Any>::const_iterator incoming_param_eventOccurrence_arguments_citer = std::next(arguments->begin(), 1);
			{
				std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>((*incoming_param_eventOccurrence_arguments_citer));
				if(ecoreAny)
				{
					try
					{
						std::shared_ptr<ecore::EObject> _temp = ecoreAny->getAsEObject();
						incoming_param_eventOccurrence = std::dynamic_pointer_cast<fUML::Semantics::CommonBehavior::EventOccurrence>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreAny' for parameter 'eventOccurrence'. Failed to invoke operation 'enter'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreAny' for parameter 'eventOccurrence'. Failed to invoke operation 'enter'!")
					return nullptr;
				}
			}
		
			//Retrieve input parameter 'leastCommonAncestor'
			//parameter 2
			std::shared_ptr<PSSM::Semantics::StateMachines::RegionActivation> incoming_param_leastCommonAncestor;
			Bag<Any>::const_iterator incoming_param_leastCommonAncestor_arguments_citer = std::next(arguments->begin(), 2);
			{
				std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>((*incoming_param_leastCommonAncestor_arguments_citer));
				if(ecoreAny)
				{
					try
					{
						std::shared_ptr<ecore::EObject> _temp = ecoreAny->getAsEObject();
						incoming_param_leastCommonAncestor = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::RegionActivation>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreAny' for parameter 'leastCommonAncestor'. Failed to invoke operation 'enter'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreAny' for parameter 'leastCommonAncestor'. Failed to invoke operation 'enter'!")
					return nullptr;
				}
			}
		
			this->enter(incoming_param_enteringTransition,incoming_param_eventOccurrence,incoming_param_leastCommonAncestor);
			break;
		}
		// PSSM::Semantics::StateMachines::VertexActivation::exit(PSSM::Semantics::StateMachines::TransitionActivation, fUML::Semantics::CommonBehavior::EventOccurrence, PSSM::Semantics::StateMachines::RegionActivation): 985410366
		case StateMachinesPackage::VERTEXACTIVATION_OPERATION_EXIT_TRANSITIONACTIVATION_REGIONACTIVATION:
		{
			//Retrieve input parameter 'exitingTransition'
			//parameter 0
			std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation> incoming_param_exitingTransition;
			Bag<Any>::const_iterator incoming_param_exitingTransition_arguments_citer = std::next(arguments->begin(), 0);
			{
				std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>((*incoming_param_exitingTransition_arguments_citer));
				if(ecoreAny)
				{
					try
					{
						std::shared_ptr<ecore::EObject> _temp = ecoreAny->getAsEObject();
						incoming_param_exitingTransition = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::TransitionActivation>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreAny' for parameter 'exitingTransition'. Failed to invoke operation 'exit'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreAny' for parameter 'exitingTransition'. Failed to invoke operation 'exit'!")
					return nullptr;
				}
			}
		
			//Retrieve input parameter 'eventOccurrence'
			//parameter 1
			std::shared_ptr<fUML::Semantics::CommonBehavior::EventOccurrence> incoming_param_eventOccurrence;
			Bag<Any>::const_iterator incoming_param_eventOccurrence_arguments_citer = std::next(arguments->begin(), 1);
			{
				std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>((*incoming_param_eventOccurrence_arguments_citer));
				if(ecoreAny)
				{
					try
					{
						std::shared_ptr<ecore::EObject> _temp = ecoreAny->getAsEObject();
						incoming_param_eventOccurrence = std::dynamic_pointer_cast<fUML::Semantics::CommonBehavior::EventOccurrence>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreAny' for parameter 'eventOccurrence'. Failed to invoke operation 'exit'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreAny' for parameter 'eventOccurrence'. Failed to invoke operation 'exit'!")
					return nullptr;
				}
			}
		
			//Retrieve input parameter 'leastCommonAncestor'
			//parameter 2
			std::shared_ptr<PSSM::Semantics::StateMachines::RegionActivation> incoming_param_leastCommonAncestor;
			Bag<Any>::const_iterator incoming_param_leastCommonAncestor_arguments_citer = std::next(arguments->begin(), 2);
			{
				std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>((*incoming_param_leastCommonAncestor_arguments_citer));
				if(ecoreAny)
				{
					try
					{
						std::shared_ptr<ecore::EObject> _temp = ecoreAny->getAsEObject();
						incoming_param_leastCommonAncestor = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::RegionActivation>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreAny' for parameter 'leastCommonAncestor'. Failed to invoke operation 'exit'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreAny' for parameter 'leastCommonAncestor'. Failed to invoke operation 'exit'!")
					return nullptr;
				}
			}
		
			this->exit(incoming_param_exitingTransition,incoming_param_eventOccurrence,incoming_param_leastCommonAncestor);
			break;
		}
		// PSSM::Semantics::StateMachines::VertexActivation::getAscendingHierarchy() : PSSM::Semantics::StateMachines::VertexActivation[*]: 2722464026
		case StateMachinesPackage::VERTEXACTIVATION_OPERATION_GETASCENDINGHIERARCHY:
		{
			std::shared_ptr<Bag<PSSM::Semantics::StateMachines::VertexActivation>> resultList = this->getAscendingHierarchy();
			return eEcoreContainerAny(resultList,PSSM::Semantics::StateMachines::StateMachinesPackage::VERTEXACTIVATION_CLASS);
			break;
		}
		// PSSM::Semantics::StateMachines::VertexActivation::getIncomingTransitions() : PSSM::Semantics::StateMachines::TransitionActivation[*]: 3061731870
		case StateMachinesPackage::VERTEXACTIVATION_OPERATION_GETINCOMINGTRANSITIONS:
		{
			std::shared_ptr<Bag<PSSM::Semantics::StateMachines::TransitionActivation>> resultList = this->getIncomingTransitions();
			return eEcoreContainerAny(resultList,PSSM::Semantics::StateMachines::StateMachinesPackage::TRANSITIONACTIVATION_CLASS);
			break;
		}
		// PSSM::Semantics::StateMachines::VertexActivation::getLeastCommonAncestor(PSSM::Semantics::StateMachines::VertexActivation) : PSSM::Semantics::StateMachines::RegionActivation: 2460273763
		case StateMachinesPackage::VERTEXACTIVATION_OPERATION_GETLEASTCOMMONANCESTOR_VERTEXACTIVATION:
		{
			//Retrieve input parameter 'vertexActivation'
			//parameter 0
			std::shared_ptr<PSSM::Semantics::StateMachines::VertexActivation> incoming_param_vertexActivation;
			Bag<Any>::const_iterator incoming_param_vertexActivation_arguments_citer = std::next(arguments->begin(), 0);
			{
				std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>((*incoming_param_vertexActivation_arguments_citer));
				if(ecoreAny)
				{
					try
					{
						std::shared_ptr<ecore::EObject> _temp = ecoreAny->getAsEObject();
						incoming_param_vertexActivation = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::VertexActivation>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreAny' for parameter 'vertexActivation'. Failed to invoke operation 'getLeastCommonAncestor'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreAny' for parameter 'vertexActivation'. Failed to invoke operation 'getLeastCommonAncestor'!")
					return nullptr;
				}
			}
		
			result = eEcoreAny(this->getLeastCommonAncestor(incoming_param_vertexActivation), PSSM::Semantics::StateMachines::StateMachinesPackage::REGIONACTIVATION_CLASS);
			break;
		}
		// PSSM::Semantics::StateMachines::VertexActivation::getOutgoingTransitions() : PSSM::Semantics::StateMachines::TransitionActivation[*]: 59353226
		case StateMachinesPackage::VERTEXACTIVATION_OPERATION_GETOUTGOINGTRANSITIONS:
		{
			std::shared_ptr<Bag<PSSM::Semantics::StateMachines::TransitionActivation>> resultList = this->getOutgoingTransitions();
			return eEcoreContainerAny(resultList,PSSM::Semantics::StateMachines::StateMachinesPackage::TRANSITIONACTIVATION_CLASS);
			break;
		}
		// PSSM::Semantics::StateMachines::VertexActivation::getOwningRegionActivation() : PSSM::Semantics::StateMachines::RegionActivation: 2347148063
		case StateMachinesPackage::VERTEXACTIVATION_OPERATION_GETOWNINGREGIONACTIVATION:
		{
			result = eEcoreAny(this->getOwningRegionActivation(), PSSM::Semantics::StateMachines::StateMachinesPackage::REGIONACTIVATION_CLASS);
			break;
		}
		// PSSM::Semantics::StateMachines::VertexActivation::getParentVertexActivation() : PSSM::Semantics::StateMachines::VertexActivation: 2317313079
		case StateMachinesPackage::VERTEXACTIVATION_OPERATION_GETPARENTVERTEXACTIVATION:
		{
			result = eEcoreAny(this->getParentVertexActivation(), PSSM::Semantics::StateMachines::StateMachinesPackage::VERTEXACTIVATION_CLASS);
			break;
		}
		// PSSM::Semantics::StateMachines::VertexActivation::getRegionActivation(fUML::Semantics::Loci::SemanticVisitor) : PSSM::Semantics::StateMachines::RegionActivation: 1289324231
		case StateMachinesPackage::VERTEXACTIVATION_OPERATION_GETREGIONACTIVATION_SEMANTICVISITOR:
		{
			//Retrieve input parameter 'semanticVisitor'
			//parameter 0
			std::shared_ptr<fUML::Semantics::Loci::SemanticVisitor> incoming_param_semanticVisitor;
			Bag<Any>::const_iterator incoming_param_semanticVisitor_arguments_citer = std::next(arguments->begin(), 0);
			{
				std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>((*incoming_param_semanticVisitor_arguments_citer));
				if(ecoreAny)
				{
					try
					{
						std::shared_ptr<ecore::EObject> _temp = ecoreAny->getAsEObject();
						incoming_param_semanticVisitor = std::dynamic_pointer_cast<fUML::Semantics::Loci::SemanticVisitor>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreAny' for parameter 'semanticVisitor'. Failed to invoke operation 'getRegionActivation'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreAny' for parameter 'semanticVisitor'. Failed to invoke operation 'getRegionActivation'!")
					return nullptr;
				}
			}
		
			result = eEcoreAny(this->getRegionActivation(incoming_param_semanticVisitor), PSSM::Semantics::StateMachines::StateMachinesPackage::REGIONACTIVATION_CLASS);
			break;
		}
		// PSSM::Semantics::StateMachines::VertexActivation::getVertexActivation(uml::Vertex) : PSSM::Semantics::StateMachines::VertexActivation: 211144229
		case StateMachinesPackage::VERTEXACTIVATION_OPERATION_GETVERTEXACTIVATION_VERTEX:
		{
			//Retrieve input parameter 'vertex'
			//parameter 0
			std::shared_ptr<uml::Vertex> incoming_param_vertex;
			Bag<Any>::const_iterator incoming_param_vertex_arguments_citer = std::next(arguments->begin(), 0);
			{
				std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>((*incoming_param_vertex_arguments_citer));
				if(ecoreAny)
				{
					try
					{
						std::shared_ptr<ecore::EObject> _temp = ecoreAny->getAsEObject();
						incoming_param_vertex = std::dynamic_pointer_cast<uml::Vertex>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreAny' for parameter 'vertex'. Failed to invoke operation 'getVertexActivation'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreAny' for parameter 'vertex'. Failed to invoke operation 'getVertexActivation'!")
					return nullptr;
				}
			}
		
			result = eEcoreAny(this->getVertexActivation(incoming_param_vertex), PSSM::Semantics::StateMachines::StateMachinesPackage::VERTEXACTIVATION_CLASS);
			break;
		}
		// PSSM::Semantics::StateMachines::VertexActivation::isActive() : bool: 3668745550
		case StateMachinesPackage::VERTEXACTIVATION_OPERATION_ISACTIVE:
		{
			result = eAny(this->isActive(), 0, false);
			break;
		}
		// PSSM::Semantics::StateMachines::VertexActivation::isEnterable(PSSM::Semantics::StateMachines::TransitionActivation, bool) : bool: 150058772
		case StateMachinesPackage::VERTEXACTIVATION_OPERATION_ISENTERABLE_TRANSITIONACTIVATION_BOOLEAN:
		{
			//Retrieve input parameter 'enteringTransition'
			//parameter 0
			std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation> incoming_param_enteringTransition;
			Bag<Any>::const_iterator incoming_param_enteringTransition_arguments_citer = std::next(arguments->begin(), 0);
			{
				std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>((*incoming_param_enteringTransition_arguments_citer));
				if(ecoreAny)
				{
					try
					{
						std::shared_ptr<ecore::EObject> _temp = ecoreAny->getAsEObject();
						incoming_param_enteringTransition = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::TransitionActivation>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreAny' for parameter 'enteringTransition'. Failed to invoke operation 'isEnterable'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreAny' for parameter 'enteringTransition'. Failed to invoke operation 'isEnterable'!")
					return nullptr;
				}
			}
		
			//Retrieve input parameter 'staticCheck'
			//parameter 1
			bool incoming_param_staticCheck;
			Bag<Any>::const_iterator incoming_param_staticCheck_arguments_citer = std::next(arguments->begin(), 1);
			try
			{
				incoming_param_staticCheck = (*incoming_param_staticCheck_arguments_citer)->get<bool>();
			}
			catch(...)
			{
				DEBUG_ERROR("Invalid type stored in 'Any' for parameter 'staticCheck'. Failed to invoke operation 'isEnterable'!")
				return nullptr;
			}
		
			result = eAny(this->isEnterable(incoming_param_enteringTransition,incoming_param_staticCheck), 0, false);
			break;
		}
		// PSSM::Semantics::StateMachines::VertexActivation::isExitable(PSSM::Semantics::StateMachines::TransitionActivation, bool) : bool: 2407893848
		case StateMachinesPackage::VERTEXACTIVATION_OPERATION_ISEXITABLE_TRANSITIONACTIVATION_BOOLEAN:
		{
			//Retrieve input parameter 'exitingTransition'
			//parameter 0
			std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation> incoming_param_exitingTransition;
			Bag<Any>::const_iterator incoming_param_exitingTransition_arguments_citer = std::next(arguments->begin(), 0);
			{
				std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>((*incoming_param_exitingTransition_arguments_citer));
				if(ecoreAny)
				{
					try
					{
						std::shared_ptr<ecore::EObject> _temp = ecoreAny->getAsEObject();
						incoming_param_exitingTransition = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::TransitionActivation>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreAny' for parameter 'exitingTransition'. Failed to invoke operation 'isExitable'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreAny' for parameter 'exitingTransition'. Failed to invoke operation 'isExitable'!")
					return nullptr;
				}
			}
		
			//Retrieve input parameter 'staticCheck'
			//parameter 1
			bool incoming_param_staticCheck;
			Bag<Any>::const_iterator incoming_param_staticCheck_arguments_citer = std::next(arguments->begin(), 1);
			try
			{
				incoming_param_staticCheck = (*incoming_param_staticCheck_arguments_citer)->get<bool>();
			}
			catch(...)
			{
				DEBUG_ERROR("Invalid type stored in 'Any' for parameter 'staticCheck'. Failed to invoke operation 'isExitable'!")
				return nullptr;
			}
		
			result = eAny(this->isExitable(incoming_param_exitingTransition,incoming_param_staticCheck), 0, false);
			break;
		}
		// PSSM::Semantics::StateMachines::VertexActivation::tagIncomingTransition(PSSM::Semantics::StateMachines::TransitionMetadata, bool): 627387886
		case StateMachinesPackage::VERTEXACTIVATION_OPERATION_TAGINCOMINGTRANSITION_TRANSITIONMETADATA_BOOLEAN:
		{
			//Retrieve input parameter 'status'
			//parameter 0
			PSSM::Semantics::StateMachines::TransitionMetadata incoming_param_status;
			Bag<Any>::const_iterator incoming_param_status_arguments_citer = std::next(arguments->begin(), 0);
			try
			{
				incoming_param_status = (*incoming_param_status_arguments_citer)->get<PSSM::Semantics::StateMachines::TransitionMetadata>();
			}
			catch(...)
			{
				DEBUG_ERROR("Invalid type stored in 'Any' for parameter 'status'. Failed to invoke operation 'tagIncomingTransition'!")
				return nullptr;
			}
		
			//Retrieve input parameter 'staticCheck'
			//parameter 1
			bool incoming_param_staticCheck;
			Bag<Any>::const_iterator incoming_param_staticCheck_arguments_citer = std::next(arguments->begin(), 1);
			try
			{
				incoming_param_staticCheck = (*incoming_param_staticCheck_arguments_citer)->get<bool>();
			}
			catch(...)
			{
				DEBUG_ERROR("Invalid type stored in 'Any' for parameter 'staticCheck'. Failed to invoke operation 'tagIncomingTransition'!")
				return nullptr;
			}
		
			this->tagIncomingTransition(incoming_param_status,incoming_param_staticCheck);
			break;
		}
		// PSSM::Semantics::StateMachines::VertexActivation::tagOutgoingTransition(PSSM::Semantics::StateMachines::TransitionMetadata, bool): 1919976538
		case StateMachinesPackage::VERTEXACTIVATION_OPERATION_TAGOUTGOINGTRANSITION_TRANSITIONMETADATA_BOOLEAN:
		{
			//Retrieve input parameter 'status'
			//parameter 0
			PSSM::Semantics::StateMachines::TransitionMetadata incoming_param_status;
			Bag<Any>::const_iterator incoming_param_status_arguments_citer = std::next(arguments->begin(), 0);
			try
			{
				incoming_param_status = (*incoming_param_status_arguments_citer)->get<PSSM::Semantics::StateMachines::TransitionMetadata>();
			}
			catch(...)
			{
				DEBUG_ERROR("Invalid type stored in 'Any' for parameter 'status'. Failed to invoke operation 'tagOutgoingTransition'!")
				return nullptr;
			}
		
			//Retrieve input parameter 'staticCheck'
			//parameter 1
			bool incoming_param_staticCheck;
			Bag<Any>::const_iterator incoming_param_staticCheck_arguments_citer = std::next(arguments->begin(), 1);
			try
			{
				incoming_param_staticCheck = (*incoming_param_staticCheck_arguments_citer)->get<bool>();
			}
			catch(...)
			{
				DEBUG_ERROR("Invalid type stored in 'Any' for parameter 'staticCheck'. Failed to invoke operation 'tagOutgoingTransition'!")
				return nullptr;
			}
		
			this->tagOutgoingTransition(incoming_param_status,incoming_param_staticCheck);
			break;
		}
		// PSSM::Semantics::StateMachines::VertexActivation::terminate(): 787068897
		case StateMachinesPackage::VERTEXACTIVATION_OPERATION_TERMINATE:
		{
			this->terminate();
			break;
		}

		default:
		{
			// call superTypes
			result = StateMachineSemanticVisitorImpl::eInvoke(operationID, arguments);
			if (result && !result->isEmpty())
				break;
			break;
		}
  	}

	return result;
}

std::shared_ptr<PSSM::Semantics::StateMachines::VertexActivation> VertexActivationImpl::getThisVertexActivationPtr() const
{
	return m_thisVertexActivationPtr.lock();
}
void VertexActivationImpl::setThisVertexActivationPtr(std::weak_ptr<PSSM::Semantics::StateMachines::VertexActivation> thisVertexActivationPtr)
{
	m_thisVertexActivationPtr = thisVertexActivationPtr;
	setThisStateMachineSemanticVisitorPtr(thisVertexActivationPtr);
}


