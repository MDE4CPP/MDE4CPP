[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 ****************************************************************************************************************************************************************
 * 
 * module to generate connector pattern instantiation code conforming to PSCS instantiation semantics
 * 
 */]
[module generateConnectorPatternsInstantiation('http://www.eclipse.org/uml2/5.0.0/UML')]

[import UML4CPP::generator::main::components::generateType /]
[import UML4CPP::generator::main::helpers::nameHelper /]
[import UML4CPP::generator::main::pscs::generatePropertyInstantiation /]


[**
 * Template for generation of connector patterns
*/]
[template public generateConnectorInstantiation(aConnector : Connector)]
[if (aConnector.isArrayPattern())]
	//instantiate array pattern for connector [aConnector.name/]
	[aConnector.generateArrayPatternInstantiation()/]
[elseif (aConnector.isStarPattern())]
	//instantiate star pattern for connector [aConnector.name/]
	[aConnector.generateStarPatternInstantiation()/]
[/if]
[/template]


[**
 * Template for generation of array pattern
*/]
[template private generateArrayPatternInstantiation(aConnector : Connector){end1 : ConnectorEnd = aConnector.end->at(1); end2 : ConnectorEnd = aConnector.end->at(2); definingAssociation : Association = aConnector.type;}]
[comment TODO: Implement instatiation if ends are parts with ports /]
[if(not definingAssociation.oclIsUndefined())]
[if(end1.partWithPort.oclIsUndefined() and end2.partWithPort.oclIsUndefined())]
[aConnector.initArrayPattern_P_P()/]
[elseif(end1.partWithPort.oclIsUndefined() and (not end2.partWithPort.oclIsUndefined()))]
[aConnector.initArrayPattern_P_PWP()/]
[elseif((not end1.partWithPort.oclIsUndefined()) and end2.partWithPort.oclIsUndefined())]
[aConnector.initArrayPattern_PWP_P()/]
[else]
[aConnector.initArrayPattern_PWP_PWP()/]
[/if]
[else]
/*
Error: Untyped connector '[aConnector.name/]'. A connector must have one and only one association set as its type.
*/
[/if]
[/template]


[**
 * Template for generation of array pattern between a part and a part
*/]
[template private initArrayPattern_P_P(aConnector : Connector){end1 : ConnectorEnd = aConnector.end->at(1); end2 : ConnectorEnd = aConnector.end->at(2); definingAssociation : Association = aConnector.type;}]
[if(definingAssociation.memberEnd->at(1).getUpper() <> 1)] [comment *-multiplicity/]
for(unsigned int i = 0; i < [end1.role.oclAsType(MultiplicityElement).getLower()/]; i++)
{
	this->get[end1.role.name.toUpperFirst()/]()->at(i)->get[end1.getDefiningEnd().name.toUpperFirst()/]()->add(this->get[end2.role.name.toUpperFirst()/]()->at(i));
	this->get[end2.role.name.toUpperFirst()/]()->at(i)->get[end2.getDefiningEnd().name.toUpperFirst()/]()->add(this->get[end1.role.name.toUpperFirst()/]()->at(i));
}
[else] [comment 1-multiplicity/]
this->get[end1.role.name.toUpperFirst()/]()->set[end1.getDefiningEnd().name.toUpperFirst()/](this->get[end2.role.name.toUpperFirst()/]());
this->get[end2.role.name.toUpperFirst()/]()->set[end2.getDefiningEnd().name.toUpperFirst()/](this->get[end1.role.name.toUpperFirst()/]());
[/if]
[/template]


[**
 * Template for generation of array pattern between a part and a part with port
*/]
[template private initArrayPattern_P_PWP(aConnector : Connector){end1 : ConnectorEnd = aConnector.end->at(1); end2 : ConnectorEnd = aConnector.end->at(2); definingAssociation : Association = aConnector.type;}]
[if(definingAssociation.memberEnd->at(1).getUpper() <> 1)] [comment *-multiplicity/]
unsigned int k = 0;
for(unsigned int i = 0; i < [end2.partWithPort.getLower()/]; i++)
{
	std::shared_ptr<[end2.partWithPort.type.transformType()/]> end2Part = this->get[end2.partWithPort.name.toUpperFirst()/]()->at(i);

	for(unsigned int j = 0; j < [end2.role.oclAsType(MultiplicityElement).getLower()/]; j++)
	{
		std::shared_ptr<[end2.role.type.transformType()/]> end2Port = end2Part->get[end2.role.name.toUpperFirst()/]()->at(j);
		std::shared_ptr<[end1.role.type.transformType()/]> end1Part = this->get[end1.role.name.toUpperFirst()/]()->at(k);

		end2Port->get[end2.getDefiningEnd().name.toUpperFirst()/]()->add(end1Part);
		end1Part->get[end1.getDefiningEnd().name.toUpperFirst()/]()->add(end2Port);

		k++;
	}
}
[else] [comment 1-multiplicity/]
std::shared_ptr<[end1.role.type.transformType()/]> end1Part = this->get[end1.role.name.toUpperFirst()/]();
std::shared_ptr<[end2.role.type.transformType()/]> end2Port = this->get[end2.partWithPort.name.toUpperFirst()/]()->get[end2.role.name.toUpperFirst()/]();
end1Part->set[end1.getDefiningEnd().name.toUpperFirst()/](end2Port);
end2Port->set[end2.getDefiningEnd().name.toUpperFirst()/](end1Part);
[/if]
[/template]


[**
 * Template for generation of array pattern between a part with port and a part
*/]
[template private initArrayPattern_PWP_P(aConnector : Connector){end1 : ConnectorEnd = aConnector.end->at(1); end2 : ConnectorEnd = aConnector.end->at(2); definingAssociation : Association = aConnector.type;}]
[if(definingAssociation.memberEnd->at(1).getUpper() <> 1)] [comment *-multiplicity/]
unsigned int k = 0;
for(unsigned int i = 0; i < [end1.partWithPort.getLower()/]; i++)
{
	std::shared_ptr<[end1.partWithPort.type.transformType()/]> end1Part = this->get[end1.partWithPort.name.toUpperFirst()/]()->at(i);

	for(unsigned int j = 0; j < [end1.role.oclAsType(MultiplicityElement).getLower()/]; j++)
	{
		std::shared_ptr<[end1.role.type.transformType()/]> end1Port = end1Part->get[end1.role.name.toUpperFirst()/]()->at(j);
		std::shared_ptr<[end2.role.type.transformType()/]> end2Part = this->get[end2.role.name.toUpperFirst()/]()->at(k);

		end1Port->get[end1.getDefiningEnd().name.toUpperFirst()/]()->add(end2Part);
		end2Part->get[end2.getDefiningEnd().name.toUpperFirst()/]()->add(end1Port);

		k++;
	}
}
[else] [comment 1-multiplicity/]
std::shared_ptr<[end1.role.type.transformType()/]> end1Port = this->get[end1.partWithPort.name.toUpperFirst()/]()->get[end1.role.name.toUpperFirst()/]();
std::shared_ptr<[end2.role.type.transformType()/]> end2Part = this->get[end2.role.name.toUpperFirst()/]();
end1Port->set[end1.getDefiningEnd().name.toUpperFirst()/](end2Part);
end2Part->set[end2.getDefiningEnd().name.toUpperFirst()/](end1Port);
[/if]
[/template]


[**
 * Template for generation of array pattern between a part with port and a part with port
*/]
[template private initArrayPattern_PWP_PWP(aConnector : Connector){end1 : ConnectorEnd = aConnector.end->at(1); end2 : ConnectorEnd = aConnector.end->at(2); definingAssociation : Association = aConnector.type;}]
[if(definingAssociation.memberEnd->at(1).getUpper() <> 1)] [comment *-multiplicity/]
unsigned int end1PartIndex = 0, end2PartIndex = 0, end1PortIndex = 0, end2PortIndex = 0;
while((end1PartIndex < [end1.partWithPort.getLower()/]) &&(end2PartIndex < [end2.partWithPort.getLower()/]))
{
	std::shared_ptr<[end1.partWithPort.type.transformType()/]> end1Part = this->get[end1.partWithPort.name.toUpperFirst()/]()->at(end1PartIndex);
	std::shared_ptr<[end2.partWithPort.type.transformType()/]> end2Part = this->get[end2.partWithPort.name.toUpperFirst()/]()->at(end2PartIndex);

	while((end1PortIndex < [end1.role.oclAsType(MultiplicityElement).getLower()/]) && (end2PortIndex < [end2.role.oclAsType(MultiplicityElement).getLower()/]))
	{
		std::shared_ptr<[end1.role.type.transformType()/]> end1Port = end1Part->get[end1.role.name.toUpperFirst()/]()->at(end1PortIndex);
		std::shared_ptr<[end2.role.type.transformType()/]> end2Port = end2Part->get[end2.role.name.toUpperFirst()/]()->at(end2PortIndex);

		end1Port->get[end1.getDefiningEnd().name.toUpperFirst()/]()->add(end2Port);
		end2Port->get[end2.getDefiningEnd().name.toUpperFirst()/]()->add(end1Port);

		end1PortIndex++;
		end2PortIndex++;
	}
	if(end1PortIndex >= [end1.role.oclAsType(MultiplicityElement).getLower()/])
	{
		end1PortIndex = 0;
		end1PartIndex++;
	}
	if(end2PortIndex >= [end2.role.oclAsType(MultiplicityElement).getLower()/])
	{
		end2PortIndex = 0;
		end2PartIndex++;
	}
}
[else] [comment 1-multiplicity/]
std::shared_ptr<[end1.role.type.transformType()/]> end1Port = this->get[end1.partWithPort.name.toUpperFirst()/]()->get[end1.role.name.toUpperFirst()/]();
std::shared_ptr<[end2.role.type.transformType()/]> end2Port = this->get[end2.partWithPort.name.toUpperFirst()/]()->get[end2.role.name.toUpperFirst()/]();
end1Port->set[end1.getDefiningEnd().name.toUpperFirst()/](end2Port);
end2Port->set[end2.getDefiningEnd().name.toUpperFirst()/](end1Port);
[/if]
[/template]





[template private generateStarPatternInstantiation(aConnector : Connector){end1 : ConnectorEnd = aConnector.end->at(1); end2 : ConnectorEnd = aConnector.end->at(2); definingAssociation : Association = aConnector.type;}]
[comment TODO: Implement instatiation if ends are parts with ports /]
[if(not definingAssociation.oclIsUndefined())]
[if(end1.partWithPort.oclIsUndefined() and end2.partWithPort.oclIsUndefined())]
[aConnector.initStarPattern_P_P()/]
[elseif(end1.partWithPort.oclIsUndefined() and (not end2.partWithPort.oclIsUndefined()))]
[aConnector.initStarPattern_P_PWP()/]
[elseif((not end1.partWithPort.oclIsUndefined()) and end2.partWithPort.oclIsUndefined())]
[aConnector.initStarPattern_PWP_P()/]
[else]
[aConnector.initStarPattern_PWP_PWP()/]
[/if]
[else]
/*
Error: Untyped connector '[aConnector.name/]'. A connector must have one and only one association set as its type.
*/
[/if]
[/template]


[**
 * Template for generation of star pattern between a part and a part
*/]
[template private initStarPattern_P_P(aConnector : Connector){end1 : ConnectorEnd = aConnector.end->at(1); end2 : ConnectorEnd = aConnector.end->at(2); definingAssociation : Association = aConnector.type;}]
[if(definingAssociation.memberEnd->at(1).getUpper() <> 1)] [comment *-multiplicity/]
for(unsigned int i = 0; i < [end1.role.oclAsType(MultiplicityElement).getLower()/]; i++)
{
	for(unsigned int j = 0; j < [end2.role.oclAsType(MultiplicityElement).getLower()/]; j++)
	{
		this->get[end1.role.name.toUpperFirst()/]()->at(i)->get[end1.getDefiningEnd().name.toUpperFirst()/]()->add(this->get[end2.role.name.toUpperFirst()/]()->at(j));
		this->get[end2.role.name.toUpperFirst()/]()->at(j)->get[end2.getDefiningEnd().name.toUpperFirst()/]()->add(this->get[end1.role.name.toUpperFirst()/]()->at(i));
	}
}
[else] [comment 1-multiplicity/]
this->get[end1.role.name.toUpperFirst()/]()->set[end1.getDefiningEnd().name.toUpperFirst()/](this->get[end2.role.name.toUpperFirst()/]());
this->get[end2.role.name.toUpperFirst()/]()->set[end2.getDefiningEnd().name.toUpperFirst()/](this->get[end1.role.name.toUpperFirst()/]());
[/if]
[/template]


[**
 * Template for generation of star pattern between a part and a part with port
*/]
[template private initStarPattern_P_PWP(aConnector : Connector){end1 : ConnectorEnd = aConnector.end->at(1); end2 : ConnectorEnd = aConnector.end->at(2); definingAssociation : Association = aConnector.type;}]
[if(definingAssociation.memberEnd->at(1).getUpper() <> 1)] [comment *-multiplicity/]
for(unsigned int i = 0; i < [end2.partWithPort.getLower()/]; i++)
{
	std::shared_ptr<[end2.partWithPort.type.transformType()/]> end2Part = this->get[end2.partWithPort.name.toUpperFirst()/]()->at(i);

	for(unsigned int j = 0; j < [end2.role.oclAsType(MultiplicityElement).getLower()/]; j++)
	{
		std::shared_ptr<[end2.role.type.transformType()/]> end2Port = end2Part->get[end2.role.name.toUpperFirst()/]()->at(j);

		for(unsigned int k = 0; k < [end1.role.oclAsType(MultiplicityElement).getLower()/]; k++)
		{
			std::shared_ptr<[end1.role.type.transformType()/]> end1Part = this->get[end1.role.name.toUpperFirst()/]()->at(k);

			end2Port->get[end2.getDefiningEnd().name.toUpperFirst()/]()->add(end1Part);
			end1Part->get[end1.getDefiningEnd().name.toUpperFirst()/]()->add(end2Port);
		}
	}
}
[else] [comment 1-multiplicity/]
std::shared_ptr<[end1.role.type.transformType()/]> end1Part = this->get[end1.role.name.toUpperFirst()/]();
std::shared_ptr<[end2.role.type.transformType()/]> end2Port = this->get[end2.partWithPort.name.toUpperFirst()/]()->get[end2.role.name.toUpperFirst()/]();
end1Part->set[end1.getDefiningEnd().name.toUpperFirst()/](end2Port);
end2Port->set[end2.getDefiningEnd().name.toUpperFirst()/](end1Part);
[/if]
[/template]


[**
 * Template for generation of star pattern between a part with port and a part
*/]
[template private initStarPattern_PWP_P(aConnector : Connector){end1 : ConnectorEnd = aConnector.end->at(1); end2 : ConnectorEnd = aConnector.end->at(2); definingAssociation : Association = aConnector.type;}]
[if(definingAssociation.memberEnd->at(1).getUpper() <> 1)] [comment *-multiplicity/]
for(unsigned int i = 0; i < [end1.partWithPort.getLower()/]; i++)
{
	std::shared_ptr<[end1.partWithPort.type.transformType()/]> end1Part = this->get[end1.partWithPort.name.toUpperFirst()/]()->at(i);

	for(unsigned int j = 0; j < [end1.role.oclAsType(MultiplicityElement).getLower()/]; j++)
	{
		std::shared_ptr<[end1.role.type.transformType()/]> end1Port = end1Part->get[end1.role.name.toUpperFirst()/]()->at(j);

		for(unsigned int k = 0; k < [end2.role.oclAsType(MultiplicityElement).getLower()/]; k++)
		{
			std::shared_ptr<[end2.role.type.transformType()/]> end2Part = this->get[end2.role.name.toUpperFirst()/]()->at(k);

			end1Port->get[end1.getDefiningEnd().name.toUpperFirst()/]()->add(end2Part);
			end2Part->get[end2.getDefiningEnd().name.toUpperFirst()/]()->add(end1Port);
		}
	}
}
[else] [comment 1-multiplicity/]
std::shared_ptr<[end1.role.type.transformType()/]> end1Port = this->get[end1.partWithPort.name.toUpperFirst()/]()->get[end1.role.name.toUpperFirst()/]();
std::shared_ptr<[end2.role.type.transformType()/]> end2Part = this->get[end2.role.name.toUpperFirst()/]();
end1Port->set[end1.getDefiningEnd().name.toUpperFirst()/](end2Part);
end2Part->set[end2.getDefiningEnd().name.toUpperFirst()/](end1Port);
[/if]
[/template]


[**
 * Template for generation of star pattern between a part with port and a part with port
*/]
[template private initStarPattern_PWP_PWP(aConnector : Connector){end1 : ConnectorEnd = aConnector.end->at(1); end2 : ConnectorEnd = aConnector.end->at(2); definingAssociation : Association = aConnector.type;}]
[if(definingAssociation.memberEnd->at(1).getUpper() <> 1)] [comment *-multiplicity/]
for(unsigned int i = 0; i < [end1.partWithPort.getLower()/]; i++)
{
	std::shared_ptr<[end1.partWithPort.type.transformType()/]> end1Part = this->get[end1.partWithPort.name.toUpperFirst()/]()->at(i);

	for(unsigned int j = 0; j < [end1.role.oclAsType(MultiplicityElement).getLower()/]; j++)
	{
		std::shared_ptr<[end1.role.type.transformType()/]> end1Port = end1Part->get[end1.role.name.toUpperFirst()/]()->at(j);

		for(unsigned int k = 0; k < [end2.partWithPort.getLower()/]; k++)
		{
			std::shared_ptr<[end2.partWithPort.type.transformType()/]> end2Part = this->get[end2.partWithPort.name.toUpperFirst()/]()->at(k);

			for(unsigned int l = 0; l < [end2.role.oclAsType(MultiplicityElement).getLower()/]; l++)
			{
				std::shared_ptr<[end2.role.type.transformType()/]> end2Port = end2Part->get[end2.role.name.toUpperFirst()/]()->at(l);
				end1Port->get[end1.getDefiningEnd().name.toUpperFirst()/]()->add(end2Port);
				end2Port->get[end2.getDefiningEnd().name.toUpperFirst()/]()->add(end1Port);
			}
		}		
	}
}
[else] [comment 1-multiplicity/]
std::shared_ptr<[end1.role.type.transformType()/]> end1Port = this->get[end1.partWithPort.name.toUpperFirst()/]()->get[end1.role.name.toUpperFirst()/]();
std::shared_ptr<[end2.role.type.transformType()/]> end2Port = this->get[end2.partWithPort.name.toUpperFirst()/]()->get[end2.role.name.toUpperFirst()/]();
end1Port->set[end1.getDefiningEnd().name.toUpperFirst()/](end2Port);
end2Port->set[end2.getDefiningEnd().name.toUpperFirst()/](end1Port);
[/if]
[/template]


[**
 *****************************************************************************************************************************************************************************************
 *****************************************************************************************************************************************************************************************
*/]


[query private getCardinality(aConnectorEnd : ConnectorEnd) : Integer = 
if(aConnectorEnd.role.oclIsKindOf(MultiplicityElement)) then
	if(aConnectorEnd.role.oclAsType(MultiplicityElement).getLower() = 0) then
		0
	else 
		if (aConnectorEnd.partWithPort.oclIsUndefined()) then
			(aConnectorEnd.role.oclAsType(MultiplicityElement).getLower())
		else ((aConnectorEnd.role.oclAsType(MultiplicityElement).getLower()) * (aConnectorEnd.partWithPort.getLower()))
		endif
	endif
else -100
endif
/]

[query private isArrayPattern(aConnector : Connector) : Boolean =
if(aConnector.end->size() = 2) then
	if(aConnector.end->at(1).role.oclIsKindOf(MultiplicityElement)) then
		if(aConnector.end->at(1).getLower() = 1) then
			if(aConnector.end->at(2).role.oclIsKindOf(MultiplicityElement)) then
				if(aConnector.end->at(2).getLower() = 1) then
					if((aConnector.end->at(1).role.oclAsType(Property).canInstantiate()) and (aConnector.end->at(2).role.oclAsType(Property).canInstantiate())) then
						((aConnector.end->at(1).getCardinality()) = (aConnector.end->at(2).getCardinality()) and aConnector.end->at(1).getCardinality() > 0 and aConnector.end->at(2).getCardinality() > 0)
					else false
					endif
				else false
				endif
			else false
			endif
		else false
		endif
	else false
	endif
else false
endif
/]

[query private isStarPattern(aConnector : Connector) : Boolean =
if(aConnector.end->size() = 2) then
	if(aConnector.end->at(1).role.oclIsKindOf(MultiplicityElement)) then
		if(aConnector.end->at(2).role.oclIsKindOf(MultiplicityElement)) then
			if((aConnector.end->at(1).role.oclAsType(Property).canInstantiate()) and (aConnector.end->at(2).role.oclAsType(Property).canInstantiate())) then
				if((aConnector.end->at(1).getCardinality()) = (aConnector.end->at(1).getLower()) and aConnector.end->at(1).getLower() > 0) then
					((aConnector.end->at(2).getCardinality()) = (aConnector.end->at(2).getLower()) and aConnector.end->at(2).getLower() > 0)
				else false
				endif
			else false
			endif
		else false
		endif
	else false
	endif
else false
endif
/]


[query private getDefiningEnd(aConnectorEnd : ConnectorEnd) : Property = (aConnectorEnd.owner.oclAsType(Connector).type.memberEnd->asOrderedSet()->select(type = aConnectorEnd.role.type))->first()/]