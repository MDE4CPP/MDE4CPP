<?xml version="1.0" encoding="UTF-8"?>
<ecore:EPackage xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore" name="PSSM" nsURI="http://www.omg.org/spec/PSSM/20161101" nsPrefix="PSSM">
  <eSubpackages name="Semantics" nsURI="http:///PSSM/Semantics.ecore" nsPrefix="PSSM.Semantics">
    <eSubpackages name="Values" nsURI="http:///PSSM/Semantics/Values.ecore" nsPrefix="PSSM.Semantics.Values">
      <eClassifiers xsi:type="ecore:EClass" name="SM_OpaqueExpressionEvaluation">
        <eOperations name="executeExpressionBehavior" ordered="false" upperBound="-1"
            eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// An opaque expression can have an associated behavior. If this is the case&#xD;&#xA;// this behavior is executed. Values produced by the execution of the behavior&#xD;&#xA;// are the result of the evaluation of the opaque expression &#xD;&#xA;//List&lt;Value> evaluation = new ArrayList&lt;Value>();&#xD;&#xA;//OpaqueExpression expression = (OpaqueExpression)this.specification;&#xD;&#xA;//Behavior behavior = expression.getBehavior();&#xD;&#xA;//if(behavior != null) {&#xD;&#xA;//&#x9;List&lt;ParameterValue> results = this.locus.executor.execute(behavior, context, this.parameterValues);&#xD;&#xA;//&#x9;for(int i = 0; i &lt; results.size(); i++) { // results.size should be 1&#xD;&#xA;//&#x9;&#x9;ParameterValue parameterValue = results.get(i);&#xD;&#xA;//&#x9;&#x9;List&lt;Value> values = parameterValue.values;&#xD;&#xA;//&#x9;&#x9;for(int j = 0; j &lt; values.size(); j++) {&#xD;&#xA;//&#x9;&#x9;&#x9;evaluation.add(values.get(j));&#xD;&#xA;//&#x9;&#x9;}&#xD;&#xA;//&#x9;}&#xD;&#xA;//}&#xD;&#xA;//return evaluation;&#xD;&#xA;&#x9;return nullptr;&#xD;&#xA;&#x9;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="initialize" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// The event occurrence that is about or is currently dispatched can&#xA;// have data. In such situation if the behavior that is associated&#xA;// to the OpaqueExpression input conforms with the proposed signal&#xA;// event occurrence or the input parameters of the call event occurrence&#xA;// then event occurrence data are passed to this behavior and used&#xA;// to produce the guard verdict.&#xA;//this.parameterValues.clear();&#xA;//OpaqueExpression expression = (OpaqueExpression)this.specification;&#xA;//if(expression.getBehavior().getOwnedParameters().size() > 0){&#xA;//&#x9;Behavior behavior = expression.getBehavior();&#xA;//&#x9;if(eventOccurrence instanceof SignalEventOccurrence){&#xA;//&#x9;&#x9;SignalEventOccurrence signalEventOccurrence = (SignalEventOccurrence) eventOccurrence;&#xA;//&#x9;&#x9;if(behavior.inputParameters().size() == 1){&#xA;//&#x9;&#x9;&#x9;Parameter parameter = behavior.inputParameters().get(0);&#xA;//&#x9;&#x9;&#x9;ParameterValue parameterValue = new ParameterValue();&#xA;//&#x9;&#x9;&#x9;parameterValue.parameter = parameter;&#xA;//&#x9;&#x9;&#x9;List&lt;Value> values = new ArrayList&lt;Value>();&#xA;//&#x9;&#x9;&#x9;values.add(signalEventOccurrence.signalInstance);&#xA;//&#x9;&#x9;&#x9;parameterValue.values = values;&#xA;//&#x9;&#x9;&#x9;this.setParameterValue(parameterValue);&#xA;//&#x9;&#x9;}&#xA;//&#x9;}else if(eventOccurrence instanceof CallEventOccurrence){&#xA;//&#x9;&#x9;CallEventOccurrence callEventOccurrence = (CallEventOccurrence) eventOccurrence;&#xA;//&#x9;&#x9;List&lt;Parameter> behaviorInputParameters = behavior.inputParameters();&#xA;//&#x9;&#x9;List&lt;ParameterValue> inputParameterValues = callEventOccurrence.execution.getInputParameterValues();&#xA;//&#x9;&#x9;if(behaviorInputParameters.size() == inputParameterValues.size()){&#xA;//&#x9;&#x9;&#x9;int i = 1;&#xA;//&#x9;&#x9;&#x9;while(i &lt;= behaviorInputParameters.size()){&#xA;//&#x9;&#x9;&#x9;&#x9;ParameterValue parameterValue = new ParameterValue();&#xA;//&#x9;&#x9;&#x9;&#x9;parameterValue.parameter = behaviorInputParameters.get(i - 1);&#xA;//&#x9;&#x9;&#x9;&#x9;parameterValue.values = inputParameterValues.get(i - 1).values;&#xA;//&#x9;&#x9;&#x9;&#x9;this.setParameterValue(parameterValue);&#xA;//&#x9;&#x9;&#x9;&#x9;i++;&#xA;//&#x9;&#x9;&#x9;}&#xA;//&#x9;&#x9;}&#xA;//&#x9;}&#xA;//}&#xA;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="getParameterValue" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/ParameterValue">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Return the parameter value corresponding to the given parameter.&#xD;&#xA;&#x9;// Null is returned if no parameter value associated with the parameter&#xD;&#xA;&#x9;// is found.&#xD;&#xA;&#x9;//int i = 0;&#xD;&#xA;&#x9;//ParameterValue parameterValue = null;&#xD;&#xA;&#x9;//while(parameterValue == null &amp;&amp; i &lt; this.parameterValues.size()){&#xD;&#xA;&#x9;//&#x9;if(this.parameterValues.get(i).parameter == parameter){&#xD;&#xA;&#x9;//&#x9;&#x9;parameterValue = this.parameterValues.get(i);&#xD;&#xA;&#x9;//&#x9;}&#xD;&#xA;&#x9;//&#x9;i++;&#xD;&#xA;&#x9;//}&#xD;&#xA;&#x9;//return parameterValue;&#xD;&#xA;&#x9;return nullptr;"/>
          </eAnnotations>
          <eParameters name="parameter" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Parameter"/>
        </eOperations>
        <eOperations name="setParameterValue" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// If this parameter value does not exist then it is added&#xA;// to the list parameter values&#xA;//if(this.getParameterValue(parameterValue.parameter) == null){&#xA;//&#x9;this.parameterValues.add(parameterValue);&#xA;//}&#xA;"/>
          </eAnnotations>
          <eParameters name="parameterValue" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/ParameterValue"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="context" ordered="false"
            eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/ParameterValue"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="parameterValues" ordered="false"
            upperBound="-1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/ParameterValue"/>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="StructuredClassifiers" nsURI="http:///PSSM/Semantics/StructuredClassifiers.ecore"
        nsPrefix="PSSM.Semantics.StructuredClassifiers">
      <eClassifiers xsi:type="ecore:EClass" name="SM_Object" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/StructuredClassifiers/Object">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="doNotGenerate" value="Class 'SM_Object' is excluded from generation because it is obsolete.&#xD;&#xA;Objects are represented by class PSSM::MDE4CPP_Extensions::PSSM_Object in this PSSM implementation.&#xD;&#xA;This is possible because in MDE4CPP, all C++ classes generated from UML classes can be used directly as their own objects.&#xD;&#xA;All Functionalities provided by this PSSM::StructuredClassifiers::SM_Object is included in the FUML_Object which is the base class for all generated C++ classes"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="SM_RedefinitionBasedDispatchStrategy">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;fUML/Semantics/Loci/Locus.hpp&quot;&#xD;&#xA;#include &quot;fUML/Semantics/Loci/ExecutionFactory.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="getMethod" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Behavior">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Behaves as in fUML and PSCS except that if no method is declared&#xD;&#xA;&#x9;// for the operation then null is returned.&#xD;&#xA;&#x9;/*auto method = std::make_shared&lt;uml::Behavior>();&#xD;&#xA;&#x9;for (auto type : *(object->getTypes()))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;for (auto memberOperation : *(type->getAllOperations()))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;if (memberOperation == operation)&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;method = memberOperation->getMethod()->operator[](0);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return method;*/&#xD;&#xA;&#x9;return nullptr;&#xD;&#xA;&#xD;&#xA;&#x9;/*Behavior method = null;&#xD;&#xA;&#x9;int i = 1;&#xD;&#xA;&#x9;while (method == null &amp; i &lt;= object.types.size()) {&#xD;&#xA;&#x9;&#x9;Class type = object.types.get(i - 1);&#xD;&#xA;&#x9;&#x9;List&lt;NamedElement> members = type.getMembers();&#xD;&#xA;&#x9;&#x9;int j = 1;&#xD;&#xA;&#x9;&#x9;while (method == null &amp; j &lt;= members.size()) {&#xD;&#xA;&#x9;&#x9;&#x9;NamedElement member = members.get(j - 1);&#xD;&#xA;&#x9;&#x9;&#x9;if (member instanceof Operation) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;Operation memberOperation = (Operation) member;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (this.operationsMatch(memberOperation, operation)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(memberOperation.getMethods().size() > 0){&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;method = memberOperation.getMethods().get(0);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;j = j + 1;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;i = i + 1;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return method;*/"/>
          </eAnnotations>
          <eParameters name="object" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//MDE4CPP_Extensions/FUML_Object"/>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
        </eOperations>
        <eOperations name="dispatch" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/Execution">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Try to dispatch the operation has specified in fUML. If no method is defined&#xD;&#xA;&#x9;// for the dispatched operation then null is returned. In this situation, the&#xD;&#xA;&#x9;// dispatching of the operation is computed as being by with using the&#xD;&#xA;&#x9;// call event semantics.&#xD;&#xA;&#x9;auto method = this->getMethod(object, operation);&#xD;&#xA;&#x9;if (method != nullptr)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;auto execution = object->getLocus()->getFactory()->createExecution(method, object);&#xD;&#xA;&#x9;&#x9;return execution;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;else&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;/*auto execution = std::make_shared&lt;PSSM::Semantics::CommonBehavior::CallEventExecution>();&#xD;&#xA;&#x9;&#x9;execution->setContext(object);&#xD;&#xA;&#x9;&#x9;execution->setOperation(operation);&#xD;&#xA;&#x9;&#x9;return execution;*/&#xD;&#xA;&#x9;&#x9;return nullptr;&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;/*Execution execution = null;&#xD;&#xA;&#x9;Behavior method = this.getMethod(object, operation);&#xD;&#xA;&#x9;if(method == null){&#xD;&#xA;&#x9;&#x9;execution = new CallEventExecution();&#xD;&#xA;&#x9;&#x9;execution.context = object;&#xD;&#xA;&#x9;&#x9;((CallEventExecution)execution).operation = operation;&#xD;&#xA;&#x9;}else{&#xD;&#xA;&#x9;&#x9;execution = object.locus.factory.createExecution(method, object);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return execution;*/"/>
          </eAnnotations>
          <eParameters name="object" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//MDE4CPP_Extensions/FUML_Object"/>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
        </eOperations>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="CommonBehavior" nsURI="http:///PSSM/Semantics/CommonBehavior.ecore"
        nsPrefix="PSSM.Semantics.CommonBehavior">
      <eClassifiers xsi:type="ecore:EClass" name="SM_ObjectActivation" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/ObjectActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;fUML/FUMLFactory.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="getNextCompletionEvent" ordered="false" lowerBound="1"
            eType="#//Semantics/StateMachines/CompletionEventOccurrence">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="for (const auto&amp; eventOccurrence : *(this->m_eventPool))&#xA;&#x9;{&#xA;&#x9;&#x9;if (const auto&amp; completionEventOccurence = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::CompletionEventOccurrence>(eventOccurrence))&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;// Delete EventOccurrence from the Event Pool here as fUML::ObjectActivation::retrieveNextEvent is not called for CompletionEventOccurrences.&#xA;&#x9;&#x9;&#x9;this->m_eventPool->erase(completionEventOccurence);&#xA;&#x9;&#x9;&#x9;return completionEventOccurence;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return nullptr;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getDeferredEventInsertionIndex" ordered="false" lowerBound="1"
            eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Integer">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Deferred events are always registered after completion events if any.&#xD;&#xA;&#x9;// Return the insertion point for deferred events.&#xD;&#xA;&#x9;for (const auto&amp; event : *(m_eventPool))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (const auto&amp; deferredEvent = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::DeferredEventOccurrence>(event)) &#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;return m_eventPool->index_of(event);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return -1;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="registerCompletionEvent" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Create a CompletionEvent for the given StateActivation&#xD;&#xA;&#x9;const auto&amp; completionEventOccurrence(PSSM::Semantics::StateMachines::StateMachinesFactory::eInstance()->createCompletionEventOccurrence());&#xD;&#xA;&#x9;completionEventOccurrence->setStateActivation(stateActivation);&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;// Place it in the Event Pool&#xD;&#xA;&#x9;std::unique_lock lock(*m_mutex);&#xD;&#xA;&#x9;this->m_eventPool->push_back(completionEventOccurrence);&#xD;&#xA;&#x9;lock.unlock();&#x9;&#xD;&#xA;&#xD;&#xA;&#x9;DEBUG_INFO(&quot;StateActivation &quot; &lt;&lt; stateActivation &lt;&lt; &quot; registered an CompletionEventOccurrence!&quot;)&#xD;&#xA;&#x9;this->m_conditionVariable->notify_one();"/>
          </eAnnotations>
          <eParameters name="stateActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateActivation"/>
        </eOperations>
        <eOperations name="releaseDeferredEvents" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// The release of event occurrence(s) deferred by the deferring state implIncludes the following step:..."/>
          </eAnnotations>
          <eParameters name="deferringState" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateActivation"/>
        </eOperations>
        <eOperations name="registerDeferredEvent" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// An event occurrence registered as being deferred is registered within the deferred event pool.&#xA;//DeferredEventOccurrence deferredEventOccurrence = new DeferredEventOccurrence();&#xA;//deferredEventOccurrence.constrainingStateActivation = deferringState;&#xA;//deferredEventOccurrence.deferredEventOccurrence = eventOccurrence;&#xA;//this.deferredEventPool.add(deferredEventOccurrence);&#xA;&#xA;//std::shared_ptr&lt;PSSM::Semantics::StateMachines::DeferredEventOccurrence> deferredEventOccurrence = new PSSM::Semantics::StateMachines::DeferredEventOccurrence();&#xA;//deferredEventOccurrence->setDeferredEventOccurrence(eventOccurrence);&#xA;//this->m_deferredEventPool->add(deferredEventOccurrence);"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="stateActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateActivation"/>
        </eOperations>
        <eOperations name="retrieveNextEvent" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// REPLACES GETNEXTEVENT()&#xD;&#xA;&#x9;// Redefinition of fUML::ObjectActivation to accommodate to priorities of PSSM-specific EventOccurrences:&#xD;&#xA;&#x9;// All CompletionEventOccurrences are dispatched first. They are dispatched according to their order of arrival in the pool. &#xD;&#xA;&#x9;// Only if no CompletionEventOccurrences are in the pool, then regular EventOccurrences are dispatched according to the set dispatching policy. &#xD;&#xA;&#x9;// Note that if the currently dispatched EventOccurrence was previously deferred, &#xD;&#xA;&#x9;// then it is unwrapped and its encapsulated 'deferredEventOccurrence' is actually dispatched.&#xD;&#xA;&#x9;auto nextEvent = std::dynamic_pointer_cast&lt;fUML::Semantics::CommonBehavior::EventOccurrence>(this->getNextCompletionEvent());&#xD;&#xA;&#x9;if(nextEvent == nullptr)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;nextEvent = this->getThisObjectActivationPtr()->retrieveNextEvent();&#xD;&#xA;&#xD;&#xA;&#x9;&#x9;auto deferredEvent = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::DeferredEventOccurrence>(nextEvent);&#xD;&#xA;&#xD;&#xA;&#x9;&#x9;if( deferredEvent != nullptr)&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;nextEvent =  deferredEvent->getDeferredEventOccurrence();&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;return nextEvent;"/>
          </eAnnotations>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="deferredEventPool"
            ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/DeferredEventOccurrence"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="EventTriggeredExecution" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/Execution">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;fUML/FUMLFactory.hpp&quot;&#xD;&#xA;#include &quot;fUML/MDE4CPP_Extensions/FUML_SignalInstance.hpp&quot;&#xD;&#xA;#include &quot;fUML/Semantics/CommonBehavior/SignalEventOccurrence.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/CallEventOccurrence.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/CallEventExecution.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="finalize" ordered="false">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Transfer output ParameterValues (produced by the wrapped execution) back to&#xD;&#xA;&#x9;// the Execution associated to the CallEventOccurrence.&#xD;&#xA;&#x9;// If an effect, entry or exit Behavior is not just input-conforming, then the&#xD;&#xA;&#x9;// values of its output Parameters are passed out of its Behavior Execution on&#xD;&#xA;&#x9;// its completion as potential values for the output Parameters of the called &#xD;&#xA;&#x9;// Operation.&#xD;&#xA;&#x9;// Notes: &#xD;&#xA;&#x9;//    If the CallEvent is for a synchronous call, then the call ends at the end&#xD;&#xA;&#x9;//    of the triggered run-to-completion (RTC) step. If the called Operation has&#xD;&#xA;&#x9;//    output Parameters, then the values returned for those parameters are those&#xD;&#xA;&#x9;//    produced by the last effect, entry or exit Behavior to complete its execution&#xD;&#xA;&#x9;//    during the RTC step. Since some or all of those Behaviors may execute concurrently,&#xD;&#xA;&#x9;//    which one completes last may be only partially determined by the specified semantics.&#xD;&#xA;&#x9;//    The values returned may legally be those produced any Behavior that produces potential&#xD;&#xA;&#x9;//    output values and is the last to complete in any execution trace for the RTC&#xD;&#xA;&#x9;//    step consistent with the specified StateMachine semantics.&#xD;&#xA;&#x9;this->_beginIsolation();&#xD;&#xA;&#x9;if (const auto&amp; callEventOccurrence = std::dynamic_pointer_cast&lt;PSSM::Semantics::CommonBehavior::CallEventOccurrence>(this->getTriggeringEventOccurrence()))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;const auto&amp; outputParameterValues = this->getWrappedExecution()->getOutputParameterValues();&#xD;&#xA;&#x9;&#x9;if(this->getWrappedExecution()->getBehavior()->outputParameters()->size() == outputParameterValues->size())&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;const auto&amp; behaviorOutputParameters = callEventOccurrence->getExecution()->getBehavior()->outputParameters();&#xD;&#xA;&#x9;&#x9;&#x9;for (unsigned int i = 0; i &lt; behaviorOutputParameters->size(); ++i)&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;auto parameterValue = fUML::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createParameterValue();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;parameterValue->setParameter(behaviorOutputParameters->at(i));&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;parameterValue->getValues()->insert(*(outputParameterValues->at(i)->getValues()));&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;callEventOccurrence->getExecution()->setParameterValue(parameterValue);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;this->_endIsolation();"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="execute" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="documentation" value="Execute the behavior given by the type of this execution. &#xD;&#xA;The parameterValues for any input (in or in-out) parameters of the behavior should be set before the execution.&#xD;&#xA;The parameteValues for any output (in-out, out or return) parameters of the behavior will be set by the execution.&#xD;&#xA;"/>
            <details key="body" value="// The Behavior handled by the wrappedExecution is parameterized&#xD;&#xA;&#x9;// with the input ParameterValues provided by the triggeringEventOccurrence.&#xD;&#xA;&#x9;// The Behavior is then executed and finally, the outputParameterValues are passed to the triggeringEventOccurrence &#xD;&#xA;&#x9;// (only occurs in the case of a CallEventOccurrence).&#xD;&#xA;&#x9;if(this->getWrappedExecution() != nullptr &amp;&amp; this->getTriggeringEventOccurrence() != nullptr)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;const auto&amp; inputParameterValues = this->initialize(this->getWrappedExecution()->getBehavior());&#xD;&#xA;&#x9;&#x9;for (const auto&amp; inputParameterValue : *inputParameterValues)&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;this->getWrappedExecution()->setParameterValue(inputParameterValue);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;this->getWrappedExecution()->execute();&#xD;&#xA;&#x9;&#x9;this->finalize();&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="initialize" ordered="false" upperBound="-1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/ParameterValue">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Transfer input parameter values of the call event execution&#xD;&#xA;&#x9;// to the wrapped execution if possible. &#xD;&#xA;&#x9;// Two situations are considered:&#xD;&#xA;&#x9;// 1. If the triggering EventOccurrence is for a SignalEvent, then all&#xD;&#xA;&#x9;//    executed Behaviors will have either one parameter or no parameters.&#xD;&#xA;&#x9;//    If the Behavior has one Parameter, the SignalInstance corresponding to&#xD;&#xA;&#x9;//    the SignalEventOccurrence is returned to be passed into the Behavior Execution as&#xD;&#xA;&#x9;//    the value of its parameter.&#xD;&#xA;&#x9;// 2. If the triggering EventOccurrence is for a CallEvent, then all executed&#xD;&#xA;&#x9;//    Behaviors will have either no Parameters or signatures that conform or&#xD;&#xA;&#x9;//    input conform to the Operation being called.&#xD;&#xA;&#x9;//    If a Behavior has parameters, then the values of the input parameters&#xD;&#xA;&#x9;//    for the call are returned to be passed into the Behavior Execution as the values&#xD;&#xA;&#x9;//    of the corresponding input parameters of the Behavior.&#xD;&#xA;&#x9;this->_beginIsolation();&#xD;&#xA;&#x9;auto parameterValues = std::make_shared&lt;Bag&lt;fUML::Semantics::CommonBehavior::ParameterValue>>();&#xD;&#xA;&#x9;if (behavior->getOwnedParameter()->size() > 0)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (const auto&amp; signalEventOccurrence = std::dynamic_pointer_cast&lt;fUML::Semantics::CommonBehavior::SignalEventOccurrence>(this->getTriggeringEventOccurrence()))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;if (behavior->inputParameters()->size() == 1)&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;auto parameterValue = fUML::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createParameterValue();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;parameterValue->setParameter(behavior->inputParameters()->at(0));&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;parameterValue->getValues()->push_back(std::dynamic_pointer_cast&lt;Any>(signalEventOccurrence->getSignalInstance()));&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;parameterValues->push_back(parameterValue);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;else if (const auto&amp; callEventOccurrence = std::dynamic_pointer_cast&lt;PSSM::Semantics::CommonBehavior::CallEventOccurrence>(this->getTriggeringEventOccurrence()))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;const auto&amp; behaviorInputParameters = behavior->inputParameters();&#xD;&#xA;&#x9;&#x9;&#x9;const auto&amp; inputParameterValues = callEventOccurrence->getExecution()->getInputParameterValues();&#xD;&#xA;&#x9;&#x9;&#x9;if (behaviorInputParameters->size() == inputParameterValues->size())&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;for (unsigned int i = 0; i &lt; behaviorInputParameters->size(); ++i)&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;auto parameterValue = fUML::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createParameterValue();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;parameterValue->setParameter(behaviorInputParameters->at(i));&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;parameterValue->getValues()->insert(*(inputParameterValues->at(i)->getValues()));&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;parameterValues->push_back(parameterValue);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;this->_endIsolation();&#xD;&#xA;&#x9;return parameterValues;"/>
          </eAnnotations>
          <eParameters name="behavior" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Behavior"/>
        </eOperations>
        <eOperations name="copy" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="auto copy = std::shared_ptr&lt;EventTriggeredExecutionImpl>(new EventTriggeredExecutionImpl);&#xA;&#x9;copy->setTriggeringEventOccurrence(this->getTriggeringEventOccurrence());&#xA;&#x9;copy->setWrappedExecution(this->getWrappedExecution());&#xA;&#x9;return std::make_shared&lt;Any>(copy);&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="new_" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="documentation" value="Create a new execution with no behavior or parameterValues.&#xD;&#xA;"/>
            <details key="body" value="return std::make_shared&lt;Any>(new EventTriggeredExecution());&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="wrappedExecution" ordered="false"
            lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/Execution"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="triggeringEventOccurrence"
            ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CallEventExecution" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/Execution">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;PSSM/Semantics/CommonBehavior/CallEventOccurrence.hpp&quot;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/CommonBehaviorFactory.hpp&quot;&#xA;#include &quot;fUML/FUMLFactory.hpp&quot;&#xA;#include &quot;uml/ParameterDirectionKind.hpp&quot;&#xA;#include &quot;uml/Parameter.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="_send" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Place the call event occurrence within the event pool of&#xA;// the target object&#xA;//if(this.context.objectActivation != null){&#xA;//&#x9;this.context.objectActivation.eventPool.add(eventOccurrence);&#xA;//&#x9;this.context.objectActivation._send(new ArrivalSignal());&#xA;//}&#xA;&#x9;// empty body because:&#xA;&#x9;// a) fUML::ObjectActivation::eventPool contains fUML::SignalInstance, not fUML::EventOccurrence (no common parent classes)&#xA;&#x9;// b) fUML::ObjectActvation::_send has an empty body too"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="#//Semantics/CommonBehavior/CallEventOccurrence"/>
        </eOperations>
        <eOperations name="_suspend" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="while(this->m_callerSuspended);"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="execute" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="documentation" value="Execute the behavior given by the type of this execution. &#xD;&#xA;The parameterValues for any input (in or in-out) parameters of the behavior should be set before the execution.&#xD;&#xA;The parameteValues for any output (in-out, out or return) parameters of the behavior will be set by the execution.&#xD;&#xA;"/>
            <details key="body" value="// The execution consists in placing a new CallEventOccurrence&#xA;// within the event pool of the target active object. Not that&#xA;// the call will not be executed if the target is not an active&#xA;// object. This is due to the fact that the call event could&#xA;// not placed anywhere since a passive object has no event pool.&#xA;// The caller is expected to be suspended until the RTC step using&#xA;// the event occurrence terminates.&#xA;//CallEventOccurrence eventOccurrence = new CallEventOccurrence();&#xA;//eventOccurrence.execution = this;&#xA;//this.callerSuspended = true;&#xA;//this._send(eventOccurrence);&#xA;//this._suspend();&#xA;&#x9;std::shared_ptr&lt;PSSM::Semantics::CommonBehavior::CallEventOccurrence> eventOccurrence = PSSM::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createCallEventOccurrence();&#xA;&#x9;eventOccurrence->setExecution(this->getThisCallEventExecutionPtr());&#xA;&#x9;this->m_callerSuspended = true;&#xA;&#x9;this->_send(eventOccurrence);&#xA;&#x9;this->_suspend();"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getBehavior" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Behavior">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value=""/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Compute a behavior signature corresponding to the operation&#xA;if(this.behavior == null){&#xA;&#x9;this.behavior = UMLFactory.eINSTANCE.createFunctionBehavior();&#xA;&#x9;for(int i = 0; i &lt; this.operation.getOwnedParameters().size(); i++){&#xA;&#x9;&#x9;Parameter operationParameter = this.operation.getOwnedParameters().get(i);&#xA;&#x9;&#x9;Parameter parameter = UMLFactory.eINSTANCE.createParameter();&#xA;&#x9;&#x9;parameter.setName(operationParameter.getName());&#xA;&#x9;&#x9;parameter.setType(operationParameter.getType());&#xA;&#x9;&#x9;parameter.setLower(operationParameter.getLower());&#xA;&#x9;&#x9;parameter.setUpper(operationParameter.getUpper());&#xA;&#x9;&#x9;parameter.setDirection(operationParameter.getDirection());&#xA;&#x9;&#x9;this.behavior.getOwnedParameters().add(parameter);&#xA;&#x9;}&#xA;}&#xA;return this.behavior;&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="new_" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="documentation" value="Create a new execution with no behavior or parameterValues.&#xD;&#xA;"/>
            <details key="body" value="return PSSM::PSSMFactory::eInstance()->createCallEventExecution();&#xD;&#xA;&#x9;//return eEcoreAny(PSSM::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createCallEventExecution(), PSSM::Semantics::CommonBehavior::CommonBehaviorPackage::CALLEVENTEXECUTION_CLASS);"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="releaseCaller" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="this->m_callerSuspended = false;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getInputParameterValues" ordered="false" upperBound="-1"
            eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/ParameterValue">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Return input parameter values for this execution&#xA;//List&lt;ParameterValue> parameterValues = new ArrayList&lt;ParameterValue>();&#xA;//for(int i=0; i &lt; this.parameterValues.size(); i++){&#xA;//&#x9;ParameterValue parameterValue = this.parameterValues.get(i);&#xA;//&#x9;if(parameterValue.parameter.getDirection() == ParameterDirectionKind.IN_LITERAL&#xA;//&#x9;&#x9;&#x9;| parameterValue.parameter.getDirection() == ParameterDirectionKind.INOUT_LITERAL){&#xA;//&#x9;&#x9;parameterValues.add(parameterValue);&#xA;//&#x9;}&#xA;//}&#xA;//return parameterValues;&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::CommonBehavior::ParameterValue>> parameterValues(new Bag&lt;fUML::Semantics::CommonBehavior::ParameterValue>());&#xA;&#x9;for(int i=0; i &lt; int(this->m_parameterValues->size()); i++) {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::CommonBehavior::ParameterValue> parameterValue = this->m_parameterValues->at(i);&#xA;&#x9;&#x9;if((parameterValue->getParameter()->getDirection() == uml::ParameterDirectionKind::IN) |&#xA;&#x9;&#x9;&#x9;&#x9;(parameterValue->getParameter()->getDirection() == uml::ParameterDirectionKind::INOUT)) {&#xA;&#x9;&#x9;&#x9;parameterValues->add(parameterValue);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return parameterValues;&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="callerSuspended" ordered="false"
            lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="callerContext" ordered="false"
            lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//MDE4CPP_Extensions/FUML_Object"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="operation" ordered="false"
            lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="behavior" ordered="false"
            lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Behavior"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CallEventOccurrence" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;fUML/FUMLFactory.hpp&quot;"/>
        </eAnnotations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="execution" ordered="false"
            lowerBound="1" eType="#//Semantics/CommonBehavior/CallEventExecution"/>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="StateMachines" nsURI="http:///PSSM/Semantics/StateMachines.ecore"
        nsPrefix="PSSM.Semantics.StateMachines">
      <eClassifiers xsi:type="ecore:EClass" name="RegionActivation" eSuperTypes="#//Semantics/StateMachines/StateMachineSemanticVisitor">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;uml/State.hpp&quot;&#xA;#include &quot;PSSM/Semantics/StateMachines/StateMachineExecution.hpp&quot;&#xA;#include &lt;condition_variable>"/>
        </eAnnotations>
        <eOperations name="terminate" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Capture the semantics related to the termination of a Region. Regions typically&#xD;&#xA;&#x9;// get terminated when the owning StateMachine terminates.&#xD;&#xA;&#x9;for (const auto&amp; vertexActivation : *m_vertexActivations) &#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;vertexActivation->terminate();&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;m_vertexActivations->clear();&#xD;&#xA;&#x9;m_transitionActivations->clear();"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getOrigin" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/InitialPseudostateActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Return, if any, the initial pseudo-state activation directly&#xD;&#xA;&#x9;// owned by this region.&#xD;&#xA;&#x9;for (const auto&amp; vertexActivation : *(this->m_vertexActivations))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (const auto&amp; initialPSActivation = std::dynamic_pointer_cast&lt;InitialPseudostateActivation>(vertexActivation))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;return initialPSActivation;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return nullptr;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getVertexActivations" ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/VertexActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="&#x9;return m_vertexActivations;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getTransitionActivations" ordered="false" upperBound="-1"
            eType="#//Semantics/StateMachines/TransitionActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="&#x9;return m_transitionActivations;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getVertexActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Recursive search through the hierarchy of Visitors materializing&#xA;&#x9;// the subset of the StateMachine represented by this Region.&#xA;&#x9;// The search is realized similar to a breadth-first search:&#xA;&#x9;// &#x9;1 - Search a matching Activation in set of VertexActivations owned by this RegionActivation&#xA;&#x9;//  2 - If no match, then the search call is propagated to each VertexActivation owned by this RegionActivation&#xA;&#x9;// Matching rules (or):&#xA;&#x9;//  1 - The node for which this Activation is an interpreter is the Vertex.&#xA;&#x9;//  2 - The node for which this Activation is an interpreter redefines the Vertex &#xA;&#x9;for (const auto&amp; vertexActivation : *this->getVertexActivations())&#xA;&#x9;{&#xA;&#x9;&#x9;if(vertexActivation->isVisitorFor(vertex))&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return vertexActivation;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;for (const auto&amp; vertexActivation : *this->getVertexActivations())&#xA;&#x9;{&#xA;&#x9;&#x9;if(vertexActivation->isVisitorFor(vertex))&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return vertexActivation;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (const auto&amp; compositeStateVertexActivation = vertexActivation->getVertexActivation(vertex))&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return compositeStateVertexActivation;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return nullptr;"/>
          </eAnnotations>
          <eParameters name="vertex" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Vertex"/>
        </eOperations>
        <eOperations name="isRedefined" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Depth-first Check if given Vertex is redefined by another Vertex of given list. The only redefinable Vertex is the State.&#xD;&#xA;&#x9;for (auto&amp; currentVertex : *vertices)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (auto currentState = std::dynamic_pointer_cast&lt;uml::State>(currentVertex))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;auto redefinedState = currentState->getRedefinedState();&#xD;&#xA;&#x9;&#x9;&#x9;while (redefinedState != nullptr) &#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (redefinedState == vertex) &#xD;&#xA;&#x9;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return true;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return false;"/>
          </eAnnotations>
          <eParameters name="vertices" ordered="false" upperBound="-1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Vertex"/>
          <eParameters name="vertex" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Vertex"/>
        </eOperations>
        <eOperations name="isRedefined" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Depth-first Check if given Transition is redefined by another Transition of given list.&#xD;&#xA;&#x9;for (const auto&amp; currentTransition : *transitions)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;auto redefinedTransition = currentTransition->getRedefinedTransition();&#xD;&#xA;&#x9;&#x9;while (redefinedTransition != nullptr) &#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;if (redefinedTransition == transition) &#xD;&#xA;&#x9;&#x9;&#x9;&#x9;return true;&#xD;&#xA;&#x9;&#x9;&#x9;else &#xD;&#xA;&#x9;&#x9;&#x9;&#x9;redefinedTransition = currentTransition->getRedefinedTransition();&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return false;"/>
          </eAnnotations>
          <eParameters name="transitions" ordered="false" upperBound="-1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Transition"/>
          <eParameters name="transition" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Transition"/>
        </eOperations>
        <eOperations name="enter" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// If a Region is entered implicitly, its execution will start at the InitialPseudoState it owns by fireing the transition to the InitialPseudoState. If no such InitialPseudoState exists, the propagation of the Transition path is invalid for this region, thus it will not be entered. &#xD;&#xA;&#x9;// In case the Region is not entered, its Activation will be removed from an owning State's set of RegionActivations to complete. Should this be the last Region to be completed, the State will be notified as completed itself.&#xD;&#xA;&#x9;auto initialPSActivation = this->getOrigin();&#xD;&#xA;&#x9;if (initialPSActivation != nullptr) &#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;initialPSActivation->enter(enteringTransition, eventOccurrence, nullptr);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;else&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (const auto&amp; parentStateActivation = std::dynamic_pointer_cast&lt;StateActivation>(this->getParent()))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;parentStateActivation->getRegionActivations()->erase(this->getThisRegionActivationPtr());&#xD;&#xA;&#x9;&#x9;&#x9;if(parentStateActivation->hasCompleted())&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;parentStateActivation->notifyCompletion();&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="exit" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Exiting a Region implies exiting all of is active Vertices.&#xD;&#xA;&#x9;// Note: There is always a single active Vertex for a given Region.&#xD;&#xA;&#x9;//for (int i = 0; i &lt; int(m_vertexActivations->size()); ++i)&#xD;&#xA;&#x9;for (const auto&amp; vertexActivation : *this->getVertexActivations())&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (vertexActivation->isActive())&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;vertexActivation->exit(exitingTransition, eventOccurrence, nullptr);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;this->setIsCompleted(false);"/>
          </eAnnotations>
          <eParameters name="exitingTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="canPropagateExecution" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Check if given Transition enters a Vertex of this Region&#xD;&#xA;&#x9;bool propagate = true;&#xD;&#xA;&#x9;if (this->getVertexActivation(std::dynamic_pointer_cast&lt;uml::Vertex>(enteringTransition->getTargetActivation()->getNode())) == nullptr)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;auto initialPSActivation = this->getOrigin();&#xD;&#xA;&#x9;&#x9;if (initialPSActivation != nullptr)&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;propagate = initialPSActivation->canPropagateExecution(enteringTransition, eventOccurrence, nullptr);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return propagate;"/>
          </eAnnotations>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="activate" ordered="false">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="[Prototype Pattern] This Operation is obsolete because Region Vertices are initialized in the model's ExecutionFactory"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="activateTransitions">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="[Prototype Pattern] This Operation is obsolete because Transitions are initialized in the model's ExecutionFactory"/>
          </eAnnotations>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="transitionActivations"
            ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/TransitionActivation"
            containment="true"/>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="isCompleted" ordered="false"
            lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="setterBody" value="m_isCompleted = _isCompleted;&#xA;&#x9;std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::StateMachineExecution>(this->getStateMachineExecution())->getConditionVariable()->notify_one();"/>
          </eAnnotations>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EReference" name="vertexActivations"
            ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/VertexActivation"
            containment="true"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="history" ordered="false"
            eType="#//Semantics/StateMachines/StateActivation"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="StateMachineSemanticVisitor" abstract="true"
          eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/Loci/SemanticVisitor">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;PSSM/Semantics/CommonBehavior/EventTriggeredExecution.hpp&quot;&#xD;&#xA;#include &quot;fUML/FUMLFactory.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/StateMachineExecution.hpp&quot;&#xD;&#xA;#include &quot;uml/CallEvent.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/ExitPointPseudostateActivation.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/EntryPointPseudostateActivation.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/CallEventOccurrence.hpp&quot;&#xD;&#xA;#include &quot;fUML/Semantics/Loci/ExecutionFactory.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/CallEventExecution.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/CommonBehaviorFactory.hpp&quot;&#xD;&#xA;#include &quot;PSSM/PSSMFactory.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="activate" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// This operation is intended to be overridden by sub-classes. For required sub-classes&#xD;&#xA;&#x9;// (e.g., RegionActivation, StateActivation) it will initiate the instantiation phase of&#xD;&#xA;&#x9;// child semantic visitors. By default, activate() does nothing.&#xD;&#xA;&#x9;return;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="activateTransitions" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// ActivateTransition is intended to be overridden by sub-classes. It will capture the instantiation&#xD;&#xA;&#x9;// of transitions visitors as well as the linking between these visitors and the required vertices&#xD;&#xA;&#x9;// activation. By default activate, does() nothing.&#xD;&#xA;&#x9;return;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getNode" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//NamedElement">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="true"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return node;&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getExecutionLocus" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Loci/Locus">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return this->getStateMachineExecution()->getLocus();"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getParent" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Loci/SemanticVisitor">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="true"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return parent;&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getExecutionContext" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//MDE4CPP_Extensions/FUML_Object">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return this->getStateMachineExecution()->getContext();"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="setParent" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Loci/SemanticVisitor">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="Obsolete due to automatic Reference Getters &amp; Setters Generation //this.parent = parent;&#xA;"/>
          </eAnnotations>
          <eParameters name="parent" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
        </eOperations>
        <eOperations name="setNode" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="Obsolete due to automatic Reference Getters &amp; Setters Generation //this.node = node;&#xA;"/>
          </eAnnotations>
          <eParameters name="node" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//NamedElement"/>
        </eOperations>
        <eOperations name="getStateMachineExecution" ordered="false" lowerBound="1"
            eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/Execution">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Return the state-machine execution from which the caller of this operation belongs&#xD;&#xA;&#x9;auto execution = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::StateMachineExecution>(this->m_parent);&#xD;&#xA;&#xD;&#xA;&#x9;if(this->m_parent != nullptr &amp;&amp; execution != nullptr)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;return std::dynamic_pointer_cast&lt;fUML::Semantics::CommonBehavior::Execution>(this->m_parent);&#xD;&#xA;&#x9;} &#xD;&#xA;&#x9;else&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;return (std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::StateMachineSemanticVisitor>(this->m_parent))->getStateMachineExecution();&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getContextChain" ordered="false" upperBound="-1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Loci/SemanticVisitor">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Return the hierarchy of visitors that need to be traversed to access&#xA;&#x9;// the visitor that called context chain. The caller is part of the returned&#xA;&#x9;// context chain.&#xA;&#x9;//&#x9;List&lt;SemanticVisitor> contextChain = new ArrayList&lt;SemanticVisitor>();&#xA;&#x9;//&#x9;if(!(this instanceof ExitPointPseudostateActivation) &amp;&amp; !(this instanceof EntryPointPseudostateActivation)){&#xA;&#x9;//&#x9;&#x9;contextChain.add(this);&#xA;&#x9;//&#x9;}&#xA;&#x9;//&#x9;if(this.parent!=null){&#xA;&#x9;//&#x9;&#x9;if(this.parent instanceof StateMachineExecution){&#xA;&#x9;//&#x9;&#x9;&#x9;contextChain.add(this.parent);&#xA;&#x9;//&#x9;&#x9;}else{&#xA;&#x9;//&#x9;&#x9;&#x9;contextChain.addAll(((StateMachineSemanticVisitor)this.parent).getContextChain());&#xA;&#x9;//&#x9;&#x9;}&#xA;&#x9;//&#x9;}&#xA;&#x9;//&#x9;return contextChain;&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Loci::SemanticVisitor>> contextChain(new Bag&lt;fUML::Semantics::Loci::SemanticVisitor>());&#xA;&#xA;&#x9;std::shared_ptr&lt;PSSM::Semantics::StateMachines::EntryPointPseudostateActivation> entryPointActivation = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::EntryPointPseudostateActivation>(this->getThisStateMachineSemanticVisitorPtr());&#xA;&#x9;std::shared_ptr&lt;PSSM::Semantics::StateMachines::ExitPointPseudostateActivation> exitPointActivation = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::ExitPointPseudostateActivation>(this->getThisStateMachineSemanticVisitorPtr());&#xA;&#xA;&#x9;std::shared_ptr&lt;PSSM::Semantics::StateMachines::StateMachineExecution> parentStateMachineExecution = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::StateMachineExecution>(this->getParent());&#xA;&#xA;&#x9;if(entryPointActivation == nullptr &amp;&amp; exitPointActivation == nullptr) {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::Loci::SemanticVisitor> tmp = this->getThisSemanticVisitorPtr();&#xA;&#x9;&#x9;contextChain->add(tmp);&#xA;&#x9;}&#xA;&#x9;if(this->getParent() != nullptr) {&#xA;&#x9;&#x9;if(parentStateMachineExecution != nullptr) {&#xA;&#x9;&#x9;&#x9;contextChain->add(this->getParent());&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Loci::SemanticVisitor>> parentContextChain = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::StateMachineSemanticVisitor>(this->getParent())->getContextChain();&#xA;&#x9;&#x9;&#x9;contextChain->insert(*parentContextChain);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return contextChain;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="isVisitorFor" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return this->m_node == node;"/>
          </eAnnotations>
          <eParameters name="node" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//NamedElement"/>
        </eOperations>
        <eOperations name="match" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;&#x9;// Check if the event occurrence matches one of the trigger in the list.&#xD;&#xA;// The matching rule are the following:&#xD;&#xA;// &#x9;&#x9;1. If the event occurrence is a signal event occurrence then type&#xD;&#xA;//&#x9;&#x9;   of the signal must conforms to the type referenced by the event&#xD;&#xA;//&#x9;&#x9;   In addition, if the trigger defines ports through wich the event occurrence&#xD;&#xA;//         is allowed to arrive then the arrival port of the event occurrence&#xD;&#xA;//&#x9;&#x9;   must be one the referenced port.&#xD;&#xA;// &#x9;&#x9;2. If the event occurrence is a call event occurrence then the operation&#xD;&#xA;// &#x9;&#x9;   that is referenced must be the same than the one specified in the call&#xD;&#xA;//&#x9;&#x9;   event.&#xD;&#xA;// NOTE: CallEventOccurrence are not related to an arrival port. This limitation is&#xD;&#xA;// introduced by a limitation in the current PSCS semantic model.&#xD;&#xA;// &#xD;&#xA;// If a match is found then true is returned, false otherwise.&#xD;&#xA;&#x9;bool match = false;&#xD;&#xA;&#x9;int i = 0;&#xD;&#xA;&#x9;std::shared_ptr&lt;PSSM::Semantics::CommonBehavior::CallEventOccurrence> callEventOccurrence = std::dynamic_pointer_cast&lt;PSSM::Semantics::CommonBehavior::CallEventOccurrence>(eventOccurrence);&#xD;&#xA;&#x9;while(!match &amp;&amp; i &lt; int(triggers->size())) {&#xD;&#xA;&#x9;&#x9;std::shared_ptr&lt;uml::Trigger> trigger = triggers->at(i);&#xD;&#xA;&#x9;&#x9;//TODO: add SignaEventOCcurrence check as per commented Java code, once fUML is implemented&#xD;&#xA;&#x9;&#x9;//if(eventOccurrence instanceof SignalEventOccurrence&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;&#x9;&amp;&amp; trigger.getEvent() instanceof SignalEvent){&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;SignalEventOccurrence signalEventOccurrence = (SignalEventOccurrence) eventOccurrence;&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;SignalEvent event = (SignalEvent) trigger.getEvent();&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;if(event.getSignal() == signalEventOccurrence.signalInstance.type){&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;&#x9;match = true;&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;if(match  &amp;&amp; trigger.getPorts().size() > 0){&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;&#x9;int j = 0;&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;&#x9;boolean matchingPort = false;&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;&#x9;while(j &lt; trigger.getPorts().size() &amp; !matchingPort){&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;&#x9;&#x9;if(((CS_SignalInstance)signalEventOccurrence.signalInstance).interactionPoint.definingPort == trigger.getPorts().get(j)){&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;&#x9;&#x9;&#x9;matchingPort = true;&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;&#x9;&#x9;j = j + 1;&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;&#x9;if(!matchingPort){&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;&#x9;&#x9;match = matchingPort;&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;if(callEventOccurrence != nullptr) {&#xD;&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::CallEvent> triggerEvent = std::dynamic_pointer_cast&lt;uml::CallEvent>(trigger->getEvent());&#xD;&#xA;&#x9;&#x9;&#x9;if(triggerEvent != nullptr) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSSM::Semantics::CommonBehavior::CallEventOccurrence> callEventOccurrence = std::dynamic_pointer_cast&lt;PSSM::Semantics::CommonBehavior::CallEventOccurrence>(eventOccurrence);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if(triggerEvent->getOperation() == callEventOccurrence->getExecution()->getOperation()) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;match = true;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;i++;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return match;&#xD;&#xA;//boolean match = false;&#xD;&#xA;//int i = 0;&#xD;&#xA;//while(!match &amp;&amp; i &lt; triggers.size()){&#xD;&#xA;//&#x9;Trigger trigger = triggers.get(i);&#xD;&#xA;//&#x9;if(eventOccurrence instanceof SignalEventOccurrence&#xD;&#xA;//&#x9;&#x9;&#x9;&amp;&amp; trigger.getEvent() instanceof SignalEvent){&#xD;&#xA;//&#x9;&#x9;SignalEventOccurrence signalEventOccurrence = (SignalEventOccurrence) eventOccurrence;&#xD;&#xA;//&#x9;&#x9;SignalEvent event = (SignalEvent) trigger.getEvent();&#xD;&#xA;//&#x9;&#x9;if(event.getSignal() == signalEventOccurrence.signalInstance.type){&#xD;&#xA;//&#x9;&#x9;&#x9;match = true;&#xD;&#xA;//&#x9;&#x9;}&#xD;&#xA;//&#x9;&#x9;if(match  &amp;&amp; trigger.getPorts().size() > 0){&#xD;&#xA;//&#x9;&#x9;&#x9;int j = 0;&#xD;&#xA;//&#x9;&#x9;&#x9;boolean matchingPort = false;&#xD;&#xA;//&#x9;&#x9;&#x9;while(j &lt; trigger.getPorts().size() &amp; !matchingPort){&#xD;&#xA;//&#x9;&#x9;&#x9;&#x9;if(((CS_SignalInstance)signalEventOccurrence.signalInstance).interactionPoint.definingPort == trigger.getPorts().get(j)){&#xD;&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;matchingPort = true;&#xD;&#xA;//&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;//&#x9;&#x9;&#x9;&#x9;j = j + 1;&#xD;&#xA;//&#x9;&#x9;&#x9;}&#xD;&#xA;//&#x9;&#x9;&#x9;if(!matchingPort){&#xD;&#xA;//&#x9;&#x9;&#x9;&#x9;match = matchingPort;&#xD;&#xA;//&#x9;&#x9;&#x9;}&#xD;&#xA;//&#x9;&#x9;}&#xD;&#xA;//&#x9;}else if(eventOccurrence instanceof CallEventOccurrence&#xD;&#xA;//&#x9;&#x9;&#x9;&amp;&amp; trigger.getEvent() instanceof CallEvent){&#xD;&#xA;//&#x9;&#x9;CallEvent event = (CallEvent) trigger.getEvent();&#xD;&#xA;//&#x9;&#x9;CallEventOccurrence callEventOccurrence = (CallEventOccurrence) eventOccurrence;&#xD;&#xA;//&#x9;&#x9;if(event.getOperation() == callEventOccurrence.execution.operation){&#xD;&#xA;//&#x9;&#x9;&#x9;match = true;&#xD;&#xA;//&#x9;&#x9;}&#xD;&#xA;//&#x9;}&#xD;&#xA;//&#x9;i++;&#xD;&#xA;//}&#xD;&#xA;//return match;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="triggers" ordered="false" upperBound="-1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Trigger"/>
        </eOperations>
        <eOperations name="getExecutionFor" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/Execution">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Create an Execution for the specified Behavior. If the Behavior Execution is triggered by &#xD;&#xA;&#x9;// the dispatching of an EventOccurrence (i.e. a CallEvent or a SignalEvent), then an EventTriggeredExecution is provided. &#xD;&#xA;&#x9;// The EventTriggeredExecution wraps the original Execution and ensures passing of Event data to the wrapped Execution.&#xD;&#xA;&#x9;// while the context both of the new Behavior Execution and its containing EventTriggeredExecution is the same as of this SMSV.&#xD;&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::CommonBehavior::Execution> execution = nullptr;&#xD;&#xA;&#x9;if(behavior != nullptr) &#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;auto originalExecution = this->getExecutionLocus()->getFactory()->createExecution(behavior, context);&#xD;&#xA;&#xD;&#xA;&#x9;&#x9;if(eventOccurrence != nullptr) &#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;auto containerExecution = PSSM::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createEventTriggeredExecution();&#xD;&#xA;&#x9;&#x9;&#x9;containerExecution->setTriggeringEventOccurrence(eventOccurrence);&#xD;&#xA;&#x9;&#x9;&#x9;containerExecution->setWrappedExecution(originalExecution);&#xD;&#xA;&#x9;&#x9;&#x9;containerExecution->setContext(originalExecution->getContext());&#xD;&#xA;&#x9;&#x9;&#x9;execution = containerExecution;&#xD;&#xA;&#x9;&#x9;} &#xD;&#xA;&#x9;&#x9;else &#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;execution = originalExecution;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return execution;"/>
          </eAnnotations>
          <eParameters name="behavior" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Behavior"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="context" eType="ecore:EClass ../../fuml/model/fUML.ecore#//MDE4CPP_Extensions/FUML_Object"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="node" ordered="false"
            lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//NamedElement"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="parent" ordered="false"
            eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Loci/SemanticVisitor"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="TransitionActivation" abstract="true"
          eSuperTypes="#//Semantics/StateMachines/StateMachineSemanticVisitor">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;uml/Transition.hpp&quot;&#xA;#include &quot;PSSM/Semantics/StateMachines/CompletionEventOccurrence.hpp&quot;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/CallEventOccurrence.hpp&quot;&#xA;#include &quot;PSSM/Semantics/StateMachines/VertexActivation.hpp&quot;&#xA;#include &quot;PSSM/Semantics/StateMachines/StateActivation.hpp&quot;&#xA;#include &quot;uml/ValueSpecification.hpp&quot;&#xA;#include &quot;uml/Constraint.hpp&quot;&#xA;#include &quot;fUML/Semantics/Loci/ExecutionFactory.hpp&quot;&#xA;#include &quot;fUML/Semantics/Loci/Executor.hpp&quot;&#xA;#include &quot;uml/OpaqueExpression.hpp&quot;&#xA;#include &quot;PSSM/Semantics/Values/SM_OpaqueExpressionEvaluation.hpp&quot;&#xA;#include &quot;fUML/FUMLFactory.hpp&quot;&#xA;#include &quot;PSSM/Semantics/StateMachines/TransitionMetadata.hpp&quot;&#xA;#include &quot;uml/OpaqueBehavior.hpp&quot;&#xA;#include &quot;fUML/Semantics/CommonBehavior/Execution.hpp&quot;&#xA;#include &quot;fUML/Semantics/Loci/Locus.hpp&quot;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/CommonBehaviorFactory.hpp&quot;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/EventTriggeredExecution.hpp&quot;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/CallEventExecution.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="isReached" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Convenience operation which returns true if the status of this transition is REACHED; false otherwise.&#xD;&#xA;&#x9;//boolean reached = true;&#xD;&#xA;&#x9;//if(staticCheck){&#xD;&#xA;&#x9;//&#x9;reached = this.analyticalStatus.equals(TransitionMetadata.REACHED);&#xD;&#xA;&#x9;//}else{&#xD;&#xA;&#x9;//&#x9;reached = this.status.equals(TransitionMetadata.REACHED);&#xD;&#xA;&#x9;//}&#xD;&#xA;&#x9;//return reached;&#xD;&#xA;&#x9;return this->getStatus() == PSSM::Semantics::StateMachines::TransitionMetadata::REACHED;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="isGuarded" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Check if the transition is guarded. A transition is guarded if it declares&#xA;// a guard or if a redefine transition that itself declares a guar. This check&#xA;// applies recursively on the redefinition hierarchy&#xA;//Transition transition = (Transition) this.node;&#xA;//boolean isGuarded = false;&#xA;//if(transition.getGuard() != null){&#xA;//&#x9;isGuarded = true;&#xA;//}&#xA;//while(!isGuarded &amp;&amp; transition.getRedefinedTransition() != null){&#xA;//&#x9;transition = transition.getRedefinedTransition();&#xA;//&#x9;if(transition.getGuard() != null){&#xA;//&#x9;&#x9;isGuarded = true;&#xA;//&#x9;}&#xA;//}&#xA;//return isGuarded;&#xA;&#x9;std::shared_ptr&lt;uml::Transition> transition = std::dynamic_pointer_cast&lt;uml::Transition>(this->getNode());&#xA;&#x9;bool isGuarded = false;&#xA;&#x9;if(transition->getGuard() != nullptr) {&#xA;&#x9;&#x9;isGuarded = true;&#xA;&#x9;}&#xA;&#x9;while(!isGuarded &amp;&amp; transition->getRedefinedTransition() != nullptr) {&#xA;&#x9;&#x9;transition = transition->getRedefinedTransition();&#xA;&#x9;&#x9;if(transition->getGuard() != nullptr) {&#xA;&#x9;&#x9;&#x9;isGuarded = true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return isGuarded;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getStatus" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionMetadata">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="true"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return status;&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="setStatus" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="Obsolete due to automatic Reference Getters &amp; Setters Generation //this.status = state;&#xA;"/>
          </eAnnotations>
          <eParameters name="status" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionMetadata"/>
        </eOperations>
        <eOperations name="getSourceActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="//&#x9;return vertexSourceActivation;&#xA;&#x9;return this->m_sourceVertexActivation;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getTargetActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="//&#x9;return vertexTargetActivation;&#xA;&#x9;return this->m_targetVertexActivation;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="fire" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// The fire sequence is broken into the following set of actions&#xD;&#xA;&#x9;// 1 - Exit the source (depends on the kind of transition that is currently used)&#xD;&#xA;&#x9;// 2 - Execute the effect (if one exists for that transition)&#xD;&#xA;&#x9;// 3 - Enter the target (depends on the kind of transition that is currently used)&#xD;&#xA;&#x9;this->exitSource(eventOccurrence);&#xD;&#xA;&#x9;//FUMLExecutionEngine.eInstance.getControlDelegate().control(this);&#xD;&#xA;&#x9;this->tryExecuteEffect(eventOccurrence);&#xD;&#xA;&#x9;this->setStatus(PSSM::Semantics::StateMachines::TransitionMetadata::TRAVERSED);&#xD;&#xA;&#x9;DEBUG_INFO(&quot;Transition &quot; &lt;&lt; this->getNode()->getName() &lt;&lt; &quot; has fired.&quot;);&#xD;&#xA;&#x9;this->enterTarget(eventOccurrence);"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="isTraversed" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Convenience operation which returns true if the status of this transition is TRAVERSED; false otherwise.&#xD;&#xA;&#x9;if(staticCheck) &#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;return this->getAnalyticalStatus() == PSSM::Semantics::StateMachines::TransitionMetadata::TRAVERSED;&#xD;&#xA;&#x9;} &#xD;&#xA;&#x9;else &#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;return this->getStatus() == PSSM::Semantics::StateMachines::TransitionMetadata::TRAVERSED;&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="staticCheck" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean"/>
        </eOperations>
        <eOperations name="isTriggered" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Check if the transition is triggered. A transition is triggered&#xD;&#xA;// if it declares triggers or if it redefines a transition that itself&#xD;&#xA;// declares triggers. This check applies recursively on the redefinition&#xD;&#xA;// hierarchy.&#xD;&#xA;//Transition transition = (Transition) this.node;&#xD;&#xA;//boolean isTriggered = false;&#xD;&#xA;//if(!transition.getTriggers().isEmpty()){&#xD;&#xA;//&#x9;isTriggered = true;&#xD;&#xA;//}&#xD;&#xA;//while(!isTriggered &amp;&amp; transition.getRedefinedTransition() != null){&#xD;&#xA;//&#x9;transition = transition.getRedefinedTransition();&#xD;&#xA;//&#x9;if(!transition.getTriggers().isEmpty()){&#xD;&#xA;//&#x9;&#x9;isTriggered = true;&#xD;&#xA;//&#x9;}&#xD;&#xA;//}&#xD;&#xA;//return isTriggered;&#xD;&#xA;&#x9;std::shared_ptr&lt;uml::Transition> transition = std::dynamic_pointer_cast&lt;uml::Transition>(this->m_node);&#xD;&#xA;&#x9;bool isTriggered = false;&#xD;&#xA;&#xD;&#xA;&#x9;if(transition->getTrigger()->size() != 0) {&#xD;&#xA;&#x9;&#x9;isTriggered = true;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;while(!isTriggered &amp;&amp; transition->getRedefinedTransition() != nullptr) {&#xD;&#xA;&#x9;&#x9;transition = transition->getRedefinedTransition();&#xD;&#xA;&#x9;&#x9;if(transition->getTrigger()->size() != 0) {&#xD;&#xA;&#x9;&#x9;&#x9;isTriggered = true;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return isTriggered;"/>
          </eAnnotations>
          <eParameters name="staticCheck" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean"/>
        </eOperations>
        <eOperations name="exitSource" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Exit the sourceVertexActivation of this TransitionActivation as the prior sequence of entering its targetVertexActivation.&#xD;&#xA;&#x9;// The source must have already been checked for exitability.&#xD;&#xA;&#x9;auto leastCommonAncestor = this->m_sourceVertexActivation->getLeastCommonAncestor(this->m_targetVertexActivation);&#xD;&#xA;&#x9;this->m_sourceVertexActivation->exit(this->getThisTransitionActivationPtr(), eventOccurrence, leastCommonAncestor);"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="getLeastCommonAncestor" ordered="false" lowerBound="1"
            eType="#//Semantics/StateMachines/RegionActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Return the common ancestor of the source and the target. This common ancestor is&#xA;// a region activation&#xA;//if(this.vertexSourceActivation.getParentVertexActivation()!=this.vertexTargetActivation.getParentVertexActivation()){&#xA;//&#x9;if(this.leastCommonAncestor==null){&#xA;//&#x9;&#x9;this.leastCommonAncestor = this.vertexSourceActivation.getLeastCommonAncestor(this.vertexTargetActivation, ((Transition)this.getNode()).getKind());&#xA;//&#x9;}&#xA;//}&#xA;//return this.leastCommonAncestor;&#xA;&#x9;if(this->getSourceVertexActivation()->getParentVertexActivation() != this->getTargetVertexActivation()->getParentVertexActivation()){&#xA;&#x9;&#x9;if(this->getLeastCommonAncestor() == nullptr) {&#xA;&#x9;&#x9;&#x9;uml::TransitionKind transitionKind = std::dynamic_pointer_cast&lt;uml::Transition>(this->getNode())->getKind();&#xA;&#x9;&#x9;&#x9;this->setLeastCommonAncestor(this->getSourceVertexActivation()->getLeastCommonAncestor(this->getTargetVertexActivation()));&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return this->m_leastCommonAncestor;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="enterTarget" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Enter the targetVertexActivation of this TransitionActivation after executing the transition's Effect Behavior.&#xD;&#xA;&#x9;// The target must have already been checked for enterability.&#xD;&#xA;&#x9;auto leastCommonAncestor = this->m_sourceVertexActivation->getLeastCommonAncestor(this->m_targetVertexActivation);&#xD;&#xA;&#x9;this->m_targetVertexActivation->enter(this->getThisTransitionActivationPtr(), eventOccurrence, leastCommonAncestor);"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="tryExecuteEffect" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Execute the effect owned by the Transition (if any). &#xD;&#xA;&#x9;// If there is no effect but the transition redefines another transition, then&#xD;&#xA;&#x9;// the effect of this transition is executed instead. This rule applies recursively.&#xD;&#xA;&#x9;auto transition = std::dynamic_pointer_cast&lt;uml::Transition>(this->getNode());&#xD;&#xA;&#x9;auto effectBehavior = transition->getEffect();&#xD;&#xA;&#xD;&#xA;&#x9;while (effectBehavior == nullptr &amp;&amp; transition->getRedefinedTransition() != nullptr) &#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;transition = transition->getRedefinedTransition();&#xD;&#xA;&#x9;&#x9;effectBehavior = transition->getEffect();&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;if (effectBehavior != nullptr) &#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (std::dynamic_pointer_cast&lt;uml::OpaqueBehavior>(effectBehavior))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;// Extract any Parameters from the given EventOccurrence (replaces EventTriggeredExecution::initialize()),&#xD;&#xA;&#x9;&#x9;&#x9;// invoke the OpaqueBehavior directly via ModelExecutor::execute()&#xD;&#xA;&#x9;&#x9;&#x9;// and pass any output ParameterValues to the eventOccurrence in case it's a CallEventOccurrence.&#xD;&#xA;&#x9;&#x9;&#x9;auto eventTriggeredExecution = PSSM::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createEventTriggeredExecution();&#xD;&#xA;&#x9;&#x9;&#x9;eventTriggeredExecution->setTriggeringEventOccurrence(eventOccurrence);&#xD;&#xA;&#x9;&#x9;&#x9;eventTriggeredExecution->setContext(this->getExecutionContext());&#xD;&#xA;&#x9;&#x9;&#x9;auto inputParameterValues = eventTriggeredExecution->initialize(effectBehavior);&#xD;&#xA;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;auto outputParameterValues = this->getExecutionLocus()->getExecutor()->execute(effectBehavior, this->getExecutionContext(), inputParameterValues);&#xD;&#xA;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;if (const auto&amp; callEventOccurrence = std::dynamic_pointer_cast&lt;PSSM::Semantics::CommonBehavior::CallEventOccurrence>(eventOccurrence))&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;for (const auto&amp; outputParameterValue : *outputParameterValues)&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;callEventOccurrence->getExecution()->setParameterValue(outputParameterValue);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;// create an Execution for the Behavior and wrap it in an EventTriggeredExecution which, when executed, &#xD;&#xA;&#x9;&#x9;&#x9;// extracts any parameters from the given EventOccurrence, executes its wrapped Behavior Execution&#xD;&#xA;&#x9;&#x9;&#x9;// and passes any output ParameterValues to its triggering EventOccurrence in case its a CallEventOccurrence.&#xD;&#xA;&#x9;&#x9;&#x9;if (const auto&amp; effectBehaviorExecution = this->getExecutionFor(effectBehavior, eventOccurrence, nullptr)) // != nullptr&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;effectBehaviorExecution->execute();&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="setSourceActivation" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="this->m_sourceVertexActivation = sourceActivation;"/>
          </eAnnotations>
          <eParameters name="sourceActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"/>
        </eOperations>
        <eOperations name="setTargetActivation" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="this->m_targetVertexActivation = targetActivation;"/>
          </eAnnotations>
          <eParameters name="targetActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"/>
        </eOperations>
        <eOperations name="canFireOn" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// A transition is can fire when:&#xA;//&#xA;// A completion event is being dispatched and this transition has no trigger&#xA;// but its eventual guard evaluates to true. Note: the scope of a completion&#xA;// event is the state from which it was generated&#xA;//&#xA;// A signal event is being dispatched and this transition has a trigger&#xA;// that matches the signal and its eventual guard evaluates to true&#xA;//boolean reactive = true;&#xA;//if(eventOccurrence instanceof CompletionEventOccurrence){&#xA;//&#x9;reactive = !this.isTriggered() &amp;&amp;&#xA;//&#x9;&#x9;&#x9;&#x9;this.getSourceActivation()==((CompletionEventOccurrence)eventOccurrence).stateActivation &amp;&amp;&#xA;//&#x9;&#x9;&#x9;&#x9;this.evaluateGuard(eventOccurrence) &amp;&amp;&#xA;//&#x9;&#x9;&#x9;&#x9;this.canPropagateExecution(eventOccurrence);&#xA;//}else if(eventOccurrence instanceof SignalEventOccurrence | eventOccurrence instanceof CallEventOccurrence){&#xA;//&#x9;reactive = this.hasTrigger(eventOccurrence) &amp;&amp;&#xA;//&#x9;&#x9;&#x9;   this.evaluateGuard(eventOccurrence) &amp;&amp;&#xA;//&#x9;&#x9;&#x9;   this.canPropagateExecution(eventOccurrence);&#xA;//}else{&#xA;//&#x9;reactive = false;&#xA;//}&#xA;//return reactive;&#xA;&#x9;bool reactive = true;&#xA;&#x9;std::shared_ptr&lt;PSSM::Semantics::CommonBehavior::CallEventOccurrence> callEventOccurrence = std::dynamic_pointer_cast&lt;PSSM::Semantics::CommonBehavior::CallEventOccurrence>(eventOccurrence);&#xA;&#x9;std::shared_ptr&lt;PSSM::Semantics::StateMachines::CompletionEventOccurrence> completionEventOccurrence = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::CompletionEventOccurrence>(eventOccurrence);&#xA;&#x9;if(completionEventOccurrence != nullptr) {&#xA;&#xA;&#x9;&#x9;reactive = !this->isTriggered(false) &amp;&amp;&#xA;&#x9;&#x9;&#x9;&#x9;this->getSourceActivation() == std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::VertexActivation>(completionEventOccurrence->getStateActivation()) &amp;&amp;&#xA;&#x9;&#x9;&#x9;&#x9;this->evaluateGuard(eventOccurrence) &amp;&amp;&#xA;&#x9;&#x9;&#x9;&#x9;this->canPropagateExecution(eventOccurrence);&#xA;&#x9;} else if(callEventOccurrence != nullptr) {&#xA;&#x9;&#x9;reactive = this->hasTrigger(eventOccurrence) &amp;&amp;&#xA;&#x9;&#x9;&#x9;&#x9;this->evaluateGuard(eventOccurrence) &amp;&amp;&#xA;&#x9;&#x9;&#x9;&#x9;this->canPropagateExecution(eventOccurrence);&#xA;&#x9;}&#xA;&#xA;&#x9;return reactive;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="hasTrigger" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Return true if the event occurrence matches a trigger of this transition.&#xA;// false otherwise. If the transition declares no trigger but redefines another&#xA;// transition then if that transition has a trigger that matches the event occurrence&#xA;// the redefining transition is considered has being able to react to the event occurrence.&#xA;// The rule applies recursively.&#xA;//Transition transition = (Transition) this.node;&#xA;//boolean match = this.match(eventOccurrence, transition.getTriggers());&#xA;//while(!match &amp;&amp; transition.getRedefinedTransition() != null){&#xA;//&#x9;transition = transition.getRedefinedTransition();&#xA;//&#x9;match = this.match(eventOccurrence, transition.getTriggers());&#xA;//}&#xA;//return match;&#xA;&#x9;std::shared_ptr&lt;uml::Transition> transition = std::dynamic_pointer_cast&lt;uml::Transition>(this->getNode());&#xA;&#x9;bool match = this->match(eventOccurrence, std::dynamic_pointer_cast&lt;Bag&lt;uml::Trigger>>(transition->getTrigger()));&#xA;&#x9;while(!match &amp;&amp; transition->getRedefinedTransition() != nullptr) {&#xA;&#x9;&#x9;transition = transition->getRedefinedTransition();&#xA;&#x9;&#x9;match = this->match(eventOccurrence, std::dynamic_pointer_cast&lt;Bag&lt;uml::Trigger>>(transition->getTrigger()));&#xA;&#x9;}&#xA;&#x9;return match;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="evaluateGuard" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Evaluate the guard specification thanks to an evaluation.&#xD;&#xA;// The evaluation does not presume of the type of the guard specification.&#xD;&#xA;//boolean result = true;&#xD;&#xA;//Transition transition = (Transition) this.node;&#xD;&#xA;//Constraint guard = transition.getGuard();&#xD;&#xA;//while(guard == null &amp;&amp; transition.getRedefinedTransition() != null){&#xD;&#xA;//&#x9;transition = transition.getRedefinedTransition();&#xD;&#xA;//&#x9;guard = transition.getGuard();&#xD;&#xA;//}&#xD;&#xA;//if (guard != null) {&#xD;&#xA;//&#x9;ValueSpecification specification = guard.getSpecification() ;&#xD;&#xA;//&#x9;if(specification!=null){&#xD;&#xA;//&#x9;&#x9;Evaluation evaluation = this.getExecutionLocus().factory.createEvaluation(specification);&#xD;&#xA;//&#x9;&#x9;if (specification instanceof OpaqueExpression) {&#xD;&#xA;//&#x9;&#x9;&#x9;((SM_OpaqueExpressionEvaluation)evaluation).context = this.getExecutionContext() ;&#xD;&#xA;//&#x9;&#x9;&#x9;((SM_OpaqueExpressionEvaluation)evaluation).initialize(eventOccurrence);&#xD;&#xA;//&#x9;&#x9;}&#xD;&#xA;//&#x9;&#x9;if(evaluation!=null){&#xD;&#xA;//&#x9;&#x9;&#x9;BooleanValue evaluationResult = (BooleanValue)evaluation.evaluate() ;&#xD;&#xA;//&#x9;&#x9;&#x9;result = evaluationResult.value ;&#xD;&#xA;//&#x9;&#x9;}&#xD;&#xA;//&#x9;}&#xD;&#xA;//&#xD;&#xA;//}&#xD;&#xA;//return result;&#xD;&#xA;&#xD;&#xA;&#x9;bool result = true;&#xD;&#xA;&#x9;std::shared_ptr&lt;uml::Transition> transition = std::dynamic_pointer_cast&lt;uml::Transition>(this->getNode());&#xD;&#xA;&#x9;std::shared_ptr&lt;uml::Constraint> guard = transition->getGuard();&#xD;&#xA;&#x9;while(guard == nullptr &amp;&amp; transition->getRedefinedTransition() != nullptr) {&#xD;&#xA;&#x9;&#x9;transition = transition->getRedefinedTransition();&#xD;&#xA;&#x9;&#x9;guard = transition->getGuard();&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;if(guard != nullptr) {&#xD;&#xA;&#x9;&#x9;std::shared_ptr&lt;uml::ValueSpecification> specification =  guard->getSpecification();&#xD;&#xA;&#x9;&#x9;if(specification != nullptr) {&#xD;&#xA;&#x9;&#x9;&#x9;auto evaluation = this->getExecutionLocus()->getExecutor()->evaluate(specification);&#xD;&#xA;&#x9;&#x9;&#x9;//std::shared_ptr&lt;fUML::Evaluation> evaluation = this->getExecutionLocus()->getFactory()->createEvaluation(specification); - IN MDE4CPP ABER SCHON FERTIGER WERT STATT EINE EVALUATION!&#xD;&#xA;&#x9;&#x9;&#x9;auto opaqueExpression = std::dynamic_pointer_cast&lt;uml::OpaqueExpression>(specification);&#xD;&#xA;&#x9;&#x9;&#x9;if(opaqueExpression != nullptr) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;auto opaqueExpressionEvaluation = std::dynamic_pointer_cast&lt;PSSM::Semantics::Values::SM_OpaqueExpressionEvaluation>(evaluation);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;//opaqueExpressionEvaluation->setContext(this->getExecutionContext());&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;opaqueExpressionEvaluation->initialize(eventOccurrence);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;if(evaluation != nullptr) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;//std::shared_ptr&lt;fUML::BooleanValue> evaluationResult = std::dynamic_pointer_cast&lt;fUML::BooleanValue>(evaluation->evaluate());&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;//result = evaluationResult->isValue();&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return result;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="canPropagateExecution" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Evaluate the possibility to propagate the static analysis through this transition activation.&#xA;// Two situations can occur:&#xA;// 1. The transition has already been &quot;traversed&quot; with using the same event occurrence. This means&#xA;//    we already know the execution can be propagated through the transiton activation. Hence true&#xA;//    is returned and the propagation stops.&#xA;// 2. The transition has not already been &quot;traversed&quot; using this event occurrence. The consequence&#xA;//    is that the analysis is propagated through the target vertex activation. &#xA;//boolean propagate = true;&#xA;//if(this.lastTriggeringEventOccurrence != eventOccurrence){&#xA;//&#x9;propagate = this.vertexTargetActivation.canPropagateExecution(this, eventOccurrence, this.getLeastCommonAncestor());&#xA;//&#x9;this.lastTriggeringEventOccurrence = eventOccurrence;&#xA;//&#x9;this.lastPropagation = propagate;&#xA;//}else{&#xA;//&#x9;propagate = this.lastPropagation;&#xA;//}&#xA;//return propagate;&#xA;&#x9;bool propagate = true;&#xA;&#x9;if(this->getLastTriggeringEventOccurrence() != eventOccurrence) {&#xA;&#x9;&#x9;propagate = this->getTargetVertexActivation()->canPropagateExecution(this->getThisTransitionActivationPtr(), eventOccurrence, this->getLeastCommonAncestor());&#xA;&#x9;&#x9;this->setLastTriggeringEventOccurrence(eventOccurrence);&#xA;&#x9;&#x9;this->setLastPropagation(propagate);&#xA;&#x9;} else {&#xA;&#x9;&#x9;propagate = this->getLastPropagation();&#xA;&#x9;}&#xA;&#xA;&#x9;return propagate;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="status" ordered="false"
            lowerBound="1" eType="#//Semantics/StateMachines/TransitionMetadata"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="sourceVertexActivation"
            ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"
            eOpposite="#//Semantics/StateMachines/VertexActivation/outgoingTransitionActivations"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="targetVertexActivation"
            ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"
            eOpposite="#//Semantics/StateMachines/VertexActivation/incomingTransitionActivations"/>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="analyticalStatus" ordered="false"
            lowerBound="1" eType="#//Semantics/StateMachines/TransitionMetadata"/>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="lastPropagation" ordered="false"
            lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="leastCommonAncestor"
            ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/RegionActivation"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="lastTriggeringEventOccurrence"
            ordered="false" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EEnum" name="TransitionMetadata">
        <eLiterals name="none"/>
        <eLiterals name="reached" value="1"/>
        <eLiterals name="traversed" value="2"/>
        <eLiterals name="completed" value="3"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="VertexActivation" abstract="true"
          eSuperTypes="#//Semantics/StateMachines/StateMachineSemanticVisitor">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;PSSM/Semantics/StateMachines/TransitionMetadata.hpp&quot;&#xA;#include &quot;PSSM/Semantics/StateMachines/StateMetadata.hpp&quot;&#xA;#include &quot;PSSM/Semantics/StateMachines/StateMachineExecution.hpp&quot;&#xA;#include &quot;PSSM/Semantics/StateMachines/StateActivation.hpp&quot;"/>
          <details key="constructorBody" value="this->m_incomingTransitionActivations = std::make_shared&lt;Bag&lt;PSSM::Semantics::StateMachines::TransitionActivation>>();&#xD;&#xA;&#x9;this->m_outgoingTransitionActivations = std::make_shared&lt;Bag&lt;PSSM::Semantics::StateMachines::TransitionActivation>>();"/>
        </eAnnotations>
        <eOperations name="terminate" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Intended to be overridden by sub-classe(s)  &#xD;&#xA;&#x9;return;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="isActive" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// By default is is possible to assess if a vertex is active by checking&#xD;&#xA;&#x9;// if its status is ACTIVE. Note this operation is overriden in the context&#xD;&#xA;&#x9;// of state activations which require a presence within the state-machine&#xD;&#xA;&#x9;// configuration.&#xD;&#xA;&#x9;return this->getStatus() == PSSM::Semantics::StateMachines::StateMetadata::ACTIVE;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getStatus" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateMetadata">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="Obsolete due to automatic Reference Getters &amp; Setters Generation //this.status = state;&#xD;&#xA;"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return this.status;&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="setStatus" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="Obsolete due to automatic Reference Getters &amp; Setters Generation //this.status = state;&#xA;"/>
          </eAnnotations>
          <eParameters name="status" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateMetadata"/>
        </eOperations>
        <eOperations name="getParentVertexActivation" ordered="false" lowerBound="1"
            eType="#//Semantics/StateMachines/VertexActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// The parent state of a vertex is either a StateMachineExecution or a StateActivation&#xD;&#xA;&#x9;std::shared_ptr&lt;PSSM::Semantics::StateMachines::RegionActivation> regionActivation = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::RegionActivation>(this->m_parent);&#xD;&#xA;&#x9;if (regionActivation != nullptr) &#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::StateMachineExecution>(regionActivation->getParent()) != nullptr) &#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;return nullptr;&#xD;&#xA;&#x9;&#x9;} &#xD;&#xA;&#x9;&#x9;else &#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;return std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::VertexActivation>(regionActivation->getParent());&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;return nullptr;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getAscendingHierarchy" ordered="false" upperBound="-1"
            eType="#//Semantics/StateMachines/VertexActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Provides the hierarchy of State Activations starting from the current&#xD;&#xA;&#x9;// element. This list is ordered from the innermost element to the outermost element&#xD;&#xA;&#x9;std::shared_ptr&lt;Bag&lt;PSSM::Semantics::StateMachines::VertexActivation>> hierarchy(new Bag&lt;PSSM::Semantics::StateMachines::VertexActivation>());&#xD;&#xA;&#x9;for (const auto&amp; element : *(this->getContextChain()))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::StateActivation>(element) != nullptr) &#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;hierarchy->add(std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::VertexActivation>(element));&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return hierarchy;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getOwningRegionActivation" ordered="false" lowerBound="1"
            eType="#//Semantics/StateMachines/RegionActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::RegionActivation>(this->m_parent);"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getIncomingTransitions" ordered="false" upperBound="-1"
            eType="#//Semantics/StateMachines/TransitionActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return this->m_incomingTransitionActivations;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getOutgoingTransitions" ordered="false" upperBound="-1"
            eType="#//Semantics/StateMachines/TransitionActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return this->m_outgoingTransitionActivations;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getVertexActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Returns nothing by default. Must be overridden by StateActivation;&#xD;&#xA;&#x9;return nullptr;"/>
          </eAnnotations>
          <eParameters name="vertex" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Vertex"/>
        </eOperations>
        <eOperations name="addIncomingTransition" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="this->getIncomingTransitionActivations()->add(transitionActivation);"/>
          </eAnnotations>
          <eParameters name="transitionActivation" ordered="false" lowerBound="1"
              eType="#//Semantics/StateMachines/TransitionActivation"/>
        </eOperations>
        <eOperations name="addOutgoingTransition" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="this->getOutgoingTransitionActivations()->add(transitionActivation);"/>
          </eAnnotations>
          <eParameters name="transitionActivation" ordered="false" lowerBound="1"
              eType="#//Semantics/StateMachines/TransitionActivation"/>
        </eOperations>
        <eOperations name="tagOutgoingTransition" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Tags all outgoingTransitionActivations as the given value.&#xD;&#xA;&#x9;if (this->m_outgoingTransitionActivations != nullptr) &#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (staticCheck)&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;for (const auto&amp; outgoingTransitionActivation : *m_outgoingTransitionActivations)&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;outgoingTransitionActivation->setAnalyticalStatus(status);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;for (const auto&amp; outgoingTransitionActivation : *m_outgoingTransitionActivations)&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;outgoingTransitionActivation->setStatus(status);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="status" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionMetadata"/>
          <eParameters name="staticCheck" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean"/>
        </eOperations>
        <eOperations name="tagIncomingTransition" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Tags all incomingTransitionActivations as the given value.&#xD;&#xA;&#x9;if (m_incomingTransitionActivations != nullptr) &#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (staticCheck)&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;for (const auto&amp; incomingTransitionActivation : *m_incomingTransitionActivations)&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;incomingTransitionActivation->setAnalyticalStatus(status);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;for (const auto&amp; incomingTransitionActivation : *m_incomingTransitionActivations)&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;incomingTransitionActivation->setStatus(status);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="status" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionMetadata"/>
          <eParameters name="staticCheck" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean"/>
        </eOperations>
        <eOperations name="getLeastCommonAncestor" ordered="false" lowerBound="1"
            eType="#//Semantics/StateMachines/RegionActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Determine the semantic visitor being the least common ancestor between&#xD;&#xA;&#x9;// the current vertex activation and the target vertex activation (provided as&#xD;&#xA;&#x9;// a parameter). The analysis is based on a comparative analysis vertices (source and&#xD;&#xA;&#x9;// target) hierarchies.&#xD;&#xA;&#x9;//RegionActivation leastCommonAncestor = null;&#xD;&#xA;&#x9;//SemanticVisitor sourceHierachyNode =  null;&#xD;&#xA;&#x9;//SemanticVisitor targetHierarchyNode = null;&#xD;&#xA;&#x9;//List&lt;SemanticVisitor> sourceHierarchy = this.getContextChain();&#xD;&#xA;&#x9;//List&lt;SemanticVisitor> targetHierarchy = targetVertexActivation.getContextChain();&#xD;&#xA;&#x9;//int sourceHierarchyIndex = sourceHierarchy.size();&#xD;&#xA;&#x9;//int targetHierarchyIndex = targetHierarchy.size();&#xD;&#xA;&#x9;std::shared_ptr&lt;PSSM::Semantics::StateMachines::RegionActivation> leastCommonAncestor = nullptr;&#xD;&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::Loci::SemanticVisitor> sourceHierarchyNode = nullptr;&#xD;&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::Loci::SemanticVisitor> targetHierarchyNode = nullptr;&#xD;&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Loci::SemanticVisitor>> sourceHierarchy = this->getContextChain();&#xD;&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Loci::SemanticVisitor>> targetHierarchy = vertexActivation->getContextChain();&#xD;&#xA;&#x9;int sourceHierarchyIndex = sourceHierarchy->size();&#xD;&#xA;&#x9;int targetHierarchyIndex = targetHierarchy->size();&#xD;&#xA;&#x9;// Check if a difference can be found in between the two subsets&#xD;&#xA;&#x9;// delimited by the common index. Iterate until the least common&#xD;&#xA;&#x9;// ancestor is found or the two subsets have been reviewed&#xD;&#xA;&#x9;//while(leastCommonAncestor == null &amp;&amp; sourceHierarchyIndex > 0 &amp;&amp; targetHierarchyIndex > 0){&#xD;&#xA;&#x9;//&#x9;sourceHierachyNode = sourceHierarchy.get(sourceHierarchyIndex - 1);&#xD;&#xA;&#x9;//&#x9;targetHierarchyNode = targetHierarchy.get(targetHierarchyIndex - 1);&#xD;&#xA;&#x9;//&#x9;if(sourceHierachyNode != targetHierarchyNode){&#xD;&#xA;&#x9;//&#x9;&#x9;leastCommonAncestor = this.getRegionActivation(sourceHierachyNode);&#xD;&#xA;&#x9;//&#x9;}else{&#xD;&#xA;&#x9;//&#x9;&#x9;sourceHierarchyIndex = sourceHierarchyIndex - 1;&#xD;&#xA;&#x9;//&#x9;&#x9;targetHierarchyIndex = targetHierarchyIndex - 1;&#xD;&#xA;&#x9;//&#x9;}&#xD;&#xA;&#x9;//}&#xD;&#xA;&#x9;while (leastCommonAncestor == nullptr &amp;&amp; sourceHierarchyIndex > 0 &amp;&amp; targetHierarchyIndex > 0) &#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;sourceHierarchyNode = sourceHierarchy->at(sourceHierarchyIndex - 1);&#xD;&#xA;&#x9;&#x9;targetHierarchyNode = targetHierarchy->at(targetHierarchyIndex - 1);&#xD;&#xA;&#x9;&#x9;if (sourceHierarchyNode != targetHierarchyNode) &#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;leastCommonAncestor = this->getRegionActivation(sourceHierarchyNode);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;else &#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;sourceHierarchyIndex = sourceHierarchyIndex -1;&#xD;&#xA;&#x9;&#x9;&#x9;targetHierarchyIndex = targetHierarchyIndex - 1;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;// It may happen than no difference could found in the hierarchy subsets&#xD;&#xA;&#x9;// previously reviewed. This indicate two possible situations:&#xD;&#xA;&#x9;// 1. The source and the target are the same.&#xD;&#xA;&#x9;// 2. There is containing / container relationship existing between&#xD;&#xA;&#x9;//    the source and the target.&#xD;&#xA;&#x9;//if(leastCommonAncestor == null){&#xD;&#xA;&#x9;//&#x9;if(sourceHierarchyIndex == 0 &amp;&amp; targetHierarchyIndex == 0){&#xD;&#xA;&#x9;//&#x9;&#x9;leastCommonAncestor = this.getRegionActivation(sourceHierarchy.get(sourceHierarchyIndex + 1));&#xD;&#xA;&#x9;//&#x9;}else{&#xD;&#xA;&#x9;//&#x9;&#x9;if(this.getVertexActivation((Vertex)targetVertexActivation.getNode()) != null){&#xD;&#xA;&#x9;//&#x9;&#x9;&#x9;if(transitionKind == TransitionKind.EXTERNAL_LITERAL){&#xD;&#xA;&#x9;//&#x9;&#x9;&#x9;&#x9;leastCommonAncestor = this.getRegionActivation(sourceHierarchy.get(sourceHierarchyIndex));&#xD;&#xA;&#x9;//&#x9;&#x9;&#x9;}else{&#xD;&#xA;&#x9;//&#x9;&#x9;&#x9;&#x9;leastCommonAncestor = this.getRegionActivation(targetHierarchy.get(targetHierarchyIndex - 1));&#xD;&#xA;&#x9;//&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;//&#x9;&#x9;}else{&#xD;&#xA;&#x9;//&#x9;&#x9;&#x9;leastCommonAncestor = this.getRegionActivation(sourceHierarchy.get(sourceHierarchyIndex - 1));&#xD;&#xA;&#x9;//&#x9;&#x9;}&#xD;&#xA;&#x9;//&#x9;}&#xD;&#xA;&#x9;//}&#xD;&#xA;&#x9;if (leastCommonAncestor == nullptr) &#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (sourceHierarchyIndex == 0 &amp;&amp; targetHierarchyIndex == 0) &#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;leastCommonAncestor = this->getRegionActivation(sourceHierarchy->at(sourceHierarchyIndex +1));&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;if (this->getVertexActivation(std::dynamic_pointer_cast&lt;uml::Vertex>(vertexActivation->getNode())) != nullptr) &#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;//transitionKind ??&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;leastCommonAncestor = this->getRegionActivation(sourceHierarchy->at(sourceHierarchyIndex - 1));&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return leastCommonAncestor;"/>
          </eAnnotations>
          <eParameters name="vertexActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"/>
        </eOperations>
        <eOperations name="isExitable" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// By default, a Vertex has no prerequisites that need to be fullfilled&#xD;&#xA;&#x9;// to be exited. Nevertheless, some Vertices (e.g., fork) have such&#xD;&#xA;&#x9;// prerequisites. Therefore this method is intended to be overridden in the VertexActivation sub-classes. &#xD;&#xA;&#x9;return true;"/>
          </eAnnotations>
          <eParameters name="exitingTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="staticCheck" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean"/>
        </eOperations>
        <eOperations name="isEnterable" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// By default, a Vertex has no prerequisites that need to be fullfilled&#xD;&#xA;&#x9;// to be entered. Nevertheless, some Vertices (e.g., join or exit) have such&#xD;&#xA;&#x9;// prerequisites. Therefore this method is intended to be overridden in the VertexActivation sub-classes. &#xD;&#xA;&#x9;return true;"/>
          </eAnnotations>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="staticCheck" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean"/>
        </eOperations>
        <eOperations name="exit" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// When a vertex is exited its parent may need to be exited too. Such situation typically&#xD;&#xA;&#x9;// occurs when the current vertex is exited through a transition that cross boundaries of&#xD;&#xA;&#x9;// the parent state (and maybe also border its own parent). This implies that from the current&#xD;&#xA;&#x9;// vertex and until the least common ancestor is reached all states are exited recursively.&#xD;&#xA;&#x9;this->tagIncomingTransition(PSSM::Semantics::StateMachines::TransitionMetadata::NONE, false);&#xD;&#xA;&#x9;this->setStatus(PSSM::Semantics::StateMachines::StateMetadata::IDLE);&#xD;&#xA;&#x9;DEBUG_INFO(this->getNode()->getName() &lt;&lt; &quot; is now IDLE&quot;);&#xD;&#xA;&#x9;const auto&amp; owningRegionActivation = this->getOwningRegionActivation();&#xD;&#xA;&#x9;if(leastCommonAncestor != nullptr &amp;&amp; owningRegionActivation != nullptr &amp;&amp; leastCommonAncestor != owningRegionActivation)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;const auto&amp; vertexActivation = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::VertexActivation>(owningRegionActivation->getParent());&#xD;&#xA;&#x9;&#x9;if(vertexActivation != nullptr)&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;vertexActivation->exit(exitingTransition, eventOccurrence, leastCommonAncestor);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="exitingTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="leastCommonAncestor" ordered="false" eType="#//Semantics/StateMachines/RegionActivation"/>
        </eOperations>
        <eOperations name="enter" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// When a vertex is entered its parent may need to be entered as well. Such situation&#xD;&#xA;&#x9;// occurs when the parent is not active while there is an attempt to enter the current&#xD;&#xA;&#x9;// vertex activation. What is important here is that entry rule is applied recursively&#xD;&#xA;&#x9;// until the least common ancestor is reached.&#xD;&#xA;&#x9;const auto&amp; owningRegionActivation = this->getOwningRegionActivation();&#xD;&#xA;&#x9;if(leastCommonAncestor != nullptr &amp;&amp; owningRegionActivation != nullptr &amp;&amp; leastCommonAncestor != owningRegionActivation)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;const auto&amp; vertexActivation = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::VertexActivation>(owningRegionActivation->getParent());&#xD;&#xA;&#x9;&#x9;if(vertexActivation != nullptr)&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;vertexActivation->enter(enteringTransition, eventOccurrence, leastCommonAncestor);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;this->setStatus(PSSM::Semantics::StateMachines::StateMetadata::ACTIVE);&#xD;&#xA;&#x9;DEBUG_INFO(this->getNode()->getName() &lt;&lt; &quot; is now ACTIVE&quot;);&#xD;&#xA;&#x9;this->tagOutgoingTransition(PSSM::Semantics::StateMachines::TransitionMetadata::REACHED, false);&#xD;&#xA;&#x9;//FUMLExecutionEngine.eInstance.getControlDelegate().control(this);"/>
          </eAnnotations>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="leastCommonAncestor" ordered="false" eType="#//Semantics/StateMachines/RegionActivation"/>
        </eOperations>
        <eOperations name="canPropagateExecution" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// The common behavior of all kind of vertices is that when the propagation analysis is done.&#xD;&#xA;&#x9;// If a the target is a Vertex that is nested within a hierarchy, then the analysis&#xD;&#xA;&#x9;// must be recursively propagated to the parent vertices.&#xD;&#xA;&#x9;bool propagate = true;&#xD;&#xA;&#x9;if(leastCommonAncestor != nullptr) {&#xD;&#xA;&#x9;&#x9;const auto&amp; parentRegionActivation = this->getOwningRegionActivation();&#xD;&#xA;&#x9;&#x9;if(leastCommonAncestor != parentRegionActivation) {&#xD;&#xA;&#x9;&#x9;&#x9;if(const auto&amp; vertexActivation = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::VertexActivation>(parentRegionActivation->getParent())) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;propagate = vertexActivation->canPropagateExecution(enteringTransition, eventOccurrence, leastCommonAncestor);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return propagate;"/>
          </eAnnotations>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="leastCommonAncestor" ordered="false" eType="#//Semantics/StateMachines/RegionActivation"/>
        </eOperations>
        <eOperations name="getRegionActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/RegionActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// If the given semantic visitor is a region activation then this activation&#xA;// is returned. Otherwise if the visitor is a vertex activation  then its&#xA;// parent region activation is returned.&#xA;//RegionActivation regionActivation = null;&#xA;//if(semanticVisitor instanceof RegionActivation){&#xA;//&#x9;regionActivation = (RegionActivation) semanticVisitor;&#xA;//}else if(semanticVisitor instanceof VertexActivation){&#xA;//&#x9;regionActivation = (RegionActivation)((VertexActivation)semanticVisitor).getParent();&#xA;//}&#xA;//return regionActivation;&#xA;&#x9;std::shared_ptr&lt;PSSM::Semantics::StateMachines::RegionActivation> regionActivation = nullptr;&#xA;&#x9;if(std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::RegionActivation>(semanticVisitor) != nullptr) {&#xA;&#x9;&#x9;regionActivation = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::RegionActivation>(semanticVisitor);&#xA;&#x9;} else if(std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::VertexActivation>(semanticVisitor) != nullptr) {&#xA;&#x9;&#x9;regionActivation = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::RegionActivation>(std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::VertexActivation>(semanticVisitor)->getParent());&#xA;&#x9;}&#xA;&#x9;return regionActivation;"/>
          </eAnnotations>
          <eParameters name="semanticVisitor" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Loci/SemanticVisitor"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="status" ordered="false"
            lowerBound="1" eType="#//Semantics/StateMachines/StateMetadata"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="incomingTransitionActivations"
            ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/TransitionActivation"
            eOpposite="#//Semantics/StateMachines/TransitionActivation/targetVertexActivation"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="outgoingTransitionActivations"
            ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/TransitionActivation"
            eOpposite="#//Semantics/StateMachines/TransitionActivation/sourceVertexActivation"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EEnum" name="StateMetadata">
        <eLiterals name="idle"/>
        <eLiterals name="active" value="1"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="StateActivation" eSuperTypes="#//Semantics/StateMachines/VertexActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;uml/Trigger.hpp&quot;&#xD;&#xA;#include &quot;uml/State.hpp&quot;&#xD;&#xA;#include &quot;fUML/MDE4CPP_Extensions/FUML_Object.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/StateMachineExecution.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/StateMachineConfiguration.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/Loci/SM_Locus.hpp&quot;&#xD;&#xA;#include &quot;fUML/Semantics/Loci/Executor.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/StateMetadata.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/SM_ObjectActivation.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/EntryPointPseudostateActivation.hpp&quot;&#xD;&#xA;#include &quot;uml/Pseudostate.hpp&quot;&#xD;&#xA;#include &quot;uml/Transition.hpp&quot;&#xD;&#xA;#include &quot;uml/OpaqueBehavior.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/CommonBehaviorFactory.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/EventTriggeredExecution.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/CallEventOccurrence.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/CallEventExecution.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/impl/VertexActivationImpl.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/DoActivityContextObject.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="notifyCompletion" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// When a State completes (i.e. its entry and doActivity Behaviors have been executed completeley),&#xD;&#xA;&#x9;// an CompletionEventOccurrence is sent to the StateMachine owning this State. &#xD;&#xA;&#x9;// EventOccurrences of this type are prioritized to others in the Dispatch Loop.&#xD;&#xA;&#x9;std::dynamic_pointer_cast&lt;PSSM::Semantics::CommonBehavior::SM_ObjectActivation>(this->getExecutionContext()->getObjectActivation())->registerCompletionEvent(this->getThisStateActivationPtr());"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="releaseDeferredEvents" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// If events have been deferred by that state then these latter return to the&#xA;// regular event pool.&#xA;//Object_ context = this.getExecutionContext();&#xA;//if(context.objectActivation != null){&#xA;//&#x9;((SM_ObjectActivation)context.objectActivation).releaseDeferredEvents(this); &#xA;//}&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="hasCompleted" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// A state is considered completed under the following circumstances:&#xA;&#x9;// 1 - If the State is simple, both its entry and doActivity Behaviors have finished their execution&#xA;&#x9;// 2 - If the State is composite, all its owned Regions must have completed (by reaching their FinalStates) additionally&#xA;&#x9;// When this operation returns 'true', then the generation of a CompletionEventOccurrence is allowed for this particular State&#xA;&#x9;bool stateHasCompleted = this->m_isEntryCompleted &amp;&amp; this->m_isDoActivityCompleted;&#xA;&#x9;if (std::dynamic_pointer_cast&lt;uml::State>(this->getNode())->isComposite())&#xA;&#x9;{&#xA;&#x9;&#x9;for (const auto&amp; ownedRegionActivation : *(this->getRegionActivations()))&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;stateHasCompleted = stateHasCompleted &amp;&amp; ownedRegionActivation->getIsCompleted();&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return stateHasCompleted;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="defer" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Postpone the time at which this Event Occurrence will be available in the event pool.&#xD;&#xA;&#x9;// The given Event Occurrence is placed in the deferred event pool and will be released&#xD;&#xA;&#x9;// only when the current State Activation leaves the State Machine configuration.&#xD;&#xA;&#x9;//Object_ context = this.getExecutionContext();&#xD;&#xA;&#x9;//if(context.objectActivation != null){&#xD;&#xA;&#x9;//&#x9;((SM_ObjectActivation)context.objectActivation).registerDeferredEvent(eventOccurrence, this); &#xD;&#xA;&#x9;//}&#xD;&#xA;&#x9;auto context = this->getExecutionContext();&#xD;&#xA;&#x9;if(context->getObjectActivation() != nullptr) {&#xD;&#xA;&#x9;&#x9;std::dynamic_pointer_cast&lt;PSSM::Semantics::CommonBehavior::SM_ObjectActivation>(context->getObjectActivation())->registerDeferredEvent(eventOccurrence, this->getThisStateActivationPtr());&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="getRegionActivation" ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/RegionActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="//return this.regionActivation;&#xA;return nullptr;&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="tryExecuteEntry" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Execute the State's entry Behavior if specified.&#xD;&#xA;&#x9;// If not, but the State redefines another State which itself has an entry Behavior specified, then this Behavior is executed.&#xD;&#xA;&#x9;// This rule applies recursively.&#xD;&#xA;&#x9;if (!this->m_isEntryCompleted)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (const auto&amp; entryBehavior = this->getEntry()) // != nullptr&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;if (std::dynamic_pointer_cast&lt;uml::OpaqueBehavior>(entryBehavior))&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;// Extract any Parameters from the given EventOccurrence (replaces EventTriggeredExecution::initialize()),&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;// invoke the OpaqueBehavior directly via ModelExecutor::execute()&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;// and pass any output ParameterValues to the eventOccurrence in case its a CallEventOccurrence.&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;auto eventTriggeredExecution = PSSM::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createEventTriggeredExecution();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;eventTriggeredExecution->setTriggeringEventOccurrence(eventOccurrence);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;eventTriggeredExecution->setContext(this->getExecutionContext());&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;auto inputParameterValues = eventTriggeredExecution->initialize(entryBehavior);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;auto outputParameterValues = this->getExecutionLocus()->getExecutor()->execute(entryBehavior, this->getExecutionContext(), inputParameterValues);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (const auto&amp; callEventOccurrence = std::dynamic_pointer_cast&lt;PSSM::Semantics::CommonBehavior::CallEventOccurrence>(eventOccurrence))&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for (const auto&amp; outputParameterValue : *outputParameterValues)&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;callEventOccurrence->getExecution()->setParameterValue(outputParameterValue);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;/// Create an Execution for the Behavior and wrap it in an EventTriggeredExecution which, when executed, &#xD;&#xA;&#x9;&#x9;&#x9;&#x9;// extracts any parameters from the given EventOccurrence, executes its wrapped Behavior Execution&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;// and passes any output ParameterValues to its triggering EventOccurrence in case it's a CallEventOccurrence.&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (const auto&amp; entryBehaviorExecution = this->getExecutionFor(entryBehavior, eventOccurrence, nullptr)) // != nullptr&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;entryBehaviorExecution->execute();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;this->setIsEntryCompleted(true);&#xD;&#xA;&#x9;&#x9;if (this->hasCompleted())&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;this->notifyCompletion();&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="tryExecuteExit" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Execute the State's exit Behavior if specified.&#xD;&#xA;&#x9;// If not, but the State redefines another State which itself has an exit Behavior specified, then this Behavior is executed.&#xD;&#xA;&#x9;// This rule applies recursively.&#xD;&#xA;&#x9;if (!this->m_isExitCompleted)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (const auto&amp; exitBehavior = this->getExit()) // != nullptr&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;if (std::dynamic_pointer_cast&lt;uml::OpaqueBehavior>(exitBehavior))&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;// Extract any Parameters from the given EventOccurrence (replaces EventTriggeredExecution::initialize()),&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;// invoke the OpaqueBehavior directly via ModelExecutor::execute()&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;// and pass any output ParameterValues to the eventOccurrence in case its a CallEventOccurrence.&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;auto eventTriggeredExecution = PSSM::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createEventTriggeredExecution();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;eventTriggeredExecution->setTriggeringEventOccurrence(eventOccurrence);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;eventTriggeredExecution->setContext(this->getExecutionContext());&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;auto inputParameterValues = eventTriggeredExecution->initialize(exitBehavior);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;auto outputParameterValues = this->getExecutionLocus()->getExecutor()->execute(exitBehavior, this->getExecutionContext(), inputParameterValues);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (const auto&amp; callEventOccurrence = std::dynamic_pointer_cast&lt;PSSM::Semantics::CommonBehavior::CallEventOccurrence>(eventOccurrence))&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for (const auto&amp; outputParameterValue : *outputParameterValues)&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;callEventOccurrence->getExecution()->setParameterValue(outputParameterValue);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;// Create an Execution for the Behavior and wrap it in an EventTriggeredExecution which, when executed, &#xD;&#xA;&#x9;&#x9;&#x9;&#x9;// extracts any parameters from the given EventOccurrence, executes its wrapped Behavior Execution&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;// and passes any output ParameterValues to its triggering EventOccurrence in case it's a CallEventOccurrence.&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (const auto&amp; exitBehaviorExecution = this->getExecutionFor(exitBehavior, eventOccurrence, nullptr)) // != nullptr&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;exitBehaviorExecution->execute();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;this->setIsExitCompleted(true);&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="tryInvokeDoActivity" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// If an doActivity Behavior is specified for that state, then it is executed asynchronously.&#xD;&#xA;&#x9;// If no doActivity is specified but the State redefines another State which&#xD;&#xA;&#x9;// provides a doActivity, then this latter is executed instead. The rule applies&#xD;&#xA;&#x9;// recursively.&#xD;&#xA;&#x9;if (!this->m_isDoActivityCompleted)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (const auto&amp; doActivityBehavior = this->getDoActivity()) // != nullptr&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;if (std::dynamic_pointer_cast&lt;uml::OpaqueBehavior>(doActivityBehavior))&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;// Extract any Parameters from the given EventOccurrence (replaces EventTriggeredExecution::initialize()),&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;// invoke the OpaqueBehavior directly via ModelExecutor::execute()&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;// and pass any output ParameterValues to the eventOccurrence in case its a CallEventOccurrence.&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;// CURRENTLY, OPAQUEBEHAVIORS ARE EXECUTED SYNCHRONOUSLY REGARDLESS OF DOACTIVITY SEMANTICS DUE TO &#xD;&#xA;&#x9;&#x9;&#x9;&#x9;// MDE4CPP INVOKING THESE OPAQUEBEHAVIORS DIRECTLY AS C++ METHOD&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;auto eventTriggeredExecution = PSSM::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createEventTriggeredExecution();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;eventTriggeredExecution->setTriggeringEventOccurrence(eventOccurrence);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;eventTriggeredExecution->setContext(this->getExecutionContext());&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;auto inputParameterValues = eventTriggeredExecution->initialize(doActivityBehavior);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;auto outputParameterValues = this->getExecutionLocus()->getExecutor()->execute(doActivityBehavior, this->getExecutionContext(), inputParameterValues);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (const auto&amp; callEventOccurrence = std::dynamic_pointer_cast&lt;PSSM::Semantics::CommonBehavior::CallEventOccurrence>(eventOccurrence))&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for (const auto&amp; outputParameterValue : *outputParameterValues)&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;callEventOccurrence->getExecution()->setParameterValue(outputParameterValue);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;this->setIsDoActivityCompleted(true);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (this->hasCompleted())&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this->notifyCompletion();&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;// Create an doActivityContextObject for the doActivity so it can run asynchronously.&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;this->setDoActivityContextObject(PSSM::Semantics::StateMachines::StateMachinesFactory::eInstance()->createDoActivityContextObject());&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;this->getExecutionLocus()->add(this->getDoActivityContextObject());&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;this->m_doActivityContextObject->initialize(this->getExecutionContext());&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;this->m_doActivityContextObject->getOwner() = std::dynamic_pointer_cast&lt;uml::Element>(this->getThisStateActivationPtr());&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;// Create an temporary Execution for the Behavior and try to wrap it in an EventTriggeredExecution &#xD;&#xA;&#x9;&#x9;&#x9;&#x9;// and extract any parameters from the given EventOccurrence which then can be passed to the doActivityContextObject.&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;const auto&amp; doActivityExecution = this->getExecutionFor(doActivityBehavior, eventOccurrence, nullptr);//this->getExecutionContext());&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;auto inputParameterValues = std::make_shared&lt;Bag&lt;fUML::Semantics::CommonBehavior::ParameterValue>>();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (const auto&amp; doActivityEventTriggeredExecution = std::dynamic_pointer_cast&lt;PSSM::Semantics::CommonBehavior::EventTriggeredExecution>(doActivityExecution))&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;inputParameterValues = doActivityEventTriggeredExecution->initialize(doActivityBehavior);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// Start doActivityExecution on its own thread with the extracted parameters if given&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this->m_doActivityContextObject->startBehavior(doActivityBehavior, inputParameterValues);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;else {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this->setIsDoActivityCompleted(true);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (this->hasCompleted())&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;this->notifyCompletion();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;this->setIsDoActivityCompleted(true);&#xD;&#xA;&#x9;&#x9;&#x9;if (this->hasCompleted())&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;this->notifyCompletion();&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="canDefer" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Return true if current state activation is capable of deferring the given&#xD;&#xA;&#x9;// event occurrence; false otherwise. Note that false is returned in case where&#xD;&#xA;&#x9;// the deferring constraint is overridden by an outgoing transition&#xD;&#xA;&#x9;// &#xD;&#xA;&#x9;// Note: for the moment the evaluation is done with the assumption that the&#xD;&#xA;&#x9;// received event occurrence is a signal event occurrence. This will change&#xD;&#xA;&#x9;// as soon as other kind of event (e.g. call event) will be supported in fUML.&#xD;&#xA;&#x9;//State state = (State) this.node;&#xD;&#xA;&#x9;//boolean deferred = this.match(eventOccurrence, state.getDeferrableTriggers());&#xD;&#xA;&#x9;//while(!deferred &amp;&amp; state.getRedefinedState() != null){&#xD;&#xA;&#x9;//&#x9;state = state.getRedefinedState();&#xD;&#xA;&#x9;//&#x9;deferred = this.match(eventOccurrence, state.getDeferrableTriggers());&#xD;&#xA;&#x9;//}&#xD;&#xA;&#x9;//if(deferred){&#xD;&#xA;&#x9;//&#x9;int i = 0;&#xD;&#xA;&#x9;//&#x9;TransitionActivation overridingTransitionActivation = null;&#xD;&#xA;&#x9;//&#x9;while(overridingTransitionActivation == null &amp;&amp; i &lt; this.outgoingTransitionActivations.size()){&#xD;&#xA;&#x9;//&#x9;&#x9;TransitionActivation currentTransitionActivation = this.outgoingTransitionActivations.get(i);&#xD;&#xA;&#x9;//&#x9;&#x9;if(currentTransitionActivation.canFireOn(eventOccurrence)){&#xD;&#xA;&#x9;//&#x9;&#x9;&#x9;overridingTransitionActivation = currentTransitionActivation;&#xD;&#xA;&#x9;//&#x9;&#x9;}&#xD;&#xA;&#x9;//&#x9;&#x9;i++;&#xD;&#xA;&#x9;//&#x9;}&#xD;&#xA;&#x9;//&#x9;deferred = overridingTransitionActivation == null;&#xD;&#xA;&#x9;//}&#xD;&#xA;&#x9;//return deferred;&#xD;&#xA;&#x9;std::shared_ptr&lt;uml::State> state = std::dynamic_pointer_cast&lt;uml::State>(this->getNode());&#xD;&#xA;&#xD;&#xA;&#x9;bool deferred = this->match(eventOccurrence, std::dynamic_pointer_cast&lt;Bag&lt;uml::Trigger>>(state->getDeferrableTrigger()));&#xD;&#xA;&#xD;&#xA;&#x9;while(!deferred &amp;&amp; state->getRedefinedState() != nullptr) &#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;state = state->getRedefinedState();&#xD;&#xA;&#x9;&#x9;deferred = this->match(eventOccurrence, std::dynamic_pointer_cast&lt;Bag&lt;uml::Trigger>>(state->getDeferrableTrigger()));&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;if(deferred)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;deferred = false;&#xD;&#xA;&#x9;&#x9;for (const auto&amp; outgoingTransitionActivation : *m_outgoingTransitionActivations)&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;if (outgoingTransitionActivation->canFireOn(eventOccurrence))&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;deferred = true;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;/*std::shared_ptr&lt;PSSM::Semantics::StateMachines::TransitionActivation> overridingTransitionActivation = nullptr;&#xD;&#xA;&#x9;&#x9;while(overridingTransitionActivation == nullptr &amp;&amp; i &lt; this->m_outgoingTransitionActivations->size()) {&#xD;&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSSM::Semantics::StateMachines::TransitionActivation> currentTransitionActivation = this->m_outgoingTransitionActivations->at(i);&#xD;&#xA;&#x9;&#x9;&#x9;if(currentTransitionActivation->canFireOn(eventOccurrence)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;overridingTransitionActivation = currentTransitionActivation;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;i++;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;deferred = overridingTransitionActivation == nullptr;*/&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return deferred;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="getConnectionPointActivation" ordered="false" eType="#//Semantics/StateMachines/ConnectionPointActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Return the activation for the exit point or the entry point.&#xD;&#xA;&#x9;for (const auto&amp; connectionPointActivation : *this->getConnectionPointActivations())&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (connectionPointActivation->getNode() == vertex)&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;return connectionPointActivation;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return nullptr;"/>
          </eAnnotations>
          <eParameters name="vertex" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Vertex"/>
        </eOperations>
        <eOperations name="getFireableTransitions" ordered="false" upperBound="-1"
            eType="#//Semantics/StateMachines/TransitionActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Return the set of transitions that can fire using the the given event occurrence&#xA;//List&lt;TransitionActivation> fireableTransitions = new ArrayList&lt;TransitionActivation>();&#xA;//for(int i=0; i &lt; this.outgoingTransitionActivations.size(); i++){&#xA;//&#x9;TransitionActivation outgoingTransitionActivation = this.outgoingTransitionActivations.get(i);&#xA;//&#x9;if(outgoingTransitionActivation.canFireOn(eventOccurrence)){&#xA;//&#x9;&#x9;fireableTransitions.add(outgoingTransitionActivation);&#xA;//&#x9;}&#xA;//}&#xA;//return fireableTransitions;&#xA;&#x9;return nullptr;&#xA;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="enterRegions" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Regions can be entered either implicitly or explicitly. &#xA;&#x9;// A Region is typically entered implicitly when its Activation is triggered&#xA;&#x9;// by a Transition terminating on the edge of its containing State.&#xA;&#x9;// A Region is typically entered explicitly when one of its contained&#xA;&#x9;// States is targeted by a Transition coming from the outside.&#xA;&#x9;// *** Regions are entered concurrently ***&#xA;&#x9;//List&lt;Vertex> targetedVertices = new ArrayList&lt;Vertex>();&#xA;&#x9;//VertexActivation sourceActivation = enteringTransition.getSourceActivation();&#xA;&#x9;//if(sourceActivation instanceof ForkPseudostateActivation){&#xA;&#x9;//&#x9;Pseudostate fork = (Pseudostate)sourceActivation.getNode();&#xA;&#x9;//&#x9;for(int i = 0; i &lt; fork.getOutgoings().size(); i++){&#xA;&#x9;//&#x9;&#x9;targetedVertices.add(fork.getOutgoings().get(i).getTarget());&#xA;&#x9;//&#x9;}&#xA;&#x9;//}else{&#xA;&#x9;//&#x9;VertexActivation targetActivation = enteringTransition.getTargetActivation();&#xA;&#x9;//&#x9;if(targetActivation instanceof EntryPointPseudostateActivation){&#xA;&#x9;//&#x9;&#x9;Pseudostate entryPoint = (Pseudostate)targetActivation.getNode();&#xA;&#x9;//&#x9;&#x9;for(int i = 0; i &lt; entryPoint.getOutgoings().size(); i++){&#xA;&#x9;//&#x9;&#x9;&#x9;targetedVertices.add(entryPoint.getOutgoings().get(i).getTarget());&#xA;&#x9;//&#x9;&#x9;}&#xA;&#x9;//&#x9;}else{&#xA;&#x9;//&#x9;&#x9;if(!(targetActivation instanceof HistoryPseudostateActivation)){&#xA;&#x9;//&#x9;&#x9;&#x9;targetedVertices.add((Vertex)targetActivation.getNode());&#xA;&#x9;//&#x9;&#x9;}&#xA;&#x9;//&#x9;}&#xA;&#x9;//}&#xA;&#x9;//for(int i=0; i &lt; this.regionActivation.size(); i++){&#xA;&#x9;//&#x9;RegionActivation regionActivation = this.regionActivation.get(i);&#xA;&#x9;//&#x9;int j = 0;&#xA;&#x9;//&#x9;boolean found = false;&#xA;&#x9;//&#x9;while(j &lt; targetedVertices.size() &amp;&amp; !found){&#xA;&#x9;//&#x9;&#x9;found = regionActivation.getVertexActivation(targetedVertices.get(j)) != null;&#xA;&#x9;//&#x9;&#x9;j++;&#xA;&#x9;//&#x9;}&#xA;&#x9;//&#x9;if(!found){&#xA;&#x9;//&#x9;&#x9;regionActivation.enter(enteringTransition, eventOccurrence);&#xA;&#x9;//&#x9;}&#xA;&#x9;//}&#xA;&#x9;std::shared_ptr&lt;Bag&lt;uml::Vertex>> targetedVertices(new Bag&lt;uml::Vertex>());&#xA;&#x9;auto sourceActivation = enteringTransition->getSourceActivation();&#xA;&#xA;&#x9;//Fork&#xA;&#xA;&#x9;//Else&#xA;&#x9;auto targetActivation = enteringTransition->getTargetActivation();&#xA;&#xA;&#x9;if (std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::EntryPointPseudostateActivation>(targetActivation) != nullptr) &#xA;&#x9;{&#xA;&#x9;&#x9;const auto&amp; entryPoint = std::dynamic_pointer_cast&lt;uml::Pseudostate>(targetActivation->getNode());&#xA;&#x9;&#x9;for (const auto&amp; outgoingTransition : *(entryPoint->getOutgoings())) &#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;targetedVertices->add(outgoingTransition->getTarget());&#xA;&#x9;&#x9;}&#xA;&#x9;} // else history&#xA;&#xA;&#x9;for (const auto&amp; regionActivation : *this->getRegionActivations())&#xA;&#x9;{&#xA;&#x9;&#x9;int j=0;&#xA;&#x9;&#x9;bool found = false;&#xA;&#x9;&#x9;while (j &lt; int(targetedVertices->size()) &amp;&amp; !found) &#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;found = regionActivation->getVertexActivation(targetedVertices->at(j)) != nullptr;&#xA;&#x9;&#x9;&#x9;j++;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if (!found) &#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;regionActivation->enter(enteringTransition, eventOccurrence);&#xA;&#x9;&#x9;}&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="getEntry" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Behavior">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Return the Entry Behavior of the State or one inherited&#xD;&#xA;&#x9;// from a Redefined State. If no Entry Behavior can be found, null is&#xD;&#xA;&#x9;// returned.&#xD;&#xA;&#x9;auto state = std::dynamic_pointer_cast&lt;uml::State>(this->getNode());&#xD;&#xA;&#x9;auto entryBehavior = state->getEntry();&#xD;&#xA;&#x9;while(entryBehavior == nullptr &amp;&amp; state->getRedefinedState() != nullptr){&#xD;&#xA;&#x9;&#x9;state = state->getRedefinedState();&#xD;&#xA;&#x9;&#x9;entryBehavior = state->getEntry();&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return entryBehavior;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getExit" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Behavior">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Return the Exit Behavior of the State or one inherited&#xD;&#xA;&#x9;// from a Redefined State. If no Exit Behavior can be found, null is&#xD;&#xA;&#x9;// returned.&#xD;&#xA;&#x9;auto state = std::dynamic_pointer_cast&lt;uml::State>(this->getNode());&#xD;&#xA;&#x9;auto exitBehavior = state->getExit();&#xD;&#xA;&#x9;while(exitBehavior == nullptr &amp;&amp; state->getRedefinedState() != nullptr){&#xD;&#xA;&#x9;&#x9;state = state->getRedefinedState();&#xD;&#xA;&#x9;&#x9;exitBehavior = state->getExit();&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return exitBehavior;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getDoActivity" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Behavior">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Return the DoActivity Behavior of the State or one inherited&#xD;&#xA;&#x9;// from a Redefined State. If no DoActivity Behavior can be found, null is&#xD;&#xA;&#x9;// returned.&#xD;&#xA;&#x9;auto state = std::dynamic_pointer_cast&lt;uml::State>(this->getNode());&#xD;&#xA;&#x9;auto doActivityBehavior = state->getDoActivity();&#xD;&#xA;&#x9;while(doActivityBehavior == nullptr &amp;&amp; state->getRedefinedState() != nullptr){&#xD;&#xA;&#x9;&#x9;state = state->getRedefinedState();&#xD;&#xA;&#x9;&#x9;doActivityBehavior = state->getDoActivity();&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return doActivityBehavior;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="enter">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Enter this State by executing its entry Behavior if one is specified, invoke its doActivity Behavior if one is specified and, if composite, all owned RegionActivations are entered.&#xA;&#x9;// As the State is now active, its Activation registers itself in the StateMachineConfiguration of the owning StateMachine and sets itself as the history of its owning RegionActivation.&#xA;&#x9;// All parent Vertices must be entered beforehand until the least common ancestor of this StateActivation and the source StateActivation of the entering Transition is reached.&#xA;&#x9;if (this->getStatus() == StateMetadata::IDLE)&#xA;&#x9;{&#xA;&#x9;&#x9;PSSM::Semantics::StateMachines::VertexActivationImpl::enter(enteringTransition, eventOccurrence, leastCommonAncestor);&#xA;&#xA;&#x9;&#x9;std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::StateMachineExecution>(this->getStateMachineExecution())->getConfiguration()->_register(this->getThisStateActivationPtr());&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;this->tryExecuteEntry(eventOccurrence);&#xA;&#x9;&#x9;this->tryInvokeDoActivity(eventOccurrence);&#x9;&#xA;&#xA;&#x9;&#x9;if (std::dynamic_pointer_cast&lt;uml::State>(this->getNode())->isComposite())&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this->enterRegions(enteringTransition, eventOccurrence);&#xA;&#x9;&#x9;}&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="leastCommonAncestor" ordered="false" eType="#//Semantics/StateMachines/RegionActivation"/>
        </eOperations>
        <eOperations name="exit">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Exit this StateActivation by exiting all owned RegionActivations if the State is composite, abort its doActivtiy Behavior if one is specified and running&#xA;&#x9;// and execute its exit Behavior synchonously if one is specified.&#xA;&#x9;// As the State is now idle, its Activation unregisters itself in the StateMachineConfiguration of the owning StateMachine.&#xA;&#x9;if (std::dynamic_pointer_cast&lt;uml::State>(this->getNode())->isComposite())&#xA;&#x9;{&#xA;&#x9;&#x9;for (const auto&amp; ownedRegionActivation : *(this->m_regionActivations))&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;ownedRegionActivation->exit(nullptr, eventOccurrence);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;// If there is a doActivity currently executing, then it is aborted.&#xA;&#x9;if(!this->m_isDoActivityCompleted){&#xA;&#x9;&#x9;this->m_doActivityContextObject->destroy();&#xA;&#x9;&#x9;this->setDoActivityContextObject(nullptr);&#xA;&#x9;}&#xA;&#x9;this->tryExecuteExit(eventOccurrence);&#xA;&#xA;&#x9;// Unregister this StateActivation&#xA;&#x9;std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::StateMachineExecution>(this->getStateMachineExecution())->getConfiguration()->unregister(this->getThisStateActivationPtr());&#xA;&#xA;&#x9;// Re-initialize the State Behavior boolean flags&#xA;&#x9;this->m_isEntryCompleted = false;&#xA;&#x9;this->m_isDoActivityCompleted = false;&#xA;&#x9;this->m_isExitCompleted = false;&#xA;&#xA;&#x9;// Change containing Region history to this StateActivation&#xA;&#x9;this->getOwningRegionActivation()->setHistory(this->getThisStateActivationPtr());&#xA;&#xA;&#x9;// The State is exited by a Transition that targets a State which is located within &#xA;&#x9;// another Region. This means that the parent State must also be exited.  &#xA;&#x9;PSSM::Semantics::StateMachines::VertexActivationImpl::exit(exitingTransition, eventOccurrence, leastCommonAncestor);"/>
          </eAnnotations>
          <eParameters name="exitingTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="leastCommonAncestor" ordered="false" eType="#//Semantics/StateMachines/RegionActivation"/>
        </eOperations>
        <eOperations name="activate" ordered="false">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="[Prototype Pattern] This Operation is obsolete because Region Vertices are initialized in the model's ExecutionFactory"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="activateTransitions">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="[Prototype Pattern] This Operation is obsolete because Transitions are initialized in the model's ExecutionFactory"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getVertexActivation" ordered="false" eType="#//Semantics/StateMachines/VertexActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Return the Activation corresponding to the Vertex. Search&#xA;&#x9;// is propagated through the owned RegionActivation of the&#xA;&#x9;// StateActivation if this latter is composite. If no Activation&#xA;&#x9;// is found, null is returned.&#xA;&#x9;auto vertexActivation = std::shared_ptr&lt;PSSM::Semantics::StateMachines::VertexActivation>();&#xA;&#x9;if (auto state = std::dynamic_pointer_cast&lt;uml::State>(this->getNode()))&#xA;&#x9;{&#xA;&#x9;&#x9;if (state->isComposite())&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;vertexActivation = this->getConnectionPointActivation(vertex);&#xA;&#x9;&#x9;&#x9;if (vertexActivation == nullptr)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;for (const auto&amp; regionActivation : *this->getRegionActivations())&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;vertexActivation = regionActivation->getVertexActivation(vertex);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (vertexActivation != nullptr) break;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return vertexActivation;"/>
          </eAnnotations>
          <eParameters name="vertex" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Vertex"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="connectionPointActivations"
            ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/ConnectionPointActivation"
            containment="true"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="regionActivations"
            ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/RegionActivation"
            containment="true"/>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="isDoActivityCompleted"
            ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean"/>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="isEntryCompleted" ordered="false"
            lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean"/>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="isExitCompleted" ordered="false"
            lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="doActivityContextObject"
            ordered="false" eType="#//Semantics/StateMachines/DoActivityContextObject"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="ConnectionPointActivation" abstract="true"
          eSuperTypes="#//Semantics/StateMachines/PseudostateActivation"/>
      <eClassifiers xsi:type="ecore:EClass" name="PseudostateActivation" abstract="true"
          eSuperTypes="#//Semantics/StateMachines/VertexActivation">
        <eOperations name="evaluateAllGuards" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Evaluate all guards of the outgoing transitions of the Pseudostate.&#xD;&#xA;&#x9;// The guard evaluation process populates the set of fireable Transitions&#xD;&#xA;&#x9;// with guards evaluating to 'true'. Not that this evaluation&#xD;&#xA;&#x9;// is not done at the time the where this Pseudostate is entered. Instead&#xD;&#xA;&#x9;// it is done statically when the compound transition leading to this&#xD;&#xA;&#x9;// Pseudostate is evaluated.&#xD;&#xA;&#x9;this->m_fireableTransitions->clear();&#xD;&#xA;&#x9;for (const auto&amp; outgoingTransitionActivation : *this->getOutgoingTransitions())&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (outgoingTransitionActivation->evaluateGuard(eventOccurrence))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;this->m_fireableTransitions->add(outgoingTransitionActivation);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="fireableTransitions"
            ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/TransitionActivation"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="DoActivityContextObject" eSuperTypes="#//MDE4CPP_Extensions/PSSM_Object">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;fUML/MDE4CPP_Extensions/impl/FUML_ObjectImpl.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/SM_ObjectActivation.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/DeferredEventOccurrence.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/DoActivityExecutionEventAccepter.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/DoActivityContextObjectActivation.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/StateActivation.hpp&quot;&#xD;&#xA;#include &quot;uml/Element.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="getFeatureValue" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Delegate read of a particular feature to the state-machine context&#xA;FeatureValue featureValue = null;&#xA;if(this.context!=null){&#xA;&#x9;featureValue = this.context.getFeatureValue(feature);&#xA;}&#xA;return featureValue;&#xA;"/>
          </eAnnotations>
          <eParameters name="feature" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//StructuralFeature"/>
        </eOperations>
        <eOperations name="setFeatureValue" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Delegate write of particular feature to the state-machine context&#xA;if(this.context!=null){&#xA;&#x9;this.context.setFeatureValue(feature, values, position);&#xA;}&#xA;"/>
          </eAnnotations>
          <eParameters name="feature" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//StructuralFeature"/>
          <eParameters name="values" ordered="false" upperBound="-1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
          <eParameters name="position" ordered="false" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Integer"/>
        </eOperations>
        <eOperations name="dispatch" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/Execution">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Delegate operation call to the state-machine context&#xA;Execution execution = null;&#xA;if(this.context!=null){&#xA;&#x9;execution = this.context.dispatch(operation);&#xA;}&#xA;return execution;&#xA;"/>
          </eAnnotations>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
        </eOperations>
        <eOperations name="send" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Delegate the sending of an EventOccurrence to the StateMachine context&#xD;&#xA;&#x9;if (this->m_context != nullptr)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;this->m_context->send(eventOccurrence);&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="unregister" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Unregistering an EventAccepter from a DoActivityContextObject includes &#xD;&#xA;&#x9;// - unregistering its encapsulating DoActivityExecutionEventAccepter from the Event Pool of the contex's ObjectActivation of this Object if given&#xD;&#xA;&#x9;// - unregistering the EventAccepter from the Event Pool of this Object's Activation&#xD;&#xA;&#x9;this->unregisterFromContext(accepter);&#xD;&#xA;&#x9;fUML::MDE4CPP_Extensions::FUML_ObjectImpl::FUML_ObjectImpl::unregister(accepter);"/>
          </eAnnotations>
          <eParameters name="accepter" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventAccepter"/>
        </eOperations>
        <eOperations name="_register" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// When the executing doActivity registers an Accepter with this DoActivityContextObject's Activation,&#xD;&#xA;&#x9;// it searches through the deferred Event Pool of the ObjectActivation associated to the StateMachine context.&#xD;&#xA;&#x9;// 1. If the Accepter being registered matches one of the deferred Events, then this Event is&#xD;&#xA;&#x9;//    transferred into the Event Pool of the doActivity ObjectActivation. This implies the&#xD;&#xA;&#x9;//    Event will be dispatched in a RTC step performed by the doActivity ObjectActivation. &#xD;&#xA;&#x9;// 2. If the Accepter being registered does not match one of the deferred Events, then this latter&#xD;&#xA;&#x9;//    is wrapped in a DoActivityExecutionEventAccepter which is registered with the State Machine context ObjectActivation.&#xD;&#xA;&#x9;//    This is realized in order to guarantee that the doActivity will have a chance to match an Event&#xD;&#xA;&#x9;//    received by the StateMachine context object.&#xD;&#xA;&#x9;fUML::MDE4CPP_Extensions::FUML_ObjectImpl::FUML_ObjectImpl::_register(accepter);&#xD;&#xA;&#x9;const auto&amp; contextObjectActivation = std::dynamic_pointer_cast&lt;PSSM::Semantics::CommonBehavior::SM_ObjectActivation>(this->m_context->getObjectActivation());&#xD;&#xA;&#xD;&#xA;&#x9;auto matchedDeferredEventOccurrence = PSSM::Semantics::StateMachines::StateMachinesFactory::eInstance()->createDeferredEventOccurrence();&#xD;&#xA;&#x9;for (const auto&amp; eventOccurrence : *(contextObjectActivation->getDeferredEventPool()))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;auto owner = std::shared_ptr&lt;uml::Element> (this->getOwner());&#xD;&#xA;&#x9;&#x9;if (owner == std::dynamic_pointer_cast&lt;uml::Element>(eventOccurrence->getConstrainingStateActivation()) &amp;&amp; accepter->match(eventOccurrence->getDeferredEventOccurrence()))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;matchedDeferredEventOccurrence = eventOccurrence;&#xD;&#xA;&#x9;&#x9;&#x9;break;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;if (matchedDeferredEventOccurrence == nullptr)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;auto encapsulatingAccepter = PSSM::Semantics::StateMachines::StateMachinesFactory::eInstance()->createDoActivityExecutionEventAccepter();&#xD;&#xA;&#x9;&#x9;encapsulatingAccepter->setEncapsulatedAccepter(accepter);&#xD;&#xA;&#x9;&#x9;encapsulatingAccepter->setContext(this->getThisDoActivityContextObjectPtr());&#xD;&#xA;&#x9;&#x9;this->m_context->_register(encapsulatingAccepter);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;else&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;contextObjectActivation->getDeferredEventPool()->erase(matchedDeferredEventOccurrence);&#xD;&#xA;&#x9;&#x9;this->m_objectActivation->getEventPool()->add(matchedDeferredEventOccurrence->getDeferredEventOccurrence());&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="accepter" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventAccepter"/>
        </eOperations>
        <eOperations name="destroy" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// When a DoActivityContextObject ist destroyed, it must remove all encapsulating DoActivityExecutionEventAccepters&#xD;&#xA;&#x9;// it has registered from the context's ObjectActivation in addition to the regular destruction behavior.&#xD;&#xA;&#x9;for (const auto&amp; waitingEventAccepter : *this->m_objectActivation->getWaitingEventAccepters())&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;this->unregisterFromContext(waitingEventAccepter);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;fUML::MDE4CPP_Extensions::FUML_ObjectImpl::FUML_ObjectImpl::destroy();"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="unregisterFromContext" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Unregister the encapsulating DoActivityExecutionEventAccepter in the contex's ObjectActivation if given.&#xD;&#xA;&#x9;if (const auto&amp; contextObjectActivation = this->m_context->getObjectActivation())&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;auto encapsulatingAccepter = PSSM::Semantics::StateMachines::StateMachinesFactory::eInstance()->createDoActivityExecutionEventAccepter();&#xD;&#xA;&#x9;&#x9;for (const auto&amp; waitingAccepter : *contextObjectActivation->getWaitingEventAccepters())&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;if (auto waitingDoActExeEvAcc = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::DoActivityExecutionEventAccepter>(waitingAccepter))&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (waitingDoActExeEvAcc->getEncapsulatedAccepter() == encapsulatedAccepter)&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;encapsulatingAccepter = waitingDoActExeEvAcc;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;break;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;&#x9;if (encapsulatingAccepter != nullptr)&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;contextObjectActivation->unregister(encapsulatingAccepter);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="encapsulatedAccepter" ordered="false" lowerBound="1"
              eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventAccepter"/>
        </eOperations>
        <eOperations name="initialize" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// The context Object of this DoActivityContextObject is the context&#xD;&#xA;&#x9;// of the State Machine which has invoked the doActivity&#xD;&#xA;&#x9;if (context != nullptr)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;this->m_context = context;&#xD;&#xA;&#x9;}&#xD;&#xA;"/>
          </eAnnotations>
          <eParameters name="context" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//MDE4CPP_Extensions/FUML_Object"/>
        </eOperations>
        <eOperations name="startBehavior" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Starts the Behavior of a DoActivityContextObject. It behaves the&#xD;&#xA;&#x9;// same as in fUML except that its Object is associated to a DoActivityContextObjectActivation&#xD;&#xA;&#x9;// as a specific type of ObjectActivation&#xD;&#xA;&#x9;if (this->m_objectActivation == nullptr)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;this->setObjectActivation(PSSM::Semantics::StateMachines::StateMachinesFactory::eInstance()->createDoActivityContextObjectActivation());&#xD;&#xA;&#x9;&#x9;this->m_objectActivation->setObject(this->getThisFUML_ObjectPtr());&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;this->m_objectActivation->startBehavior(classifier, inputs);"/>
          </eAnnotations>
          <eParameters name="classifier" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class"/>
          <eParameters name="inputs" ordered="false" upperBound="-1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/ParameterValue"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="context" ordered="false"
            lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//MDE4CPP_Extensions/FUML_Object"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="InitialPseudostateActivation" eSuperTypes="#//Semantics/StateMachines/PseudostateActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;PSSM/Semantics/StateMachines/impl/VertexActivationImpl.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="enter">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Entering an InitialPseudostateActivation results in firing its outgoing TransitionActivation immediately without the use of Events (therefore &quot;nullptr&quot;).&#xD;&#xA;&#x9;// This is because all InitialPSActivations are traversed during the first RTC Step of entering their Region instead of being triggered by any accepted EventOccurrence.&#xD;&#xA;&#x9;// Also, a InitialPS must have exactly one outgoing TransitionActivation which must not have Triggers and guards, therefore checking for fireable TransitionActivations can be omitted.&#xD;&#xA;&#x9;&#x9;PSSM::Semantics::StateMachines::VertexActivationImpl::enter(enteringTransition, eventOccurrence, leastCommonAncestor);&#xD;&#xA;&#x9;if (this->m_outgoingTransitionActivations->size() == 1)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;this->m_outgoingTransitionActivations->at(0)->fire(eventOccurrence);&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="leastCommonAncestor" ordered="false" eType="#//Semantics/StateMachines/RegionActivation"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="StateMachineExecution" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/Execution">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;PSSM/Semantics/CommonBehavior/SM_ObjectActivation.hpp&quot;&#xA;#include &quot;PSSM/Semantics/Loci/SM_ExecutionFactory.hpp&quot;&#xA;#include &quot;PSSM/Semantics/StateMachines/StateMachineEventAccepter.hpp&quot;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/CommonBehaviorFactory.hpp&quot;&#xA;#include &quot;uml/StateMachine.hpp&quot;&#xA;#include &quot;uml/Region.hpp&quot;&#xA;#include &quot;fUML/Semantics/CommonBehavior/EventAccepter.hpp&quot;&#xA;&#xA;#include &lt;mutex>&#xA;#include &lt;condition_variable>"/>
          <details key="interfaceIncludes" value="#include &lt;thread>&#xA;#include &lt;mutex>&#xA;#include &lt;condition_variable>"/>
          <details key="constructorBody" value="this->m_mutex = std::make_shared&lt;std::mutex>();&#xA;&#x9;this->m_conditionVariable = std::make_shared&lt;std::condition_variable>();"/>
        </eAnnotations>
        <eOperations name="execute" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="documentation" value="Execute the behavior given by the type of this execution. &#xD;&#xA;The parameterValues for any input (in or in-out) parameters of the behavior should be set before the execution.&#xD;&#xA;The parameteValues for any output (in-out, out or return) parameters of the behavior will be set by the execution.&#xD;&#xA;"/>
            <details key="body" value="// The execution of state-machine is realized as described below&#xA;&#x9;// 1 - An event accepter is placed in the list of waiting event accepters for this state-machine&#xA;&#x9;// 2 - All visitors required to interpret the state-machine are instantiated and link together&#xA;&#x9;// 3 - All top level regions (i.e. those directly owned by the executed state-machine) are entered&#xA;&#x9;//     concurrently. Since they are top regions then there is no transition used to enter them&#xA;&#x9;// Note: a state-machine always has at runtime a single event accepter&#xA;&#x9;/*if(this.context!=null &amp;&amp; this.context.objectActivation!=null){&#xA;&#x9;&#x9;this.context.register(new StateMachineEventAccepter(this));&#xA;&#x9;}&#xA;&#x9;this.initRegions();&#xA;&#x9;for(RegionActivation activation: this.regionActivation){&#xA;&#x9;&#x9;activation.activate();&#xA;&#x9;}&#xA;&#x9;for(RegionActivation activation: this.regionActivation){&#xA;&#x9;&#x9;activation.activateTransitions();&#xA;&#x9;}&#xA;&#x9;for(RegionActivation regionActivation: this.regionActivation){&#xA;&#x9;&#x9;regionActivation.enter(null, null);&#xA;&#x9;}*/&#xA;&#xA;&#x9;if (this->m_context != nullptr &amp;&amp; this->m_context->getObjectActivation() != nullptr)&#xA;&#x9;{&#xA;&#x9;&#x9;const auto&amp; smEventAccepter = PSSM::Semantics::StateMachines::StateMachinesFactory::eInstance()->createStateMachineEventAccepter();&#xA;&#x9;&#x9;smEventAccepter->setRegistrationContext(this->getThisStateMachineExecutionPtr());&#xA;&#x9;&#x9;this->m_context->_register(smEventAccepter);&#xA;&#x9;}&#xA;&#x9;/* Region have been initialized in the model's ExecutionFactory already&#xA;&#x9;this->initRegions();&#xA;&#x9;for (auto regionActivation : *(this->m_regionActivations))&#xA;&#x9;{&#xA;&#x9;&#x9;regionActivation->activate();&#xA;&#x9;}&#xA;&#x9;for (auto regionActivation : *(this->m_regionActivations))&#xA;&#x9;{&#xA;&#x9;&#x9;regionActivation->activateTransitions();&#xA;&#x9;}*/&#xA;&#x9;for (const auto&amp; regionActivation : *(this->m_regionActivations))&#xA;&#x9;{&#xA;&#x9;&#x9;regionActivation->enter(nullptr, nullptr);&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;// Block this thread until the StateMachine Execution is complete to prevent this StateMachineExecution&#xA;&#x9;// from being destroyed after this initial RTC Step returns.&#xA;&#x9;std::unique_lock lock(*m_mutex);&#xA;&#x9;auto&amp; regionActivations = this->getRegionActivations();&#xA;&#x9;this->m_conditionVariable->wait(lock, [&amp;regionActivations]&#xA;&#x9;{&#xA;&#x9;&#x9;bool allCompleted = true;&#xA;&#x9;&#x9;for (const auto&amp; regionActivation : *regionActivations)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if (!regionActivation->getIsCompleted()) &#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;allCompleted = false;&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return allCompleted;&#xA;&#x9;});&#xA;&#x9;lock.unlock();"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="new_" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
            <details key="documentation" value="Create a new execution with no behavior or parameterValues.&#xD;&#xA;"/>
            <details key="body" value="/*if(this.context!=null){&#xD;&#xA;&#x9;&#x9;return new StateMachineExecution(this.context);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return new StateMachineExecution();&#xD;&#xA;&#xD;&#xA;&#x9;if (this->m_context != nullptr)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;return std::shared_ptr&lt;Any>(new StateMachineExecutionImpl());&#xD;&#xA;&#x9;}*/&#xD;&#xA;&#x9;return nullptr;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="initRegions" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="[Prototype Pattern] This Operation is obsolete because Regions are initialized in the model's ExecutionFactory"/>
            <details key="body" value="// Instantiate activations for regions owned by the state machine.&#xD;&#xA;&#x9;// The parent of these activations is this state machine execution.&#xD;&#xA;&#x9;/*StateMachine machine = null;&#xD;&#xA;&#x9;if(!this.getTypes().isEmpty()){&#xD;&#xA;&#x9;&#x9;machine = (StateMachine) this.getTypes().get(0);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;if(machine!=null){&#xD;&#xA;&#x9;&#x9;for(Region region: machine.getRegions()){&#xD;&#xA;&#x9;&#x9;&#x9;RegionActivation activation = (RegionActivation) this.locus.factory.instantiateVisitor(region);&#xD;&#xA;&#x9;&#x9;&#x9;activation.setParent(this);&#xD;&#xA;&#x9;&#x9;&#x9;activation.setNode(region);&#xD;&#xA;&#x9;&#x9;&#x9;this.regionActivation.add(activation);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}*/&#xD;&#xA;&#xD;&#xA;&#x9;/*std::shared_ptr&lt;uml::StateMachine> stateMachine = nullptr;&#xD;&#xA;&#x9;if (!this->getTypes()->empty())&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;stateMachine = std::dynamic_pointer_cast&lt;uml::StateMachine>(this->getTypes()->at(0));&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;if (stateMachine != nullptr)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;for (auto region : *(stateMachine->getRegion()))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;auto regionActivation = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::RegionActivation>(this->m_locus->getFactory()->instantiateVisitor(region));&#xD;&#xA;&#x9;&#x9;&#x9;regionActivation->setParent(this->getThisSemanticVisitorPtr());&#xD;&#xA;&#x9;&#x9;&#x9;regionActivation->setNode(region);&#xD;&#xA;&#x9;&#x9;&#x9;this->m_regionActivations->add(regionActivation);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}*/"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getVertexActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Find the vertex activation corresponding to the given vertex.&#xA;&#x9;// Search goes through the overall hierarchy of visitors until&#xA;&#x9;// the activation is found. Null is returned if no activation&#xA;&#x9;// could be found.&#xA;&#x9;/*int i = 0;&#xA;&#x9;VertexActivation vertexActivation = null;&#xA;&#x9;while(vertexActivation==null &amp;&amp; i &lt; this.regionActivation.size()){&#xA;&#x9;&#x9;vertexActivation = this.regionActivation.get(i).getVertexActivation(vertex);&#xA;&#x9;&#x9;i++;&#xA;&#x9;}&#xA;&#x9;return vertexActivation;*/&#xA;&#xA;&#x9;std::shared_ptr&lt;PSSM::Semantics::StateMachines::VertexActivation> vertexActivation = nullptr;&#xA;&#x9;for (auto regionActivation : *(this->getRegionActivations()))&#xA;&#x9;{&#xA;&#x9;&#x9;if (vertexActivation = regionActivation->getVertexActivation(vertex)) break;&#xA;&#x9;}&#xA;&#x9;return vertexActivation;"/>
          </eAnnotations>
          <eParameters name="vertex" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Vertex"/>
        </eOperations>
        <eOperations name="getRegionActivation" ordered="false" lowerBound="1" upperBound="-1"
            eType="#//Semantics/StateMachines/RegionActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="return this->m_regionActivations;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="terminate" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// The termination of a State Machine consists in aborting all &quot;ongoing&quot; DoActivity Behaviors&#xD;&#xA;&#x9;// started by States owned by this State Machine. States that are currently active (i.e. registered&#xD;&#xA;&#x9;// in the State Machine configuration) are not exited (i.e. their Exit Behaviors  are not executed).&#xD;&#xA;&#x9;for (const auto&amp; regionActivation : *(this->m_regionActivations))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;regionActivation->terminate();&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;this->m_regionActivations->clear();"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="startBehavior" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// The behavior captured here is almost identical to the one provide by Object_.&#xD;&#xA;&#x9;// If not already done, a SM_ObjectActivation which allows the registering of an StateMachineEventAccepter is instantiated here and its Event Dispatch Loop is started.&#xD;&#xA;&#x9;if (this->m_objectActivation == nullptr)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;auto objectActivation(PSSM::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createSM_ObjectActivation_as_objectActivation_in_FUML_Object(this->getThisFUML_ObjectPtr()));&#xD;&#xA;&#x9;&#x9;this->setObjectActivation(objectActivation);&#xD;&#xA;&#x9;&#x9;this->m_objectActivation->setObject(this->getThisFUML_ObjectPtr());&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;this->m_objectActivation->startBehavior(classifier, inputs);"/>
          </eAnnotations>
          <eParameters name="classifier" ordered="false" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class"/>
          <eParameters name="inputs" ordered="false" upperBound="-1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/ParameterValue"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="regionActivations"
            ordered="false" lowerBound="1" upperBound="-1" eType="#//Semantics/StateMachines/RegionActivation"
            containment="true"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="configuration" ordered="false"
            lowerBound="1" eType="#//Semantics/StateMachines/StateMachineConfiguration"
            containment="true" eOpposite="#//Semantics/StateMachines/StateMachineConfiguration/execution"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="conditionVariable"
            lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/StructuredClassifiers/Object">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="cppType" value="std::shared_ptr&lt;std::condition_variable>"/>
          </eAnnotations>
        </eStructuralFeatures>
        <eStructuralFeatures xsi:type="ecore:EReference" name="mutex" lowerBound="1"
            eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/StructuredClassifiers/Object">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="cppType" value="std::shared_ptr&lt;std::mutex>"/>
          </eAnnotations>
        </eStructuralFeatures>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="StateMachineConfiguration">
        <eOperations name="getRoot" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateConfiguration">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="return this->m_rootConfiguration;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getExecution" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateMachineExecution">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="//return this->m_execution;&#xD;&#xA;&#x9;return nullptr;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getVertexActivationsAtLevel" ordered="false" upperBound="-1"
            eType="#//Semantics/StateMachines/VertexActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Traverse all StateConfigurations registert in this StateMachineConfiguration and collect those of the given level.&#xD;&#xA;&#x9;auto vertexActivationsAtLevel = std::make_shared&lt;Bag&lt;PSSM::Semantics::StateMachines::VertexActivation>>();&#xD;&#xA;&#x9;if (this->m_rootConfiguration->getLevel() == level) &#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;vertexActivationsAtLevel->add(m_rootConfiguration->getVertexActivation());&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;for (const auto&amp; child : *(this->m_rootConfiguration->getChildren()))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (child->getLevel() == level)&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;vertexActivationsAtLevel->add(child->getVertexActivation());&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return vertexActivationsAtLevel;"/>
          </eAnnotations>
          <eParameters name="level" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Integer"/>
        </eOperations>
        <eOperations name="_register" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Register the given StateActivation in the Configuration of its StateMachine as a StateConfiguration. This occurs when the StateActivation is entered.&#xD;&#xA;&#x9;// If the Configuration does not contain any StateConfigurations yet, the given one is referenced to as the rootConfiguration of the StateConfiguration tree.&#xD;&#xA;&#x9;if (this->m_rootConfiguration == nullptr)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;auto rootStateConfig = PSSM::Semantics::StateMachines::StateMachinesFactory::eInstance()->createStateConfiguration();&#xD;&#xA;&#x9;&#x9;rootStateConfig->setVertexActivation(stateActivation);&#xD;&#xA;&#x9;&#x9;rootStateConfig->setLevel(0);&#xD;&#xA;&#x9;&#x9;rootStateConfig->setCompleteConfiguration(this->getThisStateMachineConfigurationPtr());&#xD;&#xA;&#x9;&#x9;this->setRootConfiguration(rootStateConfig);&#xD;&#xA;&#x9;&#x9;return true;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return this->add(stateActivation);"/>
          </eAnnotations>
          <eParameters name="stateActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateActivation"/>
        </eOperations>
        <eOperations name="unregister" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Unregister the given StateActivation in the Configuration of its StateMachine as a StateConfiguration. This occurs when the StateActivation is exited.&#xD;&#xA;&#x9;// If the last remaining StateConfiguration is to be removed, the reference to it as the rootConfiguration must be reset.&#xD;&#xA;&#x9;// If the removal process is successful, all possibly deferred events related to that state activation are released.&#xD;&#xA;&#x9;if (this->m_rootConfiguration->getChildren()->empty())&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;stateActivation->releaseDeferredEvents();&#xD;&#xA;&#x9;&#x9;this->setRootConfiguration(nullptr);&#xD;&#xA;&#x9;&#x9;return true;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;else&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;bool removed = this->remove(stateActivation);&#xD;&#xA;&#x9;&#x9;if (removed) stateActivation->releaseDeferredEvents();&#xD;&#xA;&#x9;&#x9;return removed;&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="stateActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateActivation"/>
        </eOperations>
        <eOperations name="isStable" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean"/>
        <eOperations name="isActive" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// A State registers itself in the StateMachineConfiguration as soon as it becomes active.&#xD;&#xA;&#x9;// Therefore, a State can easily be checked for being active by finding it in the Configuration tree.&#xD;&#xA;&#x9;bool found = false;&#xD;&#xA;&#x9;if (this->m_rootConfiguration->isActive(activation)) return true;&#xD;&#xA;&#x9;else&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;for (const auto&amp; child : *this->m_rootConfiguration->getChildren())&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;found = child->isActive(activation);&#xD;&#xA;&#x9;&#x9;&#x9;if (found) break;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;return found;&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="activation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"/>
        </eOperations>
        <eOperations name="remove" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return this->m_rootConfiguration->removeChild(vertexActivation);"/>
          </eAnnotations>
          <eParameters name="vertexActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"/>
        </eOperations>
        <eOperations name="add" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return this->m_rootConfiguration->addChild(activation);"/>
          </eAnnotations>
          <eParameters name="activation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="rootConfiguration"
            ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateConfiguration"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="execution" ordered="false"
            lowerBound="1" eType="#//Semantics/StateMachines/StateMachineExecution"
            eOpposite="#//Semantics/StateMachines/StateMachineExecution/configuration"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="StateConfiguration">
        <eOperations name="getLevel" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Integer">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="return m_level;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getChildren" ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/StateConfiguration">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="true"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return m_children;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getVertexActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="return m_vertexActivation;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getContext" ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/VertexActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// The Context of a StateConfiguration is its own VertexActivation's hierarchy of parent VertexActivations&#xD;&#xA;&#x9;// down to the closest VertexActivation which is that of an own child StateActivation.&#xD;&#xA;&#x9;auto hierarchy = activation->getAscendingHierarchy();&#xD;&#xA;&#x9;auto context = std::make_shared&lt;Bag&lt;PSSM::Semantics::StateMachines::VertexActivation>>(*hierarchy->copy());&#xD;&#xA;&#x9;for (const auto&amp; hierarchyVertex : *hierarchy) &#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;for (const auto&amp; child : *(this->getChildren()))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;if (child->getVertexActivation() != hierarchyVertex)&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;context->erase(child->getVertexActivation());&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;else return context;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return context;"/>
          </eAnnotations>
          <eParameters name="activation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"/>
        </eOperations>
        <eOperations name="removeChild" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return this->remove(activation, this->getContext(activation));"/>
          </eAnnotations>
          <eParameters name="activation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"/>
        </eOperations>
        <eOperations name="remove" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Remove the given VertexActivation from the tree structure&#xD;&#xA;&#x9;bool removed = false;&#xD;&#xA;&#x9;if (!context->empty())&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;auto currentVertexActivation = context->at(context->size()-1);&#xD;&#xA;&#x9;&#x9;for (const auto&amp; child : *(this->m_children))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;if (child->getVertexActivation() == currentVertexActivation)&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;auto newContext = std::make_shared&lt;Bag&lt;PSSM::Semantics::StateMachines::VertexActivation>>(*context->copy());&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;newContext->erase(currentVertexActivation);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;removed = child->remove(activation, newContext);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;else&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;for (const auto&amp; child : *(this->m_children))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;if (child->getVertexActivation() == activation)&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;this->m_children->erase(child);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;removed = true;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return removed;"/>
          </eAnnotations>
          <eParameters name="activation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"/>
          <eParameters name="context" ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/VertexActivation"/>
        </eOperations>
        <eOperations name="addChild" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return this->add(activation, this->getContext(activation));"/>
          </eAnnotations>
          <eParameters name="activation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"/>
        </eOperations>
        <eOperations name="add" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Add the VertexActivation as a new child to the tree structure of StateConfigurations&#xD;&#xA;&#x9;bool added = false;&#xD;&#xA;&#x9;if (!context->empty())&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;auto currentVertexActivation = context->at(context->size()-1);&#xD;&#xA;&#x9;&#x9;for (const auto&amp; child : *(this->m_children))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;if (child->getVertexActivation() == currentVertexActivation)&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;auto newContext = std::make_shared&lt;Bag&lt;PSSM::Semantics::StateMachines::VertexActivation>>(*context->copy());&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;newContext->erase(currentVertexActivation);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;added = child->add(activation, newContext);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;else&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;bool alreadyAdded = false;&#xD;&#xA;&#x9;&#x9;for (const auto&amp; child : *(this->m_children))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;if (child->getVertexActivation() == activation)&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;alreadyAdded = true;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;if (alreadyAdded)&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;auto newStateConfiguration = PSSM::Semantics::StateMachines::StateMachinesFactory::eInstance()->createStateConfiguration_as_children_in_StateConfiguration(this->getThisStateConfigurationPtr());&#xD;&#xA;&#x9;&#x9;&#x9;newStateConfiguration->setVertexActivation(activation);&#xD;&#xA;&#x9;&#x9;&#x9;newStateConfiguration->setCompleteConfiguration(this->m_completeConfiguration);&#xD;&#xA;&#x9;&#x9;&#x9;newStateConfiguration->setLevel(this->m_level+1);&#xD;&#xA;&#x9;&#x9;&#x9;newStateConfiguration->setParent(this->getThisStateConfigurationPtr());&#xD;&#xA;&#x9;&#x9;&#x9;this->m_children->add(newStateConfiguration);&#xD;&#xA;&#x9;&#x9;&#x9;added = true;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return added;"/>
          </eAnnotations>
          <eParameters name="activation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"/>
          <eParameters name="context" ordered="false" lowerBound="1" upperBound="-1"
              eType="#//Semantics/StateMachines/VertexActivation"/>
        </eOperations>
        <eOperations name="isActive" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return this->m_vertexActivation == activation;"/>
          </eAnnotations>
          <eParameters name="activation" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="level" ordered="false"
            lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Integer"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="vertexActivation" ordered="false"
            lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="children" ordered="false"
            upperBound="-1" eType="#//Semantics/StateMachines/StateConfiguration"
            containment="true"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="completeConfiguration"
            ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateMachineConfiguration"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="parent" ordered="false"
            eType="#//Semantics/StateMachines/StateConfiguration"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="FinalStateActivation" eSuperTypes="#//Semantics/StateMachines/StateActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;PSSM/Semantics/StateMachines/impl/VertexActivationImpl.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="enter">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// The enter routine of a FinalState consists of completing its RegionActivation's execution and clearing its history.&#xD;&#xA;&#x9;// If this RegionActivation is owned by a StateActivation, then remove this RegionActivation from its set of owned RegionActivations to complete.&#xD;&#xA;&#x9;// If all RegionActivations owned by that StateActivation have completed, then a CompletionEventOccurrence is generated for that StateActivation.&#xD;&#xA;&#x9;// As for a regular StateActivation, all parent Vertices must be entered beforehand until the least common ancestor of this StateActivation and the source StateActivation of the entering Transition is reached.&#xD;&#xA;&#x9;PSSM::Semantics::StateMachines::VertexActivationImpl::enter(enteringTransition, eventOccurrence, leastCommonAncestor);&#xD;&#xA;&#x9;if (std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::RegionActivation>(this->m_parent) != leastCommonAncestor) {&#xD;&#xA;&#x9;&#x9;if (auto parentVertexActivation = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::VertexActivation>(this->m_parent)) {&#xD;&#xA;&#x9;&#x9;&#x9;parentVertexActivation->enter(enteringTransition, eventOccurrence, leastCommonAncestor);&#xD;&#xA;&#x9;&#x9;}&#x9;&#x9;&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;auto owningRegionActivation = this->getOwningRegionActivation();&#xD;&#xA;&#x9;owningRegionActivation->setIsCompleted(true);&#xD;&#xA;&#x9;owningRegionActivation->setHistory(nullptr);&#xD;&#xA;&#xD;&#xA;&#x9;if (auto parentStateActivation = std::dynamic_pointer_cast&lt;StateActivation>(owningRegionActivation->getParent()))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;parentStateActivation->getRegionActivations()->erase(owningRegionActivation);&#xD;&#xA;&#x9;&#x9;if(parentStateActivation->hasCompleted())&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;parentStateActivation->notifyCompletion();&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="leastCommonAncestor" ordered="false" eType="#//Semantics/StateMachines/RegionActivation"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="ExternalTransitionActivation" eSuperTypes="#//Semantics/StateMachines/TransitionActivation"/>
      <eClassifiers xsi:type="ecore:EClass" name="InternalTransitionActivation" eSuperTypes="#//Semantics/StateMachines/TransitionActivation"/>
      <eClassifiers xsi:type="ecore:EClass" name="LocalTransitionActivation" eSuperTypes="#//Semantics/StateMachines/TransitionActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;PSSM/Semantics/StateMachines/impl/EntryPointPseudostateActivationImpl.hpp&quot;&#xD;&#xA;#include &quot;uml/Vertex.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/EntryPointPseudostateActivation.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="getContainingState" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// The container of a LocalTransition is determined in the following manner:&#xD;&#xA;&#x9;// 1 - If the source Vertex is an EntryPoint, then the containing State is the&#xD;&#xA;&#x9;//     the State that has this EntryPoint on its edge&#xD;&#xA;&#x9;// 2 - Else if the source contains the target, then the containing&#xD;&#xA;&#x9;//&#x9;   State is the source itself. Otherwise the source is the target&#xD;&#xA;&#x9;auto containingState = std::shared_ptr&lt;PSSM::Semantics::StateMachines::StateActivation>();&#xD;&#xA;&#x9;if (auto PSActivation = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::EntryPointPseudostateActivation>(this->getSourceActivation()))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;containingState = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::StateActivation>(this->getSourceActivation()->getParentVertexActivation());&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;else&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (this->getSourceActivation()->getVertexActivation(std::dynamic_pointer_cast&lt;uml::Vertex>(this->getTargetActivation()->getNode())))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;containingState = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::StateActivation>(this->getSourceActivation());&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;containingState = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::StateActivation>(this->getTargetActivation());&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return containingState;"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="EntryPointPseudostateActivation"
          eSuperTypes="#//Semantics/StateMachines/ConnectionPointActivation">
        <eOperations name="_enter" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// When an exit point is entered its owning state is entered. That state maybe located&#xD;&#xA;&#x9;// in a nested hierarchy which is not already active. Hence if the hierarchy is not&#xD;&#xA;&#x9;// already active then it is entered.&#xD;&#xA;&#x9;PSSM::Semantics::StateMachines::VertexActivationImpl::enter(enteringTransition, eventOccurrence, leastCommonAncestor);&#xD;&#xA;&#x9;const auto&amp; vertexActivation = this->getParentVertexActivation();&#xD;&#xA;&#x9;if (vertexActivation != nullptr)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;vertexActivation->enter(enteringTransition, eventOccurrence, leastCommonAncestor);&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="leastCommonAncestor" ordered="false" eType="#//Semantics/StateMachines/RegionActivation"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="ExitPointPseudostateActivation"
          eSuperTypes="#//Semantics/StateMachines/ConnectionPointActivation"/>
      <eClassifiers xsi:type="ecore:EClass" name="ChoicePseudostateActivation" eSuperTypes="#//Semantics/StateMachines/ConditionalPseudostateActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="doNotGenerate"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="ConditionalPseudostateActivation"
          abstract="true" eSuperTypes="#//Semantics/StateMachines/PseudostateActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;uml/Transition.hpp&quot;&#xD;&#xA;#include &quot;uml/Constraint.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="isElseTransition" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Determine if the given Transition materializes the 'else' branch of a ConditionalPseudoState.&#xD;&#xA;&#x9;// This is the case if it has a guard whose specification is&#xD;&#xA;&#x9;// an Expression that has no operand(s) and whose symbol is 'else'&#xD;&#xA;&#x9;/*if (transitionActivation)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;auto transition = std::dynamic_pointer_cast&lt;uml::Transition>(transitionActivation->getNode());&#xD;&#xA;&#x9;&#x9;if (transition->getGuard() != nullptr &amp;&amp; std::dynamic_pointer_cast&lt;uml::Expression>(transition->getGuard()->getSpecification()))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;auto guardExpression = std::dynamic_pointer_cast&lt;uml::Expression>(transition->getGuard()->getSpecification());&#xD;&#xA;&#x9;&#x9;&#x9;return guardExpression->getOperand()->empty() &amp;&amp; !guardExpression->getSymbol().empty() &amp;&amp; guardExpression->getSymbol()->equals(ELSE_OPERATOR);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}*/&#xD;&#xA;&#x9;return false;&#xD;&#xA;&#x9;/*boolean isElse = false;&#xD;&#xA;&#x9;if(transitionActivation!=null){&#xD;&#xA;&#x9;&#x9;Transition transition = (Transition)transitionActivation.getNode();&#xD;&#xA;&#x9;&#x9;if(transition.getGuard()!=null &amp;&amp; transition.getGuard().getSpecification() instanceof Expression){&#xD;&#xA;&#x9;&#x9;&#x9;Expression expression = (Expression) transition.getGuard().getSpecification();&#xD;&#xA;&#x9;&#x9;&#x9;isElse = expression.getOperands().isEmpty() &amp;&amp; expression.getSymbol() !=null &amp;&amp; expression.getSymbol().equals(ELSE_OPERATOR);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return isElse;*/"/>
          </eAnnotations>
          <eParameters name="transitionActivation" ordered="false" lowerBound="1"
              eType="#//Semantics/StateMachines/TransitionActivation"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="ForkPseudostateActivation" eSuperTypes="#//Semantics/StateMachines/PseudostateActivation">
        <eOperations name="_canPropagateExecution" ordered="false" lowerBound="1"
            eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="This convenience method is not needed as C++, as opposed to Java, does allow calling to an explicit super class method. "/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Convenience method. Java does no allow a call to an explicit super class method. For documentation&#xA;// developpers must have a look to: VertexActivation::canPropagateExecution(...)&#xA;boolean propagate = true;&#xA;if(leastCommonAncestor != null){&#xA;&#x9;RegionActivation parentRegionActivation = this.getOwningRegionActivation();&#xA;&#x9;if(leastCommonAncestor!=parentRegionActivation){&#xA;&#x9;&#x9;VertexActivation vertexActivation = (VertexActivation) parentRegionActivation.getParent();&#xA;&#x9;&#x9;if(vertexActivation != null){&#xA;&#x9;&#x9;&#x9;propagate = vertexActivation.canPropagateExecution(enteringTransition, eventOccurrence, leastCommonAncestor);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;return propagate;&#xA;"/>
          </eAnnotations>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="leastCommonAncestor" ordered="false" eType="#//Semantics/StateMachines/RegionActivation"/>
        </eOperations>
        <eOperations name="canPropagateExecution" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Static analysis is propagated through the parent. If the propagation is accepted by the parent, then it is evaluated&#xD;&#xA;&#x9;// for this Pseudostate. A ForkPseudoState can propagate the execution if all of its outgoing Transitions can&#xD;&#xA;&#x9;// propagate the execution. Note that there is no guard evaluation. This is normal since outgoing Transitions of&#xD;&#xA;&#x9;// a ForkPseudostate cannot have guards.&#xD;&#xA;&#x9;bool propagate = PSSM::Semantics::StateMachines::VertexActivationImpl::canPropagateExecution(enteringTransition, eventOccurrence, leastCommonAncestor);&#xD;&#xA;&#x9;if (propagate &amp;&amp; this->isEnterable(enteringTransition, true))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;unsigned int i = 0;&#xD;&#xA;&#x9;&#x9;while(propagate &amp;&amp; i &lt; this->m_outgoingTransitionActivations->size())&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;propagate = this->m_outgoingTransitionActivations->at(i)->canPropagateExecution(eventOccurrence);&#xD;&#xA;&#x9;&#x9;&#x9;++i;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return propagate;"/>
          </eAnnotations>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="leastCommonAncestor" ordered="false" eType="#//Semantics/StateMachines/RegionActivation"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="JoinPseudostateActivation" eSuperTypes="#//Semantics/StateMachines/PseudostateActivation">
        <eOperations name="_canPropagateExecution" ordered="false" lowerBound="1"
            eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="This convenience method is not needed as C++, as opposed to Java, does allow calling to an explicit super class method. "/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Convenience method. Java does no allow a call to an explicit super class method. For documentation&#xA;// developpers must have a look to: VertexActivation::canPropagateExecution(...)&#xA;boolean propagate = true;&#xA;if(leastCommonAncestor != null){&#xA;&#x9;RegionActivation parentRegionActivation = this.getOwningRegionActivation();&#xA;&#x9;if(leastCommonAncestor!=parentRegionActivation){&#xA;&#x9;&#x9;VertexActivation vertexActivation = (VertexActivation) parentRegionActivation.getParent();&#xA;&#x9;&#x9;if(vertexActivation != null){&#xA;&#x9;&#x9;&#x9;propagate = vertexActivation.canPropagateExecution(enteringTransition, eventOccurrence, leastCommonAncestor);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;return propagate;&#xA;"/>
          </eAnnotations>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="leastCommonAncestor" ordered="false" eType="#//Semantics/StateMachines/RegionActivation"/>
        </eOperations>
        <eOperations name="canPropagateExecution" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// If the join PseudoState cannot be entered the propagation stops and returns true. &#xD;&#xA;&#x9;// To return true otherwise, it is required that at least one outgoing transition of the Pseudostate &#xD;&#xA;&#x9;// accepts the propagation. &#xD;&#xA;&#x9;enteringTransition->setAnalyticalStatus(TransitionMetadata::TRAVERSED);&#xD;&#xA;&#x9;bool propagate = PSSM::Semantics::StateMachines::VertexActivationImpl::canPropagateExecution(enteringTransition, eventOccurrence, leastCommonAncestor);&#xD;&#xA;&#x9;if (propagate &amp;&amp; this->isEnterable(enteringTransition, true))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;this->evaluateAllGuards(eventOccurrence);&#xD;&#xA;&#x9;&#x9;propagate = false;&#xD;&#xA;&#x9;&#x9;if (this->getFireableTransitions()->size() > 0)&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;propagate = this->getFireableTransitions()->at(0)->canPropagateExecution(eventOccurrence);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;if (propagate) &#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;this->tagIncomingTransition(TransitionMetadata::NONE, true);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return propagate;"/>
          </eAnnotations>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="leastCommonAncestor" ordered="false" eType="#//Semantics/StateMachines/RegionActivation"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="TerminatePseudostateActivation"
          eSuperTypes="#//Semantics/StateMachines/PseudostateActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="doNotGenerate"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CompletionEventOccurrence" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence">
        <eOperations name="match" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// A CompletionEvent can only trigger a Transition with no&#xD;&#xA;&#x9;// Trigger. Hence it cannot match any Trigger&#xD;&#xA;&#x9;return false;"/>
          </eAnnotations>
          <eParameters name="trigger" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Trigger"/>
        </eOperations>
        <eOperations name="_match" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// A CompletionEvent can only trigger a Transition with no&#xA;&#x9;// Trigger. Hence, only if the passed list of Triggers is empty,&#xA;&#x9;// the CompletionEventOccurrence matches&#xA;&#x9;if(triggers->size() == 0){&#xA;&#x9;&#x9;return true;&#xA;&#x9;}&#xA;&#x9;return false;"/>
          </eAnnotations>
          <eParameters name="triggers" lowerBound="1" upperBound="-1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Trigger"/>
        </eOperations>
        <eOperations name="_register">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="this->setStateActivation(stateActivation);"/>
          </eAnnotations>
          <eParameters name="stateActivation" eType="#//Semantics/StateMachines/StateActivation"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="stateActivation" ordered="false"
            lowerBound="1" eType="#//Semantics/StateMachines/StateActivation"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="StateMachineEventAccepter" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventAccepter">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;PSSM/Semantics/StateMachines/StateActivation.hpp&quot;&#xD;&#xA;#include &quot;fUML/Semantics/Loci/Locus.hpp&quot;&#xD;&#xA;#include &quot;fUML/Semantics/Loci/ExecutionFactory.hpp&quot;&#xD;&#xA;#include &quot;fUML/Semantics/Loci/ChoiceStrategy.hpp&quot;&#xD;&#xA;#include &quot;fUML/Semantics/CommonBehavior/ObjectActivation.hpp&quot;&#xD;&#xA;#include &quot;fUML/Semantics/CommonBehavior/EventAccepter.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/DoActivityExecutionEventAccepter.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/CallEventOccurrence.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/CallEventExecution.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/StateMachineConfiguration.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="match" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// There are two cases in which the state machine event accepter can match&#xD;&#xA;&#x9;// 1 - In the current state machine configuration the event can be deferred&#xD;&#xA;&#x9;// 2 - In the current state machine configuration the current event can trigger one or more transitions&#xD;&#xA;&#x9;return this->isDeferred(eventOccurrence) | this->isTriggering(eventOccurrence);"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="accept" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// When an event occurrence is accepted this marks the beginning of a new RTC step for&#xD;&#xA;&#x9;// the executed state-machine. The following set of actions takes place:&#xD;&#xA;&#x9;// 1 - The event can be deferred if required&#xD;&#xA;&#x9;// 2 - The event can trigger one or more transitions if it is not deferred&#xD;&#xA;&#x9;//  2.1 - The list of transitions that can be fired using the given event&#xD;&#xA;&#x9;//        occurrence is computed.&#xD;&#xA;&#x9;//  2.2 - Transitions in the set of fireable transitions are fired **concurrently**&#xD;&#xA;&#x9;//  2.3 - If the accepted event occurrence is a call event occurrence then there is an explicit&#xD;&#xA;&#x9;//&#x9;  &quot;return from call&quot; which enables the caller to continue its execution. &#xD;&#xA;&#x9;// 3 - When the RTC step is about to complete, a new event accepter for the state-machine&#xD;&#xA;&#x9;//     is registered in the waiting event accepter list handled by the object activation&#xD;&#xA;&#x9;// Note that there is always just a single event accepter for a state-machine. This accepter&#xD;&#xA;&#x9;// analyzes the overall state machine configuration each time an event occurrence is accepted.&#xD;&#xA;&#x9;if (this->isDeferred(eventOccurrence))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;this->defer(eventOccurrence);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;else&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;auto fireableTransitionActivations = this->select(eventOccurrence);&#xD;&#xA;&#x9;&#x9;if (!fireableTransitionActivations->empty())&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;for (const auto&amp; fireableTransitionActivation : *fireableTransitionActivations) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;fireableTransitionActivation->fire(eventOccurrence);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;// If dispatched Event was a CallEventOccurrence or a CS_EventOccurrence which wraps a CallEventOccurrence,&#xD;&#xA;&#x9;// then check if caller needs to be released.&#xD;&#xA;&#x9;/*&#xD;&#xA;&#x9;// CS_EventOccurrence has not yet been implemented&#xD;&#xA;&#x9;if (auto csEventOccurrence = std::dynamic_pointer_cast&lt;PSCS::Semantics::CommonBehavior::CS_EventOccurrence>(eventOccurrence))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (auto callEventOccurrence = std::dynamic_pointer_cast&lt;fUML::Semantics::CommonBehavior::CallEventOccurrence>(eventOccurrence)->getWrappedEventOccurrence())&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;callEventOccurrence->releaseCaller();&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;// CallEventOccurrence has not yet been implemented&#xD;&#xA;&#x9;else if (auto callEventOccurrence = std::dynamic_pointer_cast&lt;fUML::Semantics::CommonBehavior::CallEventOccurrence>(eventOccurrence))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;callEventOccurrence->releaseCaller();&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;*/&#xD;&#xA;&#xD;&#xA;&#x9;const auto&amp; context = this->getRegistrationContext()->getContext();&#xD;&#xA;&#x9;if (context != nullptr &amp;&amp; context->getObjectActivation() != nullptr)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;const auto&amp; smEventAccepter = PSSM::Semantics::StateMachines::StateMachinesFactory::eInstance()->createStateMachineEventAccepter();&#xD;&#xA;&#x9;&#x9;smEventAccepter->setRegistrationContext(this->getRegistrationContext());&#xD;&#xA;&#x9;&#x9;context->_register(smEventAccepter);&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="select" ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/TransitionActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Find for the given configuration the set of transition that can fire.&#xD;&#xA;&#x9;return this->_select(eventOccurrence, this->m_registrationContext->getConfiguration()->getRootConfiguration());"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="_select" ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/TransitionActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Find all TransitionActivations that can fire on the given EventOccurrence.&#xD;&#xA;&#x9;// The set of TransitionActivations only contains those with the highest priority. &#xD;&#xA;&#x9;// In addition, no conflicting TransitionActivations are added to the set.&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;std::shared_ptr&lt;Bag&lt;PSSM::Semantics::StateMachines::TransitionActivation>> selectedTransitionActivations(new Bag&lt;PSSM::Semantics::StateMachines::TransitionActivation>());&#xD;&#xA;&#x9;for (const auto&amp; child : *(stateConfiguration->getChildren()))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;selectedTransitionActivations->insert(*(this->_select(eventOccurrence, child)));&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;if (selectedTransitionActivations->empty() &amp;&amp; stateConfiguration->getVertexActivation() != nullptr)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;for (const auto&amp; outgoingTransitionActivation : *(stateConfiguration->getVertexActivation()->getOutgoingTransitions()))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;if (outgoingTransitionActivation->canFireOn(eventOccurrence))&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;selectedTransitionActivations->add(outgoingTransitionActivation);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;&#x9;if (selectedTransitionActivations->size() > 1)&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;const auto&amp; choiceStrategy = std::dynamic_pointer_cast&lt;fUML::Semantics::Loci::ChoiceStrategy>(this->m_registrationContext->getLocus()->getFactory()->getStrategy(&quot;choice&quot;));&#xD;&#xA;&#x9;&#x9;&#x9;const auto&amp; chosenTransitionActivation = selectedTransitionActivations->at(choiceStrategy->choose(selectedTransitionActivations->size()-1));&#xD;&#xA;&#x9;&#x9;&#x9;selectedTransitionActivations->clear();&#xD;&#xA;&#x9;&#x9;&#x9;selectedTransitionActivations->add(chosenTransitionActivation);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;return selectedTransitionActivations;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="stateConfiguration" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateConfiguration"/>
        </eOperations>
        <eOperations name="isDeferred" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Determine if the dispatched event occurrence is deferred in the&#xD;&#xA;&#x9;// current state machine configuration. An event occurrence can only be deferred&#xD;&#xA;&#x9;// if the following conditions are fulfilled:&#xD;&#xA;&#x9;// 1 - One active state in the hierarchy declares the event types as being deferred.&#xD;&#xA;&#x9;// 2 - No transitions (ready to fire) with a higher priority than the deferring state&#xD;&#xA;&#x9;//     could be found.&#xD;&#xA;&#x9;// 3 - It does not exist any running doActivity having already registered an accepter&#xD;&#xA;&#x9;//     for the given event occurrence&#xD;&#xA;&#x9;/*boolean deferred = this._isDeferred(eventOccurrence, this.registrationContext.getConfiguration().rootConfiguration);&#xD;&#xA;&#x9;if(deferred){&#xD;&#xA;&#x9;&#x9;Object_ context = this.registrationContext.context;&#xD;&#xA;&#x9;&#x9;if(context != null &amp;&amp; context.objectActivation != null){&#xD;&#xA;&#x9;&#x9;&#x9;int  i = 1;&#xD;&#xA;&#x9;&#x9;&#x9;while(deferred &amp;&amp; i &lt;= context.objectActivation.waitingEventAccepters.size()){&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;EventAccepter currentEventAccepter = context.objectActivation.waitingEventAccepters.get(i - 1);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if(currentEventAccepter != this &#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&amp;&amp; currentEventAccepter instanceof DoActivityExecutionEventAccepter&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&amp;&amp; currentEventAccepter.match(eventOccurrence)){&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;deferred = false;;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;i++;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return deferred;*/&#xD;&#xA;&#xD;&#xA;&#x9;bool deferred = this->_isDeferred(eventOccurrence, this->m_registrationContext->getConfiguration()->getRootConfiguration());&#xD;&#xA;&#x9;if (deferred) &#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;const auto&amp; context = this->m_registrationContext;&#xD;&#xA;&#x9;&#x9;if (context != nullptr &amp;&amp; context->getObjectActivation() != nullptr)&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;for (const auto&amp; waitingEventAccepter : *(context->getObjectActivation()->getWaitingEventAccepters()))&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (waitingEventAccepter != std::dynamic_pointer_cast&lt;fUML::Semantics::CommonBehavior::EventAccepter>(this->getThisStateMachineEventAccepterPtr()) &amp;&amp; waitingEventAccepter->match(eventOccurrence)) &#xD;&#xA;&#x9;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (auto doActivityExecutionEventAccepter = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::DoActivityExecutionEventAccepter>(waitingEventAccepter))&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;deferred = false;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return deferred;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="_isDeferred" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Determine if the given StateConfiguration is capable of deferring the given EvenOccurrence.&#xD;&#xA;&#x9;bool deferred = false;&#xD;&#xA;&#x9;for (const auto&amp; child : *stateConfiguration->getChildren())&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;deferred = this->_isDeferred(eventOccurrence, child);&#xD;&#xA;&#x9;&#x9;if (deferred) break;&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;if (!deferred)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (auto stateActivation = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::StateActivation>(stateConfiguration->getVertexActivation()))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;if (stateActivation->canDefer(eventOccurrence) &amp;&amp; this->_select(eventOccurrence, stateConfiguration)->empty())&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;deferred = true;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return deferred;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="stateConfiguration" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateConfiguration"/>
        </eOperations>
        <eOperations name="defer" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Defers the given event occurrence. A deferred event occurrence is registered in&#xD;&#xA;&#x9;// the deferred event pool. This latter refers to the deferred event as well as to the&#xD;&#xA;&#x9;// the deferring state.&#xD;&#xA;&#x9;return this->_defer(eventOccurrence, this->m_registrationContext->getConfiguration()->getRootConfiguration());"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="_defer" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Defers the given EventOccurrence in the context of the given StateConfiguration.&#xD;&#xA;&#x9;bool deferred = false;&#xD;&#xA;&#x9;for (const auto&amp; child : *(stateConfiguration->getChildren()))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;deferred = this->_defer(eventOccurrence, child);&#xD;&#xA;&#x9;&#x9;if (deferred) break;&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;if (!deferred)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (const auto&amp; stateActivation = std::dynamic_pointer_cast&lt;StateActivation>(stateConfiguration->getVertexActivation()))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;if (stateActivation->canDefer(eventOccurrence))&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;stateActivation->defer(eventOccurrence);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;deferred = true;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return deferred;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="stateConfiguration" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateConfiguration"/>
        </eOperations>
        <eOperations name="isTriggering" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Returns true when one or more transition are ready to be fired using this event&#xD;&#xA;&#x9;// occurrence; false otherwise.&#xD;&#xA;&#x9;return !this->select(eventOccurrence)->empty();"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="registrationContext"
            ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateMachineExecution"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="DoActivityExecutionEventAccepter"
          eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventAccepter">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;fUML/Semantics/CommonBehavior/ObjectActivation.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="match" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Delegate the operation call to the encapsulated DoActivityExecutionEventAccepter.&#xD;&#xA;&#x9;return this->m_encapsulatedAccepter->match(eventOccurrence);"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="accept" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// The EventOccurrence accepted through the StateMachine Event Pool leads&#xD;&#xA;&#x9;// to the triggering of a RTC step in the context of the doActivity.&#xD;&#xA;&#x9;// To realize this, the EventOccurrence is registered at the Event Pool of the&#xD;&#xA;&#x9;// DoActivityContextObjectActivation. This will trigger a new RTC step&#xD;&#xA;&#x9;// in the DoActivityContextObject instead of the State Machine context.&#xD;&#xA;&#x9;this->m_context->getObjectActivation()->send(eventOccurrence);"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="context" ordered="false"
            lowerBound="1" eType="#//Semantics/StateMachines/DoActivityContextObject"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="encapsulatedAccepter"
            ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventAccepter"
            containment="true"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="DoActivityContextObjectActivation"
          eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/ObjectActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;fUML/Semantics/CommonBehavior/impl/ObjectActivationImpl.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/DoActivityContextObject.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/StateActivation.hpp&quot;&#xD;&#xA;#include &quot;fUML/Semantics/Loci/Locus.hpp&quot;&#xD;&#xA;#include &quot;fUML/Semantics/Loci/Executor.hpp&quot;&#xD;&#xA;#include &quot;uml/Behavior.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="dispatchNextEvent" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// The dispatching process behaves exactly the same as specified in fUML.&#xD;&#xA;&#x9;// In addition to this behavior, the dispatch sequence of an ObjectActivation&#xD;&#xA;&#x9;// for a DoActivityContextObject notifies the owning State if the executed doActivity is now considered completed. &#xD;&#xA;&#x9;// This is the case if no EventAccepter is registered at this ObjectActivation after an RTC step.&#xD;&#xA;&#x9;fUML::Semantics::CommonBehavior::ObjectActivationImpl::ObjectActivationImpl::dispatchNextEvent();&#xD;&#xA;&#x9;if (this->m_waitingEventAccepters->size() == 0)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;auto doActivityObject = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::DoActivityContextObject>(this->getObject());&#xD;&#xA;&#x9;&#x9;auto doActivityObjectOwner = std::shared_ptr&lt;uml::Element> (doActivityObject->getOwner());&#xD;&#xA;&#x9;&#x9;if (auto owner = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::StateActivation>(doActivityObjectOwner))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;owner->setIsDoActivityCompleted(true);&#xD;&#xA;&#x9;&#x9;&#x9;if (owner->hasCompleted()) &#xD;&#xA;&#x9;&#x9;&#x9;&#x9;owner->notifyCompletion();&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="startBehavior" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// The expected Classifier is the doActivity behavior. The doActivity&#xD;&#xA;&#x9;// behavior is executed as if it was the Classifier of a Class typing&#xD;&#xA;&#x9;// the doActivity context Object. It only exists one doActivity executed&#xD;&#xA;&#x9;// as a classifier behavior for a DoActivityContextObject.&#xD;&#xA;&#xD;&#xA;&#x9;// Start the Event Dispatch Loop of this DoActivityContextObjectActivation&#xD;&#xA;&#x9;this->_startObjectBehavior();&#xD;&#xA;&#xD;&#xA;&#x9;auto doActivityBehavior = std::dynamic_pointer_cast&lt;uml::Behavior>(classifier);&#xD;&#xA;&#x9;if (doActivityBehavior != nullptr &amp;&amp; this->getClassifierBehaviorExecutions()->empty())&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;auto doActivityExecution = this->getObject()->getLocus()->getExecutor()->execute(doActivityBehavior, this->getObject(), inputs);&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;/*if(classifier != null &#xD;&#xA;&#x9;&#x9;&amp;&amp; classifier instanceof Behavior&#xD;&#xA;&#x9;&#x9;&amp;&amp; this.classifierBehaviorInvocations.isEmpty()){&#xD;&#xA;&#x9;&#x9;ClassifierBehaviorInvocationEventAccepter newInvocation = new ClassifierBehaviorInvocationEventAccepter();&#xD;&#xA;&#x9;&#x9;newInvocation.objectActivation = this;&#xD;&#xA;&#x9;&#x9;newInvocation.classifier = classifier;&#xD;&#xA;&#x9;&#x9;Execution doActivityExecution = this.object.locus.factory.createExecution((Behavior)classifier, this.object); &#xD;&#xA;&#x9;&#x9;if(inputs != null){&#xD;&#xA;&#x9;&#x9;&#x9;for(int i = 0; i &lt; inputs.size(); i++){&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;doActivityExecution.setParameterValue(inputs.get(i));&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;newInvocation.execution = doActivityExecution;&#xD;&#xA;&#x9;&#x9;this.classifierBehaviorInvocations.add(newInvocation);&#xD;&#xA;&#x9;&#x9;this.register(newInvocation);&#xD;&#xA;&#x9;&#x9;InvocationEventOccurrence invocationEventOccurrence = new InvocationEventOccurrence();&#xD;&#xA;&#x9;&#x9;invocationEventOccurrence.execution = newInvocation.execution;&#xD;&#xA;&#x9;&#x9;this.eventPool.add(invocationEventOccurrence);&#xD;&#xA;&#x9;&#x9;this._send(new ArrivalSignal());&#xD;&#xA;&#x9;}*/"/>
          </eAnnotations>
          <eParameters name="classifier" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class"/>
          <eParameters name="inputs" ordered="false" upperBound="-1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/ParameterValue"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="HistoryPseudostateActivation" abstract="true"
          eSuperTypes="#//Semantics/StateMachines/PseudostateActivation">
        <eOperations name="hasDefaultTransition" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Determine if the history pseudo-state activation has default transition.&#xA;// Returns true if it has one, false otherwise&#xA;boolean defaultTransition = false;&#xA;if(this.outgoingTransitionActivations.size()==1){&#xA;&#x9;defaultTransition = true;&#xA;}&#xA;return defaultTransition;&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="restore" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Restore the state. Restoring a state consists in :&#xA;// 1. Registering the state to the state-machine configuration&#xA;// 2. Complete the state if needs to be completed&#xA;// 3. If the state cannot be completed then execute its entry and its doActivity. Finally,&#xA;//    if it has regions then these regions are restored (in paralell).&#xA;State state = (State) stateActivation.getNode();&#xA;stateActivation.status = StateMetadata.ACTIVE;&#xA;StateMachineExecution smExecution = (StateMachineExecution)this.getStateMachineExecution();&#xA;smExecution.getConfiguration().register(stateActivation);&#xA;stateActivation.isEntryCompleted = state.getEntry() == null;&#xA;stateActivation.isDoActivityCompleted = state.getDoActivity() == null;&#xA;stateActivation.isExitCompleted = state.getExit() == null;&#xA;if(stateActivation.hasCompleted()){&#xA;&#x9;stateActivation.notifyCompletion();&#xA;}else{&#xA;&#x9;stateActivation.tryExecuteEntry(eventOccurrence);&#xA;&#x9;stateActivation.tryInvokeDoActivity(eventOccurrence);&#xA;&#x9;for(Iterator&lt;RegionActivation> regionActivationsIterator = stateActivation.regionActivation.iterator(); regionActivationsIterator.hasNext();){&#xA;&#x9;&#x9;this.restore(regionActivationsIterator.next(), enteringTransition, eventOccurrence);&#xA;&#x9;}&#xA;}&#xA;"/>
          </eAnnotations>
          <eParameters name="stateActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateActivation"/>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="restore" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="regionActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/RegionActivation"/>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="JunctionPseudostateActivation" eSuperTypes="#//Semantics/StateMachines/ConditionalPseudostateActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="doNotGenerate"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="DeepHistoryPseudostateActivation"
          eSuperTypes="#//Semantics/StateMachines/HistoryPseudostateActivation">
        <eOperations name="canRestore" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// A state activation can only be restored if it is directly or indirectly&#xA;// by the region containing the history state.&#xA;boolean canRestore = false;&#xA;if(stateActivation != null){&#xA;&#x9;RegionActivation historyRegion = (RegionActivation) this.getParent(); &#xA;&#x9;if(historyRegion.getVertexActivation((Vertex)stateActivation.getNode()) != null){&#xA;&#x9;&#x9;canRestore = true;&#xA;&#x9;}&#xA;}&#xA;return canRestore;&#xA;"/>
          </eAnnotations>
          <eParameters name="stateActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateActivation"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="ShallowHistoryPseudostateActivation"
          eSuperTypes="#//Semantics/StateMachines/HistoryPseudostateActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="doNotGenerate"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="DeferredEventOccurrence" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="//#include &quot;fUML::EventOccurrence.hpp&quot;&#xA;//#include &quot;fUML::FUMLFactory.hpp&quot;&#xA;"/>
        </eAnnotations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="constrainingStateActivation"
            ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateActivation"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="deferredEventOccurrence"
            ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="Loci" nsURI="http:///PSSM/Semantics/Loci.ecore" nsPrefix="PSSM.Semantics.Loci">
      <eClassifiers xsi:type="ecore:EClass" name="SM_ExecutionFactory" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/Loci/ExecutionFactory">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;fUML/FUMLFactory.hpp&quot;&#xA;#include &quot;uml/StateMachine.hpp&quot;&#xA;#include &quot;uml/Pseudostate.hpp&quot;&#xA;#include &quot;PSSM/Semantics/StateMachines/StateMachineExecution.hpp&quot;&#xA;#include &quot;uml/State.hpp&quot;&#xA;#include &quot;uml/FinalState.hpp&quot;&#xA;#include &quot;uml/OpaqueExpression.hpp&quot;&#xA;#include &quot;uml/ReadSelfAction.hpp&quot;&#xA;#include &quot;uml/Transition.hpp&quot;&#xA;#include &quot;uml/Region.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="instantiateVisitor" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Loci/SemanticVisitor">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="std::shared_ptr&lt;fUML::Semantics::Loci::SemanticVisitor> visitor = nullptr;&#xD;&#xA;&#xD;&#xA;&#x9;std::shared_ptr&lt;uml::StateMachine> is_sm = std::dynamic_pointer_cast&lt;uml::StateMachine>(element);&#xD;&#xA;&#x9;std::shared_ptr&lt;uml::Pseudostate> is_pseudoState = std::dynamic_pointer_cast&lt;uml::Pseudostate>(element);&#xD;&#xA;&#x9;std::shared_ptr&lt;uml::State> is_state = std::dynamic_pointer_cast&lt;uml::State>(element);&#xD;&#xA;&#x9;std::shared_ptr&lt;uml::FinalState> is_final_state = std::dynamic_pointer_cast&lt;uml::FinalState>(element);&#xD;&#xA;&#x9;std::shared_ptr&lt;uml::Transition> is_transition = std::dynamic_pointer_cast&lt;uml::Transition>(element);&#xD;&#xA;&#x9;std::shared_ptr&lt;uml::Region> is_region = std::dynamic_pointer_cast&lt;uml::Region>(element);&#xD;&#xA;&#x9;std::shared_ptr&lt;uml::OpaqueExpression> is_opaque_expression = std::dynamic_pointer_cast&lt;uml::OpaqueExpression>(element);&#xD;&#xA;&#x9;std::shared_ptr&lt;uml::ReadSelfAction> is_read_self_action = std::dynamic_pointer_cast &lt;uml::ReadSelfAction>(element);&#xD;&#xA;&#xD;&#xA;&#x9;if(is_sm != nullptr) {&#xD;&#xA;&#x9;&#x9;//visitor = new PSSM::Semantics::StateMachines::StateMachineExecution()&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;else if(is_pseudoState != nullptr) {&#xD;&#xA;&#x9;&#x9;std::shared_ptr&lt;uml::Pseudostate> pseudostate = is_pseudoState;&#xD;&#xA;//&#x9;&#x9;switch(pseudostate->getKind()){&#xD;&#xA;//&#x9;&#x9;&#x9;case uml::PseudostateKind::INITIAL: visitor = new PSSM::Semantics::StateMachines::InitialPseudostateActivation(); break;&#xD;&#xA;//&#x9;&#x9;&#x9;case uml::PseudostateKind::ENTRYPOINT:&#xD;&#xA;//&#x9;&#x9;&#x9;case uml::PseudostateKind::EXITPOINT:&#xD;&#xA;//&#x9;&#x9;&#x9;case uml::PseudostateKind::CHOICE:&#xD;&#xA;//&#x9;&#x9;&#x9;case uml::PseudostateKind::FORK:&#xD;&#xA;//&#x9;&#x9;&#x9;case uml::PseudostateKind::JOIN:&#xD;&#xA;//&#x9;&#x9;&#x9;case uml::PseudostateKind::TERMINATE:&#xD;&#xA;//&#x9;&#x9;&#x9;case uml::PseudostateKind::DEEPHISTORY:&#xD;&#xA;//&#x9;&#x9;&#x9;case uml::PseudostateKind::SHALLOWHISTORY:&#xD;&#xA;//&#x9;&#x9;&#x9;case uml::PseudostateKind::JUNCTION:&#xD;&#xA;//&#x9;&#x9;}&#xD;&#xA;&#x9;} else if(is_state != nullptr) {&#xD;&#xA;//&#x9;&#x9;if(is_final_state != nullptr){&#xD;&#xA;//&#x9;&#x9;&#x9;visitor = new PSSM::Semantics::StateMachines::FinalStateActivation();&#xD;&#xA;//&#x9;&#x9;} else {&#xD;&#xA;//&#x9;&#x9;&#x9;visitor = new PSSM::Semantics::StateMachines::StateActivation();&#xD;&#xA;//&#x9;&#x9;}&#xD;&#xA;&#x9;} else if (is_transition != nullptr) {&#xD;&#xA;&#x9;&#x9;std::shared_ptr&lt;uml::Transition> transition = is_transition;&#xD;&#xA;//&#x9;&#x9;switch(transition->getKind()){&#xD;&#xA;//&#x9;&#x9;&#x9;case uml::TransitionKind::EXTERNAL:&#xD;&#xA;//&#x9;&#x9;&#x9;case uml::TransitionKind::INTERNAL:&#xD;&#xA;//&#x9;&#x9;&#x9;case uml::TransitionKind::LOCAL:&#xD;&#xA;//&#x9;&#x9;}&#xD;&#xA;&#x9;} else if(is_region != nullptr) {&#xD;&#xA;&#x9;&#x9;//visitor = new PSSM::Semantics::StateMachines::RegionActivation();&#xD;&#xA;&#x9;} else if(is_opaque_expression != nullptr) {&#xD;&#xA;&#x9;&#x9;//visitor = new PSSM::Semantics::Values::SM_OpaqueExpressionEvaluation();&#xD;&#xA;&#x9;} else if(is_read_self_action) {&#xD;&#xA;&#x9;&#x9;//visitor = new PSSM::Semantics::Actions::SM_ReadSelfActionActivation();&#xD;&#xA;&#x9;} else {&#xD;&#xA;&#x9;&#x9;visitor = this->instantiateVisitor(element);&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;return visitor;&#xD;&#xA;//SemanticVisitor visitor = null ;&#xD;&#xA;//if(element instanceof StateMachine){&#xD;&#xA;//&#x9;visitor = new StateMachineExecution();&#xD;&#xA;//}else if (element instanceof Pseudostate) {&#xD;&#xA;//&#x9;Pseudostate pseudostate = (Pseudostate) element;&#xD;&#xA;//&#x9;switch(pseudostate.getKind()){&#xD;&#xA;//&#x9;&#x9;case INITIAL_LITERAL: visitor = new InitialPseudostateActivation(); break;&#xD;&#xA;//&#x9;&#x9;case ENTRY_POINT_LITERAL: visitor = new EntryPointPseudostateActivation(); break;&#xD;&#xA;//&#x9;&#x9;case EXIT_POINT_LITERAL: visitor = new ExitPointPseudostateActivation(); break;&#xD;&#xA;//&#x9;&#x9;case CHOICE_LITERAL: visitor = new ChoicePseudostateActivation(); break;&#xD;&#xA;//&#x9;&#x9;case FORK_LITERAL: visitor = new ForkPseudostateActivation(); break;&#xD;&#xA;//&#x9;&#x9;case JOIN_LITERAL: visitor = new JoinPseudostateActivation(); break;&#xD;&#xA;//&#x9;&#x9;case TERMINATE_LITERAL: visitor = new TerminatePseudostateActivation(); break;&#xD;&#xA;//&#x9;&#x9;case DEEP_HISTORY_LITERAL: visitor = new DeepHistoryPseudostateActivation(); break;&#xD;&#xA;//&#x9;&#x9;case SHALLOW_HISTORY_LITERAL: visitor = new ShallowHistoryPseudostateActivation(); break;&#xD;&#xA;//&#x9;&#x9;case JUNCTION_LITERAL: visitor = new JunctionPseudostateActivation(); break;&#xD;&#xA;//&#x9;}&#xD;&#xA;//}else if (element instanceof State) {&#xD;&#xA;//&#x9;if(element instanceof FinalState){&#xD;&#xA;//&#x9;&#x9;visitor = new FinalStateActivation();&#xD;&#xA;//&#x9;}else{&#xD;&#xA;//&#x9;&#x9;visitor = new StateActivation() ;&#xD;&#xA;//&#x9;}&#xD;&#xA;//}else if (element instanceof Transition) {&#xD;&#xA;//&#x9;Transition transition = (Transition) element;&#xD;&#xA;//&#x9;switch(transition.getKind()){&#xD;&#xA;//&#x9;&#x9;case EXTERNAL_LITERAL: visitor = new ExternalTransitionActivation(); break;&#xD;&#xA;//&#x9;&#x9;case INTERNAL_LITERAL: visitor = new InternalTransitionActivation(); break;&#xD;&#xA;//&#x9;&#x9;case LOCAL_LITERAL: visitor = new LocalTransitionActivation(); break;&#xD;&#xA;//&#x9;}&#xD;&#xA;//}else if (element instanceof Region) {&#xD;&#xA;//&#x9;visitor = new RegionActivation();&#xD;&#xA;//}else if(element instanceof OpaqueExpression) {&#xD;&#xA;//&#x9;visitor = new SM_OpaqueExpressionEvaluation();&#xD;&#xA;//}else if(element instanceof ReadSelfAction){&#xD;&#xA;//&#x9;visitor = new SM_ReadSelfActionActivation();&#xD;&#xA;//}else {&#xD;&#xA;//&#x9;visitor = super.instantiateVisitor(element);&#xD;&#xA;//}&#xD;&#xA;//return visitor;"/>
          </eAnnotations>
          <eParameters name="element" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Element"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="SM_Locus" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/Loci/Locus">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="&#xA;#include &lt;algorithm>&#xA;#include &quot;uml/Classifier.hpp&quot;&#xA;#include &quot;uml/Behavior.hpp&quot;&#xA;#include &quot;uml/Class.hpp&quot;&#xA;#include &quot;fUML/FUMLFactory.hpp&quot;&#xA;#include &quot;fUML/Semantics/Loci/ExecutionFactory.hpp&quot;&#xA;#include &quot;fUML/Semantics/Loci/Executor.hpp&quot;&#xA;#include &quot;PSSM/MDE4CPP_Extensions/PSSM_Object.hpp&quot;&#xA;#include &quot;fUML/Semantics/CommonBehavior/Execution.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="instantiate" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//MDE4CPP_Extensions/FUML_Object">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="documentation" value="**This method is implemented in every model-specific locus**"/>
            <details key="body" value="/*std::shared_ptr&lt;SM_Object> object = nullptr;&#xA;&#x9;std::shared_ptr&lt;uml::Behavior> behavior = std::dynamic_pointer_cast&lt;uml::Behavior>(type);&#xA;&#x9;if(behavior != nullptr)&#xA;&#x9;{&#xA;&#x9;&#x9;std::shared_ptr&lt;SM_Object>  context = nullptr;&#xA;&#x9;&#x9;object = std::dynamic_pointer_cast&lt;SM_Object>(this->getFactory()->createExecution(behavior, nullptr));&#xA;&#x9;}&#xA;&#x9;else&#xA;&#x9;{&#xA;&#x9;&#x9;object = PSSMFactory::eInstance()->createSM_Object();&#xA;&#x9;&#x9;object->getTypes()->push_back(type);&#xA;&#x9;&#x9;object->createFeatureValues();&#xA;&#x9;&#x9;//this->add(object);&#xA;&#x9;}&#xA;&#xA;&#x9;return object;*/&#xA;&#xA;&#x9;/*&#xA;&#x9; * This method is implemented in every model-specific locus&#xA;&#x9; */&#xA;&#xA;&#x9;return nullptr;"/>
          </eAnnotations>
          <eParameters name="type" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class"/>
        </eOperations>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="Actions" nsURI="http:///PSSM/Semantics/Actions.ecore" nsPrefix="PSSM.Semantics.Actions">
      <eClassifiers xsi:type="ecore:EClass" name="SM_ReadSelfActionActivation">
        <eOperations name="getExecutionContext" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//MDE4CPP_Extensions/FUML_Object">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// The context object can be a DoActivityContextObject. A DoActivityContextObject&#xD;&#xA;&#x9;// is the execution context of a doActivity behavior executed on its own thread of&#xD;&#xA;&#x9;// execution. It references the context object from which the doActivity was invoked.&#xD;&#xA;&#x9;// This context may contains features (e.g. operations, properties) that may be manipulated&#xD;&#xA;&#x9;// by the doActivity. To enable this, in this situation the ReadSelfAction must resolve&#xD;&#xA;&#x9;// to the context of the DoActivityContextObject.&#xD;&#xA;&#x9;/*Object_ context = super.getExecutionContext();&#xD;&#xA;&#x9;if(context instanceof DoActivityContextObject){&#xD;&#xA;&#x9;&#x9;context = ((DoActivityContextObject)context).context;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return context;*/&#xD;&#xA;&#x9;return nullptr;"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
    </eSubpackages>
  </eSubpackages>
  <eSubpackages name="MDE4CPP_Extensions" nsPrefix="PSSM_Semantics.Semantics.MDE4CPP_Extensions">
    <eClassifiers xsi:type="ecore:EClass" name="PSSM_Object" abstract="true" eSuperTypes="../../fuml/model/fUML.ecore#//MDE4CPP_Extensions/FUML_Object">
      <eAnnotations source="MDE4CPP_Substitutes" references="../../fuml/model/fUML.ecore#//Semantics/StructuredClassifiers/Object">
        <details key="doc" value="This class provides an interface defining fUML-specific functionality of PSSM::Semantics::StructuredClassifiers::SM_Object&#xD;&#xA;to generated UML model classes within MDE4CPP. Thus, it can be understood as a substitution of PSSM::Semantics::StructuredClassifiers::SM_Object"/>
      </eAnnotations>
      <eAnnotations source="http://tu-ilmenau.de/see/codegen">
        <details key="implIncludes" value="#include &quot;fUML/FUMLFactory.hpp&quot;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/CommonBehaviorFactory.hpp&quot;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/SM_ObjectActivation.hpp&quot;"/>
      </eAnnotations>
      <eOperations name="startBehavior" ordered="false" lowerBound="1">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="body" value="// This Operation is identical to FUML_Object::startBehavior() with the exception that &#xA;&#x9;// here, a SM_ObjectActivation is created and initialized instead of an ObjectActivation.&#xA;&#x9;// This specialized kind of ObjectActivation allows the registering of CompletionEventOccurrences.&#xA;&#x9;if(this->getObjectActivation() == nullptr)&#xA;&#x9;{&#xA;&#x9;&#x9;this->setObjectActivation(std::dynamic_pointer_cast&lt;PSSM::Semantics::CommonBehavior::SM_ObjectActivation>(PSSM::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createSM_ObjectActivation()));&#xA;&#x9;&#x9;this->getObjectActivation()->setObject(this->getThisFUML_ObjectPtr());&#xA;&#x9;}&#xA;&#x9;this->getObjectActivation()->startBehavior(classifier, inputs);"/>
        </eAnnotations>
        <eParameters name="classifier" ordered="false" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class"/>
        <eParameters name="inputs" ordered="false" upperBound="-1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/ParameterValue"/>
      </eOperations>
      <eOperations name="destroy" ordered="false" lowerBound="1">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="body" value="// In addition to realize the normal process of stopping the object activation&#xD;&#xA;// as well as removing the current object from the locus, this destruction phase&#xD;&#xA;// also implies removal of all events remaining in the pool. This prevents the&#xD;&#xA;// dispatch loop to actually get the next event (even if at this step there is no&#xD;&#xA;// chance to match an accepter) whereas the current object is not anymore registered.&#xD;&#xA;// in the Locus.&#xD;&#xA;if(this->getObjectActivation() != nullptr)&#xD;&#xA;    {&#xD;&#xA;    &#x9;this->getObjectActivation()->stop();&#xD;&#xA;    &#x9;this->getObjectActivation()->getEventPool()->clear();&#xD;&#xA;    &#x9;this->setObjectActivation(nullptr);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    this->getTypes()->clear();&#xD;&#xA;    //ExtensionalValueImpl::destroy();"/>
        </eAnnotations>
      </eOperations>
    </eClassifiers>
  </eSubpackages>
</ecore:EPackage>
