[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */]
[module generateBuildFile('http://www.eclipse.org/emf/2002/Ecore')]

[import ecore4CPP::generator::main::helper /]
[import ecore4CPP::generator::main::helpers::keywords /]
[import ecore4CPP::generator::main::validation::validation /]

[query public metaModelLibraries(anEPackage : EPackage) : Set(EPackage) = OrderedSet{anEPackage.eAllContents().eClass().getRootPackage(),anEPackage.eAllContents(EClass).eAllSuperTypes.getRootPackage(),anEPackage.eAllContents(EStructuralFeature).eType.ePackage,anEPackage.eAllContents(EParameter).eType.getRootPackage()}->flatten()->sortedBy(name) /]

[template public generateBuildFile(aPackage : EPackage) {
 	packageName : String = aPackage.getNamespace('_',false);
}]

[comment ------------------------------------------------------------------- /]
[comment generate CMakeLists.txt for model libary                            /]
[comment ------------------------------------------------------------------- /]
[file (aPackage.generateNamespacePath().concat('/').concat('CMakeLists.txt'), false, 'UTF-8')]
# DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN
# @generator: ecore4cpp::generator::main::generateBuildFile

# C++ project of model [aPackage.generateNamespacePath()/].ecore, generated by Ecore4CPP

CMAKE_MINIMUM_REQUIRED(VERSION 3.9)

[comment --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- /]
[comment generate Header only Package                            /]
[comment --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- /]

PROJECT([packageName/]_Interface)
[if (aPackage.getRootPackage().hasKey(keyPackageVersion()))]
set([packageName/]_Interface_VERSION [aPackage.getRootPackage().valueKey(keyPackageVersion())/])
[else]
set([packageName/]_Interface_VERSION 0.0.1) #No Version codegen annotation defined in model [aPackage.getRootPackage().name/]. Use default version. 
[/if]

IF(NOT CMAKE_BUILD_TYPE) 
    SET(CMAKE_BUILD_TYPE Debug)
ENDIF(NOT CMAKE_BUILD_TYPE)
SET(CMAKE_DEBUG_POSTFIX d)

SET(CMAKE_CXX_STANDARD 17)

SET(SOURCE_FILES_Interface
# Factories and packages
	[aPackage.name/]Factory.hpp
	[aPackage.name/]Package.hpp
[comment only for root packeges a plugin manager will be generated/]
[if (aPackage.eSuperPackage.oclIsUndefined())]
# Package plugin
	[aPackage.name/]Plugin.hpp
[/if]
# Package content
[for (aClass : EClass | aPackage.eContents(EClass)->reject(doNotGenerateEClassifier())->asOrderedSet()->sortedBy(name))]
	[aClass.name.toUpperFirst()/].hpp
[/for]
)

ADD_LIBRARY([packageName/]_Interface INTERFACE ${SOURCE_FILES_Interface})
[generateLibraryLinking(true)/]
ADD_LIBRARY([aPackage.getNamespace('::',false)/]::[packageName/]_Interface ALIAS [packageName/]_Interface)

[comment createConfigureDeliverPackageTargets(aPackage, packageName.concat('_Interface'))/]

[comment generatePackageConfigDelivering(packageName.concat('_Interface'))/]
[comment createInstallAllPackageConfigs(aPackage, packageName.concat('_Interface')/]

[comment --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- /]
[comment generate Implementation  Package                            					/]
[comment --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- /]
PROJECT([packageName/])
[if (aPackage.getRootPackage().hasKey(keyPackageVersion()))]
set([packageName/]_VERSION [aPackage.getRootPackage().valueKey(keyPackageVersion())/])
[else]
set([packageName/]_VERSION 0.0.1) #No Version codegen annotation defined in model [aPackage.getRootPackage().name/]. Use default version. 
[/if]

#list(APPEND CMAKE_MODULE_PATH "${PROJECT_SOURCE_DIR}")
#list(APPEND CMAKE_MODULE_PATH ${MDE4CPP_HOME}/application/lib/cmake/})
#list(APPEND CMAKE_MODULE_PATH ${MDE4CPP_HOME}/application/lib/cmake/[packageName/]})

IF(NOT CMAKE_BUILD_TYPE) 
    SET(CMAKE_BUILD_TYPE Debug)
ENDIF(NOT CMAKE_BUILD_TYPE)
SET(CMAKE_DEBUG_POSTFIX d)

SET(CMAKE_CXX_STANDARD 17)
				
[let subPackages : OrderedSet(EPackage) =  aPackage.eSubpackages->reject(doNotGenerateEPackage())->asOrderedSet()->sortedBy(name)]
[comment if there are dependencies between Subpackages, config files has to be known in Subpackages for the first time to avoid warnings/]
	[if (subPackages->size()>0)]
INCLUDE(CMakePackageConfigHelpers)
		[for (aSubPackage : EPackage| subPackages)]
[aSubPackage.generateConfigureConfigFile(aSubPackage.getNamespace( '_', false),true)/]
[aSubPackage.generateConfigureConfigFile(aSubPackage.getNamespace( '_', false).concat('_Interface'),true)/]
		[/for] 
INSTALL( 
  FILES 
		[for (aSubPackage : EPackage| subPackages)] 
     "${CMAKE_CURRENT_BINARY_DIR}/[aSubPackage.name/]/[aSubPackage.getNamespace( '_', false)/]-config.cmake"
     "${CMAKE_CURRENT_BINARY_DIR}/[aSubPackage.name/]/[aSubPackage.getNamespace( '_', false)/]_Interface-config.cmake"
		[/for]
  DESTINATION
   "${MDE4CPP_HOME}/application/lib/cmake/[aPackage.getRootPackage().name/]"
)
	[/if]

	[for (aSubPackage : EPackage| subPackages)]
ADD_SUBDIRECTORY("[aSubPackage.name/]")
	[/for]
[/let]
IF(("$ENV{DEBUG_MESSAGE_[packageName.toUpper()/]}" EQUAL "1") AND (CMAKE_BUILD_TYPE MATCHES Debug))
	SET(ENABLED_DEBUG_MESSAGE " ")
ELSE()
	SET(ENABLED_DEBUG_MESSAGE " -DNDEBUG")
ENDIF()
IF("$ENV{DEBUG_MESSAGE_ACTIVITY_DEBUGGER}" EQUAL "1")
	SET(ENABLED_DEBUG_MESSAGE "${ENABLED_DEBUG_MESSAGE} -DACTIVITY_DEBUG_ON")
ENDIF()

[comment IF("${CMAKE_CXX_COMPILER_ID}" STREQUAL "AppleClang") -> not necessary after removing openmp/]
SET(CMAKE_CXX_FLAGS "-Wall -Wno-overloaded-virtual -Wdeprecated-declarations -fmax-errors=5")
IF(APPLE)
  string(APPEND CMAKE_CXX_FLAGS " -Qunused-arguments")
ENDIF(APPLE)
SET(CMAKE_CXX_FLAGS_DEBUG " -Og -ggdb ${ENABLED_DEBUG_MESSAGE}")
SET(CMAKE_CXX_FLAGS_RELEASE " -O3  ${ENABLED_DEBUG_MESSAGE}")

string(REPLACE "\\" "/" MDE4CPP_HOME $ENV{MDE4CPP_HOME})

SET(SOURCE_FILES
# Factories and packages
	[aPackage.generatePackageAndFactory()/]
[comment only for root packeges a plugin manager will be generated/]
[if (aPackage.eSuperPackage.oclIsUndefined())]
# Package plugin
	impl/[aPackage.generateNamespacePath()/]PluginImpl.cpp
[/if]
# Package content
[for (aClass : EClass | aPackage.eContents(EClass)->reject(doNotGenerateEClassifier())->asOrderedSet()->sortedBy(name))]
	impl/[aClass.name.toUpperFirst()/]Impl.cpp
[/for]
[if (packageName='uml')]
	${MDE4CPP_HOME}/application/include/util/util.cpp
	${MDE4CPP_HOME}/application/include/util/registry.cpp
	${MDE4CPP_HOME}/application/include/util/stereotypestorage.cpp
[/if]
	#${MDE4CPP_HOME}/application/include/util/ProfileCallCount.cpp
)

[comment
INCLUDE_DIRECTORIES(
	../
	${MDE4CPP_HOME}/application/include
)/]

# Apple specific stuff
if(APPLE)
  set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -undefined dynamic_lookup")
  set(CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS} -undefined dynamic_lookup")
endif(APPLE)

[comment]
IF(UNIX AND NOT APPLE)
    # for Linux, BSD, Solaris, Minix
	[generateCMakeFindLibraryCommands('.so', 'bin')/]
ELSEIF(APPLE)
	[generateCMakeFindLibraryCommands('.dylib', 'bin')/]
ELSE()
	[generateCMakeFindLibraryCommands('', 'lib')/]
ENDIF()
[/comment]

[comment manually set Path if dependencyes between sub-Packages exists/]
#--------------------------------------------
[let dependencyPackages : EPackage = (aPackage.metaModelLibraries())]
	[for (pack : EPackage | dependencyPackages->intersection(aPackage.getRootPackage()->closure(packageIter | packageIter.eSubpackages))->reject(doNotGenerateEPackage())->asOrderedSet()) ? (not(pack.name = aPackage.name))]
set([pack.getNamespace( '_', false)/]_DIR "${CMAKE_BINARY_DIR}/[pack.name/]")
set([pack.getNamespace( '_', false)/]_Interface_DIR "${CMAKE_BINARY_DIR}/[pack.name/]")
#list(APPEND CMAKE_MODULE_PATH ${MDE4CPP_HOME}/application/lib/cmake/[pack.getNamespace( '_', false)/]})
message("[pack.getNamespace( '_', true)/]_DIR ${[pack.getNamespace( '_', false)/]_DIR}")
message("[pack.getNamespace( '_', true)/]_Interface_DIR ${[pack.getNamespace( '_', false)/]_Interface_DIR}")
	[/for]
[/let]

[generateCMakeFindLibraryCommands('', 'lib')/]

ADD_LIBRARY(${PROJECT_NAME} SHARED ${SOURCE_FILES})
[generateLibraryLinking(false)/]
#create an alias lib for [aPackage.getNamespace('_',false)/]
add_library([aPackage.getNamespace('::',false)/]::[aPackage.getNamespace('_',false)/] ALIAS [aPackage.getNamespace('_',false)/])

ADD_DEFINITIONS(-DBUILD_[aPackage.getRootPackage().name.toUpper()/]=1)

TARGET_INCLUDE_DIRECTORIES(${PROJECT_NAME}
    PUBLIC
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
        $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
    PRIVATE
		${MDE4CPP_HOME}/application/include        
		${CMAKE_SOURCE_DIR}/.. 
		${MDE4CPP_HOME}/src/[aPackage.generateNamespacePath()/]/src_gen
)

SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES PREFIX "")

[comment include cmake generation helper/]
[generatePackageConfigDelivering(packageName)/]
[generatePackageConfigDelivering(packageName.concat('_Interface'))/]

INSTALL(DIRECTORY . DESTINATION ${MDE4CPP_HOME}/application/include/[aPackage.generateNamespacePath()/]
	FILES_MATCHING PATTERN "*.hpp"
	PATTERN ".cmake" EXCLUDE
)

[createConfigureDeliverPackageTargets(aPackage, packageName)/]
[createConfigureDeliverPackageTargets(aPackage, packageName.concat('_Interface'))/]

[createInstallAllPackageConfigs(aPackage, packageName)/]
INCLUDE(GenerateExportHeader)
GENERATE_EXPORT_HEADER(${PROJECT_NAME})

[comment generate -conig-File for subpackeses to enable package find in subsets (realizing dependencies between subpackages)/]
[if (not aPackage.eSuperPackage.oclIsUndefined())]
export(TARGETS ${PROJECT_NAME} NAMESPACE [aPackage.getNamespace('::',false)/]:: FILE ${CMAKE_BINARY_DIR}/[aPackage.name/]/[packageName/]-config.cmake)
#create an alias lib for [packageName/]
add_library([aPackage.getNamespace('::',false)/]::[packageName/] ALIAS [packageName/])
file(WRITE ${CMAKE_BINARY_DIR}/[aPackage.name/]/[packageName/]-config.cmake "")
[/if]

[/file]

[comment ------------------------------------------------------------------- /]
[comment generate cmake.in Files 											 /]
[comment ------------------------------------------------------------------- /]

[file (aPackage.generateNamespacePath().concat('/').concat(packageName).concat('.cmake.in'), false, 'UTF-8')]
@PACKAGE_INIT@
set (CMAKE_INSTALL_PREFIX ${MDE4CPP_HOME}/application/lib/cmake)
include(CMakeFindDependencyMacro)
[for (pack : EPackage | aPackage.metaModelLibraries()->union(aPackage.eSubpackages)->reject(doNotGenerateEPackage())->asOrderedSet()) ? (not(pack.name = aPackage.name))]
find_dependency([pack.getNamespace( '_', false)/])
[/for]
[for (libName : String | aPackage.eContents()->filter(EClass)->reject(doNotGenerateEClassifier())->select(c : EClass | c.hasKey(keyLibrary())).valueKeys(keyLibrary())->asOrderedSet())]
[if (not (libName.oclIsUndefined() or libName = ''))]
find_dependency([libName/])
[/if]
[/for]
[comment]
Targets.cmake kann erst nach der definition der Library (ADD_LIBRARY) definiert werden. Wenn bei sub Dir's die -config-files vor der -cmake-file erstellt werden, ist das target noch nicht vorhanden!
Wird aber essenziell zum linken benötigt!  
[/comment]
include("${CMAKE_CURRENT_LIST_DIR}/[packageName/]Targets.cmake")
[comment 
check_required_components(???) /]
[/file]

[file (aPackage.generateNamespacePath().concat('/').concat(packageName).concat('_Interface.cmake.in'), false, 'UTF-8')]
@PACKAGE_INIT@
set (CMAKE_INSTALL_PREFIX ${MDE4CPP_HOME}/application/lib/cmake)
include(CMakeFindDependencyMacro)
[for (pack : EPackage | aPackage.metaModelLibraries()->union(aPackage.eSubpackages)->reject(doNotGenerateEPackage())->asOrderedSet()) ? (not(pack.name = aPackage.name))]
find_dependency([pack.getNamespace( '_', false)/]_Interface)
[/for]
[for (libName : String | aPackage.eContents()->filter(EClass)->reject(doNotGenerateEClassifier())->select(c : EClass | c.hasKey(keyLibrary())).valueKeys(keyLibrary())->asOrderedSet())]
[if (not (libName.oclIsUndefined() or libName = ''))]
find_dependency([libName/]_Interface)
[/if]
[/for]
[comment]
Targets.cmake kann erst nach der definition der Library (ADD_LIBRARY) definiert werden. Wenn bei sub Dir's die -config-files vor der -cmake-file erstellt werden, ist das target noch nicht vorhanden! 
include("${CMAKE_CURRENT_LIST_DIR}/[packageName/]_InterfaceTargets.cmake")
[/comment]
[/file]

[comment only for root packeges a plugin manager will be generated/]
[if (aPackage.eSuperPackage.oclIsUndefined())]

[comment ------------------------------------------------------------------- /]
[comment build build.gradle file for build command                                       /]
[comment ------------------------------------------------------------------- /]

	[file ('../build.gradle', false, 'UTF-8')]
// DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN
// @generator: ecore4cpp::generator::main::generateBuildFile

description 'Build task for project: [packageName/]'

task build[packageName.toUpperFirst()/]() {
	group '[packageName/]'
	description 'build [packageName/]'

	dependsOn 'model:generate[packageName.toUpperFirst()/]'
	dependsOn 'src_gen:compile[packageName.toUpperFirst()/]'
	[if(aPackage.prepareApplication())]
	dependsOn 'application:compileApplicationFor[packageName.toUpperFirst()/]'
	[/if]
	[for (pack : EPackage | aPackage.metaModelLibraries()->reject(doNotGenerateEPackage())) before ('\n') ? (not(pack.name = aPackage.name))]
	dependsOn getRootProject().getTasksByName('build[pack.name.toUpperFirst()/]', true)
	[/for]
	[for (libName : String | aPackage.eAllContents()->filter(EClass)->reject(doNotGenerateEClassifier())->select(c : EClass | c.hasKey(keyLibrary())).valueKeys(keyLibrary())->asOrderedSet())]
	[if (not (libName.oclIsUndefined() or libName = ''))]
	dependsOn getRootProject().getTasksByName('build[libName.toUpperFirst()/]', true)
	[/if]
	[/for]
}
	
tasks.getByPath('src_gen:compile[packageName.toUpperFirst()/]').mustRunAfter tasks.getByPath('model:generate[packageName.toUpperFirst()/]')
	[/file]
	
[comment ------------------------------------------------------------------- /]
[comment build build.gradle file for generate command                                    /]
[comment ------------------------------------------------------------------- /]
	[file ('../model/build.gradle', false, 'UTF-8')]
// DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN
// @generator: ecore4cpp::generator::main::generateBuildFile
import tui.sse.mde4cpp.MDE4CPPGenerate;

description 'Generate task for project: [packageName/]'

task generate[packageName.toUpperFirst()/](type: tui.sse.mde4cpp.MDE4CPPGenerate) {
	group '[packageName/]'
	description 'generate C++ code of [packageName/].ecore model'
	
	modelFilePath = file('.' + File.separator + '[packageName/].ecore')

	relatedModels = ['['/][aPackage.generateRelatedModelNameList()/][']'/]
	
	outputs.files(fileTree('../src_gen/[packageName/]') {
        exclude '.cmake/**'
    })

	dependsOn rootProject.tasks.getByPath(':generator:ecore4CPP:buildGenerator_ecore4CPP')
}
	[/file]
	
[comment ------------------------------------------------------------------- /]
[comment build build.gradle file for compile command of model                            /]
[comment ------------------------------------------------------------------- /]

	[file ('build.gradle', false, 'UTF-8')]
// DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN
// @generator: ecore4cpp::generator::main::generateBuildFile
import tui.sse.mde4cpp.MDE4CPPCompile;
import org.gradle.internal.os.OperatingSystem;

description 'Compile task for project: [packageName/]'

task compile[packageName.toUpperFirst()/](type: tui.sse.mde4cpp.MDE4CPPCompile) 
{
	group '[packageName/]'
	description 'compile [packageName/]'

	projectFolder = file('.' + File.separator + '[packageName/]')

	inputs.files(fileTree('.') {
        exclude '[packageName/]/.cmake/**'
    })

   	if(!file(['['/]'[packageName/]','.cmake'[']'/].join(File.separator)).exists()){
   	    outputs.upToDateWhen { false }
   	}

	if(OperatingSystem.current().isWindows()){
		if(project.hasProperty('RELEASE') && !project.property('RELEASE').equals('0')){outputs.file file(['['/]rootDir,'application','bin','[packageName/]' +       '.dll'[']'/].join(File.separator))}
		if(project.hasProperty('DEBUG') && !project.property('DEBUG').equals('0'))  {outputs.file file(['['/]rootDir,'application','bin','[packageName/]' + 'd' + '.dll'[']'/].join(File.separator))}
	}
	else if(OperatingSystem.current().isLinux()){
		if(project.hasProperty('RELEASE') && !project.property('RELEASE').equals('0')){outputs.file file(['['/]rootDir,'application','bin','[packageName/]' +       '.so'[']'/].join(File.separator))}
		if(project.hasProperty('DEBUG') && !project.property('DEBUG').equals('0'))  {outputs.file file(['['/]rootDir,'application','bin','[packageName/]' + 'd' + '.so'[']'/].join(File.separator))}
	}
	else if(OperatingSystem.current().isMacOsX()){
		if(project.hasProperty('RELEASE') && !project.property('RELEASE').equals('0')){outputs.file file(['['/]rootDir,'application','bin','[packageName/]' +       '.dylib'[']'/].join(File.separator))}
		if(project.hasProperty('DEBUG') && !project.property('DEBUG').equals('0'))  {outputs.file file(['['/]rootDir,'application','bin','[packageName/]' + 'd' + '.dylib'[']'/].join(File.separator))}
	}
	else {
	    //not supported os
	}

	outputs.files(fileTree(['['/]rootDir,'application','include','[packageName/]'[']'/].join(File.separator)))
	outputs.dir(['['/]rootDir,'application','include','[packageName/]'[']'/].join(File.separator))

	[comment
	// dependency to 'persistence'
	//def persistence = getRootProject().getTasksByName('compilePersistence', true)
	//dependsOn persistence
	//inputs.files(persistence.outputs)

	// dependency to 'pluginFramwork'
	//def pluginFramwork = getRootProject().getTasksByName('compilePluginFramework', true)
	//dependsOn pluginFramwork
	//inputs.files(pluginFramwork.outputs)
	/]

	[comment
		Dependency to basic interface HEADERS
		- deliverAbstractDataTypes 
    	- deliverPluginFrameworkInterface
    	- deliverPersistenceInterface
    	- deliverUtil
	/]
	dependsOn getRootProject().getTasksByName('deliverBasicInterfaces', true)
	
	[for (pack : EPackage | aPackage.metaModelLibraries()->reject(doNotGenerateEPackage())) ? (not(pack.name = aPackage.name))]
	
	// dependency to model '[pack.name/]'
	def [pack.name/] = getRootProject().getTasksByName('compile[pack.name.toUpperFirst()/]', true)
	dependsOn [pack.name/]
	inputs.files([pack.name/].outputs)
	[/for]
	[for (libName : String | aPackage.eAllContents()->filter(EClass)->reject(doNotGenerateEClassifier())->select(c : EClass | c.hasKey(keyLibrary())).valueKeys(keyLibrary())->asOrderedSet())]
	[if (not (libName.oclIsUndefined() or libName = ''))]
	
	// dependency to model '[libName/]'
	def [libName/] = getRootProject().getTasksByName('compile[libName.toUpperFirst()/]', true)
	dependsOn [libName/]
	inputs.files([libName/].outputs)
	[/if]
	[/for]
}

task clean {
	// Extension of gradle built-in task:clean
	doLast {
		def dot_cmake = file('[packageName/]/.cmake')
		if(dot_cmake.exists()){
			delete dot_cmake.absolutePath
			println "deleting: " + dot_cmake.absolutePath
		}
		
		compile[packageName.toUpperFirst()/].outputs.files.each{
			if(it.exists()){
				delete it.absolutePath
			    println "deleting: " + it
			}
  		}
	}
} 
	[/file]
[/if]
[/template]



[comment] ######################################################################################################################################################
										End of Main Template		
		  ###################################################################################################################################################### [/comment]




[comment generate CONFIGURE_PACKAGE_CONFIG_FILE for a package to generate a *-config.cmake file.  
Make shure to include CMakePackageConfigHelpers firast./]
[template public generateConfigureConfigFile (aPackage : EPackage, aPackageName : EString, usePackageName :EBoolean) ]
CONFIGURE_PACKAGE_CONFIG_FILE(
[if usePackageName]
    "[aPackage.name/]/[aPackageName/].cmake.in"
    "${CMAKE_CURRENT_BINARY_DIR}/[aPackage.name/]/[aPackageName/]-config.cmake"
[else]
    "[aPackageName/].cmake.in"
    "${CMAKE_CURRENT_BINARY_DIR}/[aPackageName/]-config.cmake"
[/if]
    INSTALL_DESTINATION ${MDE4CPP_HOME}/application/lib/cmake/[aPackage.getRootPackage().name/]
)
[/template]

[template public generatePackageConfigDelivering(projectName : EString)]
#-----------------------------------------------------
# DELIVERING binaries and header to ${MDE4CPP_HOME} 
#-----------------------------------------------------

INSTALL(TARGETS [projectName/] EXPORT [projectName/]Targets
	RUNTIME DESTINATION ${MDE4CPP_HOME}/application/bin
    LIBRARY DESTINATION ${MDE4CPP_HOME}/application/bin
    ARCHIVE DESTINATION ${MDE4CPP_HOME}/application/lib
  	INCLUDES DESTINATION ${MDE4CPP_HOME}/application/include
)

[/template]

[template public createConfigureDeliverPackageTargets (aPackage : EPackage, packageName :String)]
#-----------------------------------------------------------------------
# CREATE, Configure and DELIVER cmake package targets to ${MDE4CPP_HOME} 
#-----------------------------------------------------------------------

INSTALL(
  EXPORT [packageName/]Targets
  FILE [packageName/]Targets.cmake
  DESTINATION ${MDE4CPP_HOME}/application/lib/cmake/[aPackage.getRootPackage().name/]
  NAMESPACE [aPackage.getNamespace('::',false)/]::
)

[comment configure cmake-config file based on .cmake.in'/]
INCLUDE(CMakePackageConfigHelpers)
[aPackage.generateConfigureConfigFile(packageName,false)/]

[comment ToDo: define Major and Minor version number/]
SET_PROPERTY(TARGET [packageName/] PROPERTY VERSION ${[packageName/]_VERSION})
[comment creating a simple ConfigVersion.cmake file/]
WRITE_BASIC_PACKAGE_VERSION_FILE(
  "${CMAKE_CURRENT_BINARY_DIR}/[packageName/]-configVersion.cmake"
  VERSION ${[packageName/]_VERSION}
  COMPATIBILITY AnyNewerVersion
)
[/template]

[template public createInstallAllPackageConfigs(aPackage : EPackage, packageName :String) ]
INSTALL(
  FILES
     "${CMAKE_CURRENT_BINARY_DIR}/[packageName/]-config.cmake"
 	 "${CMAKE_CURRENT_BINARY_DIR}/[packageName/]-configVersion.cmake"
     "${CMAKE_CURRENT_BINARY_DIR}/[packageName/]_Interface-config.cmake"
 	 "${CMAKE_CURRENT_BINARY_DIR}/[packageName/]_Interface-configVersion.cmake"
  DESTINATION
   "${MDE4CPP_HOME}/application/lib/cmake/[aPackage.getRootPackage().name/]"
)
[/template]

[template private generatePackageAndFactory(aPackage : EPackage) { packageName : String = aPackage.name; }]	
impl/[packageName/]FactoryImpl.cpp
impl/[packageName/]PackageImpl.cpp
impl/[packageName/]PackageImpl_Creation.cpp
impl/[packageName/]PackageImpl_Initialization.cpp
[/template]

[template private generateCMakeFindLibraryCommands(aPackage : EPackage, ending : String, folderName : String)]
[comment]
IF (CMAKE_BUILD_TYPE STREQUAL "Debug")
	[generateCMakeFindLibraryCommand(aPackage, ending, folderName, true)/]
ELSE()
	[generateCMakeFindLibraryCommand(aPackage, ending, folderName, false)/]
ENDIF()
[/comment]
[generateCMakeFindLibraryCommand(aPackage, ending, folderName, false)/]
[/template]

[query private libraryVariableNameSuffix(debugMode : Boolean) : String = if (debugMode) then 'DEBUG' else 'RELEASE' endif/]
[query private libraryNameSuffix(debugMode : Boolean) : String = if (debugMode) then 'd' else '' endif/]
[query private buildModeCMakeProperty(debugMode : Boolean) : String = if (debugMode) then 'debug' else 'optimized' endif/]

[template private generateCMakeFindLibraryCommand(aPackage : EPackage, ending : String, folderName : String, debugMode : Boolean)]
[comment]
[for (pack : EPackage | aPackage.metaModelLibraries()->union(aPackage.eSubpackages)->reject(doNotGenerateEPackage())->asOrderedSet()) ? (not(pack.name = aPackage.name))]
find_package([pack.getNamespace( '_', false).toUpperCase()/]_[libraryVariableNameSuffix(debugMode)/] )
[/for]
[for (libName : String | aPackage.eContents()->filter(EClass)->reject(doNotGenerateEClassifier())->select(c : EClass | c.hasKey(keyLibrary())).valueKeys(keyLibrary())->asOrderedSet())]
[if (not (libName.oclIsUndefined() or libName = ''))]
find_package([libName.toUpperCase()/]_[libraryVariableNameSuffix(debugMode)/])
[/if]
[/for]
[/comment]

[let dependentPackage : OrderedSet(EPackage) = (aPackage.metaModelLibraries()-aPackage.eSubpackages)->reject(doNotGenerateEPackage())->asOrderedSet()]
	[if (not (dependentPackage->oclIsUndefined()) and dependentPackage->size()>0)]
		[for (packIt : EPackage | dependentPackage) ? (not(packIt.name = aPackage.name))]
			[if (packIt = aPackage)] [comment Config.cmake files of the same model are installed after compilation. Hence, the config files are located in the BINARY_DIR of the current model/]
set([packIt.getNamespace( '_', false)/]_DIR "${CMAKE_BINARY_DIR}")
set([packIt.getNamespace( '_', false)/]_Interface_DIR "${CMAKE_BINARY_DIR}")
			[else]
				[if ((packIt.getRootPackage() = aPackage.getRootPackage()) or (packIt = aPackage))] [comment sub dirs cant have dependency to root package --> Ring dependency??/]
[comment]
Wird die Abhängigkeit trotzdem benötigt oder kennt das System durch subDir das Root-Package???
set([packIt.getNamespace( '_', false)/]_DIR "${CMAKE_BINARY_DIR}[packIt.getNamespace( '/', true)/]")
set([packIt.getNamespace( '_', false)/]_Interface_DIR "${CMAKE_BINARY_DIR}[packIt.getNamespace( '/', true)/]")
[/comment]
				[else]
set([packIt.getNamespace( '_', false)/]_DIR "${MDE4CPP_HOME}/application/lib/cmake/[packIt.getRootPackage().name/]")
set([packIt.getNamespace( '_', false)/]_Interface_DIR "${MDE4CPP_HOME}/application/lib/cmake/[packIt.getRootPackage().name/]")
				[/if]
			[/if]
		[/for]
		[for (pack : EPackage | dependentPackage) ? (not(pack.name = aPackage.name))]
find_package([pack.getNamespace( '_', false)/] CONFIG)
find_package([pack.getNamespace( '_', false)/]_Interface CONFIG)
		[/for]
		[for (libName : String | aPackage.eContents()->filter(EClass)->reject(doNotGenerateEClassifier())->select(c : EClass | c.hasKey(keyLibrary())).valueKeys(keyLibrary())->asOrderedSet())]
			[if (not (libName.oclIsUndefined() or libName = ''))]
find_package([libName/] REQUIRED)
			[/if]
		[/for]
	[/if]
[/let]
[comment Check Package find/]
[for (pack : EPackage | (aPackage.metaModelLibraries()-aPackage.eSubpackages)->reject(doNotGenerateEPackage())->asOrderedSet()) ? (not(pack.name = aPackage.name))]
message("Dir_Name: ${[pack.getNamespace( '_', false)/]_DIR}")
message("Interface_Dir_Name: ${[pack.getNamespace( '_', false)/]_Interface_DIR}") 
message("[pack.name/][pack.getNamespace( '_', false).packageFindGenerationMessage()/]")
[/for]
[for (libName : String | aPackage.eContents()->filter(EClass)->reject(doNotGenerateEClassifier())->select(c : EClass | c.hasKey(keyLibrary())).valueKeys(keyLibrary())->asOrderedSet())]
[if (not (libName.oclIsUndefined() or libName = ''))]
message("[libName.packageFindGenerationMessage()/]")
[/if]
[/for]


[/template]

[template private generateLibraryLinking(aPackage : EPackage, isInterface: EBoolean)]
TARGET_LINK_LIBRARIES(${PROJECT_NAME}
[comment]
[template private generateLibraryLinking(aPackage : EPackage, debugMode : Boolean)]
[for (pack : EPackage | aPackage.metaModelLibraries()->union(aPackage.eSubpackages)->reject(doNotGenerateEPackage())->asOrderedSet()) ? (not(pack.name = aPackage.name))]
	[buildModeCMakeProperty(debugMode)/] ${[pack.getNamespace( '_', false).toUpperCase()/]_[libraryVariableNameSuffix(debugMode)/]}
[/for]
[for (libName : String | aPackage.eContents()->filter(EClass)->reject(doNotGenerateEClassifier())->select(c : EClass | c.hasKey(keyLibrary())).valueKeys(keyLibrary())->asOrderedSet())]
[if (not (libName.oclIsUndefined() or libName = ''))]
	[buildModeCMakeProperty(debugMode)/] ${[libName.toUpperCase()/]_[libraryVariableNameSuffix(debugMode)/]}
[/if]
[/comment]
[for (pack : EPackage | aPackage.eSubpackages->reject(doNotGenerateEPackage())->asOrderedSet()) ? (not(pack.name = aPackage.name))]
	[if (true = isInterface)]
	INTERFACE [pack.getNamespace( '_', false)/]
	[else]
	PRIVATE [pack.getNamespace( '_', false)/]
	[/if]
[/for]
[for (pack : EPackage | (aPackage.metaModelLibraries()-self->closure(myEPackage | myEPackage.eSubpackages)-self->closure(myEPackage | myEPackage.eSuperPackage))->reject(doNotGenerateEPackage())->asOrderedSet()) ? (not(pack.name = aPackage.name))]
	[if (true = isInterface)]
	INTERFACE [pack.getNamespace( '::', false)/]::[pack.getNamespace( '_', false)/]
	[else]
	PRIVATE [pack.getNamespace( '::', false)/]::[pack.getNamespace( '_', false)/]
	[/if]
[/for]
[for (libName : String | aPackage.eContents()->filter(EClass)->reject(doNotGenerateEClassifier())->select(c : EClass | c.hasKey(keyLibrary())).valueKeys(keyLibrary())->asOrderedSet())]
[if (not (libName.oclIsUndefined() or libName = ''))]
	[if (true = isInterface)]
	INTERFACE [libName/]
	[else]
	PRIVATE [libName/]
	[/if]
[/if]
[/for]
)
[/template]

[template private generateRelatedModelNameList(aPackage : EPackage) post (trim())]
[for (pack : EPackage | aPackage.metaModelLibraries()->reject(doNotGenerateEPackage())) separator (', ') ? (not(pack.name = aPackage.name))]
'[pack.name/]'[/for]
[/template]
