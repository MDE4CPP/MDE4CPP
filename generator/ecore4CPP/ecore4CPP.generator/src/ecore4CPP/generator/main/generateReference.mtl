[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */]
[module generateReference('http://www.eclipse.org/emf/2002/Ecore')]

[import ecore4CPP::generator::main::generateClass /]
[import ecore4CPP::generator::main::generateType /]
[import ecore4CPP::generator::main::helper /]
[import ecore4CPP::generator::main::helpers::keywords /]
[import ecore4CPP::generator::main::helpers::IDHelper /]

[query public hasSetter(anEReference : EReference) : EBoolean = anEReference.changeable and anEReference.upperBound=1 and not hasKey(keyNoSetter()) /]
[query public hasGetter(anEReference : EReference) : EBoolean = not hasKey(keyNoGetter()) /]

[template public generateReferenceDecl(anEReference : EReference, impl : EBoolean) ? (not doNotGenerate())]
[anEReference.generateReferenceGetterDeclaretaion(impl)/]
[anEReference.generateReferenceSetterDeclaretaion(impl)/]
[for (redefinedElement : EObject | anEReference.getAllRedefinedElements())]
[if (redefinedElement.oclIsKindOf(EReference))]
[let redefinedEReference : EReference = redefinedElement.oclAsType(EReference)]
[if(redefinedEReference.hasSetter() and not (anEReference.eContainingClass = redefinedEReference.eContainingClass))]
/*Additional Setter for '[redefinedEReference.eContainingClass.name/]::[redefinedEReference.name/]' redefined by reference '[anEReference.name/]'*/
[redefinedEReference.generateReferenceSetterDeclaretaion(impl)/]
[/if][/let][/if][/for]
[/template]

[template public generateReferenceGetterDeclaretaion(anEReference : EReference, impl : EBoolean)? (hasGetter() and (not isUnion()) )]
[anEReference.generateDocumentation()/]
virtual [anEReference.generateReferenceType()/] [anEReference.GetterName()/]() const [abstractSufix(impl)/];
[/template]

[template public generateReferenceSetterDeclaretaion(anEReference : EReference, impl : EBoolean) ? ( hasSetter() )]
[anEReference.generateDocumentation()/]
virtual void [anEReference.SetterName()/]([if (not anEReference.eGenericType.eClassifier.oclIsKindOf(EDataType))]
[anEReference.generateReferenceType()/][else]
[anEReference.eGenericType.generateCppType(true)/] _[anEReference.name/][/if]
) [abstractSufix(impl)/];
[/template]

[template public generateProtectedReference(anEReference : EReference) ? (not doNotGenerate())]
[anEReference.generateDocumentation()/]
[if(hasKey(keyQualify()))][valueKey(keyQualify())/] [/if][if(not (anEReference.upperBound = 1))]mutable [/if][anEReference.generateReferenceType()/] m_[anEReference.name/];
[/template]

[template public generateReferenceInit(eReference : EReference)? (not(eReference.upperBound=1))]
[if(eReference.isSubsetUnion())]
/*SubsetUnion*/
m_[eReference.name/].reset(new SubsetUnion<[eReference.eGenericType.generateCppType(false)/], [generateSubsetType(eReference)/] >());
#ifdef SHOW_SUBSET_UNION
	std::cout << "Initialising shared pointer SubsetUnion: " << "m_[eReference.name/] - SubsetUnion<[eReference.eGenericType.generateCppType(false)/], [generateSubsetType(eReference)/] >()" << std::endl;
#endif
[elseif(eReference.hasSubset())]
/*Subset*/
m_[eReference.name/].reset(new Subset<[eReference.eGenericType.generateCppType(false)/], [generateSubsetType(eReference)/] >());
#ifdef SHOW_SUBSET_UNION
	std::cout << "Initialising shared pointer Subset: " << "m_[eReference.name/] - Subset<[eReference.eGenericType.generateCppType(false)/], [generateSubsetType(eReference)/] >()" << std::endl;
#endif
[elseif(eReference.isUnion())]
/*Union*/
m_[eReference.name/].reset(new Union<[eReference.eGenericType.generateCppType(false)/]>());
	#ifdef SHOW_SUBSET_UNION
	std::cout << "Initialising Union: " << "m_[eReference.name/] - Union<[eReference.eGenericType.generateCppType(false)/]>()" << std::endl;
#endif
[else]
m_[eReference.name/].reset(new [eReference.generateReferenceType(false)/]());
[/if]
[/template]

[template public InitReferences(eReference : EReference)? (not(eReference.upperBound=1))]
[if(eReference.isSubsetUnion())]
/*SubsetUnion*/
m_[eReference.name/]->initSubsetUnion([generateSubsetElements(eReference)/]);
#ifdef SHOW_SUBSET_UNION
	std::cout << "Initialising value SubsetUnion: " << "m_[eReference.name/] - SubsetUnion<[eReference.eGenericType.generateCppType(false)/], [generateSubsetType(eReference)/] >([generateSubsetElements(eReference)/])" << std::endl;
#endif
[elseif(eReference.hasSubset())]
/*Subset*/
m_[eReference.name/]->initSubset([generateSubsetElements(eReference)/]);
#ifdef SHOW_SUBSET_UNION
	std::cout << "Initialising value Subset: " << "m_[eReference.name/] - Subset<[eReference.eGenericType.generateCppType(false)/], [generateSubsetType(eReference)/] >([generateSubsetElements(eReference)/])" << std::endl;
#endif
[/if]
[/template]


[***
 * Section for the Reference cpp implementation
*/]

[template public generateReferenceCpp(anEReference : EReference) ? (not doNotGenerate())]
/*
Getter & Setter for reference [anEReference.name/]
*/
[anEReference.generateReferenceGetterCpp()/]
[anEReference.generateReferenceSetterCpp()/]
[comment additional setters for redefined references are only generated for upperBound=1, since no setters are generated for * multiplicity references /]
[if (anEReference.upperBound = 1)]
[for (redefinedElement : EObject | anEReference.getAllRedefinedElements())][if (redefinedElement.oclIsKindOf(EReference))]
[let redefinedEReference : EReference = redefinedElement.oclAsType(EReference)]
[if(redefinedEReference.hasSetter() and not (anEReference.eContainingClass = redefinedEReference.eContainingClass))]
/*Additional Setter for redefined reference '[redefinedEReference.eContainingClass.name/]::[redefinedEReference.name/]'*/
[redefinedEReference.generateRedefinedReferenceSetterCpp(anEReference)/]
[/if][/let][/if][/for]
[/if]
[/template]

[template private generateReferenceGetterCpp(anEReference : EReference) ? (hasGetter() and (not isUnion()))]
[anEReference.generateReferenceType()/] [anEReference.eContainingClass.name.toUpperFirst()/]Impl::[anEReference.GetterName()/]() const
{
[if (hasKey(keyGetterBody()))]
	//generated from [keyGetterBody()/] annotation
[valueKey(keyGetterBody())/]
	//end of body
[else]
[if (not (anEReference.upperBound = 1))]
	if(m_[anEReference.name/] == nullptr)
	{
		[anEReference.generateReferenceInit()/]
		[anEReference.InitReferences()/]
	}
[/if]
[if(anEReference.lowerBound>0)]//assert(m_[anEReference.name/]);[/if]
    return m_[anEReference.name/];
[/if]
}
[/template]

[template private generateReferenceSetterCpp(anEReference : EReference) ? (hasSetter())]
void [anEReference.eContainingClass.name.toUpperFirst()/]Impl::[anEReference.SetterName()/]([anEReference.generateReferenceType()/] _[anEReference.name/])
{
	[if (hasKey(keySetterBody()))]
	//generated from [keySetterBody()/] annotation
	[valueKey(keySetterBody())/] 
	//end of body
	[else]
    m_[anEReference.name/] = _[anEReference.name/];
	[anEReference.generateRedefinedReferencesSet()/]
	[/if]
}
[/template]

[template private generateRedefinedReferencesSet(anEReference : EReference)]
[for (redefinedElement : EObject | anEReference.getDirectlyRedefinedElements())]
[if (redefinedElement.oclIsKindOf(EReference))]
[let redefinedEReference : EReference = redefinedElement.oclAsType(EReference)]
[if(redefinedEReference.hasSetter())]
//additional setter call for redefined reference [redefinedEReference.eContainingClass.name/]::[redefinedEReference.name/]
[if(redefinedEReference.eContainingClass = anEReference.eContainingClass)]this->[else][redefinedEReference.eContainingClass.transformType()/]Impl::[/if]set[redefinedEReference.name.toUpperFirst()/](_[anEReference.name/][if(anEReference.isBackReference())].lock()[/if]);
[else]
[if (redefinedEReference.upperBound = 1)]
m_[redefinedEReference.name/] = this->[if(anEReference.hasGetter())][anEReference.GetterName()/]()[else]m_[anEReference.name/][/if][if(anEReference.isBackReference())].lock()[/if];
[/if]
[comment recursive call to set possibly redefined references of redefinedEReference --> would normally be handled by calling the setter of redefinedEReference, but we do not have a setter here /]
[redefinedEReference.generateRedefinedReferencesSet()/]
[/if][/let][/if][/for]
[/template]

[template private generateRedefinedReferenceSetterCpp(redefinedEReference : EReference, anEReference : EReference) ? (anEReference.hasSetter() and redefinedEReference.hasSetter())]
void [anEReference.eContainingClass.name.toUpperFirst()/]Impl::[redefinedEReference.SetterName()/]([redefinedEReference.generateReferenceType()/] _[redefinedEReference.name/])
{
	[if(redefinedEReference.isBackReference())]
	std::shared_ptr<[anEReference.eGenericType.generateCppType(false)/]> _[anEReference.name/] = std::dynamic_pointer_cast<[anEReference.eGenericType.generateCppType(false)/]>(_[redefinedEReference.name/].lock());
	[else]
	std::shared_ptr<[anEReference.eGenericType.generateCppType(false)/]> _[anEReference.name/] = std::dynamic_pointer_cast<[anEReference.eGenericType.generateCppType(false)/]>(_[redefinedEReference.name/]);
	[/if]
	if(_[anEReference.name/])
	{
		m_[anEReference.name/] = _[anEReference.name/];

		[if (not anEReference.getDirectlyRedefinedElements()->select(redefines(redefinedEReference.oclAsType(EObject)))->isEmpty())]
			[for (directlyRedefinedElement : EObject | anEReference.getDirectlyRedefinedElements())]
				[if (directlyRedefinedElement.oclIsKindOf(EReference) and directlyRedefinedElement.redefines(redefinedEReference.oclAsType(EObject)))]
				[let directlyRedefinedEReference : EReference = directlyRedefinedElement.oclAsType(EReference)]
		//additional setter call for redefined reference [directlyRedefinedEReference.eContainingClass.name/]::[directlyRedefinedEReference.name/]
		[directlyRedefinedEReference.eContainingClass.transformType()/]Impl::set[redefinedEReference.name.toUpperFirst()/](_[redefinedEReference.name/]);
				[/let]
				[/if]
			[/for]
		[else]
		//additional setter call for redefined reference [redefinedEReference.eContainingClass.name/]::[redefinedEReference.name/]
		[redefinedEReference.eContainingClass.transformType()/]Impl::set[redefinedEReference.name.toUpperFirst()/](_[anEReference.name/]);
		[/if]
	}
	else
	{
		std::cerr<<"['['/][anEReference.eContainingClass.name.toUpperFirst()/]::[redefinedEReference.SetterName()/][']'/] : Could not set [redefinedEReference.name/] because provided [redefinedEReference.name/] was not of type '[anEReference.eGenericType.generateCppType(true)/]'"<<std::endl;
	}
}
[/template]


[***###########################################################################################
 * Section for creating the Attribute elements in the metamodel package
*/]

[template public generateReferenceCreation(anEReference : EReference)]
[anEReference.getClassMemberName()/] = factory->createEReference_as_eStructuralFeatures_in_EClass([anEReference.eContainingClass.getClassMemberName()/], [anEReference.getStaticAttributeIDName()/]);
[/template] 
 
[** Handling of doNotGenerate: if an Attribute has a Type on an external Class, which is not generated, then create a dummy EClass /]
[template public generateReferenceInitialization(anEReference : EReference)]
[anEReference.getClassMemberName()/]->setName("[anEReference.name/]");
[if (anEReference.eGenericType.eClassifier.doNotGenerate())]
{
	std::shared_ptr<ecore::ecoreFactory> factory = ecore::ecoreFactory::eInstance();
	std::shared_ptr<ecore::EClass> unknownClass = factory ->createEClass(-1);
   	unknownClass->setName("[anEReference.eType.oclAsType(EDataType).name/]");
	unknownClass->setAbstract(true);
	unknownClass->setInterface(true);
	[anEReference.getClassMemberName()/]->setEType(unknownClass);
}
[else]
[anEReference.getClassMemberName()/]->setEType([anEReference.eGenericType.eClassifier.packageGetter(anEReference)/]);
[/if]
[anEReference.getClassMemberName()/]->setLowerBound([anEReference.lowerBound/]);
[anEReference.getClassMemberName()/]->setUpperBound([anEReference.upperBound/]);
[anEReference.getClassMemberName()/]->setTransient([anEReference.transient.toString()/]);
[anEReference.getClassMemberName()/]->setVolatile([anEReference.volatile.toString()/]);
[anEReference.getClassMemberName()/]->setChangeable([anEReference.changeable.toString()/]);
[anEReference.getClassMemberName()/]->setUnsettable([anEReference.unsettable.toString()/]);
[anEReference.getClassMemberName()/]->setUnique([anEReference.unique.toString()/]);
[anEReference.getClassMemberName()/]->setDerived([anEReference.derived.toString()/]);
[anEReference.getClassMemberName()/]->setOrdered([anEReference.ordered.toString()/]);
[anEReference.getClassMemberName()/]->setContainment([anEReference.containment.toString()/]);
[anEReference.getClassMemberName()/]->setResolveProxies([anEReference.resolveProxies.toString()/]);
{
	std::string defaultValue = "[anEReference.defaultValueLiteral/]";
	if (!defaultValue.empty())
	{
		[anEReference.getClassMemberName()/]->setDefaultValueLiteral(defaultValue);
	}				
	[if not anEReference.eOpposite.oclIsUndefined()]						
	std::shared_ptr<ecore::EReference>  otherEnd = [anEReference.eOpposite.eContainingClass.getPackage_eInstance()/]->[anEReference.eOpposite.packageGetter()/];
	if (otherEnd != nullptr)
    {
   		[anEReference.getClassMemberName()/]->setEOpposite(otherEnd);
    }
	[else]
		//undefined otherEnd
		std::shared_ptr<ecore::EReference>  otherEnd = nullptr; 
	[/if]
}

[/template]

[template public generateStaticReferenceID(anEReference : EReference)]
static const long long [anEReference.getStaticAttributeIDName()/] = [anEReference.generateNamespaceDefinition().generatePolynomialRollingHash()/];

[/template]