package tui.sse.mde4cpp;

import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import org.gradle.api.Project;

/**
 * Class for analyzing Gradle properties assigned to this task<br>
 * The following aspects are investigated: <br>
 * <br>
 * 
 * Count of parallel jobs:
 * <ul>
 * <li>Creates option for make execution defining the count of jobs executed in
 * parallel
 * <li>Gradle property syntax: WORKER={@code value}</li>
 * <li>{@code value} should be greater than 0.</li>
 * <li>{@code value} has no upper limit, but it is advisable to do not exceed
 * the core limit.
 * <li>If this property is not set, the system default is used (in general no
 * parallism)</li>
 * </ul>
 * 
 * Configure build modes
 * <ul>
 * <li>Calculates, which build modes should be performed based on property
 * settings
 * <li>Properties for {@code BUILD_MODE.DEBUG}: {@code D} or {@code DEBUG}</li>
 * <li>Properties for {@code BUILD_MODE.DEBUG}: {@code R} or
 * {@code RELEASE}</li>
 * <li>If no property is set, DEBUG and RELEASE are performed.</li>
 * <li>If {@code D} or {@code DEBUG} is defined, DEBUG is performed.</li>
 * <li>If {@code R} or {@code RELEASE} is defined, RELEASE is performed.</li>
 * <li>DEBUG and RELEASE can be defined together.</li>
 * <li>Properties with assigned value {@code 0} are ignored. (e.g. {@code -PD=0})
 * </ul>
 *
 * Configure builds to be compile (only projects generated with fUML4CPP)
 * <ul>
 * <li>The generator fUML4CPP creates two projects - one for the structural part
 * and one for the execution.</li>
 * <li>Path to structure project is be set automatically in a Gradle task
 * generated by fUML4CPP.</li>
 * <li>Path to execution project will be calculated based on folder structure and name
 * convention. The execution project is placed in same parent folder and named
 * identically to structure project extended by 'Exec'.</li>
 * <li>Same as the build mode, properties are used to enable or disable the
 * compilation of structure or execution project.</li>
 * <li>If {@code S} or {@code STRUCTURE} is defined, structure project will be
 * compiled.</li>
 * <li>If {@code E} or {@code EXECUTION} is defined, execution project will be
 * compiled.</li>
 * </ul>
 */
class GradlePropertyAnalyser
{
	/**
	 * Creates cmake option to specify count of parallel jobs
	 * 
	 * @param project
	 *            current project instance contains existing properties
	 * @return cmake option specify count of parallel jobs
	 */
	static String getParallelJobsFlag(Project project)
	{
		if (project.hasProperty("WORKER"))
		{
			return " -j" + project.property("WORKER");
		}
		else
		{
			return "";
		}
	}

	/**
	 * Checks, if project should be compiled with debug options
	 * 
	 * @param project
	 *            current project instance contains existing properties
	 * @return {@code true} if {@core DEBUG} is requested, otherwise {@code false}
	 */
	static boolean isDebugBuildModeRequestet(Project project)
	{		
		if (project.hasProperty("DEBUG") && project.hasProperty("D"))
		{
			return !project.property("DEBUG").equals("0") && !project.property("D").equals("0");
		}
		else if (project.hasProperty("DEBUG"))
		{
			return !project.property("DEBUG").equals("0");
		}
		else if (project.hasProperty("D"))
		{
			return !project.property("D").equals("0");
		}
		else 
		{
			return !project.hasProperty("RELEASE") && !project.hasProperty("R") && !project.hasProperty("DEBUG") && !project.hasProperty("D");
		}
	}

	/**
	 * Checks, if project should be compiled with release options
	 * 
	 * @param project
	 *            current project instance contains existing properties
	 * @return {@code true} if {@core RELEASE} is requested, otherwise {@code false}
	 */
	static boolean isReleaseBuildModeRequested(Project project)
	{
		
		if (project.hasProperty("RELEASE") && project.hasProperty("R"))
		{
			return !project.property("RELEASE").equals("0") && !project.property("R").equals("0");
		}
		else if (project.hasProperty("RELEASE"))
		{
			return !project.property("RELEASE").equals("0");
		}
		else if (project.hasProperty("R"))
		{
			return !project.property("R").equals("0");
		}
		else 
		{
			return !project.hasProperty("RELEASE") && !project.hasProperty("R") && !project.hasProperty("DEBUG") && !project.hasProperty("D");
		}
	}

	/**
	 * Checks, if execution project should be compiled
	 * 
	 * @param project
	 *            current project instance contains existing properties
	 * @return {@code true} if execution project should be compiled, otherwise
	 *         {@code false}
	 */
	static boolean isExecutionBuildRequested(Project project)
	{
		if (project.hasProperty("EXECUTION") && project.hasProperty("E"))
		{
			return !project.property("EXECUTION").equals("0") && !project.property("E").equals("0");
		}
		else if (project.hasProperty("EXECUTION"))
		{
			return !project.property("EXECUTION").equals("0");
		}
		else if (project.hasProperty("E"))
		{
			return !project.property("E").equals("0");
		}
		else 
		{
			return !project.hasProperty("EXECUTION") && !project.hasProperty("E") && !project.hasProperty("STRUCTURE") && !project.hasProperty("S");
		}
	}

	/**
	 * Checks, if structure project should be compiled
	 * 
	 * @param project
	 *            current project instance contains existing properties
	 * @return {@code true} if structure project should be compiled, otherwise
	 *         {@code false}
	 */
	static boolean isStructureBuildRequested(Project project)
	{
		if (project.hasProperty("STRUCTURE") && project.hasProperty("S"))
		{
			return !project.property("STRUCTURE").equals("0") && !project.property("S").equals("0");
		}
		else if (project.hasProperty("STRUCTURE"))
		{
			return !project.property("STRUCTURE").equals("0");
		}
		else if (project.hasProperty("S"))
		{
			return !project.property("S").equals("0");
		}
		else 
		{
			return !project.hasProperty("EXECUTION") && !project.hasProperty("E") && !project.hasProperty("STRUCTURE") && !project.hasProperty("S");
		}
	}
	
	/**
	 * select all project properties, which start with:
	 * - DEBUG_
	 * - CMAKE_
	 * - USER_
	 * 
	 * @param project current project instance contains existing properties
	 * @return list with related property string: 'property name'='property value'
	 */
	static List<String[]> getPropertiesForCMake(Project project)
	{
		List<String[]> propertyList = new LinkedList<String[]>();
		Set<String> keySet = project.getProperties().keySet();
		for (String key : keySet)
		{
			if (key.startsWith("DEBUG_") || key.startsWith("CMAKE_") || key.startsWith("USER_"))
			{
				String[] variableSet = {key, project.findProperty(key).toString()};
				propertyList.add(variableSet);
			}
		}
		
		return propertyList;
	}
}
