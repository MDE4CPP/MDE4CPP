
#include "uml/impl/OperationImpl.hpp"
#ifdef NDEBUG
	#define DEBUG_MESSAGE(a) /**/
#else
	#define DEBUG_MESSAGE(a) a
#endif

#ifdef ACTIVITY_DEBUG_ON
    #define ACT_DEBUG(a) a
#else
    #define ACT_DEBUG(a) /**/
#endif

//#include "util/ProfileCallCount.hpp"

#include <cassert>
#include <iostream>
#include <sstream>
#include <stdexcept>
#include "abstractDataTypes/SubsetUnion.hpp"


#include "abstractDataTypes/AnyEObject.hpp"
#include "abstractDataTypes/AnyEObjectBag.hpp"
#include "abstractDataTypes/SubsetUnion.hpp"
#include "ecore/EAnnotation.hpp"
#include "ecore/EClass.hpp"
#include "ecore/EAttribute.hpp"
#include "ecore/EStructuralFeature.hpp"
#include "ecore/ecorePackage.hpp"
//Forward declaration includes
#include "persistence/interfaces/XLoadHandler.hpp" // used for Persistence
#include "persistence/interfaces/XSaveHandler.hpp" // used for Persistence

#include <exception> // used in Persistence
#include "uml/umlFactory.hpp"
#include "uml/Behavior.hpp"
#include "uml/BehavioralFeature.hpp"
#include "uml/Class.hpp"
#include "uml/Classifier.hpp"
#include "uml/Comment.hpp"
#include "uml/Constraint.hpp"
#include "uml/DataType.hpp"
#include "uml/Dependency.hpp"
#include "uml/Element.hpp"
#include "uml/ElementImport.hpp"
#include "uml/Interface.hpp"
#include "uml/NamedElement.hpp"
#include "uml/Namespace.hpp"
#include "uml/Operation.hpp"
#include "uml/PackageImport.hpp"
#include "uml/PackageableElement.hpp"
#include "uml/Parameter.hpp"
#include "uml/ParameterSet.hpp"
#include "uml/ParameterableElement.hpp"
#include "uml/RedefinableElement.hpp"
#include "uml/StringExpression.hpp"
#include "uml/TemplateBinding.hpp"
#include "uml/TemplateParameter.hpp"
#include "uml/TemplateSignature.hpp"
#include "uml/TemplateableElement.hpp"
#include "uml/Type.hpp"
//Factories and Package includes
#include "uml/umlPackage.hpp"

using namespace uml;

//*********************************
// Constructor / Destructor
//*********************************
OperationImpl::OperationImpl()
{	
	/*
	NOTE: Due to virtual inheritance, base class constrcutors may not be called correctly
	*/
}

OperationImpl::~OperationImpl()
{
#ifdef SHOW_DELETION
	std::cout << "-------------------------------------------------------------------------------------------------\r\ndelete Operation "<< this << "\r\n------------------------------------------------------------------------ " << std::endl;
#endif
}

//Additional constructor for the containments back reference
OperationImpl::OperationImpl(std::weak_ptr<uml::Class> par_class)
:OperationImpl()
{
	m_class = par_class;
	m_namespace = par_class;
}

//Additional constructor for the containments back reference
OperationImpl::OperationImpl(std::weak_ptr<uml::DataType> par_datatype)
:OperationImpl()
{
	m_datatype = par_datatype;
	m_namespace = par_datatype;
}

//Additional constructor for the containments back reference
OperationImpl::OperationImpl(std::weak_ptr<uml::Interface> par_interface)
:OperationImpl()
{
	m_interface = par_interface;
	m_namespace = par_interface;
}

//Additional constructor for the containments back reference
OperationImpl::OperationImpl(std::weak_ptr<uml::Namespace> par_namespace)
:OperationImpl()
{
	m_namespace = par_namespace;
	m_owner = par_namespace;
}

//Additional constructor for the containments back reference
OperationImpl::OperationImpl(std::weak_ptr<uml::Element> par_owner)
:OperationImpl()
{
	m_owner = par_owner;
}

//Additional constructor for the containments back reference
OperationImpl::OperationImpl(std::weak_ptr<uml::TemplateParameter> par_owningTemplateParameter)
:OperationImpl()
{
	m_owningTemplateParameter = par_owningTemplateParameter;
	m_owner = par_owningTemplateParameter;
}

OperationImpl::OperationImpl(const OperationImpl & obj): OperationImpl()
{
	*this = obj;
}

OperationImpl& OperationImpl::operator=(const OperationImpl & obj)
{
	//call overloaded =Operator for each base class
	BehavioralFeatureImpl::operator=(obj);
	ParameterableElementImpl::operator=(obj);
	TemplateableElementImpl::operator=(obj);
	/* TODO: Find out if this call is necessary
	 * Currently, this causes an error because it calls an implicit assignment operator of Operation 
	 * which is generated by the compiler (as Operation is an abstract class and does not have a user-defined assignment operator).
	 * Implicit compiler-generated assignment operators however only create shallow copies of members,
	 * which implies, that not a real deep copy is created when using the copy()-method.
	 * 
	 * NOTE: Since all members are deep-copied by this assignment-operator anyway, why is it even necessary to call this implicit assignment-operator?
	 * This is only done for ecore-models, not for UML-models.
	 */
	//Operation::operator=(obj);

	//create copy of all Attributes
	#ifdef SHOW_COPIES
	std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\ncopy Operation "<< this << "\r\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ " << std::endl;
	#endif
	//Clone Attributes with (deep copy)
	m_isOrdered = obj.getIsOrdered();
	m_isQuery = obj.getIsQuery();
	m_isUnique = obj.getIsUnique();
	m_lower = obj.getLower();
	m_upper = obj.getUpper();

	//copy references with no containment (soft copy)
	m_class  = obj.getClass();
	m_datatype  = obj.getDatatype();
	m_interface  = obj.getInterface();
	m_type  = obj.getType();
	//Clone references with containment (deep copy)
	//clone reference 'bodyCondition'
	if(obj.getBodyCondition()!=nullptr)
	{
		m_bodyCondition = std::dynamic_pointer_cast<uml::Constraint>(obj.getBodyCondition()->copy());
	}

	//clone reference 'postcondition'
	std::shared_ptr<Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/>> postconditionList = obj.getPostcondition();
	if(postconditionList)
	{
		/*Subset*/
		m_postcondition.reset(new Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/ >());
		#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising shared pointer Subset: " << "m_postcondition - Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/ >()" << std::endl;
		#endif
		
		/*Subset*/
		getPostcondition()->initSubset(getOwnedRule());
		#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising value Subset: " << "m_postcondition - Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/ >(getOwnedRule())" << std::endl;
		#endif
		
		for(const std::shared_ptr<uml::Constraint> postconditionindexElem: *postconditionList) 
		{
			std::shared_ptr<uml::Constraint> temp = std::dynamic_pointer_cast<uml::Constraint>((postconditionindexElem)->copy());
			m_postcondition->push_back(temp);
		}
	}
	else
	{
		DEBUG_MESSAGE(std::cout << "Warning: container is nullptr postcondition."<< std::endl;)
	}

	//clone reference 'precondition'
	std::shared_ptr<Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/>> preconditionList = obj.getPrecondition();
	if(preconditionList)
	{
		/*Subset*/
		m_precondition.reset(new Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/ >());
		#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising shared pointer Subset: " << "m_precondition - Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/ >()" << std::endl;
		#endif
		
		/*Subset*/
		getPrecondition()->initSubset(getOwnedRule());
		#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising value Subset: " << "m_precondition - Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/ >(getOwnedRule())" << std::endl;
		#endif
		
		for(const std::shared_ptr<uml::Constraint> preconditionindexElem: *preconditionList) 
		{
			std::shared_ptr<uml::Constraint> temp = std::dynamic_pointer_cast<uml::Constraint>((preconditionindexElem)->copy());
			m_precondition->push_back(temp);
		}
	}
	else
	{
		DEBUG_MESSAGE(std::cout << "Warning: container is nullptr precondition."<< std::endl;)
	}

	//clone reference 'redefinedOperation'
	std::shared_ptr<Subset<uml::Operation, uml::RedefinableElement>> redefinedOperationList = obj.getRedefinedOperation();
	if(redefinedOperationList)
	{
		/*Subset*/
		m_redefinedOperation.reset(new Subset<uml::Operation, uml::RedefinableElement >());
		#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising shared pointer Subset: " << "m_redefinedOperation - Subset<uml::Operation, uml::RedefinableElement >()" << std::endl;
		#endif
		
		/*Subset*/
		getRedefinedOperation()->initSubset(getRedefinedElement());
		#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising value Subset: " << "m_redefinedOperation - Subset<uml::Operation, uml::RedefinableElement >(getRedefinedElement())" << std::endl;
		#endif
		
		for(const std::shared_ptr<uml::Operation> redefinedOperationindexElem: *redefinedOperationList) 
		{
			std::shared_ptr<uml::Operation> temp = std::dynamic_pointer_cast<uml::Operation>((redefinedOperationindexElem)->copy());
			m_redefinedOperation->push_back(temp);
		}
	}
	else
	{
		DEBUG_MESSAGE(std::cout << "Warning: container is nullptr redefinedOperation."<< std::endl;)
	}
	
	return *this;
}

std::shared_ptr<ecore::EObject> OperationImpl::copy() const
{
	std::shared_ptr<OperationImpl> element(new OperationImpl());
	*element =(*this);
	element->setThisOperationPtr(element);
	return element;
}

//*********************************
// Operations
//*********************************
bool OperationImpl::at_most_one_return(const Any& diagnostics, std::shared_ptr<std::map < Any, Any>> context)
{
	throw std::runtime_error("UnsupportedOperationException: " + std::string(__PRETTY_FUNCTION__));
}

int OperationImpl::getLower()
{
	throw std::runtime_error("UnsupportedOperationException: " + std::string(__PRETTY_FUNCTION__));
}

std::shared_ptr<uml::Parameter> OperationImpl::getReturnResult()
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	return this->returnResult();
	//end of body
}



int OperationImpl::getUpper()
{
	throw std::runtime_error("UnsupportedOperationException: " + std::string(__PRETTY_FUNCTION__));
}

bool OperationImpl::isOrdered()
{
	throw std::runtime_error("UnsupportedOperationException: " + std::string(__PRETTY_FUNCTION__));
}

bool OperationImpl::isUnique()
{
	throw std::runtime_error("UnsupportedOperationException: " + std::string(__PRETTY_FUNCTION__));
}

bool OperationImpl::matches(const std::shared_ptr<uml::Operation>& comparedOperation)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	//Checks whether two uml::Operations share the same name and input parameter types (= share same signature)

bool equals = false;

if(this->getName() != comparedOperation->getName()) {return equals;}

const std::shared_ptr<Bag<uml::Parameter>>& thisParameters = this->getOwnedParameter();
const std::shared_ptr<Bag<uml::Parameter>>& otherParameters = comparedOperation->getOwnedParameter();

if(thisParameters->size() != otherParameters->size()) {return equals;}

for(unsigned int i = 0; i < thisParameters->size(); i++)
{
	if(thisParameters->at(i)->getType() != otherParameters->at(i)->getType()) {return equals;}
}

equals = true;
return equals;

	//end of body
}

bool OperationImpl::only_body_for_query(const Any& diagnostics, std::shared_ptr<std::map < Any, Any>> context)
{
	throw std::runtime_error("UnsupportedOperationException: " + std::string(__PRETTY_FUNCTION__));
}

std::shared_ptr<uml::Parameter> OperationImpl::returnResult()
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	const std::shared_ptr<Bag<uml::Parameter>>& ownedParameters = this->getOwnedParameter();
	std::shared_ptr<uml::Parameter> returnResult;

	for(const std::shared_ptr<uml::Parameter>& p : *ownedParameters)
	{
		if(p->getDirection() == uml::ParameterDirectionKind::RETURN)
		{
				returnResult=p;
				break;
		}
	}
	
	return returnResult;
	//end of body
}

void OperationImpl::setIsOrdered(bool newIsOrdered)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	m_isOrdered = newIsOrdered;
	//end of body
}

void OperationImpl::setIsUnique(bool newIsUnique)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	m_isUnique = newIsUnique;
	//end of body
}

void OperationImpl::setLower(int newLower)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	m_lower = newLower;
	//end of body
}

void OperationImpl::setType(const std::shared_ptr<uml::Type>& newType)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	m_type = newType;
	//end of body
}

void OperationImpl::setUpper(int newUpper)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	m_upper = newUpper;
	//end of body
}

//*********************************
// Attribute Getters & Setters
//*********************************
/* Getter & Setter for attribute isOrdered */
bool OperationImpl::getIsOrdered() const
{
	return m_isOrdered;
}

/* Getter & Setter for attribute isQuery */
bool OperationImpl::getIsQuery() const
{
	return m_isQuery;
}
void OperationImpl::setIsQuery(bool _isQuery)
{
	m_isQuery = _isQuery;
	
}

/* Getter & Setter for attribute isUnique */
bool OperationImpl::getIsUnique() const
{
	return m_isUnique;
}

/* Getter & Setter for attribute lower */
int OperationImpl::getLower() const
{
	return m_lower;
}

/* Getter & Setter for attribute upper */
int OperationImpl::getUpper() const
{
	return m_upper;
}

//*********************************
// Reference Getters & Setters
//*********************************
/* Getter & Setter for reference bodyCondition */
const std::shared_ptr<uml::Constraint>& OperationImpl::getBodyCondition() const
{
    return m_bodyCondition;
}
void OperationImpl::setBodyCondition(const std::shared_ptr<uml::Constraint>& _bodyCondition)
{
    m_bodyCondition = _bodyCondition;
	
}

/* Getter & Setter for reference class */
std::weak_ptr<uml::Class> OperationImpl::getClass() const
{
    return m_class;
}
void OperationImpl::setClass(std::weak_ptr<uml::Class> _class)
{
    m_class = _class;
	
}

/* Getter & Setter for reference datatype */
std::weak_ptr<uml::DataType> OperationImpl::getDatatype() const
{
    return m_datatype;
}
void OperationImpl::setDatatype(std::weak_ptr<uml::DataType> _datatype)
{
    m_datatype = _datatype;
	
}

/* Getter & Setter for reference interface */
std::weak_ptr<uml::Interface> OperationImpl::getInterface() const
{
    return m_interface;
}
void OperationImpl::setInterface(std::weak_ptr<uml::Interface> _interface)
{
    m_interface = _interface;
	
}

/* Getter & Setter for reference ownedParameter */
std::shared_ptr<Bag<uml::Parameter>> OperationImpl::getProperty_OwnedParameter() const
{
	//Getter call of redefined container reference BehavioralFeature::ownedParameter 
	return uml::BehavioralFeatureImpl::getOwnedParameter();
}

/* Getter & Setter for reference postcondition */
const std::shared_ptr<Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/>>& OperationImpl::getPostcondition() const
{
	if(m_postcondition == nullptr)
	{
		/*Subset*/
		m_postcondition.reset(new Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/ >());
		#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising shared pointer Subset: " << "m_postcondition - Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/ >()" << std::endl;
		#endif
		
		/*Subset*/
		getPostcondition()->initSubset(getOwnedRule());
		#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising value Subset: " << "m_postcondition - Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/ >(getOwnedRule())" << std::endl;
		#endif
		
	}
    return m_postcondition;
}

/* Getter & Setter for reference precondition */
const std::shared_ptr<Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/>>& OperationImpl::getPrecondition() const
{
	if(m_precondition == nullptr)
	{
		/*Subset*/
		m_precondition.reset(new Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/ >());
		#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising shared pointer Subset: " << "m_precondition - Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/ >()" << std::endl;
		#endif
		
		/*Subset*/
		getPrecondition()->initSubset(getOwnedRule());
		#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising value Subset: " << "m_precondition - Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/ >(getOwnedRule())" << std::endl;
		#endif
		
	}
    return m_precondition;
}

/* Getter & Setter for reference redefinedOperation */
const std::shared_ptr<Subset<uml::Operation, uml::RedefinableElement>>& OperationImpl::getRedefinedOperation() const
{
	if(m_redefinedOperation == nullptr)
	{
		/*Subset*/
		m_redefinedOperation.reset(new Subset<uml::Operation, uml::RedefinableElement >());
		#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising shared pointer Subset: " << "m_redefinedOperation - Subset<uml::Operation, uml::RedefinableElement >()" << std::endl;
		#endif
		
		/*Subset*/
		getRedefinedOperation()->initSubset(getRedefinedElement());
		#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising value Subset: " << "m_redefinedOperation - Subset<uml::Operation, uml::RedefinableElement >(getRedefinedElement())" << std::endl;
		#endif
		
	}
    return m_redefinedOperation;
}

/* Getter & Setter for reference type */
const std::shared_ptr<uml::Type>& OperationImpl::getType() const
{
    return m_type;
}

//*********************************
// Union Getter
//*********************************
std::shared_ptr<Union<uml::Classifier>> OperationImpl::getFeaturingClassifier() const
{
	if(m_featuringClassifier == nullptr)
	{
		/*Union*/
		m_featuringClassifier.reset(new Union<uml::Classifier>());
			#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising Union: " << "m_featuringClassifier - Union<uml::Classifier>()" << std::endl;
		#endif
		
		
	}
	return m_featuringClassifier;
}

std::shared_ptr<Union<uml::NamedElement>> OperationImpl::getMember() const
{
	if(m_member == nullptr)
	{
		/*Union*/
		m_member.reset(new Union<uml::NamedElement>());
			#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising Union: " << "m_member - Union<uml::NamedElement>()" << std::endl;
		#endif
		
		
	}
	return m_member;
}

std::weak_ptr<uml::Namespace> OperationImpl::getNamespace() const
{
	return m_namespace;
}

std::shared_ptr<Union<uml::Element>> OperationImpl::getOwnedElement() const
{
	if(m_ownedElement == nullptr)
	{
		/*Union*/
		m_ownedElement.reset(new Union<uml::Element>());
			#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising Union: " << "m_ownedElement - Union<uml::Element>()" << std::endl;
		#endif
		
		
	}
	return m_ownedElement;
}

std::shared_ptr<SubsetUnion<uml::NamedElement, uml::Element, uml::NamedElement>> OperationImpl::getOwnedMember() const
{
	if(m_ownedMember == nullptr)
	{
		/*SubsetUnion*/
		m_ownedMember.reset(new SubsetUnion<uml::NamedElement, uml::Element, uml::NamedElement >());
		#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising shared pointer SubsetUnion: " << "m_ownedMember - SubsetUnion<uml::NamedElement, uml::Element, uml::NamedElement >()" << std::endl;
		#endif
		
		/*SubsetUnion*/
		getOwnedMember()->initSubsetUnion(getOwnedElement(), getMember());
		#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising value SubsetUnion: " << "m_ownedMember - SubsetUnion<uml::NamedElement, uml::Element, uml::NamedElement >(getOwnedElement(), getMember())" << std::endl;
		#endif
		
	}
	return m_ownedMember;
}

std::weak_ptr<uml::Element> OperationImpl::getOwner() const
{
	return m_owner;
}

std::shared_ptr<Union<uml::RedefinableElement>> OperationImpl::getRedefinedElement() const
{
	if(m_redefinedElement == nullptr)
	{
		/*Union*/
		m_redefinedElement.reset(new Union<uml::RedefinableElement>());
			#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising Union: " << "m_redefinedElement - Union<uml::RedefinableElement>()" << std::endl;
		#endif
		
		
	}
	return m_redefinedElement;
}

std::shared_ptr<Union<uml::Classifier>> OperationImpl::getRedefinitionContext() const
{
	if(m_redefinitionContext == nullptr)
	{
		/*Union*/
		m_redefinitionContext.reset(new Union<uml::Classifier>());
			#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising Union: " << "m_redefinitionContext - Union<uml::Classifier>()" << std::endl;
		#endif
		
		
	}
	return m_redefinitionContext;
}



//*********************************
// Container Getter
//*********************************
std::shared_ptr<ecore::EObject> OperationImpl::eContainer() const
{
	if(auto wp = m_class.lock())
	{
		return wp;
	}

	if(auto wp = m_datatype.lock())
	{
		return wp;
	}

	if(auto wp = m_interface.lock())
	{
		return wp;
	}

	if(auto wp = m_namespace.lock())
	{
		return wp;
	}

	if(auto wp = m_owner.lock())
	{
		return wp;
	}

	if(auto wp = m_owningTemplateParameter.lock())
	{
		return wp;
	}
	return nullptr;
}

//*********************************
// Persistence Functions
//*********************************
void OperationImpl::load(std::shared_ptr<persistence::interfaces::XLoadHandler> loadHandler)
{
	std::map<std::string, std::string> attr_list = loadHandler->getAttributeList();
	loadAttributes(loadHandler, attr_list);

	//
	// Create new objects (from references (containment == true))
	//
	// get umlFactory
	int numNodes = loadHandler->getNumOfChildNodes();
	for(int ii = 0; ii < numNodes; ii++)
	{
		loadNode(loadHandler->getNextNodeName(), loadHandler);
	}
}		

void OperationImpl::loadAttributes(std::shared_ptr<persistence::interfaces::XLoadHandler> loadHandler, std::map<std::string, std::string> attr_list)
{
	try
	{
		std::map<std::string, std::string>::const_iterator iter;
	
		iter = attr_list.find("isQuery");
		if ( iter != attr_list.end() )
		{
			// this attribute is a 'bool'
			bool value;
			std::istringstream(iter->second) >> std::boolalpha >> value;
			this->setIsQuery(value);
		}
		std::shared_ptr<ecore::EClass> metaClass = this->eClass(); // get MetaClass
		iter = attr_list.find("bodyCondition");
		if ( iter != attr_list.end() )
		{
			// add unresolvedReference to loadHandler's list
			loadHandler->addUnresolvedReference(iter->second, loadHandler->getCurrentObject(), metaClass->getEStructuralFeature("bodyCondition")); // TODO use getEStructuralFeature() with id, for faster access to EStructuralFeature
		}

		iter = attr_list.find("postcondition");
		if ( iter != attr_list.end() )
		{
			// add unresolvedReference to loadHandler's list
			loadHandler->addUnresolvedReference(iter->second, loadHandler->getCurrentObject(), metaClass->getEStructuralFeature("postcondition")); // TODO use getEStructuralFeature() with id, for faster access to EStructuralFeature
		}

		iter = attr_list.find("precondition");
		if ( iter != attr_list.end() )
		{
			// add unresolvedReference to loadHandler's list
			loadHandler->addUnresolvedReference(iter->second, loadHandler->getCurrentObject(), metaClass->getEStructuralFeature("precondition")); // TODO use getEStructuralFeature() with id, for faster access to EStructuralFeature
		}

		iter = attr_list.find("redefinedOperation");
		if ( iter != attr_list.end() )
		{
			// add unresolvedReference to loadHandler's list
			loadHandler->addUnresolvedReference(iter->second, loadHandler->getCurrentObject(), metaClass->getEStructuralFeature("redefinedOperation")); // TODO use getEStructuralFeature() with id, for faster access to EStructuralFeature
		}
	}
	catch (std::exception& e)
	{
		std::cout << "| ERROR    | " << e.what() << std::endl;
	}
	catch (...) 
	{
		std::cout << "| ERROR    | " <<  "Exception occurred" << std::endl;
	}

	BehavioralFeatureImpl::loadAttributes(loadHandler, attr_list);
	ParameterableElementImpl::loadAttributes(loadHandler, attr_list);
	TemplateableElementImpl::loadAttributes(loadHandler, attr_list);
}

void OperationImpl::loadNode(std::string nodeName, std::shared_ptr<persistence::interfaces::XLoadHandler> loadHandler)
{

	try
	{
		if ( nodeName.compare("ownedParameter") == 0 )
		{
  			std::string typeName = loadHandler->getCurrentXSITypeName();
			if (typeName.empty())
			{
				typeName = "Parameter";
			}
			loadHandler->handleChildContainer<uml::Parameter>(this->getProperty_OwnedParameter());  

			return; 
		}
	}
	catch (std::exception& e)
	{
		std::cout << "| ERROR    | " << e.what() << std::endl;
	}
	catch (...) 
	{
		std::cout << "| ERROR    | " <<  "Exception occurred" << std::endl;
	}
	//load BasePackage Nodes
	BehavioralFeatureImpl::loadNode(nodeName, loadHandler);
	ParameterableElementImpl::loadNode(nodeName, loadHandler);
	TemplateableElementImpl::loadNode(nodeName, loadHandler);
}

void OperationImpl::resolveReferences(const int featureID, std::vector<std::shared_ptr<ecore::EObject> > references)
{
	switch(featureID)
	{
		case uml::umlPackage::OPERATION_ATTRIBUTE_BODYCONDITION:
		{
			if (references.size() == 1)
			{
				// Cast object to correct type
				std::shared_ptr<uml::Constraint> _bodyCondition = std::dynamic_pointer_cast<uml::Constraint>( references.front() );
				setBodyCondition(_bodyCondition);
			}
			
			return;
		}

		case uml::umlPackage::OPERATION_ATTRIBUTE_CLASS:
		{
			if (references.size() == 1)
			{
				// Cast object to correct type
				std::shared_ptr<uml::Class> _class = std::dynamic_pointer_cast<uml::Class>( references.front() );
				setClass(_class);
			}
			
			return;
		}

		case uml::umlPackage::OPERATION_ATTRIBUTE_DATATYPE:
		{
			if (references.size() == 1)
			{
				// Cast object to correct type
				std::shared_ptr<uml::DataType> _datatype = std::dynamic_pointer_cast<uml::DataType>( references.front() );
				setDatatype(_datatype);
			}
			
			return;
		}

		case uml::umlPackage::OPERATION_ATTRIBUTE_INTERFACE:
		{
			if (references.size() == 1)
			{
				// Cast object to correct type
				std::shared_ptr<uml::Interface> _interface = std::dynamic_pointer_cast<uml::Interface>( references.front() );
				setInterface(_interface);
			}
			
			return;
		}

		case uml::umlPackage::OPERATION_ATTRIBUTE_POSTCONDITION:
		{
			const std::shared_ptr<Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/>>& _postcondition = getPostcondition();
			for(const std::shared_ptr<ecore::EObject>& ref : references)
			{
				std::shared_ptr<uml::Constraint>  _r = std::dynamic_pointer_cast<uml::Constraint>(ref);
				if (_r != nullptr)
				{
					_postcondition->push_back(_r);
				}
			}
			return;
		}

		case uml::umlPackage::OPERATION_ATTRIBUTE_PRECONDITION:
		{
			const std::shared_ptr<Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/>>& _precondition = getPrecondition();
			for(const std::shared_ptr<ecore::EObject>& ref : references)
			{
				std::shared_ptr<uml::Constraint>  _r = std::dynamic_pointer_cast<uml::Constraint>(ref);
				if (_r != nullptr)
				{
					_precondition->push_back(_r);
				}
			}
			return;
		}

		case uml::umlPackage::OPERATION_ATTRIBUTE_REDEFINEDOPERATION:
		{
			const std::shared_ptr<Subset<uml::Operation, uml::RedefinableElement>>& _redefinedOperation = getRedefinedOperation();
			for(const std::shared_ptr<ecore::EObject>& ref : references)
			{
				std::shared_ptr<uml::Operation>  _r = std::dynamic_pointer_cast<uml::Operation>(ref);
				if (_r != nullptr)
				{
					_redefinedOperation->push_back(_r);
				}
			}
			return;
		}
	}
	BehavioralFeatureImpl::resolveReferences(featureID, references);
	ParameterableElementImpl::resolveReferences(featureID, references);
	TemplateableElementImpl::resolveReferences(featureID, references);
}

void OperationImpl::save(std::shared_ptr<persistence::interfaces::XSaveHandler> saveHandler) const
{
	saveContent(saveHandler);

	BehavioralFeatureImpl::saveContent(saveHandler);
	ParameterableElementImpl::saveContent(saveHandler);
	TemplateableElementImpl::saveContent(saveHandler);
	
	FeatureImpl::saveContent(saveHandler);
	NamespaceImpl::saveContent(saveHandler);
	
	RedefinableElementImpl::saveContent(saveHandler);
	
	NamedElementImpl::saveContent(saveHandler);
	
	ElementImpl::saveContent(saveHandler);
	
	ObjectImpl::saveContent(saveHandler);
	
	ecore::EObjectImpl::saveContent(saveHandler);
}

void OperationImpl::saveContent(std::shared_ptr<persistence::interfaces::XSaveHandler> saveHandler) const
{
	try
	{
		std::shared_ptr<uml::umlPackage> package = uml::umlPackage::eInstance();
		// Add attributes
		if ( this->eIsSet(package->getOperation_Attribute_isQuery()) )
		{
			saveHandler->addAttribute("isQuery", this->getIsQuery());
		}
	// Add references
		saveHandler->addReference(this->getBodyCondition(), "bodyCondition", getBodyCondition()->eClass() != uml::umlPackage::eInstance()->getConstraint_Class()); 
		saveHandler->addReferences<uml::Constraint>("postcondition", this->getPostcondition());
		saveHandler->addReferences<uml::Constraint>("precondition", this->getPrecondition());
		saveHandler->addReferences<uml::Operation>("redefinedOperation", this->getRedefinedOperation());
		//
		// Add new tags (from references)
		//
		std::shared_ptr<ecore::EClass> metaClass = this->eClass();
		// Save 'ownedParameter'

		saveHandler->addReferences<uml::Parameter>("ownedParameter", this->getProperty_OwnedParameter());
	}
	catch (std::exception& e)
	{
		std::cout << "| ERROR    | " << e.what() << std::endl;
	}
}

const std::shared_ptr<ecore::EClass>& OperationImpl::eStaticClass() const
{
	return uml::umlPackage::eInstance()->getOperation_Class();
}

//*********************************
// EStructuralFeature Get/Set/IsSet
//*********************************
Any OperationImpl::eGet(int featureID, bool resolve, bool coreType) const
{
	switch(featureID)
	{
		case uml::umlPackage::OPERATION_ATTRIBUTE_BODYCONDITION:
			return eAny(getBodyCondition(),uml::umlPackage::CONSTRAINT_CLASS,false); //16730
		case uml::umlPackage::OPERATION_ATTRIBUTE_CLASS:
		{
			std::shared_ptr<ecore::EObject> returnValue=getClass().lock();
			return eAnyObject(returnValue,uml::umlPackage::CLASS_CLASS); //16731
		}
		case uml::umlPackage::OPERATION_ATTRIBUTE_DATATYPE:
		{
			std::shared_ptr<ecore::EObject> returnValue=getDatatype().lock();
			return eAnyObject(returnValue,uml::umlPackage::DATATYPE_CLASS); //16732
		}
		case uml::umlPackage::OPERATION_ATTRIBUTE_INTERFACE:
		{
			std::shared_ptr<ecore::EObject> returnValue=getInterface().lock();
			return eAnyObject(returnValue,uml::umlPackage::INTERFACE_CLASS); //16733
		}
		case uml::umlPackage::OPERATION_ATTRIBUTE_ISORDERED:
			return eAny(getIsOrdered(),ecore::ecorePackage::EBOOLEAN_CLASS,false); //16734
		case uml::umlPackage::OPERATION_ATTRIBUTE_ISQUERY:
			return eAny(getIsQuery(),ecore::ecorePackage::EBOOLEAN_CLASS,false); //16735
		case uml::umlPackage::OPERATION_ATTRIBUTE_ISUNIQUE:
			return eAny(getIsUnique(),ecore::ecorePackage::EBOOLEAN_CLASS,false); //16736
		case uml::umlPackage::OPERATION_ATTRIBUTE_LOWER:
			return eAny(getLower(),ecore::ecorePackage::EINT_CLASS,false); //16737
		case uml::umlPackage::OPERATION_ATTRIBUTE_OWNEDPARAMETER:
			return eAnyBag(getProperty_OwnedParameter(),uml::umlPackage::PARAMETER_CLASS); //16743
		case uml::umlPackage::OPERATION_ATTRIBUTE_POSTCONDITION:
			return eAnyBag(getPostcondition(),uml::umlPackage::CONSTRAINT_CLASS); //16738
		case uml::umlPackage::OPERATION_ATTRIBUTE_PRECONDITION:
			return eAnyBag(getPrecondition(),uml::umlPackage::CONSTRAINT_CLASS); //16739
		case uml::umlPackage::OPERATION_ATTRIBUTE_REDEFINEDOPERATION:
			return eAnyBag(getRedefinedOperation(),uml::umlPackage::OPERATION_CLASS); //16740
		case uml::umlPackage::OPERATION_ATTRIBUTE_TYPE:
			return eAny(getType(),uml::umlPackage::TYPE_CLASS,false); //16741
		case uml::umlPackage::OPERATION_ATTRIBUTE_UPPER:
			return eAny(getUpper(),0,false); //16742
	}
	Any result;
	result = BehavioralFeatureImpl::eGet(featureID, resolve, coreType);
	if (result != nullptr && !result->isEmpty())
	{
		return result;
	}
	result = ParameterableElementImpl::eGet(featureID, resolve, coreType);
	if (result != nullptr && !result->isEmpty())
	{
		return result;
	}
	result = TemplateableElementImpl::eGet(featureID, resolve, coreType);
	return result;
}

bool OperationImpl::internalEIsSet(int featureID) const
{
	switch(featureID)
	{
		case uml::umlPackage::OPERATION_ATTRIBUTE_BODYCONDITION:
			return getBodyCondition() != nullptr; //16730
		case uml::umlPackage::OPERATION_ATTRIBUTE_CLASS:
			return getClass().lock() != nullptr; //16731
		case uml::umlPackage::OPERATION_ATTRIBUTE_DATATYPE:
			return getDatatype().lock() != nullptr; //16732
		case uml::umlPackage::OPERATION_ATTRIBUTE_INTERFACE:
			return getInterface().lock() != nullptr; //16733
		case uml::umlPackage::OPERATION_ATTRIBUTE_ISORDERED:
			return getIsOrdered() != false; //16734
		case uml::umlPackage::OPERATION_ATTRIBUTE_ISQUERY:
			return getIsQuery() != false; //16735
		case uml::umlPackage::OPERATION_ATTRIBUTE_ISUNIQUE:
			return getIsUnique() != true; //16736
		case uml::umlPackage::OPERATION_ATTRIBUTE_LOWER:
			return getLower() != 1; //16737
		case uml::umlPackage::OPERATION_ATTRIBUTE_OWNEDPARAMETER:
			return getProperty_OwnedParameter() != nullptr; //16743
		case uml::umlPackage::OPERATION_ATTRIBUTE_POSTCONDITION:
			return getPostcondition() != nullptr; //16738
		case uml::umlPackage::OPERATION_ATTRIBUTE_PRECONDITION:
			return getPrecondition() != nullptr; //16739
		case uml::umlPackage::OPERATION_ATTRIBUTE_REDEFINEDOPERATION:
			return getRedefinedOperation() != nullptr; //16740
		case uml::umlPackage::OPERATION_ATTRIBUTE_TYPE:
			return getType() != nullptr; //16741
		case uml::umlPackage::OPERATION_ATTRIBUTE_UPPER:
			return getUpper() != 1; //16742
	}
	bool result = false;
	result = BehavioralFeatureImpl::internalEIsSet(featureID);
	if (result)
	{
		return result;
	}
	result = ParameterableElementImpl::internalEIsSet(featureID);
	if (result)
	{
		return result;
	}
	result = TemplateableElementImpl::internalEIsSet(featureID);
	return result;
}

bool OperationImpl::eSet(int featureID, const Any& newValue)
{
	switch(featureID)
	{
		case uml::umlPackage::OPERATION_ATTRIBUTE_BODYCONDITION:
		{
			// CAST Any to uml::Constraint
			std::shared_ptr<ecore::EObject> _temp = newValue->get<std::shared_ptr<ecore::EObject>>();
			std::shared_ptr<uml::Constraint> _bodyCondition = std::dynamic_pointer_cast<uml::Constraint>(_temp);
			setBodyCondition(_bodyCondition); //16730
			return true;
		}
		case uml::umlPackage::OPERATION_ATTRIBUTE_CLASS:
		{
			// CAST Any to uml::Class
			std::shared_ptr<ecore::EObject> _temp = newValue->get<std::shared_ptr<ecore::EObject>>();
			std::shared_ptr<uml::Class> _class = std::dynamic_pointer_cast<uml::Class>(_temp);
			setClass(_class); //16731
			return true;
		}
		case uml::umlPackage::OPERATION_ATTRIBUTE_DATATYPE:
		{
			// CAST Any to uml::DataType
			std::shared_ptr<ecore::EObject> _temp = newValue->get<std::shared_ptr<ecore::EObject>>();
			std::shared_ptr<uml::DataType> _datatype = std::dynamic_pointer_cast<uml::DataType>(_temp);
			setDatatype(_datatype); //16732
			return true;
		}
		case uml::umlPackage::OPERATION_ATTRIBUTE_INTERFACE:
		{
			// CAST Any to uml::Interface
			std::shared_ptr<ecore::EObject> _temp = newValue->get<std::shared_ptr<ecore::EObject>>();
			std::shared_ptr<uml::Interface> _interface = std::dynamic_pointer_cast<uml::Interface>(_temp);
			setInterface(_interface); //16733
			return true;
		}
		case uml::umlPackage::OPERATION_ATTRIBUTE_ISQUERY:
		{
			// CAST Any to bool
			bool _isQuery = newValue->get<bool>();
			setIsQuery(_isQuery); //16735
			return true;
		}
		case uml::umlPackage::OPERATION_ATTRIBUTE_OWNEDPARAMETER:
		{
			// CAST Any to Bag<uml::Parameter>
			if((newValue->isContainer()) && (uml::umlPackage::PARAMETER_CLASS ==newValue->getTypeId()))
			{ 
				try
				{
					std::shared_ptr<Bag<uml::Parameter>> ownedParameterList= newValue->get<std::shared_ptr<Bag<uml::Parameter>>>();
					std::shared_ptr<Bag<uml::Parameter>> _ownedParameter=getProperty_OwnedParameter();
					for(const std::shared_ptr<uml::Parameter> indexOwnedParameter: *_ownedParameter)
					{
						if (!(ownedParameterList->includes(indexOwnedParameter)))
						{
							_ownedParameter->erase(indexOwnedParameter);
						}
					}

					for(const std::shared_ptr<uml::Parameter> indexOwnedParameter: *ownedParameterList)
					{
						if (!(_ownedParameter->includes(indexOwnedParameter)))
						{
							_ownedParameter->add(indexOwnedParameter);
						}
					}
				}
				catch(...)
				{
					DEBUG_MESSAGE(std::cout << "invalid Type to set of eAttributes."<< std::endl;)
					return false;
				}
			}
			else
			{
				return false;
			}
			return true;
		}
		case uml::umlPackage::OPERATION_ATTRIBUTE_POSTCONDITION:
		{
			// CAST Any to Bag<uml::Constraint>
			if((newValue->isContainer()) && (uml::umlPackage::CONSTRAINT_CLASS ==newValue->getTypeId()))
			{ 
				try
				{
					std::shared_ptr<Bag<uml::Constraint>> postconditionList= newValue->get<std::shared_ptr<Bag<uml::Constraint>>>();
					std::shared_ptr<Bag<uml::Constraint>> _postcondition=getPostcondition();
					for(const std::shared_ptr<uml::Constraint> indexPostcondition: *_postcondition)
					{
						if (!(postconditionList->includes(indexPostcondition)))
						{
							_postcondition->erase(indexPostcondition);
						}
					}

					for(const std::shared_ptr<uml::Constraint> indexPostcondition: *postconditionList)
					{
						if (!(_postcondition->includes(indexPostcondition)))
						{
							_postcondition->add(indexPostcondition);
						}
					}
				}
				catch(...)
				{
					DEBUG_MESSAGE(std::cout << "invalid Type to set of eAttributes."<< std::endl;)
					return false;
				}
			}
			else
			{
				return false;
			}
			return true;
		}
		case uml::umlPackage::OPERATION_ATTRIBUTE_PRECONDITION:
		{
			// CAST Any to Bag<uml::Constraint>
			if((newValue->isContainer()) && (uml::umlPackage::CONSTRAINT_CLASS ==newValue->getTypeId()))
			{ 
				try
				{
					std::shared_ptr<Bag<uml::Constraint>> preconditionList= newValue->get<std::shared_ptr<Bag<uml::Constraint>>>();
					std::shared_ptr<Bag<uml::Constraint>> _precondition=getPrecondition();
					for(const std::shared_ptr<uml::Constraint> indexPrecondition: *_precondition)
					{
						if (!(preconditionList->includes(indexPrecondition)))
						{
							_precondition->erase(indexPrecondition);
						}
					}

					for(const std::shared_ptr<uml::Constraint> indexPrecondition: *preconditionList)
					{
						if (!(_precondition->includes(indexPrecondition)))
						{
							_precondition->add(indexPrecondition);
						}
					}
				}
				catch(...)
				{
					DEBUG_MESSAGE(std::cout << "invalid Type to set of eAttributes."<< std::endl;)
					return false;
				}
			}
			else
			{
				return false;
			}
			return true;
		}
		case uml::umlPackage::OPERATION_ATTRIBUTE_REDEFINEDOPERATION:
		{
			// CAST Any to Bag<uml::Operation>
			if((newValue->isContainer()) && (uml::umlPackage::OPERATION_CLASS ==newValue->getTypeId()))
			{ 
				try
				{
					std::shared_ptr<Bag<uml::Operation>> redefinedOperationList= newValue->get<std::shared_ptr<Bag<uml::Operation>>>();
					std::shared_ptr<Bag<uml::Operation>> _redefinedOperation=getRedefinedOperation();
					for(const std::shared_ptr<uml::Operation> indexRedefinedOperation: *_redefinedOperation)
					{
						if (!(redefinedOperationList->includes(indexRedefinedOperation)))
						{
							_redefinedOperation->erase(indexRedefinedOperation);
						}
					}

					for(const std::shared_ptr<uml::Operation> indexRedefinedOperation: *redefinedOperationList)
					{
						if (!(_redefinedOperation->includes(indexRedefinedOperation)))
						{
							_redefinedOperation->add(indexRedefinedOperation);
						}
					}
				}
				catch(...)
				{
					DEBUG_MESSAGE(std::cout << "invalid Type to set of eAttributes."<< std::endl;)
					return false;
				}
			}
			else
			{
				return false;
			}
			return true;
		}
	}

	bool result = false;
	result = BehavioralFeatureImpl::eSet(featureID, newValue);
	if (result)
	{
		return result;
	}
	result = ParameterableElementImpl::eSet(featureID, newValue);
	if (result)
	{
		return result;
	}
	result = TemplateableElementImpl::eSet(featureID, newValue);
	return result;
}

//*********************************
// EOperation Invoke
//*********************************
Any OperationImpl::eInvoke(int operationID, const std::shared_ptr<std::list<Any>>& arguments)
{
	Any result;
 
  	switch(operationID)
	{
		// uml::Operation::at_most_one_return(Any, std::map) : bool: 1796067314
		case umlPackage::OPERATION_OPERATION_AT_MOST_ONE_RETURN_EDIAGNOSTICCHAIN_EMAP:
		{
			//Retrieve input parameter 'diagnostics'
			//parameter 0
			Any incoming_param_diagnostics;
			std::list<Any>::const_iterator incoming_param_diagnostics_arguments_citer = std::next(arguments->begin(), 0);
			incoming_param_diagnostics = (*incoming_param_diagnostics_arguments_citer)->get<Any >();
			//Retrieve input parameter 'context'
			//parameter 1
			std::shared_ptr<std::map < Any, Any>> incoming_param_context;
			std::list<Any>::const_iterator incoming_param_context_arguments_citer = std::next(arguments->begin(), 1);
			incoming_param_context = (*incoming_param_context_arguments_citer)->get<std::shared_ptr<std::map < Any, Any>> >();
			result = eAny(this->at_most_one_return(incoming_param_diagnostics,incoming_param_context),0,false);
			break;
		}
		// uml::Operation::getLower() : int: 2432712746
		case umlPackage::OPERATION_OPERATION_GETLOWER:
		{
			result = eAny(this->getLower(),0,false);
			break;
		}
		// uml::Operation::getReturnResult() : uml::Parameter: 3209085960
		case umlPackage::OPERATION_OPERATION_GETRETURNRESULT:
		{
			result = eAnyObject(this->getReturnResult(), uml::umlPackage::PARAMETER_CLASS);
			break;
		}
		// uml::Operation::getUpper() : int: 1198605197
		case umlPackage::OPERATION_OPERATION_GETUPPER:
		{
			result = eAny(this->getUpper(),0,false);
			break;
		}
		// uml::Operation::isOrdered() : bool: 2709191195
		case umlPackage::OPERATION_OPERATION_ISORDERED:
		{
			result = eAny(this->isOrdered(),0,false);
			break;
		}
		// uml::Operation::isUnique() : bool: 4020565657
		case umlPackage::OPERATION_OPERATION_ISUNIQUE:
		{
			result = eAny(this->isUnique(),0,false);
			break;
		}
		// uml::Operation::matches(uml::Operation) : bool: 1582514854
		case umlPackage::OPERATION_OPERATION_MATCHES_OPERATION:
		{
			//Retrieve input parameter 'comparedOperation'
			//parameter 0
			std::shared_ptr<uml::Operation> incoming_param_comparedOperation;
			std::list<Any>::const_iterator incoming_param_comparedOperation_arguments_citer = std::next(arguments->begin(), 0);
			incoming_param_comparedOperation = (*incoming_param_comparedOperation_arguments_citer)->get<std::shared_ptr<uml::Operation> >();
			result = eAny(this->matches(incoming_param_comparedOperation),0,false);
			break;
		}
		// uml::Operation::only_body_for_query(Any, std::map) : bool: 2418925081
		case umlPackage::OPERATION_OPERATION_ONLY_BODY_FOR_QUERY_EDIAGNOSTICCHAIN_EMAP:
		{
			//Retrieve input parameter 'diagnostics'
			//parameter 0
			Any incoming_param_diagnostics;
			std::list<Any>::const_iterator incoming_param_diagnostics_arguments_citer = std::next(arguments->begin(), 0);
			incoming_param_diagnostics = (*incoming_param_diagnostics_arguments_citer)->get<Any >();
			//Retrieve input parameter 'context'
			//parameter 1
			std::shared_ptr<std::map < Any, Any>> incoming_param_context;
			std::list<Any>::const_iterator incoming_param_context_arguments_citer = std::next(arguments->begin(), 1);
			incoming_param_context = (*incoming_param_context_arguments_citer)->get<std::shared_ptr<std::map < Any, Any>> >();
			result = eAny(this->only_body_for_query(incoming_param_diagnostics,incoming_param_context),0,false);
			break;
		}
		// uml::Operation::returnResult() : uml::Parameter: 3088060264
		case umlPackage::OPERATION_OPERATION_RETURNRESULT:
		{
			result = eAnyObject(this->returnResult(), uml::umlPackage::PARAMETER_CLASS);
			break;
		}
		// uml::Operation::setIsOrdered(bool): 563533641
		case umlPackage::OPERATION_OPERATION_SETISORDERED_BOOLEAN:
		{
			//Retrieve input parameter 'newIsOrdered'
			//parameter 0
			bool incoming_param_newIsOrdered;
			std::list<Any>::const_iterator incoming_param_newIsOrdered_arguments_citer = std::next(arguments->begin(), 0);
			incoming_param_newIsOrdered = (*incoming_param_newIsOrdered_arguments_citer)->get<bool >();
			this->setIsOrdered(incoming_param_newIsOrdered);
			break;
		}
		// uml::Operation::setIsUnique(bool): 1317393399
		case umlPackage::OPERATION_OPERATION_SETISUNIQUE_BOOLEAN:
		{
			//Retrieve input parameter 'newIsUnique'
			//parameter 0
			bool incoming_param_newIsUnique;
			std::list<Any>::const_iterator incoming_param_newIsUnique_arguments_citer = std::next(arguments->begin(), 0);
			incoming_param_newIsUnique = (*incoming_param_newIsUnique_arguments_citer)->get<bool >();
			this->setIsUnique(incoming_param_newIsUnique);
			break;
		}
		// uml::Operation::setLower(int): 3045305040
		case umlPackage::OPERATION_OPERATION_SETLOWER_INTEGER:
		{
			//Retrieve input parameter 'newLower'
			//parameter 0
			int incoming_param_newLower;
			std::list<Any>::const_iterator incoming_param_newLower_arguments_citer = std::next(arguments->begin(), 0);
			incoming_param_newLower = (*incoming_param_newLower_arguments_citer)->get<int >();
			this->setLower(incoming_param_newLower);
			break;
		}
		// uml::Operation::setType(uml::Type): 295406386
		case umlPackage::OPERATION_OPERATION_SETTYPE_TYPE:
		{
			//Retrieve input parameter 'newType'
			//parameter 0
			std::shared_ptr<uml::Type> incoming_param_newType;
			std::list<Any>::const_iterator incoming_param_newType_arguments_citer = std::next(arguments->begin(), 0);
			incoming_param_newType = (*incoming_param_newType_arguments_citer)->get<std::shared_ptr<uml::Type> >();
			this->setType(incoming_param_newType);
			break;
		}
		// uml::Operation::setUpper(int): 1811197491
		case umlPackage::OPERATION_OPERATION_SETUPPER_UNLIMITEDNATURAL:
		{
			//Retrieve input parameter 'newUpper'
			//parameter 0
			int incoming_param_newUpper;
			std::list<Any>::const_iterator incoming_param_newUpper_arguments_citer = std::next(arguments->begin(), 0);
			incoming_param_newUpper = (*incoming_param_newUpper_arguments_citer)->get<int >();
			this->setUpper(incoming_param_newUpper);
			break;
		}

		default:
		{
			// call superTypes
			result = TemplateableElementImpl::eInvoke(operationID, arguments);
			if (result && !result->isEmpty())
				break;
			result = ParameterableElementImpl::eInvoke(operationID, arguments);
			if (result && !result->isEmpty())
				break;
			result = BehavioralFeatureImpl::eInvoke(operationID, arguments);
			if (result && !result->isEmpty())
				break;
			break;
		}
  	}

	return result;
}

std::shared_ptr<uml::Operation> OperationImpl::getThisOperationPtr() const
{
	return m_thisOperationPtr.lock();
}
void OperationImpl::setThisOperationPtr(std::weak_ptr<uml::Operation> thisOperationPtr)
{
	m_thisOperationPtr = thisOperationPtr;
	setThisBehavioralFeaturePtr(thisOperationPtr);
	setThisParameterableElementPtr(thisOperationPtr);
	setThisTemplateableElementPtr(thisOperationPtr);
}


