[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 ****************************************************************************************************************************************************************
 * 
 * module for generation of UML Type artefacts
 * 
 */]
[module generateType('http://www.eclipse.org/uml2/5.0.0/UML')]

[import UML4CPP::generator::main::helpers::generalHelper /]
[import UML4CPP::generator::main::helpers::nameHelper /]
[import UML4CPP::generator::main::validation::validation/]
[import UML4CPP::generator::main::profiles::uml4CPPProfileHelper /]

[**
 * check if type is primitive type
*/]
[query public isPrimitive(type : Type) : Boolean = (not type.oclIsUndefined()) and ((type.name = 'Integer') or (type.name = 'Boolean') or (type.name = 'String') or (type.name = 'Real') or (type.name = 'EInt') or (type.name = 'EBoolean') or (type.name = 'EString') or (type.name = 'EDouble')  or (type.name = 'EFloat') or (type.name = 'UnlimitedNatural'))/]

[query public supportedTypes(type : Type) : Boolean = (not type.oclIsUndefined()) and ((name = 'Integer') or (name = 'Boolean') or (name = 'String') or (name = 'Real') or (name = 'UnlimitedNatural')) /]

[**
 * check if a property is back reference of composition 
*/]
[query public isBackReference(aProperty : Property) : Boolean = (not aProperty.association.oclIsUndefined()) and (not aProperty.owner.oclIsKindOf(Association)) and aProperty.association.memberEnd->excluding(aProperty)->asOrderedSet()->first().isComposite /]

[**
 * generate the C++ representation of a type for a Property
 * 
 * - pointer for types, which are not primitive or enumeration:
 * 	- shared pointer for all properties except back reference properties
 *  - weak pointer for back reference pointers
 * - upper <> 1 -> Bag used  
 * - error message, if property type is undefined or property type name is undefined
*/]
[template public generateCppType(aProperty : Property)]
[if (aProperty.upper <> 1)]
	[if (aProperty.isSubsetUnion())]
		[if (aProperty.type.oclIsUndefined() or ((not aProperty.type.isPrimitive()) and (not aProperty.type.oclIsKindOf(Enumeration))))]
[aProperty.pointertype()/]<SubsetUnion<[aProperty.type.transformType()/], [aProperty.generateSubsetTypes()/]>>[else]
std::shared_ptr<SubsetUnion<[aProperty.type.transformType()/], [aProperty.generateSubsetTypes()/]>>[/if]
		[elseif(aProperty.isSubset())]
			[if (aProperty.type.oclIsUndefined() or ((not aProperty.type.isPrimitive()) and (not aProperty.type.oclIsKindOf(Enumeration))))]
[aProperty.pointertype()/]<Subset<[aProperty.type.transformType()/], [aProperty.generateSubsetTypes()/]>>[else]
std::shared_ptr<Subset<[aProperty.type.transformType()/], [aProperty.generateSubsetTypes()/]>>[/if]
		[elseif(aProperty.isUnion())]
			[if (aProperty.type.oclIsUndefined() or ((not aProperty.type.isPrimitive()) and (not aProperty.type.oclIsKindOf(Enumeration))))]
[aProperty.pointertype()/]<Union<[aProperty.type.transformType()/]>>[else]
std::shared_ptr<Union<[aProperty.type.transformType()/]>>[/if]
		[else]
			[if (aProperty.type.oclIsUndefined() or ((not aProperty.type.isPrimitive()) and (not aProperty.type.oclIsKindOf(Enumeration))))]
[aProperty.pointertype()/]<Bag<[aProperty.type.transformType()/]>>[else]
std::shared_ptr<Bag<[aProperty.type.transformType()/]>>[/if]
		[/if]
[else]
		[if (aProperty.type.oclIsUndefined() or ((not aProperty.type.isPrimitive()) and (not aProperty.type.oclIsKindOf(Enumeration))))]
[aProperty.pointertype()/]<[aProperty.type.transformType()/]>[else]
[aProperty.type.transformType()/][/if]
[/if]
[/template]

[template public generateSubsetTypes(aProperty : Property)]
[for (subsettedProperty : Property | aProperty.subsettedProperty->select(owner.oclIsTypeOf(Class) or owner.oclIsKindOf(Interface))->asOrderedSet()->sortedBy(type.name)) separator(', ')]
[subsettedProperty.type.generateCppRawType(true)/][if (not subsettedProperty.isUnion())] /*Subset does not reference a union*/[/if][/for]
[/template]

[template public generateSubsetElements(aProperty : Property)]
[for (subsettedProperty : Property | aProperty.subsettedProperty->select(owner.oclIsTypeOf(Class) or owner.oclIsKindOf(Interface))->asOrderedSet()->sortedBy(type.name)) separator(', ')]
[subsettedProperty.getterName()/]()[/for]
[/template]

[**
 * generate the C++ representation of a type for an Operation
 * 
 * - if anOperation does not have a return parameter, C++ type will be void
 * - if anOperation has a return parameter, anOperation.type will be transformed...
 * 		- ... as simple value in case of primitive type or enumeration
 * 		- ... as shared_ptr (and possibly shared_ptr<Bag<>>) otherwise
*/]
[template public generateCppType(anOperation : Operation) post (trim())]
[if (anOperation.returnResult()->isEmpty())]
void
[else]
	[if (anOperation.upper <> 1)]
std::shared_ptr<Bag<[anOperation.type.transformType()/]>>
	[elseif (anOperation.type.oclIsUndefined() or ((not anOperation.type.isPrimitive()) and (not anOperation.type.oclIsKindOf(Enumeration))))]
std::shared_ptr<[anOperation.type.transformType()/]>
	[else]
[anOperation.type.transformType()/]
	[/if]
[/if]
[/template]

[**
 * generate the C++ representation of a type for an OpaqueBehavior
 * 
 * - if anOpaqueBehavior does not have a return parameter, C++ type will be void
 * - if anOpaqueBehavior has a return parameter, it's type will be transformed...
 * 		- ... as simple value in case of primitive type or enumeration
 * 		- ... as shared_ptr (and possibly shared_ptr<Bag<>>) otherwise
*/]
[template public generateCppType(anOpaqueBehavior : OpaqueBehavior) post (trim())]
[if (not anOpaqueBehavior.ownedParameter->select(direction = ParameterDirectionKind::return)->isEmpty())]
[let returnParameter : Parameter = anOpaqueBehavior.ownedParameter->select(direction = ParameterDirectionKind::return)->first()]
	[let returnType : Type = returnParameter.type]
	[if (returnParameter.upper <> 1)]
std::shared_ptr<Bag<[returnType.transformType()/]>>
		[elseif (returnType.oclIsUndefined() or ((not returnType.isPrimitive()) and (not returnType.oclIsKindOf(Enumeration))))]
std::shared_ptr<[returnType.transformType()/]>
		[else]
[returnType.transformType()/][/if]
	[/let]
[/let]
[else]
void
[/if]
[/template]

[**
 * generate the C++ representation of a type for a Parameter
 * 
 * - aParameter's type will be transformed...
 * 		- ... as simple value in case of primitive type or enumeration with upper = 1
 * 		- ... as shared_ptr (and possibly shared_ptr<Bag<>>) otherwise
*/]
[template public generateCppType(aParameter : Parameter, useReference : Boolean) post (trim())]
[if (aParameter.type.oclIsUndefined() or ((not aParameter.type.isPrimitive()) and (not aParameter.type.oclIsKindOf(Enumeration))))]
std::shared_ptr<[if (aParameter.upper <> 1)]Bag<[/if][aParameter.type.transformType()/]>[if (aParameter.upper <> 1)]>[/if]
[else]
[if (aParameter.upper <> 1)]std::shared_ptr<Bag<[/if][aParameter.type.transformType()/][if(useReference and (aParameter.direction = ParameterDirectionKind::inout or aParameter.direction = ParameterDirectionKind::out) and aParameter.upper = 1)]&[/if][if (aParameter.upper <> 1)]>>[/if][/if]
[/template]

[**
 * generate the C++ representation of a type for a Pin
 * 
 * - aPin's type will be transformed...
 * 		- ... as simple value in case of primitive type or enumeration with upper = 1
 * 		- ... as shared_ptr (and possibly shared_ptr<Bag<>>) otherwise
*/]
[template public generateCppType(aPin : Pin, useReference : Boolean) post (trim())]
[if (aPin.type.oclIsUndefined() or ((not aPin.type.isPrimitive()) and (not aPin.type.oclIsKindOf(Enumeration))))]
std::shared_ptr<[if (aPin.upper <> 1)]Bag<[/if][aPin.type.transformType()/]>[if (aPin.upper <> 1)]>[/if]
[else]
[if (aPin.upper <> 1)]std::shared_ptr<Bag<[/if][aPin.type.transformType()/][if (aPin.upper <> 1)]>>[/if][/if]
[/template]

[**
 * generate the C++ representation of a type for a Type
 * 
 * - aType will be transformed...
 * 		- ... as simple value in case of primitive type or enumeration or noShared = true
 * 		- ... as shared_ptr otherwise
*/]
[template public generateCppRawType(aType : Type, noShared : Boolean) ? (aType.oclIsUndefined())]
[if (not noShared)]std::shared_ptr<[/if]Any[if (not noShared)]>[/if]
[/template]

[template public generateCppRawType(aType : Type, noShared : Boolean)]
[if (not (aType.isPrimitive() or noShared or aType.oclIsKindOf(Enumeration)))]std::shared_ptr<[/if][aType.transformType()/][if (not (aType.isPrimitive() or noShared or aType.oclIsKindOf(Enumeration)))]>[/if]
[/template]


[**
 * determine if weak pointer or shared pointer should be used:
 * - shared pointer for all properties except back reference properties
 * - weak pointer for back reference pointers
*/]
[template private pointertype(aProperty : Property) post(trim())]
[if(aProperty.isBackReference())]
std::weak_ptr
[else]
std::shared_ptr
[/if]
[/template]

[**
 * Transformation uml to C++
*/]
[template public transformType(aType : Type) ? (oclIsUndefined())]
Any
[/template]

[template public transformType(aType : Type) ? (name = 'Boolean' or name = 'EBoolean')]
bool
[/template]

[template public transformType(aType : Type) ? (name = 'UnlimitedNatural' )]
int
[/template]

[template public transformType(aType : Type) ? (name = 'Integer' or name = 'EInt')]
int
[/template]

[template public transformType(aType : Type) ? (name = 'Real' or name = 'EDouble' or name = 'EFloat')]
double
[/template]

[template public transformType(aType : Type) ? (oclIsKindOf(PrimitiveType) and name = 'String' or name = 'EString')]
std::string
[/template]

[template public transformType(aType : Type) ? (oclIsKindOf(Enumeration))]
[if (not aType.getNearestPackage().isIgnoreNamespace())][aType.namespace.oclAsType(Package).generateNamespace(true)/]::[/if][aType.name/]
[/template]

[template public transformType(aType : Type) ? (not oclIsKindOf(PrimitiveType) and not oclIsKindOf(Enumeration) )]
[if (aType.name.oclIsUndefined())]undefinedType[else][if (not aType.isIgnoreNamespace())][aType.namespace.oclAsType(Package).generateNamespace(true)/]::[/if][aType.name.toUpperFirst()/][/if]
[/template]

[query public collectTypeIncludeStrings(aType : Type) : Set(String) = Set(String)
{
	'#include "' + aType.getNearestPackage().generateNamespacePath(true) + '/' + aType.name.toUpperFirst() + '.hpp"'
}->flatten()
/]