[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 ****************************************************************************************************************************************************************
 * 
 * module for generation of eSet/ eGet artefacts
 * 
 */]
[module setGetHelper('http://www.eclipse.org/uml2/5.0.0/UML')]

[import UML4CPP::generator::main::components::generateProperty /]
[import UML4CPP::generator::main::components::generateOperation /]
[import UML4CPP::generator::main::components::generateType /]
[import UML4CPP::generator::main::components::generateClass /]
[import UML4CPP::generator::main::components::generateNamedElement /]
[import UML4CPP::generator::main::helpers::generalHelper /]
[import UML4CPP::generator::main::helpers::nameHelper /]
[import UML4CPP::generator::main::helpers::IDHelper /]
[import UML4CPP::generator::main::profiles::uml4CPPProfileHelper /]

[**
 * generate get, set and unset function declaration
*/]
[template public generateeGetSetDel(aClass : Class,impl : Boolean)]
//Get
virtual std::shared_ptr<Any> get(const std::shared_ptr<uml::Property>& _property) const [abstractSuffix(impl)/];
virtual std::shared_ptr<Any> get(std::string _qualifiedName) const [abstractSuffix(impl)/];
virtual std::shared_ptr<Any> get(unsigned long _uID) const [abstractSuffix(impl)/];
//Set
virtual bool set(const std::shared_ptr<uml::Property>& _property, const std::shared_ptr<Any>& value) [abstractSuffix(impl)/];
virtual bool set(std::string _qualifiedName, const std::shared_ptr<Any>& value) [abstractSuffix(impl)/];
virtual bool set(unsigned long _uID, const std::shared_ptr<Any>& value) [abstractSuffix(impl)/];
//Add
virtual bool add(const std::shared_ptr<uml::Property>& _property, const std::shared_ptr<Any>& value, int insertAt = -1) [abstractSuffix(impl)/];
virtual bool add(std::string _qualifiedName, const std::shared_ptr<Any>& value, int insertAt = -1) [abstractSuffix(impl)/];
virtual bool add(unsigned long _uID, const std::shared_ptr<Any>& value, int insertAt = -1) [abstractSuffix(impl)/];
//Unset
virtual bool unset(const std::shared_ptr<uml::Property>& _property) [abstractSuffix(impl)/];
virtual bool unset(std::string _qualifiedName) [abstractSuffix(impl)/];
virtual bool unset(unsigned long _uID) [abstractSuffix(impl)/];
//Remove
virtual bool remove(const std::shared_ptr<uml::Property>& _property, const std::shared_ptr<Any>& value, int removeAt = -1, bool isRemoveDuplicates = false) [abstractSuffix(impl)/];
virtual bool remove(std::string _qualifiedName, const std::shared_ptr<Any>& value, int removeAt = -1, bool isRemoveDuplicates = false) [abstractSuffix(impl)/];
virtual bool remove(unsigned long _uID, const std::shared_ptr<Any>& value, int removeAt = -1, bool isRemoveDuplicates = false) [abstractSuffix(impl)/];
[/template]

[**
 * generate get, set and unset function declaration
*/]
[template public generateInvoke(aClass : Class,impl : Boolean)]
//Operation invocation
virtual std::shared_ptr<Any> invoke(const std::shared_ptr<uml::Operation>& _operation, const std::shared_ptr<Bag<Any>>& inputArguments, const std::shared_ptr<Bag<Any>>& outputArguments) [abstractSuffix(impl)/];
virtual std::shared_ptr<Any> invokeOperation(std::string _qualifiedName, const std::shared_ptr<Bag<Any>>& inputArguments, const std::shared_ptr<Bag<Any>>& outputArguments) [abstractSuffix(impl)/];
virtual std::shared_ptr<Any> invokeOperation(unsigned long _uID, const std::shared_ptr<Bag<Any>>& inputArguments, const std::shared_ptr<Bag<Any>>& outputArguments) [abstractSuffix(impl)/];

//OpaqueBehavior invocation
virtual std::shared_ptr<Any> invoke(const std::shared_ptr<uml::OpaqueBehavior>& _opaqueBehavior, const std::shared_ptr<Bag<Any>>& inputArguments, const std::shared_ptr<Bag<Any>>& outputArguments) [abstractSuffix(impl)/];
virtual std::shared_ptr<Any> invokeOpaqueBehavior(std::string _qualifiedName, const std::shared_ptr<Bag<Any>>& inputArguments, const std::shared_ptr<Bag<Any>>& outputArguments) [abstractSuffix(impl)/];
virtual std::shared_ptr<Any> invokeOpaqueBehavior(unsigned long _uID, const std::shared_ptr<Bag<Any>>& inputArguments, const std::shared_ptr<Bag<Any>>& outputArguments) [abstractSuffix(impl)/];
[/template]

[query private getPropertiesForGetAndSet(aClass : Class) : OrderedSet(Property) = aClass.attribute->addAll(aClass.interfaceRealization.contract.attribute)->reject(isDoNotGenerateElement())->sortedBy(myQualifiedName())/]
[query private getOperationsForInvoke(aClass : Class) : OrderedSet(Operation) = aClass.ownedOperation->addAll(aClass.interfaceRealization.contract.ownedOperation)->reject(isDoNotGenerateElement())->sortedBy(myQualifiedName())/]

[**
 * generate get, set and unset function implementation
*/]
[template public generateeGetSetImpl(aClass : Class)]
//Get
[aClass.generateGetImplementation()/]

//Set
[aClass.generateSetImplementation()/]

//Add
[aClass.generateAddImplementation()/]

//Unset
[aClass.generateUnSetImplementation()/]

//Remove
[aClass.generateRemoveImplementation()/]
[/template]

[template private generateGetImplementation(aClass : Class)]
std::shared_ptr<Any> [aClass.name.toUpperFirst().concat('Impl')/]::get(const std::shared_ptr<uml::Property>& _property) const
{
	return this->get(_property->_getID());
}

std::shared_ptr<Any> [aClass.name.toUpperFirst().concat('Impl')/]::get(std::string _qualifiedName) const
{
	unsigned long uID = util::Util::polynomialRollingHash(_qualifiedName);
	return this->get(uID);
}

std::shared_ptr<Any> [aClass.name.toUpperFirst().concat('Impl')/]::get(unsigned long _uID) const
{
[if (not aClass.getPropertiesForGetAndSet()->isEmpty())]
	switch(_uID)
	{
		[for (aProperty : Property | aClass.getPropertiesForGetAndSet())]
		case [aProperty.getNearestPackage().generateNamespace(true)/]::[aProperty.getNearestPackage().getPackageName()/]Package::[aProperty.getMemberName().toUpperCase()/]:
			[if (aProperty.type.oclIsUndefined())]
			return eAny(this->[aProperty.getterName()/](), -1, [if(aProperty.upper = 1)]false[else]true[/if]);
			[elseif(not aProperty.type.isComplex())]
			return eAny(this->[aProperty.getterName()/](), [aProperty.type.oclAsType(Classifier).generateStaticClassifierIDAccess()/], [if(aProperty.upper = 1)]false[else]true[/if]);
			[else]
			return [if(aProperty.upper = 1)]eUMLAny[else]eUMLContainerAny[/if](this->[aProperty.getterName()/]()[if(aProperty.isBackReference())].lock()[/if], [aProperty.type.oclAsType(Classifier).generateStaticClassifierIDAccess()/]);
			[/if]
		[/for]
		[for (compositeOwnerClass : Class | aClass.getImplicitCompositeOwners()) before('//Composite owner properties\n')]
		case [aClass.generateNamespace(true)/]::[aClass._package.getPackageName()/]Package::[aClass.name.toUpperCase()/]_ATTRIBUTE_[compositeOwnerClass.name.toUpperCase()/]:
			return eUMLAny(this->get[compositeOwnerClass.name.toUpperFirst()/]().lock(), [compositeOwnerClass.generateStaticClassifierIDAccess()/]);
		[/for]
	}

[/if]
[let classList : OrderedSet(Class) = aClass.superClass->reject(oclIsUndefined() and name.oclIsUndefined())->sortedBy(name)]
[if (classList->size() > 0)]
	std::shared_ptr<Any> result;
	[for (sClass : Class | aClass.superClass->reject(oclIsUndefined() and name.oclIsUndefined()))]
	//Call get() for base class [sClass.name/]
	result = [sClass.generateNamespaceName(true)/]Impl::get(_uID);
	if (result != nullptr)
	{
		return result;
	}
	[/for]
	return result;
[else]
	return nullptr;
[/if]
[/let]
}
[/template]

[template private generateSetImplementation(aClass : Class)]
bool [aClass.name.toUpperFirst().concat('Impl')/]::set(const std::shared_ptr<uml::Property>& _property, const std::shared_ptr<Any>& value)
{
	return this->set(_property->_getID(), value);
}

bool [aClass.name.toUpperFirst().concat('Impl')/]::set( std::string _qualifiedName, const std::shared_ptr<Any>& value)
{
	unsigned long uID = util::Util::polynomialRollingHash(_qualifiedName);
	return this->set(uID, value);
}

bool [aClass.name.toUpperFirst().concat('Impl')/]::set(unsigned long _uID, const std::shared_ptr<Any>& value)
{
[if (not aClass.getPropertiesForGetAndSet()->select(hasSetter())->isEmpty())]
	switch(_uID)
	{
		[for (aProperty : Property | aClass.getPropertiesForGetAndSet()->select(hasSetter()))]
		case [aProperty.getNearestPackage().generateNamespace(true)/]::[aProperty.getNearestPackage().getPackageName()/]Package::[aProperty.getMemberName().toUpperCase()/]:
		{
		[comment aProperty has no type. i.e. is of any type /]
		[if (aProperty.type.oclIsUndefined())]
			[comment anEStructuralFeature is a single-instanced value /]
			[if (aProperty.upper = 1)]
			try
			{
				std::shared_ptr<Any> _[aProperty.name/] = value->get<std::shared_ptr<Any>>();
				[aProperty.setterName()/](_[aProperty.name/]);
				return true;
			}
			catch(...)
			{
				DEBUG_ERROR("Invalid type stored in 'Any' for property '[aProperty.name/]'. Failed to set property!")
				return true;
			}
			[else]
			[comment aProperty is a bag value /]
			try
			{
				std::shared_ptr<Bag<Any>> _[aProperty.name/]List = value->get<std::shared_ptr<Bag<Any>>();
				std::shared_ptr<Bag<Any>> _[aProperty.name.toLowerFirst()/] = [aProperty.getterName()/]();
				
				for(const std::shared_ptr<Any>& valueToAdd: *_[aProperty.name/]List)
				{
					if (valueToAdd)
					{
						if(!(_[aProperty.name.toLowerFirst()/]->includes(valueToAdd)))
						{
							_[aProperty.name.toLowerFirst()/]->add(valueToAdd);
							return true;
						}
						//else, valueToAdd is already present so it won't be added again
					}
					else
					{
						throw "Invalid argument";
					}
				}
			}
			catch(...)
			{
				DEBUG_ERROR("Invalid type stored in 'Any' for property '[aProperty.name/]'. Failed to set property!")
				return true;
			}
			[/if]
		[comment aProperty is typed by an a PrimitiveType or Enumeration /]
		[elseif (not aProperty.type.isComplex())]
			[comment anEStructuralFeature is a single-instanced value /]
			[if (aProperty.upper = 1)]
			try
			{
				[aProperty.type.generateCppRawType(false)/] _[aProperty.name/] = value->get<[aProperty.type.generateCppRawType(false)/]>();
				[aProperty.setterName()/](_[aProperty.name/]);
				return true;
			}
			catch(...)
			{
				DEBUG_ERROR("Invalid type stored in 'Any' for property '[aProperty.name/]'. Failed to set property!")
				return true;
			}
			[else]
			[comment aProperty is a bag value /]
			try
			{
				std::shared_ptr<Bag<[aProperty.type.generateCppRawType(true)/]>> _[aProperty.name/]List = value->get<std::shared_ptr<Bag<[aProperty.type.generateCppRawType(true)/]>>();
				std::shared_ptr<Bag<[aProperty.type.generateCppRawType(true)/]>> _[aProperty.name.toLowerFirst()/] = [aProperty.getterName()/]();
				
				for(const std::shared_ptr<[aProperty.type.generateCppRawType(true)/]>& valueToAdd: *_[aProperty.name/]List)
				{
					if (valueToAdd)
					{
						if(!(_[aProperty.name.toLowerFirst()/]->includes(valueToAdd)))
						{
							_[aProperty.name.toLowerFirst()/]->add(valueToAdd);
							return true;
						}
						//else, valueToAdd is already present so it won't be added again
					}
					else
					{
						throw "Invalid argument";
					}
				}
			}
			catch(...)
			{
				DEBUG_ERROR("Invalid type stored in 'Any' for property '[aProperty.name/]'. Failed to set property!")
				return true;
			}
			[/if]	
		[comment aProperty is typed by a Class or an Interface /]
		[else]
			[comment aProperty is a single-instanced value /]
			[if (aProperty.upper = 1)]
			std::shared_ptr<uml::UMLAny> umlAny = std::dynamic_pointer_cast<uml::UMLAny>(value);
			if(umlAny)
			{
				try
				{
					std::shared_ptr<uml::Element> element = umlAny->getAsElement();
					std::shared_ptr<[aProperty.type.generateCppRawType(true)/]> _[aProperty.name/] = std::dynamic_pointer_cast<[aProperty.type.generateCppRawType(true)/]>(umlAny);
					if(_[aProperty.name/])
					{
						[aProperty.setterName()/](_[aProperty.name/]);
						return true;
					}			
					else
					{
						throw "Invalid argument";
					}		
				}
				catch(...)
				{
					DEBUG_ERROR("Invalid type stored in 'uml::UMLAny' for property '[aProperty.name/]'. Failed to set property!")
					return true;
				}
			}
			else
			{
				DEBUG_ERROR("Invalid instance of 'uml::UMLAny' for property '[aProperty.name/]'. Failed to set property!")
				return true;
			}
			[comment aProperty is a bag value /]
			[else]
			std::shared_ptr<uml::UMLContainerAny> umlContainerAny = std::dynamic_pointer_cast<uml::UMLContainerAny>(value);
			if(umlContainerAny)
			{
				try
				{
					std::shared_ptr<Bag<uml::Element>> elementList = umlContainerAny->getAsElementContainer();
	
					if(elementList)
					{
						std::shared_ptr<[aProperty.type.generateCppRawType(true)/]> _[aProperty.name.toLowerFirst()/] = [aProperty.getterName()/]();
	
						for(const std::shared_ptr<uml::Element>& anElement: *elementList)
						{
							std::shared_ptr<[aProperty.type.generateCppRawType(true)/]> valueToAdd = std::dynamic_pointer_cast<[aProperty.type.generateCppRawType(true)/]>(anElement);
	
							if (valueToAdd)
							{
								if(!(_[aProperty.name.toLowerFirst()/]->includes(valueToAdd)))
								{
									_[aProperty.name.toLowerFirst()/]->add(valueToAdd);
									return true;
								}
								//else, valueToAdd is already present so it won't be added again
							}
							else
							{
								throw "Invalid argument";
							}
						}
					}
				}
				catch(...)
				{
					DEBUG_ERROR("Invalid type stored in 'uml::UMLContainerAny' for property '[aProperty.name/]'. Failed to set property!")
					return true;
				}
			}
			else
			{
				DEBUG_ERROR("Invalid instance of 'uml::UMLContainerAny' for property '[aProperty.name/]'. Failed to set property!")
				return true;
			}
			[/if]
		[/if]
		break;
		}
		[/for]
		[for (compositeOwnerClass : Class | aClass.getImplicitCompositeOwners()) before('//Composite owner properties\n')]
		case [aClass.generateNamespace(true)/]::[aClass._package.getPackageName()/]Package::[aClass.name.toUpperCase()/]_ATTRIBUTE_[compositeOwnerClass.name.toUpperCase()/]:
		{
			std::shared_ptr<uml::UMLAny> umlAny = std::dynamic_pointer_cast<uml::UMLAny>(value);
			if(umlAny)
			{
				try
				{
					std::shared_ptr<uml::Element> element = umlAny->getAsElement();
					std::shared_ptr<[compositeOwnerClass.generateCppRawType(true)/]> _[compositeOwnerClass.name/] = std::dynamic_pointer_cast<[compositeOwnerClass.generateCppRawType(true)/]>(umlAny);
					if(_[compositeOwnerClass.name/])
					{
						this->set[compositeOwnerClass.name.toUpperFirst()/](_[compositeOwnerClass.name/]);
						return true;
						//TODO also set back reference?
					}			
					else
					{
						throw "Invalid argument";
					}		
				}
				catch(...)
				{
					DEBUG_ERROR("Invalid type stored in 'uml::UMLAny' for property '[compositeOwnerClass.name/]'. Failed to set property!")
					return false;
				}
			}
			else
			{
				DEBUG_ERROR("Invalid instance of 'uml::UMLAny' for property '[compositeOwnerClass.name/]'. Failed to set property!")
				return false;
			}
			break;
		}
		[/for]
	}
[/if]
[for (sClass : Class | aClass.superClass->reject(oclIsUndefined() and name.oclIsUndefined()))]
	//Call set() for base class [sClass.name/]
	if([sClass.generateNamespaceName(true)/]Impl::set(_uID, value)) return true;
[/for]
	return false;
}
[/template]

[template private generateAddImplementation(aClass : Class)]
bool [aClass.name.toUpperFirst().concat('Impl')/]::add(const std::shared_ptr<uml::Property>& _property, const std::shared_ptr<Any>& value, int insertAt /*= -1*/)
{
	return this->add(_property->_getID(), value, insertAt);
}

bool [aClass.name.toUpperFirst().concat('Impl')/]::add(std::string _qualifiedName, const std::shared_ptr<Any>& value, int insertAt /*= -1*/)
{
	unsigned long uID = util::Util::polynomialRollingHash(_qualifiedName);
	return this->add(uID, value, insertAt);
}

bool [aClass.name.toUpperFirst().concat('Impl')/]::add(unsigned long _uID, const std::shared_ptr<Any>& value, int insertAt /*= -1*/)
{
[if (not aClass.getPropertiesForGetAndSet()->select(p : Property | (not p.isReadOnly) and p.upper <> 1)->isEmpty())]
	switch(_uID)
	{
		[for (aProperty : Property | aClass.getPropertiesForGetAndSet()->select(p : Property | (not p.isReadOnly) and p.upper <> 1))]
		case [aProperty.getNearestPackage().generateNamespace(true)/]::[aProperty.getNearestPackage().getPackageName()/]Package::[aProperty.getMemberName().toUpperCase()/]:
		{
			[if (aProperty.type.oclIsUndefined())]
			std::shared_ptr<Any> valueToAdd;
			[else]
			[aProperty.type.generateCppRawType(false)/] valueToAdd;
			[/if]
			if(value->isContainer())
			{
				[if (aProperty.type.oclIsUndefined())]
				std::shared_ptr<Bag<Any>> container = value->get<std::shared_ptr<Bag<Any>>>();
				if(container && !(container->empty()))
				{
						// If a non-empty container is passed, the first value of the container will be added to the property
						valueToAdd = container->at(0);
				}
				[elseif (not aProperty.type.isComplex())]
				std::shared_ptr<Bag<[aProperty.type.generateCppRawType(true)/]>> container = value->get<std::shared_ptr<Bag<[aProperty.type.generateCppRawType(true)/]>>>();
				if(container && !(container->empty()))
				{
						// If a non-empty container is passed, the first value of the container will be added to the property
						valueToAdd = [if(not aProperty.type.isComplex())]*([/if]container->at(0)[if(not aProperty.type.isComplex())])[/if];
				}
				[else]
				std::shared_ptr<uml::UMLContainerAny> umlContainerAny = std::dynamic_pointer_cast<uml::UMLContainerAny>(value);
				if(umlContainerAny)
				{
					std::shared_ptr<Bag<uml::Element>> container = umlContainerAny->getAsElementContainer();
					if(container && !(container->empty()))
					{
						// If a non-empty container is passed, the first value of the container will be added to the property
						std::shared_ptr<uml::Element> firstElement = container->at(0);
						valueToAdd = std::dynamic_pointer_cast<[aProperty.type.generateCppRawType(true)/]>(firstElement);
					}
				}
				[/if]
			}
			else
			{
				[if (aProperty.type.oclIsUndefined())]
				valueToAdd = value->get<std::shared_ptr<Any>>();
				[elseif (not aProperty.type.isComplex())]
				valueToAdd = value->get<[aProperty.type.generateCppRawType(false)/]>();
				[else]
				std::shared_ptr<uml::UMLAny> umlAny = std::dynamic_pointer_cast<uml::UMLAny>(value);
				if(umlAny)
				{
					std::shared_ptr<uml::Element> element = umlAny->getAsElement();
					valueToAdd = std::dynamic_pointer_cast<[aProperty.type.generateCppRawType(true)/]>(element);
				}
				[/if]
			}

			[if (aProperty.isUnique)]
			// [aProperty.name/] is unique
			if(!(this->[aProperty.getterName()/]()->includes(valueToAdd)))
			{
				this->[aProperty.getterName()/]()->add(valueToAdd, insertAt);
				return true;
			}
			[else]
			this->[aProperty.getterName()/]()->add(valueToAdd, insertAt);
			return true;
			[/if]
		}
		[/for]
	}

[/if]
[for (sClass : Class | aClass.superClass->reject(oclIsUndefined() and name.oclIsUndefined()))]
	//Call add() for base class [sClass.name/]
	if([sClass.generateNamespaceName(true)/]Impl::add(_uID, value, insertAt)) return true;
[/for]
	return false;
}
[/template]

[template private generateUnSetImplementation(aClass : Class)]
bool [aClass.name.toUpperFirst().concat('Impl')/]::unset(const std::shared_ptr<uml::Property>& _property)
{
	return this->unset(_property->_getID());
}

bool [aClass.name.toUpperFirst().concat('Impl')/]::unset(std::string _qualifiedName)
{
	unsigned long uID = util::Util::polynomialRollingHash(_qualifiedName);
	return this->unset(uID);
}

bool [aClass.name.toUpperFirst().concat('Impl')/]::unset(unsigned long _uID)
{
[if ((not aClass.getPropertiesForGetAndSet()->select(p : Property | (not p.isReadOnly))->isEmpty()))]
	switch(_uID)
	{
		[for (aProperty : Property | aClass.getPropertiesForGetAndSet()->select(p : Property | (not p.isReadOnly)))]
		case [aProperty.getNearestPackage().generateNamespace(true)/]::[aProperty.getNearestPackage().getPackageName()/]Package::[aProperty.getMemberName().toUpperCase()/]:
		{
			[if (aProperty.upper = 1)]
			[if (aProperty.isBackReference())] [comment required for std::weak_ptr, as nullptr cannot be assigned to std::weak_ptr /]
			m_[aProperty.name/].reset();
			[else]
			m_[aProperty.name/] = [aProperty.type.generateDefaultValue()/];
			[/if]
			return true;
			[else]
			this->[aProperty.getterName()/]()->clear();
			return true;
			[/if]
		}
		[/for]
		[for (compositeOwnerClass : Class | aClass.getImplicitCompositeOwners()) before('//Composite owner properties\n')]
		case [aClass.generateNamespace(true)/]::[aClass._package.getPackageName()/]Package::[aClass.name.toUpperCase()/]_ATTRIBUTE_[compositeOwnerClass.name.toUpperCase()/]:
		{
			m_[compositeOwnerClass.name/].reset();
			//TODO also unset back reference?
			return true;
		}
		[/for]
	}

[/if]
	[for (sClass : Class | aClass.superClass->reject(oclIsUndefined() and name.oclIsUndefined()))]
	//Call unset() for base class [sClass.name/]
	if([sClass.generateNamespaceName(true)/]Impl::unset(_uID)) return true;
	[/for]
	return false;
}
[/template]

[template public generateRemoveImplementation(aClass : Class)]
bool [aClass.name.toUpperFirst().concat('Impl')/]::remove(const std::shared_ptr<uml::Property>& _property, const std::shared_ptr<Any>& value, int removeAt /*= -1*/, bool isRemoveDuplicates /*= false*/)
{
	return this->remove(_property->_getID(), value, removeAt, isRemoveDuplicates);
}

bool [aClass.name.toUpperFirst().concat('Impl')/]::remove(std::string _qualifiedName, const std::shared_ptr<Any>& value, int removeAt /*= -1*/, bool isRemoveDuplicates /*= false*/)
{
	unsigned long uID = util::Util::polynomialRollingHash(_qualifiedName);
	return this->remove(uID, value, removeAt, isRemoveDuplicates);
}

bool [aClass.name.toUpperFirst().concat('Impl')/]::remove(unsigned long _uID, const std::shared_ptr<Any>& value, int removeAt /*= -1*/, bool isRemoveDuplicates /*= false*/)
{
[if (not aClass.getPropertiesForGetAndSet()->select(p : Property | (not p.isReadOnly))->isEmpty())]
	switch(_uID)
	{
		[for (aProperty : Property | aClass.getPropertiesForGetAndSet()->select(p : Property | (not p.isReadOnly)))]
		case [aProperty.getNearestPackage().generateNamespace(true)/]::[aProperty.getNearestPackage().getPackageName()/]Package::[aProperty.getMemberName().toUpperCase()/]:
		{
			[if (aProperty.type.oclIsUndefined())]
			std::shared_ptr<Any> valueToRemove;
			[else]
			[aProperty.type.generateCppRawType(false)/] valueToRemove = [aProperty.type.generateDefaultValue()/];
			[/if]
			if(value->isContainer())
			{
				[if (aProperty.type.oclIsUndefined())]
				std::shared_ptr<Bag<Any>> container = value->get<std::shared_ptr<Bag<Any>>>();
				if(container && !(container->empty()))
				{
					// If a non-empty container is passed, the first value of the container will be removed from the property
					valueToRemove = container->at(0);
				}
				[elseif (not aProperty.type.isComplex())]
				std::shared_ptr<Bag<[aProperty.type.generateCppRawType(true)/]>> container = value->get<std::shared_ptr<Bag<[aProperty.type.generateCppRawType(true)/]>>>();
				if(container && !(container->empty()))
				{
						// If a non-empty container is passed, the first value of the container will be removed from the property
						valueToRemove = [if(not aProperty.type.isComplex())]*([/if]container->at(0)[if(not aProperty.type.isComplex())])[/if];
				}
				[else]
				std::shared_ptr<uml::UMLContainerAny> umlContainerAny = std::dynamic_pointer_cast<uml::UMLContainerAny>(value);
				if(umlContainerAny)
				{
					std::shared_ptr<Bag<uml::Element>> container = umlContainerAny->getAsElementContainer();
					if(container && !(container->empty()))
					{
						// If a non-empty container is passed, the first value of the container will be removed from the property
						std::shared_ptr<uml::Element> firstElement = container->at(0);
						valueToRemove = std::dynamic_pointer_cast<[aProperty.type.generateCppRawType(true)/]>(firstElement);
					}
				}
				[/if]
			}
			else
			{
				[if (aProperty.type.oclIsUndefined())]
				valueToRemove = value->get<std::shared_ptr<Any>>();
				[elseif (not aProperty.type.isComplex())]
				valueToRemove = value->get<[aProperty.type.generateCppRawType(false)/]>();
				[else]
				std::shared_ptr<uml::UMLAny> umlAny = std::dynamic_pointer_cast<uml::UMLAny>(value);
				if(umlAny)
				{
					std::shared_ptr<uml::Element> element = umlAny->getAsElement();
					valueToRemove = std::dynamic_pointer_cast<[aProperty.type.generateCppRawType(true)/]>(element);
				}
				[/if]
			}

			
			if(removeAt >= 1 && !isRemoveDuplicates) // As per fUML-specification, if isRemoveDuplicates is true, removeAt is ignored
			{
				// If removeAt != -1, the value to remove is not taken into account anymore.
				// Instead, the value at index = removeAt is removed
				// NOTE: removeAt is 1-based rather than 0-based
				[if (aProperty.upper = 1)]
				[comment if aProperty is a simple property, removeAt may only be exactly 1 /]
				if(removeAt == 1)
				{
					[if (aProperty.isBackReference())] [comment required for std::weak_ptr, as nullptr cannot be assigned to std::weak_ptr /]
					m_[aProperty.name/].reset();
					[else]
					m_[aProperty.name/] = [aProperty.type.generateDefaultValue()/];
					[/if]
					return true;
				}
				[else]
				if((long)this->[aProperty.getterName()/]()->size() >= (long)removeAt)
				{
					this->[aProperty.getterName()/]()->erase(this->[aProperty.getterName()/]()->begin() + (removeAt - 1));
					return true;
				}
				[/if]
			}
			else
			{
				[if (aProperty.upper = 1)]
				[comment if aProperty is a simple property, valueToRemove must equal the current value of aProperty /]
				if(m_[aProperty.name/][if (aProperty.isBackReference())].lock()[/if] == valueToRemove)
				{
					[if (aProperty.isBackReference())] [comment required for std::weak_ptr, as nullptr cannot be assigned to std::weak_ptr /]
					m_[aProperty.name/].reset();
					[else]
					m_[aProperty.name/] = [aProperty.type.generateDefaultValue()/];
					[/if]
					return true;
				}
				[else]
				if(isRemoveDuplicates)
				{
					int index = this->[aProperty.getterName()/]()->index_of(valueToRemove);
					while(index != -1)
					{
						this->[aProperty.getterName()/]()->erase(this->[aProperty.getterName()/]()->begin() + index);
						index = this->[aProperty.getterName()/]()->index_of(valueToRemove);
					}
					return true;
				}
				else
				{
					this->[aProperty.getterName()/]()->erase(valueToRemove);
					return true;
				}
				[/if]
			}
		}
		[/for]
	}

[/if]
[for (sClass : Class | aClass.superClass->reject(oclIsUndefined() and name.oclIsUndefined()))]
	//Call set() for base class [sClass.name/]
	if([sClass.generateNamespaceName(true)/]Impl::remove(_uID, value, removeAt, isRemoveDuplicates)) return true;
[/for]
	return false;
}
[/template]

[**
 * generate invoke function implementation
*/]
[template public generateInvokeImpl(aClass : Class)]
//Operation Invocation
[aClass.generateOperationInvokeImplementation()/]

//OpaqueBehavior Invocation
[aClass.generateOpaqueBehaviorInvokeImplementation()/]
[/template]

[template private generateOperationInvokeImplementation(aClass : Class)]
std::shared_ptr<Any> [aClass.name.toUpperFirst().concat('Impl')/]::invoke(const std::shared_ptr<uml::Operation>& _operation, const std::shared_ptr<Bag<Any>>& inputArguments, const std::shared_ptr<Bag<Any>>& outputArguments)
{
	return this->invokeOperation(_operation->_getID(), inputArguments, outputArguments);
}

std::shared_ptr<Any> [aClass.name.toUpperFirst().concat('Impl')/]::invokeOperation(std::string _qualifiedName, const std::shared_ptr<Bag<Any>>& inputArguments, const std::shared_ptr<Bag<Any>>& outputArguments)
{
	unsigned long uID = util::Util::polynomialRollingHash(_qualifiedName);
	return this->invokeOperation(uID, inputArguments, outputArguments);
}

std::shared_ptr<Any> [aClass.name.toUpperFirst().concat('Impl')/]::invokeOperation(unsigned long _uID, const std::shared_ptr<Bag<Any>>& inputArguments, const std::shared_ptr<Bag<Any>>& outputArguments)
{
	std::shared_ptr<Any> result = nullptr;
[if (not aClass.getOperationsForInvoke()->isEmpty())]

	switch(_uID)
	{
		[for (anOperation : Operation | aClass.getOperationsForInvoke())]
		case [anOperation.getNearestPackage().generateNamespace(true)/]::[anOperation.getNearestPackage().getPackageName()/]Package::[anOperation.getMemberName().toUpperCase()/]:
		{
			[comment Retrieve all parameter values for parameters with in or inout direction /]
			[let inputParameterList : OrderedSet(Parameter) = anOperation.ownedParameter->select((direction = ParameterDirectionKind::_in) or (direction = ParameterDirectionKind::inout))]
			[for (anInputParameter : Parameter | inputParameterList) before('\t\t//Retrieve input parameters\n') after('\n')]
			//Retrieve [anInputParameter.direction/] parameter '[anInputParameter.name/]'
			std::shared_ptr<Any> any[anInputParameter.name.toUpperFirst()/] =  inputArguments->at([inputParameterList->indexOf(anInputParameter) - 1/]);
			[anInputParameter.generateCppType(false)/] [anInputParameter.name/];
			[comment anInputParameter is typed by a PrimitiveType or Enumeration or is of Any type /]
				[if (anInputParameter.type.oclIsUndefined() or (not anInputParameter.type.isComplex()))]
			try
			{
				[anInputParameter.name/] = any[anInputParameter.name.toUpperFirst()/]->get<[anInputParameter.generateCppType(false)/]>();
			}
			catch(...)
			{
				DEBUG_ERROR("Invalid type stored in 'Any' for parameter '[anInputParameter.name/]'. Failed to invoke operation '[anInputParameter.operation.name/]'!")
				return nullptr;
			}
				[comment anInputParameter is typed by a Class or Interface /]
				[else]
					[comment anInputParameter is a single-instanced value /]
					[if (anInputParameter.upper = 1)]
			{
				std::shared_ptr<uml::UMLAny> umlAny = std::dynamic_pointer_cast<uml::UMLAny>(any[anInputParameter.name.toUpperFirst()/]);
				if(umlAny)
				{
					try
					{
						std::shared_ptr<uml::Element> _temp = umlAny->getAsElement();
						[anInputParameter.name/] = std::dynamic_pointer_cast<[anInputParameter.type.generateCppRawType(true)/]>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'uml::UMLAny' for parameter '[anInputParameter.name/]'. Failed to invoke operation '[anInputParameter.operation.name/]'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'uml::UMLAny' for parameter '[anInputParameter.name/]'. Failed to invoke operation '[anInputParameter.operation.name/]'!")
					return nullptr;
				}
			}
					[comment anInputParameter is a bag value /]
					[else]
			{
				std::shared_ptr<uml::UMLContainerAny> umlContainerAny = std::dynamic_pointer_cast<uml::UMLContainerAny>(any[anInputParameter.name.toUpperFirst()/]);
				if(umlContainerAny)
				{
					try
					{
						std::shared_ptr<Bag<uml::Element>> elementList = umlContainerAny->getAsElementContainer();
					
						if(elementList)
						{
							[anInputParameter.name/] = std::make_shared<Bag<[anInputParameter.type.generateCppRawType(true)/]>>();
							for(const std::shared_ptr<uml::Element>& anElement: *elementList)
							{
								std::shared_ptr<[anInputParameter.type.generateCppRawType(true)/]> _temp = std::dynamic_pointer_cast<[anInputParameter.type.generateCppRawType(true)/]>(anElement);
								[anInputParameter.name/]->add(_temp);
							}
						}
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'uml::UMLContainerAny' for parameter '[anInputParameter.name/]'. Failed to invoke operation '[anInputParameter.operation.name/]'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'uml::UMLContainerAny' for parameter '[anInputParameter.name/]'. Failed to invoke operation '[anInputParameter.operation.name/]'!")
					return nullptr;
				}
			}
					[/if]
				[/if]
			[/for]
			[/let]
			[comment Create all parameter values for parameters with out direction /]
			[let outputParameterList : OrderedSet(Parameter) = anOperation.ownedParameter->select(direction = ParameterDirectionKind::out)]
			[for (anOutputParameter : Parameter | outputParameterList) before('\t\t//Create output parameters\n') after('\n')]
			//Create [anOutputParameter.direction/] parameter '[anOutputParameter.name/]'
			[anOutputParameter.generateCppType(false)/] [anOutputParameter.name/];
			[/for]
			[/let]
			[comment Create return parameter (if there is any) and invoke the operation /]
			//Invoke method
			[let returnParameterList : OrderedSet(Parameter) = anOperation.ownedParameter->select(p :Parameter | (p.direction = ParameterDirectionKind::return))]
				[comment anOperation has a return parameter /]
				[if(not returnParameterList->isEmpty() and not returnParameterList->first().oclIsInvalid())]
				[let returnParameter : Parameter = returnParameterList->first()]
			[returnParameter.generateCppType(false)/] [returnParameter.name/] = this->[anOperation.name/]([for (inputParameter : Parameter | anOperation.ownedParameter->select(not (direction = ParameterDirectionKind::return))) separator (', ')][inputParameter.name/][/for]);
					[comment returnParameter has no type, i.e. is of any type, ergo can be passed right away /]
					[if (returnParameter.type.oclIsUndefined())]
			std::shared_ptr<Any> returnArgument = eAny([returnParameter.name/], -1, [if(returnParameter.upper = 1)]false[else]true[/if]);
					[comment returnParameter is typed by a PrimitiveType or Enumeration /]
					[elseif (not returnParameter.type.isComplex())]
			std::shared_ptr<Any> returnArgument = eAny([returnParameter.name/], [returnParameter.type.oclAsType(Classifier).generateStaticClassifierIDAccess()/], [if(returnParameter.upper = 1)]false[else]true[/if]);
					[comment returnParameter is typed by a Class or Interface /]
					[else]
			std::shared_ptr<Any> returnArgument = [if(returnParameter.upper = 1)]eUMLAny[else]eUMLContainerAny[/if]([returnParameter.name/], [returnParameter.type.oclAsType(Classifier).generateStaticClassifierIDAccess()/]);
					[/if]
				[/let]
				[comment anOperation has no return parameter /]
				[else]
			this->[anOperation.name/]([for (inputParameter : Parameter | anOperation.ownedParameter->select(not (direction = ParameterDirectionKind::return))) separator (', ')][inputParameter.name/][/for]);
			std::shared_ptr<Any> returnArgument = eAny(nullptr, -1, false);
				[/if]
			[/let]

			[comment Add all parameter values for parameters with inout or out direction the outputArguments /]
			[let outputParameterList : OrderedSet(Parameter) = anOperation.ownedParameter->select((direction = ParameterDirectionKind::inout) or (direction = ParameterDirectionKind::out))]
			[for (anOutputParameter : Parameter | outputParameterList) before('\t\t//Store output parameters\n') after('\n')]
				[comment For inout parameters, we can reuse the previously retrieved Any-object IF the stored value is of non-primitive type (i.e. stored as a shared pointer /]
			//Store [anOutputParameter.direction/] parameter '[anOutputParameter.name/]'
				[if (anOutputParameter.direction = ParameterDirectionKind::inout)]
					[comment Only IF the inout parameter is primitive-typed, the new value (i.e. after operation invocation) has to be re-stored /]
					[if (not anOutputParameter.type.isComplex())]
			any[anOutputParameter.name.toUpperFirst()/] = eAny([anOutputParameter.name/], [anOutputParameter.type.oclAsType(Classifier).generateStaticClassifierIDAccess()/], [if(anOutputParameter.upper = 1)]false[else]true[/if]); 
					[/if]
				[comment For out parameters, create a new Any-object to store the value /]
				[else]
					[comment anOutputParameter has no type, i.e. is of any type, ergo can be passed right away /]
					[if (anOutputParameter.type.oclIsUndefined())]
			std::shared_ptr<Any> any[anOutputParameter.name.toUpperFirst()/] = eAny([anOutputParameter.name/], -1, [if(anOutputParameter.upper = 1)]false[else]true[/if]);
					[comment anOutputParameter is typed by a PrimitiveType or Enumeration /]
					[elseif (not anOutputParameter.type.isComplex())]
			std::shared_ptr<Any> any[anOutputParameter.name.toUpperFirst()/] = eAny([anOutputParameter.name/], [anOutputParameter.type.oclAsType(Classifier).generateStaticClassifierIDAccess()/], [if(anOutputParameter.upper = 1)]false[else]true[/if]);
					[comment anOutputParameter is typed by a Class or Interface /]
					[else]
			std::shared_ptr<Any> any[anOutputParameter.name.toUpperFirst()/] = [if(anOutputParameter.upper = 1)]eUMLAny[else]eUMLContainerAny[/if]([anOutputParameter.name/], [anOutputParameter.type.oclAsType(Classifier).generateStaticClassifierIDAccess()/]);
					[/if]
				[/if]
			outputArguments->add(any[anOutputParameter.name.toUpperFirst()/]);
			[/for]
			[/let]
			return returnArgument;
		}
		[/for]
	}

[/if]	
[for (sClass : Class | aClass.superClass->reject(oclIsUndefined() and name.oclIsUndefined())->sortedBy(name))]
	//Call invoke() for base class [sClass.name/]
	result = [sClass.generateNamespaceName(true)/]Impl::invokeOperation(_uID, inputArguments, outputArguments);
	if (result != nullptr)
	{
		return result;
	}
[/for]
	return result;
}
[/template]

[template private generateOpaqueBehaviorInvokeImplementation(aClass : Class)]
std::shared_ptr<Any> [aClass.name.toUpperFirst().concat('Impl')/]::invoke(const std::shared_ptr<uml::OpaqueBehavior>& _opaqueBehavior, const std::shared_ptr<Bag<Any>>& inputArguments, const std::shared_ptr<Bag<Any>>& outputArguments)
{
	return this->invokeOpaqueBehavior(_opaqueBehavior->_getID(), inputArguments, outputArguments);
}

std::shared_ptr<Any> [aClass.name.toUpperFirst().concat('Impl')/]::invokeOpaqueBehavior(std::string _qualifiedName, const std::shared_ptr<Bag<Any>>& inputArguments, const std::shared_ptr<Bag<Any>>& outputArguments)
{
	unsigned long uID = util::Util::polynomialRollingHash(_qualifiedName);
	return this->invokeOpaqueBehavior(uID, inputArguments, outputArguments);
}

std::shared_ptr<Any> [aClass.name.toUpperFirst().concat('Impl')/]::invokeOpaqueBehavior(unsigned long _uID, const std::shared_ptr<Bag<Any>>& inputArguments, const std::shared_ptr<Bag<Any>>& outputArguments)
{
[if (not aClass.collectOpaqueBehaviorsContexedByClass()->isEmpty())]
	switch(_uID)
	{
	[for (anOpaqueBehavior : OpaqueBehavior | aClass.collectOpaqueBehaviorsContexedByClass())]
		case [anOpaqueBehavior.getNearestPackage().generateNamespace(true)/]::[anOpaqueBehavior.getNearestPackage().getPackageName()/]Package::[anOpaqueBehavior.getMemberName().toUpperCase()/]:
		{
			[comment Retrieve all parameter values for parameters with in or inout direction /]
			[let inputParameterList : OrderedSet(Parameter) = anOpaqueBehavior.ownedParameter->select((direction = ParameterDirectionKind::_in) or (direction = ParameterDirectionKind::inout))]
			[for (anInputParameter : Parameter | inputParameterList) before('\t\t//Retrieve input parameters\n') after('\n')]
			//Retrieve [anInputParameter.direction/] parameter '[anInputParameter.name/]'
			std::shared_ptr<Any> any[anInputParameter.name.toUpperFirst()/] =  inputArguments->at([inputParameterList->indexOf(anInputParameter) - 1/]);
			[anInputParameter.generateCppType(false)/] [anInputParameter.name/];
			[comment anInputParameter has no type. i.e. is of any type, ergo no transformation required /]
			[comment anInputParameter is typed by a PrimitiveType or Enumeration or is of Any type/]
				[if (anInputParameter.type.oclIsUndefined() or (not anInputParameter.type.isComplex()))]
			try
			{
				[anInputParameter.name/] = any[anInputParameter.name.toUpperFirst()/]->get<[anInputParameter.generateCppType(false)/]>();
			}
			catch(...)
			{
				DEBUG_ERROR("Invalid type stored in 'Any' for parameter '[anInputParameter.name/]'. Failed to invoke operation '[anInputParameter.operation.name/]'!")
				return nullptr;
			}
				[comment anInputParameter is typed by a Class or Interface /]
				[else]
					[comment anInputParameter is a single-instanced value /]
					[if (anInputParameter.upper = 1)]
			{
				std::shared_ptr<uml::UMLAny> umlAny = std::dynamic_pointer_cast<uml::UMLAny>(any[anInputParameter.name.toUpperFirst()/]);
				if(umlAny)
				{
					try
					{
						std::shared_ptr<uml::Element> _temp = umlAny->getAsElement();
						[anInputParameter.name/] = std::dynamic_pointer_cast<[anInputParameter.type.generateCppRawType(true)/]>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'uml::UMLAny' for parameter '[anInputParameter.name/]'. Failed to invoke operation '[anInputParameter.operation.name/]'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'uml::UMLAny' for parameter '[anInputParameter.name/]'. Failed to invoke operation '[anInputParameter.operation.name/]'!")
					return nullptr;
				}
			}
					[comment anInputParameter is a bag value /]
					[else]
			{
				std::shared_ptr<uml::UMLContainerAny> umlContainerAny = std::dynamic_pointer_cast<uml::UMLContainerAny>(any[anInputParameter.name.toUpperFirst()/]);
				if(umlContainerAny)
				{
					try
					{
						std::shared_ptr<Bag<uml::Element>> elementList = umlContainerAny->getAsElementContainer();
					
						if(elementList)
						{
							[anInputParameter.name/] = std::make_shared<Bag<[anInputParameter.type.generateCppRawType(true)/]>>();
							for(const std::shared_ptr<uml::Element>& anElement: *elementList)
							{
								std::shared_ptr<[anInputParameter.type.generateCppRawType(true)/]> _temp = std::dynamic_pointer_cast<[anInputParameter.type.generateCppRawType(true)/]>(anElement);
								[anInputParameter.name/]->add(_temp);
							}
						}
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'uml::UMLContainerAny' for parameter '[anInputParameter.name/]'. Failed to invoke operation '[anInputParameter.operation.name/]'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'uml::UMLContainerAny' for parameter '[anInputParameter.name/]'. Failed to invoke operation '[anInputParameter.operation.name/]'!")
					return nullptr;
				}
			}
					[/if]
				[/if]
			[/for]
			[/let]
			[comment Create all parameter values for parameters with out direction /]
			[let outputParameterList : OrderedSet(Parameter) = anOpaqueBehavior.ownedParameter->select(direction = ParameterDirectionKind::out)]
			[for (anOutputParameter : Parameter | outputParameterList) before('\t\t//Create output parameters\n') after('\n')]
			//Create [anOutputParameter.direction/] parameter '[anOutputParameter.name/]'
			[anOutputParameter.generateCppType(false)/] [anOutputParameter.name/];
			[/for]
			[/let]
			[comment Create return parameter (if there is any) and invoke the operation /]
			//Invoke method
			[let returnParameterList : OrderedSet(Parameter) = anOpaqueBehavior.ownedParameter->select(p :Parameter | (p.direction = ParameterDirectionKind::return))]
				[comment anOpaqueBehavior has a return parameter /]
				[if(not returnParameterList->isEmpty() and not returnParameterList->first().oclIsInvalid())]
				[let returnParameter : Parameter = returnParameterList->first()]
			[returnParameter.generateCppType(false)/] [returnParameter.name/] = this->[anOpaqueBehavior.name/]([for (inputParameter : Parameter | anOpaqueBehavior.ownedParameter->select(not (direction = ParameterDirectionKind::return))) separator (', ')][inputParameter.name/][/for]);
					[comment returnParameter has no type, i.e. is of any type, ergo can be passed right away /]
					[if (returnParameter.type.oclIsUndefined())]
			std::shared_ptr<Any> returnArgument = eAny([returnParameter.name/], -1, [if(returnParameter.upper = 1)]false[else]true[/if]);
					[comment returnParameter is typed by a PrimitiveType or Enumeration /]
					[elseif (not returnParameter.type.isComplex())]
			std::shared_ptr<Any> returnArgument = eAny([returnParameter.name/], [returnParameter.type.oclAsType(Classifier).generateStaticClassifierIDAccess()/], [if(returnParameter.upper = 1)]false[else]true[/if]);
					[comment returnParameter is typed by a Class or Interface /]
					[else]
			std::shared_ptr<Any> returnArgument = [if(returnParameter.upper = 1)]eUMLAny[else]eUMLContainerAny[/if]([returnParameter.name/], [returnParameter.type.oclAsType(Classifier).generateStaticClassifierIDAccess()/]);
					[/if]
				[/let]
				[comment anOpaqueBehavior has no return parameter /]
				[else]
			this->[anOpaqueBehavior.name/]([for (inputParameter : Parameter | anOpaqueBehavior.ownedParameter->select(not (direction = ParameterDirectionKind::return))) separator (', ')][inputParameter.name/][/for]);
			std::shared_ptr<Any> returnArgument = eAny(nullptr, -1, false);
				[/if]
			[/let]
	
			[comment Add all parameter values for parameters with inout or out direction the outputArguments /]
			[let outputParameterList : OrderedSet(Parameter) = anOpaqueBehavior.ownedParameter->select((direction = ParameterDirectionKind::inout) or (direction = ParameterDirectionKind::out))]
			[for (anOutputParameter : Parameter | outputParameterList) before('\t\t//Store output parameters\n') after('\n')]
				[comment For inout parameters, we can reuse the previously retrieved Any-object IF the stored value is of non-primitive type (i.e. stored as a shared pointer /]
			//Store [anOutputParameter.direction/] parameter '[anOutputParameter.name/]'
				[if (anOutputParameter.direction = ParameterDirectionKind::inout)]
					[comment Only IF the inout parameter is primitive-typed, the new value (i.e. after operation invocation) has to be re-stored /]
					[if (not anOutputParameter.type.isComplex())]
			any[anOutputParameter.name.toUpperFirst()/] = eAny([anOutputParameter.name/], [anOutputParameter.type.oclAsType(Classifier).generateStaticClassifierIDAccess()/], [if(anOutputParameter.upper = 1)]false[else]true[/if]); 
					[/if]
				[comment For out parameters, create a new Any-object to store the value /]
				[else]
					[comment anOutputParameter has no type, i.e. is of any type, ergo can be passed right away /]
					[if (anOutputParameter.type.oclIsUndefined())]
			std::shared_ptr<Any> any[anOutputParameter.name.toUpperFirst()/] = eAny([anOutputParameter.name/], -1, [if(anOutputParameter.upper = 1)]false[else]true[/if]);
					[comment anOutputParameter is typed by a PrimitiveType or Enumeration /]
					[elseif (not anOutputParameter.type.isComplex())]
			std::shared_ptr<Any> any[anOutputParameter.name.toUpperFirst()/] = eAny([anOutputParameter.name/], [anOutputParameter.type.oclAsType(Classifier).generateStaticClassifierIDAccess()/], [if(anOutputParameter.upper = 1)]false[else]true[/if]);
					[comment anOutputParameter is typed by a Class or Interface /]
					[else]
			std::shared_ptr<Any> any[anOutputParameter.name.toUpperFirst()/] = [if(anOutputParameter.upper = 1)]eUMLAny[else]eUMLContainerAny[/if]([anOutputParameter.name/], [anOutputParameter.type.oclAsType(Classifier).generateStaticClassifierIDAccess()/]);
					[/if]
				[/if]
			outputArguments->add(any[anOutputParameter.name.toUpperFirst()/]);
			[/for]
			[/let]
			return returnArgument;
		}
	[/for]
	}
[/if]	
	[let classList : OrderedSet(Class) = aClass.superClass->reject(oclIsUndefined() and name.oclIsUndefined())->sortedBy(name)]
	[if (classList->size() > 0)]
	std::shared_ptr<Any> result = nullptr;
	[for (sClass : Class | aClass.superClass->reject(oclIsUndefined() and name.oclIsUndefined()))]
	//Call invoke() for base class [sClass.name/]
	result = [sClass.generateNamespaceName(true)/]Impl::invokeOpaqueBehavior(_uID, inputArguments, outputArguments);
	if (result != nullptr)
	{
		return result;
	}
	[/for]
	return result;
	[else]
	return nullptr;
	[/if]
	[/let]
}
[/template]