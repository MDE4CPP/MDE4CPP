[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */]
[module generateExecutionBuildFile('http://www.eclipse.org/uml2/5.0.0/UML')]

[import fUML4CPP::generator::main::generateOpaqueBehaviorExecution /]
[import fUML4CPP::generator::main::generateOperationExecution /]
[import fUML4CPP::generator::main::parameterHelper /]
[import fUML4CPP::generator::main::fUMLKeywords /]
[import UML4CPP::generator::main::helpers::generalHelper /]
[import UML4CPP::generator::main::helpers::nameHelper /]
[import UML4CPP::generator::main::helpers::keywords /]
[import UML4CPP::generator::main::profiles::profileHelper /]
[import UML4CPP::generator::main::profiles::uml4CPPProfileHelper /]
[import UML4CPP::generator::main::helpers::isGeneratableHelper /]
[import UML4CPP::generator::main::profiles::strategyHelper /]


[template public generateExecutionBuildFiles(aPackage : Package, packageOnly : Boolean)]
[generateCMakeLists(aPackage, packageOnly)/]
[generateGradleFiles(aPackage)/]
[/template]

[template private generateCMakeLists(aPackage : Package, packageOnly : Boolean) { packageName : String = getPackageName(); execPackageName : String = getPackageName().concat('Exec'); }]
[comment ------------------------------------------------------------------- /]
[comment Generate CMakeLists.txt for model libary                            /]
[comment ------------------------------------------------------------------- /]
[file (aPackage.generateNamespacePath(false).concat('Exec/').concat('CMakeLists.txt'), false, 'UTF-8')]
# DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN
# @generator: fuml4cpp::generator::main::generateExecutionBuildFile

# C++ project of model [packageName/].ecore, generated by fUML4CPP

CMAKE_MINIMUM_REQUIRED(VERSION 3.9)

PROJECT([execPackageName/])

IF(NOT CMAKE_BUILD_TYPE) 
    SET(CMAKE_BUILD_TYPE Debug)
ENDIF(NOT CMAKE_BUILD_TYPE)
SET(CMAKE_DEBUG_POSTFIX d)

SET(CMAKE_CXX_STANDARD 17)

[comment IF("${CMAKE_CXX_COMPILER_ID}" STREQUAL "AppleClang") -> not necessary after removing openmp/]
SET(CMAKE_CXX_FLAGS "-Wall -Wno-overloaded-virtual -Wdeprecated-declarations -fmax-errors=5")
IF(APPLE)
  string(APPEND CMAKE_CXX_FLAGS " -Qunused-arguments")
ENDIF(APPLE)
SET(CMAKE_CXX_FLAGS_DEBUG " -Og -ggdb")
SET(CMAKE_CXX_FLAGS_RELEASE " -O3 -DNDEBUG")

string(REPLACE "\\" "/" MDE4CPP_HOME $ENV{MDE4CPP_HOME})

SET(SOURCE_FILES
	#Model Execution Plugin
	[aPackage.name.concat('ExecPlugin.cpp')/]
	['impl/'.concat(aPackage.name).concat('ExecPluginImpl.cpp')/]
	[if (not packageOnly)]
	# Model Execution Locus
	impl/[aPackage.name/]LocusImpl.cpp
	[/if]
	[aPackage.generatePackageSourceFilesToCompile(packageOnly, true)/]
)

INCLUDE_DIRECTORIES(
    ../
	${MDE4CPP_HOME}/application/include
)

# Apple specific stuff
IF(APPLE)
  SET(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -undefined dynamic_lookup")
  SET(CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS} -undefined dynamic_lookup")
ENDIF(APPLE)

IF(UNIX AND NOT APPLE)
    # for Linux, BSD, Solaris, Minix
	[generateCMakeFindLibraryCommands('.so', 'bin')/]
ELSEIF(APPLE)
	[generateCMakeFindLibraryCommands('.dylib', 'bin')/]
ELSE()
	[generateCMakeFindLibraryCommands('', 'lib')/]
ENDIF()


ADD_LIBRARY(${PROJECT_NAME} SHARED ${SOURCE_FILES})
SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES PREFIX "")

IF (CMAKE_BUILD_TYPE STREQUAL "Debug")
	[generateLibraryLinking(true)/]
ELSE()
	[generateLibraryLinking(false)/]
ENDIF()

#-----------------------------------------------------
# DELIVERING binaries and header to ${MDE4CPP_HOME}
#-----------------------------------------------------

INSTALL(TARGETS ${PROJECT_NAME}
	RUNTIME DESTINATION ${MDE4CPP_HOME}/application/bin
	LIBRARY DESTINATION ${MDE4CPP_HOME}/application/bin
    ARCHIVE DESTINATION ${MDE4CPP_HOME}/application/lib
)

INSTALL(DIRECTORY . DESTINATION ${MDE4CPP_HOME}/application/include/${PROJECT_NAME}
	FILES_MATCHING PATTERN "*.hpp"
	PATTERN ".cmake" EXCLUDE
)
[/file]
[/template]

[template private generateGradleFiles(aPackage : Package) { packageName : String = getPackageName(); execPackageName : String = getPackageName().concat('Exec'); }]
[comment ------------------------------------------------------------------- /]
[comment gradle file for build command                                       /]
[comment ------------------------------------------------------------------- /]
[file ('../build.gradle', false, 'UTF-8')]
// DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN
// @generator: fuml4cpp::generator::main::generateExecutionBuildFile

description 'Build tasks for project: [packageName/]'

task build[packageName.toUpperFirst()/]() {
	group '[packageName/]'
	description 'build [packageName/]'

	dependsOn project.tasks.getByPath('model:generate[packageName.toUpperFirst()/]')
	dependsOn project.tasks.getByPath('src_gen:compile[packageName.toUpperFirst()/]')
[if(aPackage.hasMainBehavior())]
	dependsOn project.tasks.getByPath('application:compileApplicationFor[packageName.toUpperFirst()/]')
[/if]
[for (packName : String | aPackage.metaModelLibrariesNames()) ? (not(packName = aPackage.getPackageName()))]
	dependsOn getRootProject().getTasksByName('build[packName.toUpperFirst()/]', true)
[/for]
}

tasks.getByPath('src_gen:compile[packageName.toUpperFirst()/]').mustRunAfter tasks.getByPath('model:generate[packageName.toUpperFirst()/]')
[/file]

[comment ------------------------------------------------------------------- /]
[comment gradle file for generate command                                    /]
[comment ------------------------------------------------------------------- /]
[file ('../model/build.gradle', false, 'UTF-8')]
// DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN
// @generator: fuml4cpp::generator::main::generateExecutionBuildFile
import tui.sse.mde4cpp.MDE4CPPGenerate;

description 'Generate tasks for project: [packageName/]'

task generate[packageName.toUpperFirst()/](type: tui.sse.mde4cpp.MDE4CPPGenerate) {
	group '[packageName/]'
	description 'generate C++ code of [packageName/].uml model'

	modelFilePath = file('.' + File.separator + '[packageName/].uml')
	structureOnly = false

	relatedModels = ['['/][aPackage.generateRelatedModelNameList()/][']'/]

	dependsOn rootProject.tasks.getByPath(':generator:fUML4CPP:buildGenerator_fUML4CPP')
}
[/file]

[comment ------------------------------------------------------------------- /]
[comment gradle file for compile command of model                            /]
[comment ------------------------------------------------------------------- /]
[file ('build.gradle', false, 'UTF-8')]
// DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN
// @generator: fuml4cpp::generator::main::generateExecutionBuildFile
import tui.sse.mde4cpp.MDE4CPPCompile;
import org.gradle.internal.os.OperatingSystem;

description 'Compile tasks for project: [packageName/]'

task compile[packageName.toUpperFirst()/](type: tui.sse.mde4cpp.MDE4CPPCompile) {
	group '[packageName/]'
	description 'compile [packageName/]'

	projectFolder = file('.' + File.separator + '[packageName/]')

	inputs.files(fileTree('.') {
        exclude '[packageName/]/.cmake/**'
        exclude '[execPackageName/]/.cmake/**'
    })

	if(!file('.' + File.separator + '[packageName/]' + File.separator + '.cmake' + File.separator).exists()) {
		outputs.upToDateWhen { false }
	}

	if(!file('.' + File.separator + '[execPackageName/]' + File.separator + '.cmake' + File.separator).exists()) {
		outputs.upToDateWhen { false }
	}

	if(OperatingSystem.current().isWindows()){
		if(project.hasProperty('RELEASE') && !project.property('RELEASE').equals('0')){outputs.file file(['['/]rootDir,'application','bin','[packageName/]' +                '.dll'[']'/].join(File.separator))}
		if(project.hasProperty('DEBUG') && !project.property('DEBUG').equals('0'))  {outputs.file file(['['/]rootDir,'application','bin','[packageName/]' +          'd' + '.dll'[']'/].join(File.separator))}
		if(project.hasProperty('RELEASE') && !project.property('RELEASE').equals('0')){outputs.file file(['['/]rootDir,'application','bin','[packageName/]' + 'Exec' +       '.dll'[']'/].join(File.separator))}
		if(project.hasProperty('DEBUG') && !project.property('DEBUG').equals('0'))  {outputs.file file(['['/]rootDir,'application','bin','[packageName/]' + 'Exec' + 'd' + '.dll'[']'/].join(File.separator))}
	}
	else if(OperatingSystem.current().isLinux()){
		if(project.hasProperty('RELEASE') && !project.property('RELEASE').equals('0')){outputs.file file(['['/]rootDir,'application','bin','[packageName/]' +                '.so'[']'/].join(File.separator))}
		if(project.hasProperty('DEBUG') && !project.property('DEBUG').equals('0'))  {outputs.file file(['['/]rootDir,'application','bin','[packageName/]' +          'd' + '.so'[']'/].join(File.separator))}
		if(project.hasProperty('RELEASE') && !project.property('RELEASE').equals('0')){outputs.file file(['['/]rootDir,'application','bin','[packageName/]' + 'Exec' +       '.so'[']'/].join(File.separator))}
		if(project.hasProperty('DEBUG') && !project.property('DEBUG').equals('0'))  {outputs.file file(['['/]rootDir,'application','bin','[packageName/]' + 'Exec' + 'd' + '.so'[']'/].join(File.separator))}
	}
	else if(OperatingSystem.current().isMacOsX()){
		if(project.hasProperty('RELEASE') && !project.property('RELEASE').equals('0')){outputs.file file(['['/]rootDir,'application','bin','[packageName/]' +                '.dylib'[']'/].join(File.separator))}
		if(project.hasProperty('DEBUG') && !project.property('DEBUG').equals('0'))  {outputs.file file(['['/]rootDir,'application','bin','[packageName/]' +          'd' + '.dylib'[']'/].join(File.separator))}
		if(project.hasProperty('RELEASE') && !project.property('RELEASE').equals('0')){outputs.file file(['['/]rootDir,'application','bin','[packageName/]' + 'Exec' +       '.dylib'[']'/].join(File.separator))}
		if(project.hasProperty('DEBUG') && !project.property('DEBUG').equals('0'))  {outputs.file file(['['/]rootDir,'application','bin','[packageName/]' + 'Exec' + 'd' + '.dylib'[']'/].join(File.separator))}
	}
	else {
	    //not supported os
	}

	outputs.files(fileTree(['['/]rootDir,'application','include','[packageName/]'[']'/].join(File.separator)))
	outputs.files(fileTree(['['/]rootDir,'application','include','[execPackageName/]'[']'/].join(File.separator)))
	outputs.dir(['['/]rootDir,'application','include','[packageName/]'[']'/].join(File.separator))
	outputs.dir(['['/]rootDir,'application','include','[execPackageName/]'[']'/].join(File.separator))
	
	[comment
	// dependency to basic interfaces
	//   - deliverAbstractDataTypes 
    //   - deliverPluginFrameworkInterface
    //   - deliverPersistenceInterface
    //   - deliverUtil
	/]
	dependsOn getRootProject().getTasksByName('deliverBasicInterfaces', true)

[for (packName : String | aPackage.metaModelLibrariesNames()) ? (not(packName = aPackage.getPackageName()))]

	// dependency to model '[packName/]'
	def [packName/] = getRootProject().getTasksByName('compile[packName.toUpperFirst()/]', true)
	dependsOn [packName/]
	inputs.files([packName/].outputs)
[/for]
}

task clean {
	// Extension of gradle built-in task:clean
	doLast {
		def dot_cmake = file('[packageName/]/.cmake')
		if(dot_cmake.exists()){
			delete dot_cmake.absolutePath
			println "deleting: " + dot_cmake.absolutePath
		}

		def dot_cmakeExec = file('[execPackageName/]/.cmake')
		if(dot_cmakeExec.exists()){
			delete dot_cmakeExec.absolutePath
			println "deleting: " + dot_cmakeExec.absolutePath
		}
		
		compile[packageName.toUpperFirst()/].outputs.files.each{
			if(it.exists()){
				delete it.absolutePath
			    println "deleting: " + it
			}
  		}
	}
}
[/file]
[/template]

[template private generatePackageSourceFilesToCompile(aPackage : Package, packOnly : Boolean, isRoot : Boolean)]
#ClassifierObject classes for Package [aPackage.generateNamespace(false)/]
[for (aClassifier : Classifier | getClassifiersForObjectClasses()->select(isGeneratable())->sortedBy(name))]
[if(not isRoot)]../[aPackage.generateNamespacePath(false)/]Exec/[/if][aClassifier.name.toUpperFirst()/]Object.cpp
[/for]
#Strategy classes for Package [aPackage.generateNamespace(false)/]
[for (aClass : Class | getPackageClasses()->select(isStrategyClass())->sortedBy(name))]
[if(not isRoot)]../[aPackage.generateNamespacePath(false)/]Exec/[/if][aClass.name.toUpperFirst()/].cpp
[/for]
[if (not packOnly)]
#OpaqueBehaviorExecution classes for Package [aPackage.generateNamespace(false)/]
[for (anOpaqueBehavior : OpaqueBehavior | aPackage.getPackageOpaqueBehaviors()->reject(isDoNotGenerateElement())->reject(hasStereotypeApplied(QN_STEREOTYPE_NONEXECUTABLE()))->sortedBy(name))]
[if(not isRoot)]../[aPackage.generateNamespacePath(false)/]Exec/[/if][anOpaqueBehavior.generateOpaqueBehaviorExecutionName()/].cpp
[/for]
#OperationExecution classes for Package [aPackage.generateNamespace(false)/]
[for (anOperation : Operation | aPackage.getPackageOperations()->reject(isDoNotGenerateElement())->reject(hasStereotypeApplied(QN_STEREOTYPE_NONEXECUTABLE()))->sortedBy(name))]
[if(not isRoot)]../[aPackage.generateNamespacePath(false)/]Exec/[/if][anOperation.generateOperationExecutionName()->sortedBy(name)/].cpp
[/for]
[/if]
[for (subPackage : Package | aPackage.ownedElement->filter(Package))]
[subPackage.generatePackageSourceFilesToCompile(packOnly, false)/]
[/for]
[/template]

[template private generateCMakeFindLibraryCommands(aPackage : Package, ending : String, folderName : String)]
IF (CMAKE_BUILD_TYPE STREQUAL "Debug")
	[generateCMakeFindLibraryCommand(aPackage, ending, folderName, true)/]
ELSE()
	[generateCMakeFindLibraryCommand(aPackage, ending, folderName, false)/]
ENDIF()
[/template]

[template private generateCMakeFindLibraryCommand(aPackage : Package, ending : String, folderName : String, debugMode : Boolean)]
[for (packName : String | aPackage.metaModelLibrariesNames()->reject(name : String | aPackage.getAllSubPackageNames()->includes(name)))]
FIND_LIBRARY([packName.toUpperCase()/]_[libraryVariableNameSuffix(debugMode)/] [packName/][libraryNameSuffix(debugMode)/][ending/] ${MDE4CPP_HOME}/application/[folderName/])
[if (OrderedSet{'ecore', 'uml', 'fUML', 'PSCS', 'ecoreReflection', 'primitivetypesReflection', 'oclParser', aPackage.getPackageName()}->excludes(packName))]
FIND_LIBRARY([packName.toUpperCase()/]EXEC_[libraryVariableNameSuffix(debugMode)/] [packName/]Exec[libraryNameSuffix(debugMode)/][ending/] ${MDE4CPP_HOME}/application/[folderName/])
[/if]
[/for]
[/template]

[template private generateLibraryLinking(aPackage : Package, debugMode : Boolean)]
TARGET_LINK_LIBRARIES(${PROJECT_NAME}
[for (packName : String | aPackage.metaModelLibrariesNames()->reject(name : String | aPackage.getAllSubPackageNames()->includes(name)))]
	[buildModeCMakeProperty(debugMode)/] ${[packName.toUpperCase()/]_[libraryVariableNameSuffix(debugMode)/]}
	[if (OrderedSet{'ecore', 'uml', 'fUML', 'PSCS', 'ecoreReflection', 'primitivetypesReflection', 'oclParser', aPackage.getPackageName()}->excludes(packName))]
	[buildModeCMakeProperty(debugMode)/] ${[packName.toUpperCase()/]EXEC_[libraryVariableNameSuffix(debugMode)/]}
	[/if]
[/for]
)
[/template]

[template private generateRelatedModelNameList(aPackage : Package) post (trim())]
[for (packName : String | aPackage.metaModelLibrariesNames()) separator (', ') ? (not(packName = aPackage.getPackageName()))]
'[packName/]'[/for]
[/template]

[query private libraryVariableNameSuffix(debugMode : Boolean) : String = if (debugMode) then 'DEBUG' else 'RELEASE' endif/]
[query private libraryNameSuffix(debugMode : Boolean) : String = if (debugMode) then 'd' else '' endif/]
[query private buildModeCMakeProperty(debugMode : Boolean) : String = if (debugMode) then 'debug' else 'optimized' endif/]

[query public metaModelIncludes(aPackage : Package) : Set(Package) = OrderedSet{
																			aPackage.member->filter(Class)->reject(isDoNotGenerateElement()).attribute.type->reject(oclIsUndefined()).getNearestPackage(),
																			aPackage.member->filter(Class)->reject(isDoNotGenerateElement()).ownedOperation.ownedParameter.type->reject(oclIsUndefined()).getNearestPackage(),
																			aPackage.member->filter(Class)->reject(isDoNotGenerateElement()).attribute.getAppliedStereotypes().getNearestPackage(), 
																			aPackage.member->filter(Class)->reject(isDoNotGenerateElement()).interfaceRealization.supplier.getNearestPackage(), 
																			aPackage.member->filter(Class)->reject(isDoNotGenerateElement()).generalization.general.getNearestPackage(), 
																			aPackage.getCallOperationActions().operation.method->reject(oclIsUndefined()).ownedParameter.type->reject(oclIsUndefined()).getNearestPackage(),
																			aPackage.allOwnedElements()->filter(CallBehaviorAction).behavior->reject(oclIsUndefined()).getNearestPackage(),
																		    aPackage.allOwnedElements()->filter(CallOperationAction).operation->reject(oclIsUndefined()).getNearestPackage(),
																			aPackage.packageImport->reject(isDoNotGenerateElement()).importedPackage
																		}->flatten()->reject(oclIsUndefined())->reject(pack : Package | (pack = aPackage) or pack.isReflectionModel() or pack.name = QN_PROFILE_UML4CPPPROFILE())->reject(isDoNotGenerate()) /]
[query public isReflectionModel(aPackage : Package) : Boolean = if ((aPackage.name='UML') or (aPackage.name='Ecore')or (aPackage.name='PrimitiveTypes') or (aPackage.eAllContents()->filter(ecore::EAnnotation)->select(source = 'SDK')->notEmpty())) then true else false endif /]
[query public metaModelIncludesWithoutReflection(aPackage : Package) : Set(Package) = aPackage.metaModelIncludes()->reject((name = aPackage.name) or (name = 'PrimitiveTypes') or (name = 'UML')or (name = 'Ecore'))/]
[query public metaModelIncludesReflection(aPackage : Package) : Set(Package) = aPackage.metaModelIncludes()->select((not (name = aPackage.name) or (name = 'PrimitiveTypes') or (name = 'UML')or (name = 'Ecore')))/]
[query public metaModelLibrariesNamesForNonReflectionModels(aPackage : Package) : Set(String) = if(metaModelIncludesWithoutReflection()->size() = 0) then OrderedSet{'ecore', 'uml', 'fUML', 'PSCS', 'ecoreReflection', 'primitivetypesReflection', 'umlReflection', aPackage.name}->addAll(aPackage.addOclParser()) else OrderedSet{'ecore', 'uml', 'fUML', 'PSCS', 'ecoreReflection', 'primitivetypesReflection', 'umlReflection', aPackage.name}->addAll(metaModelIncludesWithoutReflection()->sortedBy(name).name)->flatten()->addAll(aPackage.addOclParser()) endif/]
[query public metaModelLibrariesNamesForReflectionModels(aPackage : Package) : Set(String) = if ((aPackage.name='UML') or (aPackage.eAllContents()->filter(ecore::EAnnotation)->select(source = 'SDK')->notEmpty())) then OrderedSet{'ecore', 'uml', 'ecoreReflection', 'primitivetypesReflection', 'fUML', 'PSCS', 'umlReflection'}->addAll(aPackage.addOclParser()) else OrderedSet{'ecore', 'uml'} endif/]
[query public metaModelLibrariesNames(aPackage : Package) : Set(String) = if (aPackage.isReflectionModel()) then metaModelLibrariesNamesForReflectionModels() else metaModelLibrariesNamesForNonReflectionModels() endif/]
[query public getBinaryTypeName(buildLibrary : Boolean) : String = if (buildLibrary) then 'SharedLibrary' else 'Executable' endif/]
[query public getBinaryTypeExtension(buildLibrary : Boolean) : String = if (buildLibrary) then 'dll' else 'exe' endif/]
[query public getBinaryTypeFolder(buildLibrary : Boolean) : String = if (buildLibrary) then 'libs' else 'exe' endif/]
[query public getBuildTask(buildLibrary : Boolean) : String = if (buildLibrary) then 'NativeLibrarySpec' else 'NativeExecutableSpec' endif/]
[query public addOclParser(aPackage : Package) : Set(String) = if (aPackage.getPackageOpaqueBehaviors().language->includes(keyOCL())->size() > 0) then Set{'oclParser'} else Set{} endif/]
