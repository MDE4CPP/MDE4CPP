[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */]
[module generateExecutionPluginImplementationSource('http://www.eclipse.org/uml2/5.0.0/UML')]

[import fUML4CPP::generator::main::generateMainExecution /]
[import fUML4CPP::generator::main::generateOpaqueBehaviorExecution /]
[import fUML4CPP::generator::main::generateOperationExecution /]
[import fUML4CPP::generator::main::parameterHelper /]
[import fUML4CPP::generator::main::fUMLCollectionHelper /]
[import UML4CPP::generator::main::components::generateType /]
[import UML4CPP::generator::main::helpers::generalHelper /]
[import UML4CPP::generator::main::helpers::nameHelper /]

[template public generateExecutionPluginImplSource(aPackage : Package) { packageName : String = aPackage.name.toUpperFirst().concat('ExecPluginImpl'); }]
[file (aPackage.getPackageName().concat('Exec/impl/').concat(packageName).concat('.cpp'), false, 'UTF-8')]
#include "[aPackage.getPackageName()/]Exec/impl/[packageName/].hpp"

[defineDebugMacro()/]

#include <cassert>
#include <iostream>
#include "abstractDataTypes/Any.hpp"
#include "abstractDataTypes/Bag.hpp"
#include "uml/Activity.hpp"
#include "uml/Element.hpp"

[if (aPackage.getUsedActivities()->size() > 0)]
[generateMainIncludes()/]
[/if]
[for (act : Activity | aPackage.getUsedActivities()->select(owner.oclIsKindOf(Class)))]
[generateActivityRelatedIncludes(act, aPackage)/]
#include "[act.owner.oclAsType(Classifier).namespace.myNamespaceName()/]Exec/[act.owner.oclAsType(Classifier).name.toUpperFirst()/]Object.hpp"
#include "[act.owner.oclAsType(Classifier).namespace.myNamespaceName()/]/[act.owner.oclAsType(Classifier).name.toUpperFirst()/].hpp"
[/for]

using namespace [aPackage.name/];

//*********************************
// Constructor / Destructor
//*********************************
[packageName/]::[packageName/]()
{	[comment initialization of execution locus, factory, executer/]
	[if (aPackage.allOwnedElements()->filter(Activity)->size() > 0)]
	[generateExecutionPluginInitialization()/]

	[comment create opaque behavior executions for operations /]
	[for (anOperation : Operation | aPackage.getClassOperations())]
	[anOperation.generateOpaqueBehaviorForOperationExecution()/]
	[/for]

	[comment create opaque behavior executions for opaque behaviors in the model that are executed either by a call behavior action or by a desicion node/]
	[for (anOpaqueBehavior : OpaqueBehavior | aPackage.collectAllExecutedOpaqueBehaviors())]
	[anOpaqueBehavior.generateOpaqueBehaviorExecution()/]
	[/for]
	[/if]
}

[packageName/]::~[packageName/]()
{	[comment uninitialization of execution locus, factory, executer as well as clearance of opaque behaviors from operations/]
	[if (aPackage.allOwnedElements()->filter(Activity)->size() > 0)]
	[aPackage.generateExecutionPluginDeinitialization()/]
	[/if]
}

std::string [packageName/]::eclipseURI()
{
	return "";
}

std::string [packageName/]::eNAME()
{
	return "[aPackage.name/]Exec";
}

std::string [packageName/]::eNS_URI()
{
	return "[aPackage.URI/]";
}

std::string [packageName/]::eNS_PREFIX()
{
	return "[if(not (aPackage.namespace.oclIsUndefined()))][aPackage.namespace.name/][/if]";
}

std::shared_ptr<ecore::EObject> [packageName/]::create(const std::string& name) const
{		
	return nullptr;
}

std::shared_ptr<ecore::EObject> [packageName/]::create(const std::string& name, std::shared_ptr<ecore::EObject> container, const unsigned int referenceID) const
{
	return nullptr;
}

Any [packageName/]::executeActivity(std::shared_ptr<uml::Activity> activity, std::shared_ptr<std::vector<Any>> parameterList, std::shared_ptr<uml::Element> element)
{
[for (act : Activity | aPackage.getUsedActivities()->sortedBy(myQualifiedName()))]
	if (activity == [act.getNearestPackage().myNamespaceName()/]::[act.getNearestPackage().myName()/]Package::eInstance()->[act.generatePackageGetterCall()/])
	{
		[act.generateGetInputParameter()/]
		[act.generateActivityExecution()/]   
		[act.generateReturnParameter()/]
	}
[/for]
	return nullptr;
}

[/file]
[/template]

[template public generateMainIncludes(aPackage : Package)]
#include "abstractDataTypes/SubsetUnion.hpp"
#include "PSCS/Semantics/Loci/LociFactory.hpp"
#include "PSCS/Semantics/Loci/CS_Locus.hpp"
#include "PSCS/Semantics/Loci/CS_ExecutionFactory.hpp"
#include "PSCS/Semantics/Loci/CS_Executor.hpp"
#include "PSCS/Semantics/StructuredClassifiers/StructuredClassifiersFactory.hpp"
#include "PSCS/Semantics/StructuredClassifiers/CS_DispatchOperationOfInterfaceStrategy.hpp"
#include "PSCS/Semantics/StructuredClassifiers/CS_NameBased_StructuralFeatureOfInterfaceAccessStrategy.hpp"
#include "PSCS/Semantics/StructuredClassifiers/CS_DefaultRequestPropagationStrategy.hpp"
#include "PSCS/Semantics/Actions/ActionsFactory.hpp"
#include "PSCS/Semantics/Actions/CS_DefaultConstructStrategy.hpp"
#include "fUML/Semantics/CommonBehavior/CommonBehaviorFactory.hpp"
#include "fUML/Semantics/Loci/LociFactory.hpp"
#include "fUML/Semantics/SimpleClassifiers/SimpleClassifiersFactory.hpp"
#include "fUML/Semantics/CommonBehavior/ParameterValue.hpp"
#include "fUML/Semantics/Loci/FirstChoiceStrategy.hpp"
#include "fUML/Semantics/StructuredClassifiers/DispatchStrategy.hpp"
#include "fUML/Semantics/Values/Value.hpp"
#include "uml/Activity.hpp"
#include "uml/Enumeration.hpp"
#include "uml/OpaqueBehavior.hpp"
#include "uml/FunctionBehavior.hpp"
#include "uml/Interface.hpp"
#include "uml/Operation.hpp"
#include "uml/Parameter.hpp"
#include "uml/PrimitiveType.hpp"
#include "uml/UmlFactory.hpp"


//include Model locus and package
#include "[aPackage.getPackageName()/]Exec/[aPackage.getPackageName().toUpperFirst()/]Locus.hpp"
#include "[aPackage.getPackageName()/]Exec/impl/[aPackage.getPackageName().toUpperFirst()/]LocusImpl.hpp"
#include "[aPackage.getPackageName()/]/[aPackage.getPackageName().toUpperFirst().concat('Package')/].hpp"

[for (anotherPackage : Package | aPackage.findPackagesForOpaqueBehaviorExecutions())]
#include "[anotherPackage.getPackageName()/]/[anotherPackage.getPackageName().toUpperFirst().concat('Package')/].hpp" 
[/for] 
[for (pack : Package | aPackage.getCallOperationActions().operation.ownedParameter.type.getNearestPackage()->asSet()->addAll(aPackage.allOwnedElements()->filter(Activity).ownedParameter.type.getNearestPackage()->asSet())->sortedBy(name))]
[if (not (pack.name='StandardProfile'))]
#include "[pack.getPackageName()/]/[pack.name.concat('Package').toUpperFirst()/].hpp"
[/if]
[/for]

//OpaqueBehaviourExecutions
[aPackage.getCallBehaviorActionsWithOB().generateInclude()/]
[aPackage.getDecisionNodesWithOB().generateInclude()/]
[aPackage.getClassOperations().generateInclude()/]
[/template]

[template public generateActivityRelatedIncludes(anActivity : Activity, aPackage : Package)]
#include "PSCS/Semantics/StructuredClassifiers/CS_Reference.hpp"
#include "[aPackage.getPackageName()/]/[aPackage.getPackageName().toUpperFirst()/]Factory.hpp"
#include "[aPackage.getPackageName()/]/[aPackage.getPackageName().toUpperFirst()/]Package.hpp"

[for ( type : Type | anActivity->asOrderedSet()->first().ownedParameter.type->asOrderedSet())]
[type.generateTypeInclude(aPackage)/]
[/for]
[/template]

[template public generateGetInputParameter(anActivity : Activity)]
[for (par : Parameter | anActivity.ownedParameter->select((direction = ParameterDirectionKind::inout) or (direction = ParameterDirectionKind::_in)))]
//retrieving value for input parameter [anActivity.name/]::[par.name/]
[par.generateCppType(true)/] [par.name.toLowerFirst()/][if (par.upper <> 1)]List[/if] = parameterList->at([par.listNumber(anActivity)/])->get<[par.generateCppType(true)/]>();
[/for]
[/template]

[template public generateExecutionPluginInitialization(aPackage : Package) {locusName : String = aPackage.getPackageName().sanitize().toUpperFirst() + 'Locus' ;}]
//initialize execution locus
std::shared_ptr<[locusName/]Impl> locusImpl(new [locusName/]Impl);
locusImpl->setThisLocusPtr(locusImpl);
m_locus = locusImpl;

//initialize executor
std::shared_ptr<PSCS::Semantics::Loci::CS_Executor> m_executor = PSCS::Semantics::Loci::LociFactory::eInstance()->createCS_Executor();
m_executor->setLocus(m_locus);
m_locus->setExecutor(m_executor);

std::shared_ptr<PSCS::Semantics::Loci::CS_ExecutionFactory> m_factory = PSCS::Semantics::Loci::LociFactory::eInstance()->createCS_ExecutionFactory_in_Locus(m_locus);
m_locus->setFactory(m_factory);

//assign ConstructStrategy to execution factory
m_factory->assignStrategy(PSCS::Semantics::Actions::ActionsFactory::eInstance()->createCS_DefaultConstructStrategy());
//assign ChoiceStrategy to execution factory
m_factory->assignStrategy(fUML::Semantics::Loci::LociFactory::eInstance()->createFirstChoiceStrategy());
//assign DispatchStrategy to execution factory
m_factory->assignStrategy(PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_DispatchOperationOfInterfaceStrategy());
//assign StructuralFeatureOfInterfaceAccessStrategy to execution factory
m_factory->assignStrategy(PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_NameBased_StructuralFeatureOfInterfaceAccessStrategy());
//assign RequestPropagationStrategy to execution factory
m_factory->assignStrategy(PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_DefaultRequestPropagationStrategy());
[/template]

[template public generateOpaqueBehaviorForOperationExecution(anOperation : Operation)]
[if (not anOperation.name.oclIsUndefined())]
{	/*creating opaque behavior for operation [anOperation.owner.oclAsType(NamedElement).name/]::[anOperation.name/]*/
	m_[anOperation.getFBNameForOperation()/] = uml::UmlFactory::eInstance()->createOpaqueBehavior();
	m_[anOperation.getFBNameForOperation()/]->setName("[anOperation.getFBNameForOperation()/]");
	[anOperation.generatePackageGetterCall()/]->getMethod()->insert([anOperation.generatePackageGetterCall()/]->getMethod()->begin(), m_[anOperation.getFBNameForOperation()/]);

	[for (aParameter : Parameter | anOperation.ownedParameter)]
	{	/*creating parameter [aParameter.name/]*/
		std::shared_ptr<uml::Parameter> [memberName(aParameter)/](uml::UmlFactory::eInstance()->createParameter_in_Behavior(m_[anOperation.getFBNameForOperation()/]));
		[memberName(aParameter)/]->setName("[aParameter.name/]");
		[memberName(aParameter)/]->setType([if(aParameter.type.getNearestPackage() = aParameter.getNearestPackage())][aParameter.getNearestPackage().myNamespaceName().concat('::').concat(aParameter.getNearestPackage().name.toUpperFirst()).concat('Package').concat('::eInstance()->')/][/if][aParameter.type.generatePackageGetterCall(aParameter)/]);
		[memberName(aParameter)/]->setLower([aParameter.lower/]);
		[memberName(aParameter)/]->setUpper([aParameter.upper/]);
		[memberName(aParameter)/]->setDirection(uml::ParameterDirectionKind::[direction.toString().toUpper()/]);
		//m_[anOperation.getFBNameForOperation()/]->getOwnedParameter()->push_back([memberName(aParameter)/]);
	}
	[/for]

	/*creating execution*/
	std::shared_ptr<[anOperation.getNearestPackage().myNamespaceName()/]::[anOperation.getOperationExecutionName()/]> [memberName(anOperation)/]Execution(new [anOperation.getNearestPackage().myNamespaceName()/]::[anOperation.getOperationExecutionName()/]());
	[memberName(anOperation)/]Execution->setThisExecutionPtr([memberName(anOperation)/]Execution);
	[memberName(anOperation)/]Execution->getTypes()->push_back(m_[anOperation.getFBNameForOperation()/]);
	[memberName(anOperation)/]Execution->setLocus(m_locus);
	m_factory->addPrimitiveBehaviorPrototype([memberName(anOperation)/]Execution);
}
[else]
{
	std::cerr << "an Operation without name" << std::endl;
	throw "error";
}
[/if]
[/template]

[template public generateOpaqueBehaviorExecution(anOpaqueBehavior : OpaqueBehavior)]
[if (not anOpaqueBehavior.name.oclIsUndefined())]
[let executionName : String = anOpaqueBehavior.name.sanitize().toUpperFirst().concat('Execution')]
{	/*creating execution for opaque behavior [anOpaqueBehavior.owner.oclAsType(NamedElement).name/]::[anOpaqueBehavior.name/]*/
	std::shared_ptr<[anOpaqueBehavior.getNearestPackage().myNamespaceName()/]::[executionName/]> [memberName(anOpaqueBehavior)/]Execution(new [anOpaqueBehavior.getNearestPackage().myNamespaceName()/]::[executionName/]());
	[memberName(anOpaqueBehavior)/]Execution->setThisExecutionPtr([memberName(anOpaqueBehavior)/]Execution);
	[memberName(anOpaqueBehavior)/]Execution->getTypes()->push_back([anOpaqueBehavior.generatePackageGetterCall()/]);
	[memberName(anOpaqueBehavior)/]Execution->setLocus(m_locus);
	m_factory->addPrimitiveBehaviorPrototype([memberName(anOpaqueBehavior)/]Execution);
}
[/let]
[/if]
[/template]

[template public generateActivityExecution(anActivity : Activity)]
std::shared_ptr<Bag<fUML::Semantics::CommonBehavior::ParameterValue> > pList(new Bag<fUML::Semantics::CommonBehavior::ParameterValue>());
[for (par : Parameter | anActivity.ownedParameter->select((direction = ParameterDirectionKind::inout) or (direction = ParameterDirectionKind::_in))->sortedBy(name))]
//creating input parameter [anActivity.name/]::[par.name/] 
std::shared_ptr<fUML::Semantics::CommonBehavior::ParameterValue> [par.name/]P = fUML::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createParameterValue();
[par.name/]P->setParameter([par.generatePackageGetterCall()/]);
[if (par.upper = 1)]
[par.generateValue()/]
[else]
Bag<[par.type.generateCppType(true)/]>::iterator [par.name.toLowerFirst()/]Iter = [par.name.toLowerFirst()/]List->begin();
Bag<[par.type.generateCppType(true)/]>::iterator [par.name.toLowerFirst()/]End = [par.name.toLowerFirst()/]List->end();
while ([par.name.toLowerFirst()/]Iter != [par.name.toLowerFirst()/]End)
{
	[par.type.generateCppType(false)/] [par.name.toLowerFirst()/][if (par.upper <> 1)]Temp[/if] = *[par.name.toLowerFirst()/]Iter;
	[par.generateValue()/]
	[par.name.toLowerFirst()/]Iter++;
}
[/if]
pList->push_back([par.name/]P);

[/for]
[if (anActivity.owner.oclIsKindOf(Class))]
std::shared_ptr<[anActivity.owner.oclAsType(Classifier).name.toUpperFirst()/]Object> object(new [anActivity.owner.oclAsType(Classifier).name.toUpperFirst()/]Object());
object->setThis[anActivity.owner.oclAsType(Classifier).name.toUpperFirst()/]ObjectPtr(object);
object->setUmlValue(std::dynamic_pointer_cast<[anActivity.owner.oclAsType(Classifier).namespace.myNamespaceName()/]::[anActivity.owner.oclAsType(Classifier).name.toUpperFirst()/]>(element));
object->setLocus(m_locus);
[/if]
//executing activity [anActivity.name/]
std::shared_ptr<Bag<fUML::Semantics::CommonBehavior::ParameterValue>> resultPList = m_locus->getExecutor()->execute([anActivity.generatePackageGetterCall()/], [if (anActivity.owner.oclIsKindOf(Class))]object[else]nullptr[/if], pList);
[/template]

[template private generateValue(aParameter : Parameter)]
[aParameter.generateOutputParameter()/]
[if(aParameter.type.supportedTypes())]
[aParameter.name/]OutValue->setValue([aParameter.name.toLowerFirst()/]);
[else]
[aParameter.name/]OutUmlLinker->setLocus(m_locus);
[aParameter.name/]OutValue->setReferent([aParameter.name/]OutUmlLinker);
[/if]
[aParameter.name/]P->getValues()->push_back([aParameter.name/]OutValue);
[/template]

[template public generateReturnParameter(anActivity : Activity)]
[if (anActivity.ownedParameter->select(p :Parameter | p.direction = ParameterDirectionKind::return)->notEmpty())]
//The activity has a return parameter
[let par : Parameter = anActivity.ownedParameter->select(p :Parameter | p.direction = ParameterDirectionKind::return)->sortedBy(name)->first()]
[if(par.type.supportedTypes())]
[if (par.upper =1)]
assert(resultPList->front());
std::shared_ptr<fUML::Semantics::SimpleClassifiers::[par.type.name/]Value> ret = std::dynamic_pointer_cast<fUML::Semantics::SimpleClassifiers::[par.type.name/]Value>(resultPList->front()->getValues()->front());
assert(ret != nullptr);
return eAny(ret->getValue());
[else]
std::shared_ptr<Bag<[par.type.generateCppType(true)/]>> [par.name/](new Bag<[par.type.generateCppType(true)/]>());
std::shared_ptr<Bag<fUML::Semantics::Values::Value>> returnValues = resultPList->front()->getValues();
Bag<fUML::Semantics::Values::Value>::iterator returnValuesIter = returnValues->begin();
Bag<fUML::Semantics::Values::Value>::iterator returnValuesEnd = returnValues->end();
while (returnValuesIter != returnValuesEnd)
{
	std::shared_ptr<[par.type.getValueClass()/]> valueObject = std::dynamic_pointer_cast<[par.type.getValueClass()/]>(*returnValuesIter);
	std::shared_ptr<[par.type.generateCppType(true)/]> value(new [par.type.generateCppType(true)/](valueObject->getValue()));
	[par.name/]->push_back(value);
	returnValuesIter++;
}
return eAny([par.name/]);
[/if]
[elseif (par.type.oclIsKindOf(Enumeration))]
assert(resultPList->front());
std::shared_ptr<fUML::Semantics::SimpleClassifiers::EnumerationValue> ret = std::dynamic_pointer_cast<fUML::Semantics::SimpleClassifiers::EnumerationValue>(resultPList->front()->getValues()->front());
assert(ret != nullptr);
std::shared_ptr<uml::EnumerationLiteral> literal[par.name.toUpperFirst()/] = ret->getLiteral();
[for (literal : EnumerationLiteral | par.type.oclAsType(Enumeration).ownedLiteral)]
if (literal[par.name.toUpperFirst()/] == [literal.generatePackageGetterCall()/])
{
	return eAny([literal.enumeration.namespace.name/]::[literal.enumeration.name/]::[literal.name.toUpperCase()/]);
}
[/for]
std::cerr << "unknown literal of [par.type.name/]" << std::endl;
throw "error";
[else]
[if (par.upper =1)]
assert(resultPList->front());
std::shared_ptr<PSCS::Semantics::StructuredClassifiers::CS_Reference> [par.name/]Value = std::dynamic_pointer_cast<PSCS::Semantics::StructuredClassifiers::CS_Reference>(resultPList->front()->getValues()->front());
std::shared_ptr<[par.type.name.toUpperFirst()/]Object> [par.name/]UmlLinker = std::dynamic_pointer_cast<[par.type.name.toUpperFirst()/]Object>([par.name/]Value->getReferent());
return eAny([par.name/]UmlLinker->[par.type.oclAsType(Classifier).UMLValueGetterName()/][if(not (par.upper = 1))]s[/if]());
[else]
std::shared_ptr<fUML::Semantics::CommonBehavior::ParameterValue> returnParameter = resultPList->front();
std::shared_ptr<Bag<fUML::Semantics::Values::Value>> returnValues = returnParameter->getValues();
Bag<fUML::Semantics::Values::Value>::iterator valueIter = returnValues->begin();
Bag<fUML::Semantics::Values::Value>::iterator valueEnd = returnValues->end();
std::shared_ptr<Bag<[par.type.generateCppType(true)/]>> returnList(new Bag<[par.type.generateCppType(true)/]>());
while (valueIter != valueEnd)
{
	std::shared_ptr<PSCS::Semantics::StructuredClassifiers::CS_Reference> returnValue = std::dynamic_pointer_cast<PSCS::Semantics::StructuredClassifiers::CS_Reference>(*valueIter);
	std::shared_ptr<[par.type.name.toUpperFirst()/]Object> returnObject = std::dynamic_pointer_cast<[par.type.name.toUpperFirst()/]Object>(returnValue->getReferent());
	returnList->push_back(returnObject->[par.type.oclAsType(Classifier).UMLValueGetterName()/]());
	valueIter++;
}
return eAny(returnList);
[/if]
[/if]
[/let]
[else]
DEBUG_MESSAGE(std::cout << "Activity [anActivity.myQualifiedName()/] has no return parameter" << std::endl;)
return nullptr;
[/if]
[/template]

[template public generateExecutionPluginDeinitialization(aPackage : Package)]
/*clearing opaque behaviors from operations*/
[for (anOperation : Operation | aPackage.getClassOperations())]
[anOperation.generatePackageGetterCall()/]->getMethod()->erase(m_[anOperation.getFBPackageElement()/]);
[/for]

//uninitialize execution factory
m_factory->getPrimitiveBehaviorPrototypes()->clear();
m_factory->setLocus(nullptr);

//uninitialize executor
m_executor->setLocus(nullptr);

//uninitialize execution locus
m_locus->setExecutor(nullptr);
m_locus->setFactory(nullptr);
[/template]

[query private findPackagesForOpaqueBehaviorExecutions(aPackage : Package) : OrderedSet(Package) = 
	OrderedSet(Package){
		aPackage.getCallBehaviorActionsWithOB().behavior.getNearestPackage(),
		aPackage.getCallOperationActions().operation.getNearestPackage(),
		aPackage.getDecisionNodesWithOB().decisionInput.getNearestPackage()
	}->flatten()->sortedBy(name) /]

[query private getOperationExecutionName(anOperation : Operation) : String = 
	anOperation.owner.oclAsType(NamedElement).name.concat('_').concat(anOperation.name.sanitize()).concat(('Execution')) /]

[query private getFBNameForOperation(anOperation : Operation) : String = 
	'ob_'.concat(anOperation.owner.oclAsType(NamedElement).name.replaceAll(' ', '')).concat('_').concat(anOperation.myName().sanitize())/]

[query private getActivitiesUsedByCallBehaviorAction(aPackage : Package) : Set(Activity) = 
	aPackage.allOwnedElements()->filter(CallBehaviorAction).behavior->reject(oclIsUndefined())->reject(not oclIsKindOf(Activity))->asSet()/]

[query private getActivitiesUsedByDecisionNode(aPackage : Package) : Set(Activity) = 
	aPackage.allOwnedElements()->filter(DecisionNode).decisionInput->reject(oclIsUndefined())->reject(not oclIsKindOf(Activity))->asSet()/]

[query private getActivitiesUsedByOperation(aPackage : Package) : Set(Activity) = 
	aPackage.allOwnedElements()->filter(Operation).method->reject(oclIsUndefined())->reject(not oclIsKindOf(Activity))->asSet()/]

[query private getUsedActivities (aPackage : Package) : OrderedSet(Activity) = 
	Set{aPackage.getActivitiesUsedByCallBehaviorAction(), aPackage.getActivitiesUsedByDecisionNode(), aPackage.getActivitiesUsedByOperation(), aPackage.getMainActivity()->asSet()->reject(oclIsUndefined())}->flatten()->sortedBy(name)/]

[query public listNumber(aParameter : Parameter, anActivity : Activity) : Integer =  
	anActivity.ownedParameter->select((direction = ParameterDirectionKind::_out) or (direction = ParameterDirectionKind::_in))->indexOf(aParameter)-1 /]