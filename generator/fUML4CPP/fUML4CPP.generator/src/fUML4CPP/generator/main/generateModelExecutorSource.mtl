[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */]
[module generateModelExecutorSource('http://www.eclipse.org/uml2/5.0.0/UML')]

[import UML4CPP::generator::main::helpers::generalHelper /]
[import UML4CPP::generator::main::helpers::nameHelper /]
[import UML4CPP::generator::main::helpers::isGeneratableHelper /]
[import UML4CPP::generator::main::profiles::uml4CPPProfileHelper /]
[import UML4CPP::generator::main::profiles::profileHelper /]
[import UML4CPP::generator::main::helpers::collectionHelper /]
[import UML4CPP::generator::main::components::generateType /]
[import UML4CPP::generator::main::helpers::keywords /]
[import fUML4CPP::generator::main::fUMLCollectionHelper /]

[template public generateModelExecutorSource(aPackage : Package) 
{
packageName : String = aPackage.getPackageName().sanitize(); 
originalName : String = aPackage.generateNamespacePath(false);
}]

[file (originalName.concat('Exec/impl/') + packageName.concat('ExecutorImpl.cpp'), false, 'UTF-8')]
#include "[packageName/]ExecutorImpl.hpp"
#include <iostream>

[defineDebugMacro()/]

#include "abstractDataTypes/SubsetUnion.hpp"
#include "ecore/EClass.hpp"
#include "uml/umlPackage.hpp"
#include "uml/Activity.hpp"
#include "uml/Enumeration.hpp"
#include "uml/EnumerationLiteral.hpp"
#include "uml/FunctionBehavior.hpp"
#include "uml/InstanceValue.hpp"
#include "uml/OpaqueBehavior.hpp"
#include "uml/Parameter.hpp"
#include "uml/ParameterDirectionKind.hpp"
#include "fUML/Semantics/CommonBehavior/ParameterValue.hpp"
#include "fUML/Semantics/Activities/ActivityExecution.hpp"
#include "fUML/Semantics/Activities/ActivityNodeActivationGroup.hpp"
#include "fUML/Semantics/Activities/ActivitiesFactory.hpp"
#include "fUML/Semantics/CommonBehavior/CommonBehaviorFactory.hpp"
#include "fUML/Semantics/Loci/Locus.hpp"
#include "fUML/Semantics/Loci/ExecutionFactory.hpp"
#include "[aPackage.generateNamespace(false)/]/[aPackage.generateNamespace(false)/]Package.hpp"
[for (anEnumeration : Enumeration | aPackage.allOwnedElements()->filter(Enumeration)->select(isGeneratable())->sortedBy(myQualifiedName()))]
#include "[aPackage.generateNamespacePath(true)/]/[anEnumeration.name.toUpperFirst()/].hpp"
[/for]
[for (anIncludeString : String | 	
	aPackage.allOwnedElements()
	->filter(OpaqueBehavior)
	->reject(oB : OpaqueBehavior | (not oB._context.oclIsUndefined()) and oB._context.oclIsTypeOf(Class))
	->reject(oB : OpaqueBehavior | oB.hasStereotypeApplied(QN_STEREOTYPE_MAINBEHAVIOR()))
	->reject(oB : OpaqueBehavior | oB.isDoNotGenerateElement())
	->select(oB : OpaqueBehavior | oB.specification.oclIsUndefined())
	.getNearestPackage().collectPackageGlobalFunctions_IncludeString()->asSet())]
[anIncludeString/]
[/for]

#include "pluginFramework/PluginFramework.hpp"
#include "pluginFramework/UMLExecutionModelPlugin.hpp"

using namespace [aPackage.generateNamespace(false)/];

//*********************************
// Constructor / Destructor
//*********************************
[packageName/]ExecutorImpl::[packageName/]ExecutorImpl()
{
}

[packageName/]ExecutorImpl::~[packageName/]ExecutorImpl()
{
}

std::shared_ptr<Any> [packageName/]ExecutorImpl::evaluate(std::shared_ptr<uml::ValueSpecification> specification)
{
	switch (specification->eClass()->getClassifierID())
	{
		case uml::umlPackage::INSTANCEVALUE_CLASS:
		{
			std::shared_ptr<uml::EnumerationLiteral> literal = 
				std::dynamic_pointer_cast<uml::EnumerationLiteral>((std::dynamic_pointer_cast<uml::InstanceValue>(specification))->getInstance());

			if(literal)
			{
				std::shared_ptr<uml::Enumeration> enumeration = literal->getEnumeration().lock();
				std::shared_ptr<uml::Package> enumerationPackage = enumeration->getPackage().lock();
	
				//Model-internal Enumerations
				if(enumerationPackage == [aPackage.generateNamespace(false)/]::[aPackage.name/]Package::eInstance())
				{
					[for (anEnumeration : Enumeration | aPackage.allOwnedElements()->filter(Enumeration)->select(isGeneratable())->sortedBy(myQualifiedName()))]
					if(enumeration == [anEnumeration.generatePackageGetterCall()/])
					{
						[for (anEnumerationLiteral : EnumerationLiteral | anEnumeration.ownedLiteral)]
						if (literal == [anEnumerationLiteral.generatePackageGetterCall()/])
						{	
							return eAny([aPackage.generateNamespace(false)/]::[anEnumeration.name/]::[anEnumerationLiteral.name.toUpper()/], [aPackage.generateNamespace(false)/]::[aPackage.name/]Package::[anEnumeration.getMemberName().toUpperCase()/], false);
						}
						[/for]
					}
					[/for]
				}
				//Model-external Enumerations
				else
				{
					std::shared_ptr<PluginFramework> pluginFramework = PluginFramework::eInstance();
					std::string pluginName = enumerationPackage->getName() + "Exec";
					std::shared_ptr<MDE4CPPPlugin> plugin = pluginFramework->findPluginByName(pluginName);
			
					if (plugin)
					{
						DEBUG_INFO("Plugin '" << plugin->eNAME() << "' found.")
			
						std::shared_ptr<UMLExecutionModelPlugin> executionPlugin = std::dynamic_pointer_cast<UMLExecutionModelPlugin>(plugin);
						if (executionPlugin)
						{
							DEBUG_INFO("Execution plugin '" << executionPlugin->eNAME() << "' is accessable.")
			
							return executionPlugin->evaluateSpecification(specification);
						}
						else
						{
							DEBUG_ERROR("Plugin '" << plugin->eNAME() << "' is not an execution plugin!")
						}
					}
					else
					{ 
						DEBUG_ERROR("Plugin '" << pluginName << "' not found!")
					}
				}
			}
		}
		default:
		{
			return fUML::Semantics::Loci::ExecutorImpl::evaluate(specification);
			//return PSCS::Semantics::Loci::CS_ExecutorImpl::evaluate(specification);
		}
	}
	return fUML::Semantics::Loci::ExecutorImpl::evaluate(specification);
	//return PSCS::Semantics::Loci::CS_ExecutorImpl::evaluate(specification);
}

std::shared_ptr<Bag<fUML::Semantics::CommonBehavior::ParameterValue>> [packageName/]ExecutorImpl::execute(std::shared_ptr<uml::Behavior> behavior, std::shared_ptr<uml::Element> context, std::shared_ptr<Bag<fUML::Semantics::CommonBehavior::ParameterValue>> inputs)
{
	int behaviorMetaElementID = behavior->getMetaElementID();
    if((behaviorMetaElementID == uml::umlPackage::OPAQUEBEHAVIOR_CLASS) || (behaviorMetaElementID == uml::umlPackage::FUNCTIONBEHAVIOR_CLASS))
    {
		std::shared_ptr<uml::OpaqueBehavior> opaqueBehavior = std::dynamic_pointer_cast<uml::OpaqueBehavior>(behavior);
		return this->invokeOpaqueBehavior(opaqueBehavior, context, inputs);
    }
	else if(behaviorMetaElementID == uml::umlPackage::ACTIVITY_CLASS)
	{
		std::shared_ptr<fUML::Semantics::Activities::ActivityExecution> activityExecution = 
			std::dynamic_pointer_cast<fUML::Semantics::Activities::ActivityExecution>(this->getLocus().lock()->getFactory()->createExecution(behavior, context));

		if(!activityExecution)
		{
		    std::cerr << "['['/][packageName/]ExecutorImpl::execute[']'/] Execution is null" << std::endl;
		    return nullptr;
		}

		activityExecution->getParameterValues()->clear();
		activityExecution->setContext(context);

		for(std::shared_ptr<fUML::Semantics::CommonBehavior::ParameterValue> inputParameterValue : *inputs)
	    {
	        activityExecution->setParameterValue(inputParameterValue);
	    }

		activityExecution->execute_new();
		std::shared_ptr<Bag<fUML::Semantics::CommonBehavior::ParameterValue>> outputParameterValues = activityExecution->getOutputParameterValues();
		activityExecution->getActivationGroup()->terminateAll();
		
		return outputParameterValues;
	}
	else
	{
		std::cerr<<__PRETTY_FUNCTION__<<" : Unsupported type of Behavior! Currently only Activities, OpaqueBehaviors and FunctionBehaviors are supported!"<<std::endl;
	}

	return fUML::Semantics::Loci::ExecutorImpl::execute(behavior, context, inputs);
}

std::shared_ptr<Bag<fUML::Semantics::CommonBehavior::ParameterValue>> [packageName/]ExecutorImpl::invokeOpaqueBehavior(std::shared_ptr<uml::OpaqueBehavior> opaqueBehavior, std::shared_ptr<uml::Element> context, std::shared_ptr<Bag<fUML::Semantics::CommonBehavior::ParameterValue>> inputs)
{
	std::shared_ptr<Bag<fUML::Semantics::CommonBehavior::ParameterValue>> outputParameterValues(new Bag<fUML::Semantics::CommonBehavior::ParameterValue>());
	std::shared_ptr<fUML::Semantics::CommonBehavior::ParameterValue> returnParameterValue = fUML::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createParameterValue();

	std::shared_ptr<Bag<Any>> inputArguments(new Bag<Any>());
	std::shared_ptr<Bag<Any>> outputArguments(new Bag<Any>());
	std::shared_ptr<Any> result;

	for(std::shared_ptr<fUML::Semantics::CommonBehavior::ParameterValue> parameterValue : *inputs)
	{
		inputArguments->add(parameterValue->getValues()->at(0));
	}

	[for (anOpaqueBehavior : OpaqueBehavior | 	aPackage.allOwnedElements()
	->filter(OpaqueBehavior)
	->reject(oB : OpaqueBehavior | oB.hasStereotypeApplied(QN_STEREOTYPE_MAINBEHAVIOR()))
	->reject(oB : OpaqueBehavior | oB.isDoNotGenerateElement()))]
	if(opaqueBehavior == [anOpaqueBehavior.generatePackageGetterCall()/])
	{	
		[comment 
			If the OpaqueBehavior has a specification (i.e. it implements an Operation),
			then invoke this Operation on the corresponding context object
		/]
		[if (not anOpaqueBehavior.specification.oclIsUndefined())]
			[if (anOpaqueBehavior.specification.oclIsKindOf(Operation))]
			[let specifiedOperation : Operation = anOpaqueBehavior.specification.oclAsType(Operation)]
		// OpaqueBehavior [anOpaqueBehavior.generateNamespaceName(true)/] specifies Operation [specifiedOperation.generateNamespaceName(true)/]
		if(!context)
		{
			DEBUG_ERROR("Context for execution OpaqueBehavior [anOpaqueBehavior.generateNamespaceName(true)/] is null!");
			return outputParameterValues;
		}
		result = context->invoke([specifiedOperation.generatePackageGetterCall()/], inputArguments, outputArguments);
				[let outputParameters : OrderedSet(Parameter) = specifiedOperation.ownedParameter->select(p : Parameter | (p.direction = ParameterDirectionKind::inout) or (p.direction = ParameterDirectionKind::out))]
				[for (outputParameter : Parameter | outputParameters) before('\n')]
		//Create output ParameterValue for [outputParameter.direction/] parameter [outputParameter.name/]
		std::shared_ptr<fUML::Semantics::CommonBehavior::ParameterValue> [outputParameter.name/]ParameterValue = fUML::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createParameterValue();
		[outputParameter.name/]ParameterValue->setParameter([outputParameter.generatePackageGetterCall()/]);
		[outputParameter.name/]ParameterValue->getValues()->add(outputArguments->at([outputParameters->indexOf(outputParameter) - 1/]));
		outputParameterValues->add([outputParameter.name/]ParameterValue);
				[/for]
				[/let]
				[if (specifiedOperation.ownedParameter->select(p :Parameter | p.direction = ParameterDirectionKind::return)->notEmpty())]
				[let returnParameter : Parameter = specifiedOperation.ownedParameter->select(p :Parameter | p.direction = ParameterDirectionKind::return)->first()]
		returnParameterValue->setParameter([returnParameter.generatePackageGetterCall()/]);
				[/let]
				[/if]
			[/let]
			[/if]
		[comment 
			Else if the OpaqueBehavior has no specification (i.e. it does not implement any Operation)
			but it has a defined context and this context is a class,
			then execute this Behavior on the corresponding context object
		/]
		[elseif ((not anOpaqueBehavior._context.oclIsUndefined()) and anOpaqueBehavior._context.oclIsTypeOf(Class))]
		// OpaqueBehavior [anOpaqueBehavior.generateNamespaceName(true)/] has Class [anOpaqueBehavior._context.generateNamespaceName(true)/] as its context
		if(!context)
		{
			DEBUG_ERROR("Context for execution OpaqueBehavior [anOpaqueBehavior.generateNamespaceName(true)/] is null!");
			return outputParameterValues;
		}
		result = context->invoke(opaqueBehavior, inputArguments, outputArguments);
			[let outputParameters : OrderedSet(Parameter) = anOpaqueBehavior.ownedParameter->select(p : Parameter | (p.direction = ParameterDirectionKind::inout) or (p.direction = ParameterDirectionKind::out))]
			[for (outputParameter : Parameter | outputParameters) before('\n')]
		std::shared_ptr<fUML::Semantics::CommonBehavior::ParameterValue> [outputParameter.name/]ParameterValue = fUML::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createParameterValue();
		[outputParameter.name/]ParameterValue->setParameter([outputParameter.generatePackageGetterCall()/]);
		[outputParameter.name/]ParameterValue->getValues()->add(outputArguments->at([outputParameters->indexOf(outputParameter) - 1/]));
		outputParameterValues->add([outputParameter.name/]ParameterValue);
			[/for]
			[/let]
			[if (anOpaqueBehavior.ownedParameter->select(p :Parameter | p.direction = ParameterDirectionKind::return)->notEmpty())]
			[let returnParameter : Parameter = anOpaqueBehavior.ownedParameter->select(p :Parameter | p.direction = ParameterDirectionKind::return)->first()]
		returnParameterValue->setParameter([returnParameter.generatePackageGetterCall()/]);
			[/let]
			[/if]
		[comment 
			Else execute the global model function corresponding to this Behavior
		/]
		[else]
		// OpaqueBehavior [anOpaqueBehavior.generateNamespaceName(true)/] has [if (anOpaqueBehavior._context.oclIsUndefined())]no context[else][anOpaqueBehavior._context.eClass().name/] [anOpaqueBehavior._context.generateNamespaceName(true)/] as its context[/if]
		// and is therefore realized as a global function
		result = [anOpaqueBehavior.getNearestPackage().generateNamespace(true)/]::invoke(opaqueBehavior, inputArguments, outputArguments);
			[let outputParameters : OrderedSet(Parameter) = anOpaqueBehavior.ownedParameter->select(p : Parameter | (p.direction = ParameterDirectionKind::inout) or (p.direction = ParameterDirectionKind::out))]
			[for (outputParameter : Parameter | outputParameters) before('\n')]
		std::shared_ptr<fUML::Semantics::CommonBehavior::ParameterValue> [outputParameter.name/]ParameterValue = fUML::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createParameterValue();
		[outputParameter.name/]ParameterValue->setParameter([outputParameter.generatePackageGetterCall()/]);
		[outputParameter.name/]ParameterValue->getValues()->add(outputArguments->at([outputParameters->indexOf(outputParameter) - 1/]));
		outputParameterValues->add([outputParameter.name/]ParameterValue);
			[/for]
			[/let]
			[if (anOpaqueBehavior.ownedParameter->select(p :Parameter | p.direction = ParameterDirectionKind::return)->notEmpty())]
			[let returnParameter : Parameter = anOpaqueBehavior.ownedParameter->select(p :Parameter | p.direction = ParameterDirectionKind::return)->first()]
		returnParameterValue->setParameter([returnParameter.generatePackageGetterCall()/]);
			[/let]
			[/if]
		[/if]
	}
	[/for]

	if(result)
	{
		returnParameterValue->getValues()->add(result);
		outputParameterValues->add(returnParameterValue);
	}

	return outputParameterValues;
}

void [packageName/]ExecutorImpl::setThisExecutorPtr(std::weak_ptr</*PSCS::Semantics::Loci::CS_Executor*/fUML::Semantics::Loci::Executor> thisExecutorPtr)
{
	/*PSCS::Semantics::Loci::CS_ExecutorImpl::setThisExecutorPtr(thisExecutorPtr)*/ fUML::Semantics::Loci::ExecutorImpl::setThisExecutorPtr(thisExecutorPtr);
}
[/file]
[/template]

[query private collectPackageGlobalFunctions_IncludeString(aPackage : Package) : String = '#include "' + aPackage.generateNamespacePath(true) + '/_GlobalFunctions.hpp"' /]