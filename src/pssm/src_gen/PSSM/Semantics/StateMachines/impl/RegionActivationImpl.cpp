
#include "PSSM/Semantics/StateMachines/impl/RegionActivationImpl.hpp"
#ifdef NDEBUG
	#define DEBUG_INFO(a)		/**/
	#define DEBUG_WARNING(a)	/**/
	#define DEBUG_ERROR(a)		/**/
#else
	#define DEBUG_INFO(a) 		std::cout<<"[\e[0;32mInfo\e[0m]:\t\t"<<__PRETTY_FUNCTION__<<"\n\t\t  -- Message: "<<a<<std::endl;
	#define DEBUG_WARNING(a) 	std::cout<<"[\e[0;33mWarning\e[0m]:\t"<<__PRETTY_FUNCTION__<<"\n\t\t  -- Message: "<<a<<std::endl;
	#define DEBUG_ERROR(a)		std::cout<<"[\e[0;31mError\e[0m]:\t"<<__PRETTY_FUNCTION__<<"\n\t\t  -- Message: "<<a<<std::endl;
#endif

#ifdef ACTIVITY_DEBUG_ON
    #define ACT_DEBUG(a) a
#else
    #define ACT_DEBUG(a) /**/
#endif

//#include "util/ProfileCallCount.hpp"

#include <cassert>
#include <iostream>
#include <sstream>
#include <stdexcept>
#include "abstractDataTypes/Bag.hpp"


#include "ecore/EcoreAny.hpp"
#include "ecore/EcoreContainerAny.hpp"
#include "abstractDataTypes/SubsetUnion.hpp"
#include "ecore/EAnnotation.hpp"
#include "ecore/EClass.hpp"
#include "ecore/EAttribute.hpp"
#include "ecore/EReference.hpp"
#include "ecore/EStructuralFeature.hpp"
#include "ecore/ecorePackage.hpp"
#include "ecore/ecoreFactory.hpp"
//Includes from codegen annotation
#include "uml/State.hpp"
#include "PSSM/Semantics/StateMachines/StateMachineExecution.hpp"
#include <condition_variable>
//Forward declaration includes
#include "persistence/interfaces/XLoadHandler.hpp" // used for Persistence
#include "persistence/interfaces/XSaveHandler.hpp" // used for Persistence

#include <exception> // used in Persistence
#include "PSSM/Semantics/StateMachines/StateMachinesFactory.hpp"
#include "uml/umlFactory.hpp"
#include "fUML/Semantics/Loci/LociFactory.hpp"
#include "fUML/Semantics/CommonBehavior/EventOccurrence.hpp"
#include "PSSM/Semantics/StateMachines/InitialPseudostateActivation.hpp"
#include "uml/NamedElement.hpp"
#include "fUML/Semantics/Loci/SemanticVisitor.hpp"
#include "PSSM/Semantics/StateMachines/StateActivation.hpp"
#include "PSSM/Semantics/StateMachines/StateMachineSemanticVisitor.hpp"
#include "uml/Transition.hpp"
#include "PSSM/Semantics/StateMachines/TransitionActivation.hpp"
#include "uml/Vertex.hpp"
#include "PSSM/Semantics/StateMachines/VertexActivation.hpp"
//Factories and Package includes
#include "PSSM/PSSMPackage.hpp"
#include "PSSM/Semantics/SemanticsPackage.hpp"
#include "fUML/Semantics/CommonBehavior/CommonBehaviorPackage.hpp"
#include "fUML/Semantics/Loci/LociPackage.hpp"
#include "PSSM/Semantics/StateMachines/StateMachinesPackage.hpp"
#include "uml/umlPackage.hpp"

using namespace PSSM::Semantics::StateMachines;

//*********************************
// Constructor / Destructor
//*********************************
RegionActivationImpl::RegionActivationImpl()
{	
	/*
	NOTE: Due to virtual inheritance, base class constrcutors may not be called correctly
	*/
}

RegionActivationImpl::~RegionActivationImpl()
{
#ifdef SHOW_DELETION
	std::cout << "-------------------------------------------------------------------------------------------------\r\ndelete RegionActivation "<< this << "\r\n------------------------------------------------------------------------ " << std::endl;
#endif
}


RegionActivationImpl::RegionActivationImpl(const RegionActivationImpl & obj): RegionActivationImpl()
{
	*this = obj;
}

RegionActivationImpl& RegionActivationImpl::operator=(const RegionActivationImpl & obj)
{
	//call overloaded =Operator for each base class
	StateMachineSemanticVisitorImpl::operator=(obj);
	/* TODO: Find out if this call is necessary
	 * Currently, this causes an error because it calls an implicit assignment operator of RegionActivation 
	 * which is generated by the compiler (as RegionActivation is an abstract class and does not have a user-defined assignment operator).
	 * Implicit compiler-generated assignment operators however only create shallow copies of members,
	 * which implies, that not a real deep copy is created when using the copy()-method.
	 * 
	 * NOTE: Since all members are deep-copied by this assignment-operator anyway, why is it even necessary to call this implicit assignment-operator?
	 * This is only done for ecore-models, not for UML-models.
	 */
	//RegionActivation::operator=(obj);

	//create copy of all Attributes
	#ifdef SHOW_COPIES
	std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\ncopy RegionActivation "<< this << "\r\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ " << std::endl;
	#endif
	//Clone Attributes with (deep copy)
	m_isCompleted = obj.getIsCompleted();

	//copy references with no containment (soft copy)
	m_history  = obj.getHistory();
	//Clone references with containment (deep copy)
	//clone reference 'transitionActivations'
	const std::shared_ptr<Bag<PSSM::Semantics::StateMachines::TransitionActivation>>& transitionActivationsList = obj.getTransitionActivations();
	if(transitionActivationsList)
	{
		m_transitionActivations.reset(new Bag<PSSM::Semantics::StateMachines::TransitionActivation>());
		
		
		for(const std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation>& transitionActivationsindexElem: *transitionActivationsList) 
		{
			const std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation>& temp = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::TransitionActivation>((transitionActivationsindexElem)->copy());
			m_transitionActivations->push_back(temp);
		}
	}
	else
	{
		DEBUG_WARNING("container is nullptr for transitionActivations.")
	}

	//clone reference 'vertexActivations'
	const std::shared_ptr<Bag<PSSM::Semantics::StateMachines::VertexActivation>>& vertexActivationsList = obj.getVertexActivations();
	if(vertexActivationsList)
	{
		m_vertexActivations.reset(new Bag<PSSM::Semantics::StateMachines::VertexActivation>());
		
		
		for(const std::shared_ptr<PSSM::Semantics::StateMachines::VertexActivation>& vertexActivationsindexElem: *vertexActivationsList) 
		{
			const std::shared_ptr<PSSM::Semantics::StateMachines::VertexActivation>& temp = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::VertexActivation>((vertexActivationsindexElem)->copy());
			m_vertexActivations->push_back(temp);
		}
	}
	else
	{
		DEBUG_WARNING("container is nullptr for vertexActivations.")
	}
	
	
	return *this;
}

std::shared_ptr<ecore::EObject> RegionActivationImpl::copy() const
{
	std::shared_ptr<RegionActivationImpl> element(new RegionActivationImpl());
	*element =(*this);
	element->setThisRegionActivationPtr(element);
	return element;
}

//*********************************
// Operations
//*********************************




bool RegionActivationImpl::canPropagateExecution(const std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation>& enteringTransition, const std::shared_ptr<fUML::Semantics::CommonBehavior::EventOccurrence>& eventOccurrence)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	// Check if given Transition enters a Vertex of this Region
	bool propagate = true;
	if (this->getVertexActivation(std::dynamic_pointer_cast<uml::Vertex>(enteringTransition->getTargetActivation()->getNode())) == nullptr)
	{
		auto initialPSActivation = this->getOrigin();
		if (initialPSActivation != nullptr)
		{
			propagate = initialPSActivation->canPropagateExecution(enteringTransition, eventOccurrence, nullptr);
		}
	}
	return propagate;
	//end of body
}

void RegionActivationImpl::enter(const std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation>& enteringTransition, const std::shared_ptr<fUML::Semantics::CommonBehavior::EventOccurrence>& eventOccurrence)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	// If a Region is entered implicitly, its execution will start at the InitialPseudoState it owns by fireing the transition to the InitialPseudoState. If no such InitialPseudoState exists, the propagation of the Transition path is invalid for this region, thus it will not be entered. 
	// In case the Region is not entered, its Activation will be removed from an owning State's set of RegionActivations to complete. Should this be the last Region to be completed, the State will be notified as completed itself.
	auto initialPSActivation = this->getOrigin();
	if (initialPSActivation != nullptr) 
	{
		initialPSActivation->enter(enteringTransition, eventOccurrence, nullptr);
	}
	else
	{
		if (const auto& parentStateActivation = std::dynamic_pointer_cast<StateActivation>(this->getParent()))
		{
			parentStateActivation->getRegionActivations()->erase(this->getThisRegionActivationPtr());
			if(parentStateActivation->hasCompleted())
			{
				parentStateActivation->notifyCompletion();
			}
		}
	}
	//end of body
}

void RegionActivationImpl::exit(const std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation>& exitingTransition, const std::shared_ptr<fUML::Semantics::CommonBehavior::EventOccurrence>& eventOccurrence)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	// Exiting a Region implies exiting all of is active Vertices.
	// Note: There is always a single active Vertex for a given Region.
	//for (int i = 0; i < int(m_vertexActivations->size()); ++i)
	for (const auto& vertexActivation : *this->getVertexActivations())
	{
		if (vertexActivation->isActive())
		{
			vertexActivation->exit(exitingTransition, eventOccurrence, nullptr);
		}
	}
	this->setIsCompleted(false);
	//end of body
}

std::shared_ptr<PSSM::Semantics::StateMachines::InitialPseudostateActivation> RegionActivationImpl::getOrigin()
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	// Return, if any, the initial pseudo-state activation directly
	// owned by this region.
	for (const auto& vertexActivation : *(this->m_vertexActivations))
	{
		if (const auto& initialPSActivation = std::dynamic_pointer_cast<InitialPseudostateActivation>(vertexActivation))
		{
			return initialPSActivation;
		}
	}
	return nullptr;
	//end of body
}



std::shared_ptr<PSSM::Semantics::StateMachines::VertexActivation> RegionActivationImpl::getVertexActivation(const std::shared_ptr<uml::Vertex>& vertex)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	// Recursive search through the hierarchy of Visitors materializing
	// the subset of the StateMachine represented by this Region.
	// The search is realized similar to a breadth-first search:
	// 	1 - Search a matching Activation in set of VertexActivations owned by this RegionActivation
	//  2 - If no match, then the search call is propagated to each VertexActivation owned by this RegionActivation
	// Matching rules (or):
	//  1 - The node for which this Activation is an interpreter is the Vertex.
	//  2 - The node for which this Activation is an interpreter redefines the Vertex 
	for (const auto& vertexActivation : *this->getVertexActivations())
	{
		if(vertexActivation->isVisitorFor(vertex))
		{
			return vertexActivation;
		}
	}
	for (const auto& vertexActivation : *this->getVertexActivations())
	{
		if(vertexActivation->isVisitorFor(vertex))
		{
			return vertexActivation;
		}
		else if (const auto& compositeStateVertexActivation = vertexActivation->getVertexActivation(vertex))
		{
			return compositeStateVertexActivation;
		}
	}
	return nullptr;
	//end of body
}



bool RegionActivationImpl::isRedefined(const std::shared_ptr<Bag<uml::Vertex>>& vertices, const std::shared_ptr<uml::Vertex>& vertex)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	// Depth-first Check if given Vertex is redefined by another Vertex of given list. The only redefinable Vertex is the State.
	for (auto& currentVertex : *vertices)
	{
		if (auto currentState = std::dynamic_pointer_cast<uml::State>(currentVertex))
		{
			auto redefinedState = currentState->getRedefinedState();
			while (redefinedState != nullptr) 
			{
				if (redefinedState == vertex) 
				{
					return true;
				}
			}
		}
	}
	return false;
	//end of body
}

bool RegionActivationImpl::isRedefined(const std::shared_ptr<Bag<uml::Transition>>& transitions, const std::shared_ptr<uml::Transition>& transition)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	// Depth-first Check if given Transition is redefined by another Transition of given list.
	for (const auto& currentTransition : *transitions)
	{
		auto redefinedTransition = currentTransition->getRedefinedTransition();
		while (redefinedTransition != nullptr) 
		{
			if (redefinedTransition == transition) 
				return true;
			else 
				redefinedTransition = currentTransition->getRedefinedTransition();
		}
	}
	return false;
	//end of body
}

void RegionActivationImpl::terminate()
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	// Capture the semantics related to the termination of a Region. Regions typically
	// get terminated when the owning StateMachine terminates.
	this->setIsCompleted(false);
	for (const auto& vertexActivation : *m_vertexActivations) 
	{
		vertexActivation->terminate();
	}
	//end of body
}

//*********************************
// Attribute Getters & Setters
//*********************************
/* Getter & Setter for attribute isCompleted */
bool RegionActivationImpl::getIsCompleted() const 
{
	return m_isCompleted;
}
void RegionActivationImpl::setIsCompleted(bool _isCompleted)
{
	//generated from setterBody annotation
	m_isCompleted = _isCompleted;
	if (_isCompleted) this->getStateMachineExecution()->getConditionVariable()->notify_one();  
	//end of body
}

//*********************************
// Reference Getters & Setters
//*********************************
/* Getter & Setter for reference history */
const std::shared_ptr<PSSM::Semantics::StateMachines::StateActivation>& RegionActivationImpl::getHistory() const
{
    return m_history;
}
void RegionActivationImpl::setHistory(const std::shared_ptr<PSSM::Semantics::StateMachines::StateActivation>& _history)
{
    m_history = _history;
	
}

/* Getter & Setter for reference transitionActivations */
const std::shared_ptr<Bag<PSSM::Semantics::StateMachines::TransitionActivation>>& RegionActivationImpl::getTransitionActivations() const
{
	if(m_transitionActivations == nullptr)
	{
		m_transitionActivations.reset(new Bag<PSSM::Semantics::StateMachines::TransitionActivation>());
		
		
	}
    return m_transitionActivations;
}

/* Getter & Setter for reference vertexActivations */
const std::shared_ptr<Bag<PSSM::Semantics::StateMachines::VertexActivation>>& RegionActivationImpl::getVertexActivations() const
{
	if(m_vertexActivations == nullptr)
	{
		m_vertexActivations.reset(new Bag<PSSM::Semantics::StateMachines::VertexActivation>());
		
		
	}
    return m_vertexActivations;
}

//*********************************
// Union Getter
//*********************************

//*********************************
// Container Getter
//*********************************
std::shared_ptr<ecore::EObject> RegionActivationImpl::eContainer() const
{
	return nullptr;
}

//*********************************
// Persistence Functions
//*********************************
void RegionActivationImpl::load(std::shared_ptr<persistence::interfaces::XLoadHandler> loadHandler)
{
	std::map<std::string, std::string> attr_list = loadHandler->getAttributeList();
	loadAttributes(loadHandler, attr_list);

	//
	// Create new objects (from references (containment == true))
	//
	// get PSSMFactory
	int numNodes = loadHandler->getNumOfChildNodes();
	for(int ii = 0; ii < numNodes; ii++)
	{
		loadNode(loadHandler->getNextNodeName(), loadHandler);
	}
}		

void RegionActivationImpl::loadAttributes(std::shared_ptr<persistence::interfaces::XLoadHandler> loadHandler, std::map<std::string, std::string> attr_list)
{
	try
	{
		std::map<std::string, std::string>::const_iterator iter;
	
		iter = attr_list.find("isCompleted");
		if ( iter != attr_list.end() )
		{
			// this attribute is a 'bool'
			bool value;
			std::istringstream(iter->second) >> std::boolalpha >> value;
			this->setIsCompleted(value);
		}
		std::shared_ptr<ecore::EClass> metaClass = this->eClass(); // get MetaClass
		iter = attr_list.find("history");
		if ( iter != attr_list.end() )
		{
			// add unresolvedReference to loadHandler's list
			loadHandler->addUnresolvedReference(iter->second, loadHandler->getCurrentObject(), metaClass->getEStructuralFeature("history")); // TODO use getEStructuralFeature() with id, for faster access to EStructuralFeature
		}
	}
	catch (std::exception& e)
	{
		std::cout << "| ERROR    | " << e.what() << std::endl;
	}
	catch (...) 
	{
		std::cout << "| ERROR    | " <<  "Exception occurred" << std::endl;
	}

	StateMachineSemanticVisitorImpl::loadAttributes(loadHandler, attr_list);
}

void RegionActivationImpl::loadNode(std::string nodeName, std::shared_ptr<persistence::interfaces::XLoadHandler> loadHandler)
{

	try
	{
		if ( nodeName.compare("transitionActivations") == 0 )
		{
  			std::string typeName = loadHandler->getCurrentXSITypeName();
			if (typeName.empty())
			{
				std::cout << "| WARNING    | type of an eClassifiers node is empty" << std::endl;
				return; // no type name given and reference type is abstract
			}
			else
			{
				if (std::string::npos == typeName.find("PSSM::Semantics::StateMachines/]"))
				{
					typeName = "PSSM::Semantics::StateMachines::"+typeName;
				}
			}
			std::shared_ptr<ecore::ecoreFactory> modelFactory = ecore::ecoreFactory::eInstance();		
			std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation> new_transitionActivations = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::TransitionActivation>(modelFactory->create(typeName, loadHandler->getCurrentObject(), PSSM::Semantics::StateMachines::StateMachinesPackage::REGIONACTIVATION_ATTRIBUTE_TRANSITIONACTIVATIONS));
			if(new_transitionActivations)
			{
				loadHandler->handleChild(new_transitionActivations);
				getTransitionActivations()->push_back(new_transitionActivations);
			} 

			return; 
		}

		if ( nodeName.compare("vertexActivations") == 0 )
		{
  			std::string typeName = loadHandler->getCurrentXSITypeName();
			if (typeName.empty())
			{
				std::cout << "| WARNING    | type of an eClassifiers node is empty" << std::endl;
				return; // no type name given and reference type is abstract
			}
			else
			{
				if (std::string::npos == typeName.find("PSSM::Semantics::StateMachines/]"))
				{
					typeName = "PSSM::Semantics::StateMachines::"+typeName;
				}
			}
			std::shared_ptr<ecore::ecoreFactory> modelFactory = ecore::ecoreFactory::eInstance();		
			std::shared_ptr<PSSM::Semantics::StateMachines::VertexActivation> new_vertexActivations = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::VertexActivation>(modelFactory->create(typeName, loadHandler->getCurrentObject(), PSSM::Semantics::StateMachines::StateMachinesPackage::REGIONACTIVATION_ATTRIBUTE_VERTEXACTIVATIONS));
			if(new_vertexActivations)
			{
				loadHandler->handleChild(new_vertexActivations);
				getVertexActivations()->push_back(new_vertexActivations);
			} 

			return; 
		}
	}
	catch (std::exception& e)
	{
		std::cout << "| ERROR    | " << e.what() << std::endl;
	}
	catch (...) 
	{
		std::cout << "| ERROR    | " <<  "Exception occurred" << std::endl;
	}
	//load BasePackage Nodes
	StateMachineSemanticVisitorImpl::loadNode(nodeName, loadHandler);
}

void RegionActivationImpl::resolveReferences(const int featureID, std::vector<std::shared_ptr<ecore::EObject>> references)
{
	switch(featureID)
	{
		case PSSM::Semantics::StateMachines::StateMachinesPackage::REGIONACTIVATION_ATTRIBUTE_HISTORY:
		{
			if (references.size() == 1)
			{
				// Cast object to correct type
				std::shared_ptr<PSSM::Semantics::StateMachines::StateActivation> _history = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::StateActivation>( references.front() );
				setHistory(_history);
			}
			
			return;
		}
	}
	StateMachineSemanticVisitorImpl::resolveReferences(featureID, references);
}

void RegionActivationImpl::save(std::shared_ptr<persistence::interfaces::XSaveHandler> saveHandler) const
{
	saveContent(saveHandler);

	StateMachineSemanticVisitorImpl::saveContent(saveHandler);
	
	fUML::Semantics::Loci::SemanticVisitorImpl::saveContent(saveHandler);
	
	ecore::EObjectImpl::saveContent(saveHandler);
}

void RegionActivationImpl::saveContent(std::shared_ptr<persistence::interfaces::XSaveHandler> saveHandler) const
{
	try
	{
		std::shared_ptr<PSSM::Semantics::StateMachines::StateMachinesPackage> package = PSSM::Semantics::StateMachines::StateMachinesPackage::eInstance();
		// Add attributes
          if ( this->eIsSet(package->getRegionActivation_Attribute_isCompleted()) )
          {
			saveHandler->addAttribute("isCompleted", this->getIsCompleted());
          }
	// Add references
	if ( this->eIsSet(package->getRegionActivation_Attribute_history()) )
	{
		saveHandler->addReference(this->getHistory(), "history", getHistory()->eClass() != PSSM::Semantics::StateMachines::StateMachinesPackage::eInstance()->getStateActivation_Class()); 
	}
		//
		// Add new tags (from references)
		//
		std::shared_ptr<ecore::EClass> metaClass = this->eClass();
		// Save 'transitionActivations'
	    if ( this->eIsSet(package->getRegionActivation_Attribute_transitionActivations()) )
	    {
		saveHandler->addReferences<PSSM::Semantics::StateMachines::TransitionActivation>("transitionActivations", this->getTransitionActivations());
	    }

		// Save 'vertexActivations'
	    if ( this->eIsSet(package->getRegionActivation_Attribute_vertexActivations()) )
	    {
		saveHandler->addReferences<PSSM::Semantics::StateMachines::VertexActivation>("vertexActivations", this->getVertexActivations());
	    }
	}
	catch (std::exception& e)
	{
		std::cout << "| ERROR    | " << e.what() << std::endl;
	}
}

const std::shared_ptr<ecore::EClass>& RegionActivationImpl::eStaticClass() const
{
	return PSSM::Semantics::StateMachines::StateMachinesPackage::eInstance()->getRegionActivation_Class();
}

//*********************************
// EStructuralFeature Get/Set/IsSet
//*********************************
std::shared_ptr<Any> RegionActivationImpl::eGet(int featureID, bool resolve, bool coreType) const
{
	switch(featureID)
	{
		case PSSM::Semantics::StateMachines::StateMachinesPackage::REGIONACTIVATION_ATTRIBUTE_HISTORY:
			return eAny(getHistory(),PSSM::Semantics::StateMachines::StateMachinesPackage::STATEACTIVATION_CLASS,false); //265
		case PSSM::Semantics::StateMachines::StateMachinesPackage::REGIONACTIVATION_ATTRIBUTE_ISCOMPLETED:
			return eAny(getIsCompleted(),ecore::ecorePackage::EBOOLEAN_CLASS,false); //263
		case PSSM::Semantics::StateMachines::StateMachinesPackage::REGIONACTIVATION_ATTRIBUTE_TRANSITIONACTIVATIONS:
			return eEcoreContainerAny(getTransitionActivations(),PSSM::Semantics::StateMachines::StateMachinesPackage::TRANSITIONACTIVATION_CLASS); //262
		case PSSM::Semantics::StateMachines::StateMachinesPackage::REGIONACTIVATION_ATTRIBUTE_VERTEXACTIVATIONS:
			return eEcoreContainerAny(getVertexActivations(),PSSM::Semantics::StateMachines::StateMachinesPackage::VERTEXACTIVATION_CLASS); //264
	}
	return StateMachineSemanticVisitorImpl::eGet(featureID, resolve, coreType);
}

bool RegionActivationImpl::internalEIsSet(int featureID) const
{
	switch(featureID)
	{
		case PSSM::Semantics::StateMachines::StateMachinesPackage::REGIONACTIVATION_ATTRIBUTE_HISTORY:
			return getHistory() != nullptr; //265
		case PSSM::Semantics::StateMachines::StateMachinesPackage::REGIONACTIVATION_ATTRIBUTE_ISCOMPLETED:
			return getIsCompleted() != false; //263
		case PSSM::Semantics::StateMachines::StateMachinesPackage::REGIONACTIVATION_ATTRIBUTE_TRANSITIONACTIVATIONS:
			return getTransitionActivations() != nullptr; //262
		case PSSM::Semantics::StateMachines::StateMachinesPackage::REGIONACTIVATION_ATTRIBUTE_VERTEXACTIVATIONS:
			return getVertexActivations() != nullptr; //264
	}
	return StateMachineSemanticVisitorImpl::internalEIsSet(featureID);
}

bool RegionActivationImpl::eSet(int featureID,  const std::shared_ptr<Any>& newValue)
{
	switch(featureID)
	{
		case PSSM::Semantics::StateMachines::StateMachinesPackage::REGIONACTIVATION_ATTRIBUTE_HISTORY:
		{
			std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>(newValue);
			if(ecoreAny)
			{
				try
				{
					std::shared_ptr<ecore::EObject> eObject = ecoreAny->getAsEObject();
					std::shared_ptr<PSSM::Semantics::StateMachines::StateActivation> _history = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::StateActivation>(eObject);
					if(_history)
					{
						setHistory(_history); //265
					}
					else
					{
						throw "Invalid argument";
					}
				}
				catch(...)
				{
					DEBUG_ERROR("Invalid type stored in 'ecore::ecoreAny' for feature 'history'. Failed to set feature!")
					return false;
				}
			}
			else
			{
				DEBUG_ERROR("Invalid instance of 'ecore::ecoreAny' for feature 'history'. Failed to set feature!")
				return false;
			}
		return true;
		}
		case PSSM::Semantics::StateMachines::StateMachinesPackage::REGIONACTIVATION_ATTRIBUTE_ISCOMPLETED:
		{
			try
			{
				bool _isCompleted = newValue->get<bool>();
				setIsCompleted(_isCompleted); //263
			}
			catch(...)
			{
				DEBUG_ERROR("Invalid type stored in 'Any' for feature 'isCompleted'. Failed to set feature!")
				return false;
			}
		return true;
		}
		case PSSM::Semantics::StateMachines::StateMachinesPackage::REGIONACTIVATION_ATTRIBUTE_TRANSITIONACTIVATIONS:
		{
			std::shared_ptr<ecore::EcoreContainerAny> ecoreContainerAny = std::dynamic_pointer_cast<ecore::EcoreContainerAny>(newValue);
			if(ecoreContainerAny)
			{
				try
				{
					std::shared_ptr<Bag<ecore::EObject>> eObjectList = ecoreContainerAny->getAsEObjectContainer();
	
					if(eObjectList)
					{
						const std::shared_ptr<Bag<PSSM::Semantics::StateMachines::TransitionActivation>>& _transitionActivations = getTransitionActivations();
	
						for(const std::shared_ptr<ecore::EObject>& anEObject: *eObjectList)
						{
							std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation> valueToAdd = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::TransitionActivation>(anEObject);
	
							if (valueToAdd)
							{
								if(!(_transitionActivations->includes(valueToAdd)))
								{
									_transitionActivations->add(valueToAdd);
								}
								//else, valueToAdd is already present so it won't be added again
							}
							else
							{
								throw "Invalid argument";
							}
						}
					}
				}
				catch(...)
				{
					DEBUG_ERROR("Invalid type stored in 'ecore::ecoreContainerAny' for feature 'transitionActivations'. Failed to set feature!")
					return false;
				}
			}
			else
			{
				DEBUG_ERROR("Invalid instance of 'ecore::ecoreContainerAny' for feature 'transitionActivations'. Failed to set feature!")
				return false;
			}
		return true;
		}
		case PSSM::Semantics::StateMachines::StateMachinesPackage::REGIONACTIVATION_ATTRIBUTE_VERTEXACTIVATIONS:
		{
			std::shared_ptr<ecore::EcoreContainerAny> ecoreContainerAny = std::dynamic_pointer_cast<ecore::EcoreContainerAny>(newValue);
			if(ecoreContainerAny)
			{
				try
				{
					std::shared_ptr<Bag<ecore::EObject>> eObjectList = ecoreContainerAny->getAsEObjectContainer();
	
					if(eObjectList)
					{
						const std::shared_ptr<Bag<PSSM::Semantics::StateMachines::VertexActivation>>& _vertexActivations = getVertexActivations();
	
						for(const std::shared_ptr<ecore::EObject>& anEObject: *eObjectList)
						{
							std::shared_ptr<PSSM::Semantics::StateMachines::VertexActivation> valueToAdd = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::VertexActivation>(anEObject);
	
							if (valueToAdd)
							{
								if(!(_vertexActivations->includes(valueToAdd)))
								{
									_vertexActivations->add(valueToAdd);
								}
								//else, valueToAdd is already present so it won't be added again
							}
							else
							{
								throw "Invalid argument";
							}
						}
					}
				}
				catch(...)
				{
					DEBUG_ERROR("Invalid type stored in 'ecore::ecoreContainerAny' for feature 'vertexActivations'. Failed to set feature!")
					return false;
				}
			}
			else
			{
				DEBUG_ERROR("Invalid instance of 'ecore::ecoreContainerAny' for feature 'vertexActivations'. Failed to set feature!")
				return false;
			}
		return true;
		}
	}

	return StateMachineSemanticVisitorImpl::eSet(featureID, newValue);
}

//*********************************
// EOperation Invoke
//*********************************
std::shared_ptr<Any> RegionActivationImpl::eInvoke(int operationID, const std::shared_ptr<Bag<Any>>& arguments)
{
	std::shared_ptr<Any> result;
 
  	switch(operationID)
	{
		// PSSM::Semantics::StateMachines::RegionActivation::canPropagateExecution(PSSM::Semantics::StateMachines::TransitionActivation, fUML::Semantics::CommonBehavior::EventOccurrence) : bool: 1102738232
		case StateMachinesPackage::REGIONACTIVATION_OPERATION_CANPROPAGATEEXECUTION_TRANSITIONACTIVATION_EVENTOCCURRENCE:
		{
			//Retrieve input parameter 'enteringTransition'
			//parameter 0
			std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation> incoming_param_enteringTransition;
			Bag<Any>::const_iterator incoming_param_enteringTransition_arguments_citer = std::next(arguments->begin(), 0);
			{
				std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>((*incoming_param_enteringTransition_arguments_citer));
				if(ecoreAny)
				{
					try
					{
						std::shared_ptr<ecore::EObject> _temp = ecoreAny->getAsEObject();
						incoming_param_enteringTransition = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::TransitionActivation>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreAny' for parameter 'enteringTransition'. Failed to invoke operation 'canPropagateExecution'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreAny' for parameter 'enteringTransition'. Failed to invoke operation 'canPropagateExecution'!")
					return nullptr;
				}
			}
		
			//Retrieve input parameter 'eventOccurrence'
			//parameter 1
			std::shared_ptr<fUML::Semantics::CommonBehavior::EventOccurrence> incoming_param_eventOccurrence;
			Bag<Any>::const_iterator incoming_param_eventOccurrence_arguments_citer = std::next(arguments->begin(), 1);
			{
				std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>((*incoming_param_eventOccurrence_arguments_citer));
				if(ecoreAny)
				{
					try
					{
						std::shared_ptr<ecore::EObject> _temp = ecoreAny->getAsEObject();
						incoming_param_eventOccurrence = std::dynamic_pointer_cast<fUML::Semantics::CommonBehavior::EventOccurrence>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreAny' for parameter 'eventOccurrence'. Failed to invoke operation 'canPropagateExecution'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreAny' for parameter 'eventOccurrence'. Failed to invoke operation 'canPropagateExecution'!")
					return nullptr;
				}
			}
		
			result = eAny(this->canPropagateExecution(incoming_param_enteringTransition,incoming_param_eventOccurrence), 0, false);
			break;
		}
		// PSSM::Semantics::StateMachines::RegionActivation::enter(PSSM::Semantics::StateMachines::TransitionActivation, fUML::Semantics::CommonBehavior::EventOccurrence): 3653178107
		case StateMachinesPackage::REGIONACTIVATION_OPERATION_ENTER_TRANSITIONACTIVATION_EVENTOCCURRENCE:
		{
			//Retrieve input parameter 'enteringTransition'
			//parameter 0
			std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation> incoming_param_enteringTransition;
			Bag<Any>::const_iterator incoming_param_enteringTransition_arguments_citer = std::next(arguments->begin(), 0);
			{
				std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>((*incoming_param_enteringTransition_arguments_citer));
				if(ecoreAny)
				{
					try
					{
						std::shared_ptr<ecore::EObject> _temp = ecoreAny->getAsEObject();
						incoming_param_enteringTransition = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::TransitionActivation>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreAny' for parameter 'enteringTransition'. Failed to invoke operation 'enter'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreAny' for parameter 'enteringTransition'. Failed to invoke operation 'enter'!")
					return nullptr;
				}
			}
		
			//Retrieve input parameter 'eventOccurrence'
			//parameter 1
			std::shared_ptr<fUML::Semantics::CommonBehavior::EventOccurrence> incoming_param_eventOccurrence;
			Bag<Any>::const_iterator incoming_param_eventOccurrence_arguments_citer = std::next(arguments->begin(), 1);
			{
				std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>((*incoming_param_eventOccurrence_arguments_citer));
				if(ecoreAny)
				{
					try
					{
						std::shared_ptr<ecore::EObject> _temp = ecoreAny->getAsEObject();
						incoming_param_eventOccurrence = std::dynamic_pointer_cast<fUML::Semantics::CommonBehavior::EventOccurrence>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreAny' for parameter 'eventOccurrence'. Failed to invoke operation 'enter'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreAny' for parameter 'eventOccurrence'. Failed to invoke operation 'enter'!")
					return nullptr;
				}
			}
		
			this->enter(incoming_param_enteringTransition,incoming_param_eventOccurrence);
			break;
		}
		// PSSM::Semantics::StateMachines::RegionActivation::exit(PSSM::Semantics::StateMachines::TransitionActivation, fUML::Semantics::CommonBehavior::EventOccurrence): 2256684395
		case StateMachinesPackage::REGIONACTIVATION_OPERATION_EXIT_TRANSITIONACTIVATION_EVENTOCCURRENCE:
		{
			//Retrieve input parameter 'exitingTransition'
			//parameter 0
			std::shared_ptr<PSSM::Semantics::StateMachines::TransitionActivation> incoming_param_exitingTransition;
			Bag<Any>::const_iterator incoming_param_exitingTransition_arguments_citer = std::next(arguments->begin(), 0);
			{
				std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>((*incoming_param_exitingTransition_arguments_citer));
				if(ecoreAny)
				{
					try
					{
						std::shared_ptr<ecore::EObject> _temp = ecoreAny->getAsEObject();
						incoming_param_exitingTransition = std::dynamic_pointer_cast<PSSM::Semantics::StateMachines::TransitionActivation>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreAny' for parameter 'exitingTransition'. Failed to invoke operation 'exit'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreAny' for parameter 'exitingTransition'. Failed to invoke operation 'exit'!")
					return nullptr;
				}
			}
		
			//Retrieve input parameter 'eventOccurrence'
			//parameter 1
			std::shared_ptr<fUML::Semantics::CommonBehavior::EventOccurrence> incoming_param_eventOccurrence;
			Bag<Any>::const_iterator incoming_param_eventOccurrence_arguments_citer = std::next(arguments->begin(), 1);
			{
				std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>((*incoming_param_eventOccurrence_arguments_citer));
				if(ecoreAny)
				{
					try
					{
						std::shared_ptr<ecore::EObject> _temp = ecoreAny->getAsEObject();
						incoming_param_eventOccurrence = std::dynamic_pointer_cast<fUML::Semantics::CommonBehavior::EventOccurrence>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreAny' for parameter 'eventOccurrence'. Failed to invoke operation 'exit'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreAny' for parameter 'eventOccurrence'. Failed to invoke operation 'exit'!")
					return nullptr;
				}
			}
		
			this->exit(incoming_param_exitingTransition,incoming_param_eventOccurrence);
			break;
		}
		// PSSM::Semantics::StateMachines::RegionActivation::getOrigin() : PSSM::Semantics::StateMachines::InitialPseudostateActivation: 2233447196
		case StateMachinesPackage::REGIONACTIVATION_OPERATION_GETORIGIN:
		{
			result = eEcoreAny(this->getOrigin(), PSSM::Semantics::StateMachines::StateMachinesPackage::INITIALPSEUDOSTATEACTIVATION_CLASS);
			break;
		}
		// PSSM::Semantics::StateMachines::RegionActivation::getVertexActivation(uml::Vertex) : PSSM::Semantics::StateMachines::VertexActivation: 1788635095
		case StateMachinesPackage::REGIONACTIVATION_OPERATION_GETVERTEXACTIVATION_VERTEX:
		{
			//Retrieve input parameter 'vertex'
			//parameter 0
			std::shared_ptr<uml::Vertex> incoming_param_vertex;
			Bag<Any>::const_iterator incoming_param_vertex_arguments_citer = std::next(arguments->begin(), 0);
			{
				std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>((*incoming_param_vertex_arguments_citer));
				if(ecoreAny)
				{
					try
					{
						std::shared_ptr<ecore::EObject> _temp = ecoreAny->getAsEObject();
						incoming_param_vertex = std::dynamic_pointer_cast<uml::Vertex>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreAny' for parameter 'vertex'. Failed to invoke operation 'getVertexActivation'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreAny' for parameter 'vertex'. Failed to invoke operation 'getVertexActivation'!")
					return nullptr;
				}
			}
		
			result = eEcoreAny(this->getVertexActivation(incoming_param_vertex), PSSM::Semantics::StateMachines::StateMachinesPackage::VERTEXACTIVATION_CLASS);
			break;
		}
		// PSSM::Semantics::StateMachines::RegionActivation::isRedefined(uml::Vertex[*], uml::Vertex) : bool: 3308766828
		case StateMachinesPackage::REGIONACTIVATION_OPERATION_ISREDEFINED_VERTEX_VERTEX:
		{
			//Retrieve input parameter 'vertices'
			//parameter 0
			std::shared_ptr<Bag<uml::Vertex>> incoming_param_vertices;
			Bag<Any>::const_iterator incoming_param_vertices_arguments_citer = std::next(arguments->begin(), 0);
			{
				std::shared_ptr<ecore::EcoreContainerAny> ecoreContainerAny = std::dynamic_pointer_cast<ecore::EcoreContainerAny>((*incoming_param_vertices_arguments_citer));
				if(ecoreContainerAny)
				{
					try
					{
						std::shared_ptr<Bag<ecore::EObject>> eObjectList = ecoreContainerAny->getAsEObjectContainer();
				
						if(eObjectList)
						{
							incoming_param_vertices.reset();
							for(const std::shared_ptr<ecore::EObject> anEObject: *eObjectList)
							{
								std::shared_ptr<uml::Vertex> _temp = std::dynamic_pointer_cast<uml::Vertex>(anEObject);
								incoming_param_vertices->add(_temp);
							}
						}
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreContainerAny' for parameter 'vertices'. Failed to invoke operation 'isRedefined'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreContainerAny' for parameter 'vertices'. Failed to invoke operation 'isRedefined'!")
					return nullptr;
				}
			}
		
			//Retrieve input parameter 'vertex'
			//parameter 1
			std::shared_ptr<uml::Vertex> incoming_param_vertex;
			Bag<Any>::const_iterator incoming_param_vertex_arguments_citer = std::next(arguments->begin(), 1);
			{
				std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>((*incoming_param_vertex_arguments_citer));
				if(ecoreAny)
				{
					try
					{
						std::shared_ptr<ecore::EObject> _temp = ecoreAny->getAsEObject();
						incoming_param_vertex = std::dynamic_pointer_cast<uml::Vertex>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreAny' for parameter 'vertex'. Failed to invoke operation 'isRedefined'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreAny' for parameter 'vertex'. Failed to invoke operation 'isRedefined'!")
					return nullptr;
				}
			}
		
			result = eAny(this->isRedefined(incoming_param_vertices,incoming_param_vertex), 0, false);
			break;
		}
		// PSSM::Semantics::StateMachines::RegionActivation::isRedefined(uml::Transition[*], uml::Transition) : bool: 2625455814
		case StateMachinesPackage::REGIONACTIVATION_OPERATION_ISREDEFINED_TRANSITION_TRANSITION:
		{
			//Retrieve input parameter 'transitions'
			//parameter 0
			std::shared_ptr<Bag<uml::Transition>> incoming_param_transitions;
			Bag<Any>::const_iterator incoming_param_transitions_arguments_citer = std::next(arguments->begin(), 0);
			{
				std::shared_ptr<ecore::EcoreContainerAny> ecoreContainerAny = std::dynamic_pointer_cast<ecore::EcoreContainerAny>((*incoming_param_transitions_arguments_citer));
				if(ecoreContainerAny)
				{
					try
					{
						std::shared_ptr<Bag<ecore::EObject>> eObjectList = ecoreContainerAny->getAsEObjectContainer();
				
						if(eObjectList)
						{
							incoming_param_transitions.reset();
							for(const std::shared_ptr<ecore::EObject> anEObject: *eObjectList)
							{
								std::shared_ptr<uml::Transition> _temp = std::dynamic_pointer_cast<uml::Transition>(anEObject);
								incoming_param_transitions->add(_temp);
							}
						}
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreContainerAny' for parameter 'transitions'. Failed to invoke operation 'isRedefined'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreContainerAny' for parameter 'transitions'. Failed to invoke operation 'isRedefined'!")
					return nullptr;
				}
			}
		
			//Retrieve input parameter 'transition'
			//parameter 1
			std::shared_ptr<uml::Transition> incoming_param_transition;
			Bag<Any>::const_iterator incoming_param_transition_arguments_citer = std::next(arguments->begin(), 1);
			{
				std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>((*incoming_param_transition_arguments_citer));
				if(ecoreAny)
				{
					try
					{
						std::shared_ptr<ecore::EObject> _temp = ecoreAny->getAsEObject();
						incoming_param_transition = std::dynamic_pointer_cast<uml::Transition>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreAny' for parameter 'transition'. Failed to invoke operation 'isRedefined'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreAny' for parameter 'transition'. Failed to invoke operation 'isRedefined'!")
					return nullptr;
				}
			}
		
			result = eAny(this->isRedefined(incoming_param_transitions,incoming_param_transition), 0, false);
			break;
		}
		// PSSM::Semantics::StateMachines::RegionActivation::terminate(): 2364559763
		case StateMachinesPackage::REGIONACTIVATION_OPERATION_TERMINATE:
		{
			this->terminate();
			break;
		}

		default:
		{
			// call superTypes
			result = StateMachineSemanticVisitorImpl::eInvoke(operationID, arguments);
			if (result && !result->isEmpty())
				break;
			break;
		}
  	}

	return result;
}

std::shared_ptr<PSSM::Semantics::StateMachines::RegionActivation> RegionActivationImpl::getThisRegionActivationPtr() const
{
	return m_thisRegionActivationPtr.lock();
}
void RegionActivationImpl::setThisRegionActivationPtr(std::weak_ptr<PSSM::Semantics::StateMachines::RegionActivation> thisRegionActivationPtr)
{
	m_thisRegionActivationPtr = thisRegionActivationPtr;
	setThisStateMachineSemanticVisitorPtr(thisRegionActivationPtr);
}


