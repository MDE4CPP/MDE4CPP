/*
 * MDE4CPP - Model Driven Engineering for C++
 *
 * Copyright (c) TU Ilmenau, Systems and Software Engineering Group
 * All rights reserved.
 *
 * MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this
 * software and associated documentation files (the "Software"), to deal in the Software
 * without restriction, including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons
 * to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or
 * substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
 * FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
plugins{
	id "tui.sse.mde4cpp.MDE4CPPCompile" version "0.6"	
}
import org.gradle.internal.os.OperatingSystem;

description "Build task for project: pluginFramework"

task deliverPluginFrameworkInterface(type: Copy) {
	group 'pluginFramework'
	description 'deliver pluginFramework interface header to %MDE4CPP_HOME%/application/include/pluginFramework'
	
	from ('src/pluginFramework') {
		include '*.hpp'
		exclude '**/*/.gradle', '**/*/.cmake', '**/*/impl', 'PluginFramework.cpp'
	}
	
	into file([rootDir,'application','include',project.name].join(File.separator))
	
	inputs.files(fileTree(['src',project.name].join(File.separator)){exclude '**/.cmake/'})
	
	//redundant dir - Copy task adds 'from' directory to the outputs
	outputs.files(fileTree([rootDir,'application','include',project.name].join(File.separator)))
	outputs.dir([rootDir,'application','include',project.name].join(File.separator))
}

task compilePluginFramework(type: tui.sse.mde4cpp.MDE4CPPCompile) {
	group "pluginFramework"
	description "compile pluginFramework"
	
	projectFolder = file('src/pluginFramework')
	
	inputs.files(fileTree('.') {
        exclude 'src/pluginFramework/.cmake/**'
    })
   
   	if(!file(['src',project.name,'.cmake'].join(File.separator)).exists()){
   	    outputs.upToDateWhen { false }
   	}
    
	if(OperatingSystem.current().isWindows()){
		if(project.hasProperty('RELEASE') && !project.property('RELEASE').equals('0')){outputs.file file([rootDir,'application','bin',project.name +       '.dll'].join(File.separator))}
		if(project.hasProperty('DEBUG') && !project.property('DEBUG').equals('0'))  {outputs.file file([rootDir,'application','bin',project.name + 'd' + '.dll'].join(File.separator))}
	}
	else if(OperatingSystem.current().isLinux()){
		if(project.hasProperty('RELEASE') && !project.property('RELEASE').equals('0')){outputs.file file([rootDir,'application','bin',project.name +       '.so'].join(File.separator))}
		if(project.hasProperty('DEBUG') && !project.property('DEBUG').equals('0'))  {outputs.file file([rootDir,'application','bin',project.name + 'd' + '.so'].join(File.separator))}
	}
	else if(OperatingSystem.current().isMacOsX()){
		if(project.hasProperty('RELEASE') && !project.property('RELEASE').equals('0')){outputs.file file([rootDir,'application','bin',project.name +       '.dylib'].join(File.separator))}
		if(project.hasProperty('DEBUG') && !project.property('DEBUG').equals('0'))  {outputs.file file([rootDir,'application','bin',project.name + 'd' + '.dylib'].join(File.separator))}
	}
	else {
	    //not supported os
	}
}

task clean {
	description 'Extension of gradle built-in task:clean'
	
	doLast {
		def dot_cmake = file('src/pluginFramework/.cmake')
		if(dot_cmake.exists()){
			delete dot_cmake.absolutePath
			println "deleting: " + dot_cmake.absolutePath
		}
		
		compilePluginFramework.outputs.files.each{
			if(it.exists()){
				delete it.absolutePath
			    println "deleting: " + it
			}
  		}
  		
  		deliverPluginFrameworkInterface.outputs.files.each{
			if(it.exists()){
				delete it.absolutePath
			    println "deleting: " + it
			}
  		}
	}
}

//EOF
