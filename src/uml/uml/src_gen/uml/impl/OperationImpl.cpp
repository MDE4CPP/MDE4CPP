
#include "uml/impl/OperationImpl.hpp"
#ifdef NDEBUG
	#define DEBUG_INFO(a)		/**/
	#define DEBUG_WARNING(a)	/**/
	#define DEBUG_ERROR(a)		/**/
#else
	#define DEBUG_INFO(a) 		std::cout<<"[\e[0;32mInfo\e[0m]:\t\t"<<__PRETTY_FUNCTION__<<"\n\t\t  -- Message: "<<a<<std::endl;
	#define DEBUG_WARNING(a) 	std::cout<<"[\e[0;33mWarning\e[0m]:\t"<<__PRETTY_FUNCTION__<<"\n\t\t  -- Message: "<<a<<std::endl;
	#define DEBUG_ERROR(a)		std::cout<<"[\e[0;31mError\e[0m]:\t"<<__PRETTY_FUNCTION__<<"\n\t\t  -- Message: "<<a<<std::endl;
#endif

#ifdef ACTIVITY_DEBUG_ON
    #define ACT_DEBUG(a) a
#else
    #define ACT_DEBUG(a) /**/
#endif

//#include "util/ProfileCallCount.hpp"

#include <cassert>
#include <iostream>
#include <sstream>
#include <stdexcept>
#include "abstractDataTypes/SubsetUnion.hpp"


#include "ecore/EcoreAny.hpp"
#include "ecore/EcoreContainerAny.hpp"
#include "abstractDataTypes/SubsetUnion.hpp"
#include "ecore/EAnnotation.hpp"
#include "ecore/EClass.hpp"
#include "ecore/EAttribute.hpp"
#include "ecore/EStructuralFeature.hpp"
#include "ecore/ecorePackage.hpp"
//Forward declaration includes
#include "persistence/interfaces/XLoadHandler.hpp" // used for Persistence
#include "persistence/interfaces/XSaveHandler.hpp" // used for Persistence

#include <exception> // used in Persistence
#include "uml/umlFactory.hpp"
#include "uml/Behavior.hpp"
#include "uml/BehavioralFeature.hpp"
#include "uml/Class.hpp"
#include "uml/Classifier.hpp"
#include "uml/Comment.hpp"
#include "uml/Constraint.hpp"
#include "uml/DataType.hpp"
#include "uml/Dependency.hpp"
#include "uml/Element.hpp"
#include "uml/ElementImport.hpp"
#include "uml/Interface.hpp"
#include "uml/NamedElement.hpp"
#include "uml/Namespace.hpp"
#include "uml/Operation.hpp"
#include "uml/PackageImport.hpp"
#include "uml/PackageableElement.hpp"
#include "uml/Parameter.hpp"
#include "uml/ParameterSet.hpp"
#include "uml/ParameterableElement.hpp"
#include "uml/RedefinableElement.hpp"
#include "uml/StringExpression.hpp"
#include "uml/TemplateBinding.hpp"
#include "uml/TemplateParameter.hpp"
#include "uml/TemplateSignature.hpp"
#include "uml/TemplateableElement.hpp"
#include "uml/Type.hpp"
//Factories and Package includes
#include "uml/umlPackage.hpp"

using namespace uml;

//*********************************
// Constructor / Destructor
//*********************************
OperationImpl::OperationImpl()
{	
	/*
	NOTE: Due to virtual inheritance, base class constrcutors may not be called correctly
	*/
}

OperationImpl::~OperationImpl()
{
#ifdef SHOW_DELETION
	std::cout << "-------------------------------------------------------------------------------------------------\r\ndelete Operation "<< this << "\r\n------------------------------------------------------------------------ " << std::endl;
#endif
}

//Additional constructor for the containments back reference
OperationImpl::OperationImpl(std::weak_ptr<uml::Class> par_class)
:OperationImpl()
{
	m_class = par_class;
	m_namespace = par_class;
}

//Additional constructor for the containments back reference
OperationImpl::OperationImpl(std::weak_ptr<uml::DataType> par_datatype)
:OperationImpl()
{
	m_datatype = par_datatype;
	m_namespace = par_datatype;
}

//Additional constructor for the containments back reference
OperationImpl::OperationImpl(std::weak_ptr<uml::Interface> par_interface)
:OperationImpl()
{
	m_interface = par_interface;
	m_namespace = par_interface;
}

//Additional constructor for the containments back reference
OperationImpl::OperationImpl(std::weak_ptr<uml::Namespace> par_namespace)
:OperationImpl()
{
	m_namespace = par_namespace;
	m_owner = par_namespace;
}

//Additional constructor for the containments back reference
OperationImpl::OperationImpl(std::weak_ptr<uml::Element> par_owner)
:OperationImpl()
{
	m_owner = par_owner;
}

//Additional constructor for the containments back reference
OperationImpl::OperationImpl(std::weak_ptr<uml::TemplateParameter> par_owningTemplateParameter)
:OperationImpl()
{
	m_owningTemplateParameter = par_owningTemplateParameter;
	m_owner = par_owningTemplateParameter;
}

OperationImpl::OperationImpl(const OperationImpl & obj): OperationImpl()
{
	*this = obj;
}

OperationImpl& OperationImpl::operator=(const OperationImpl & obj)
{
	//call overloaded =Operator for each base class
	BehavioralFeatureImpl::operator=(obj);
	ParameterableElementImpl::operator=(obj);
	TemplateableElementImpl::operator=(obj);
	/* TODO: Find out if this call is necessary
	 * Currently, this causes an error because it calls an implicit assignment operator of Operation 
	 * which is generated by the compiler (as Operation is an abstract class and does not have a user-defined assignment operator).
	 * Implicit compiler-generated assignment operators however only create shallow copies of members,
	 * which implies, that not a real deep copy is created when using the copy()-method.
	 * 
	 * NOTE: Since all members are deep-copied by this assignment-operator anyway, why is it even necessary to call this implicit assignment-operator?
	 * This is only done for ecore-models, not for UML-models.
	 */
	//Operation::operator=(obj);

	//create copy of all Attributes
	#ifdef SHOW_COPIES
	std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\ncopy Operation "<< this << "\r\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ " << std::endl;
	#endif
	//Clone Attributes with (deep copy)
	m_isOrdered = obj.getIsOrdered();
	m_isQuery = obj.getIsQuery();
	m_isUnique = obj.getIsUnique();
	m_lower = obj.getLower();
	m_upper = obj.getUpper();

	//copy references with no containment (soft copy)
	m_class  = obj.getClass();
	m_datatype  = obj.getDatatype();
	m_interface  = obj.getInterface();
	m_type  = obj.getType();
	//Clone references with containment (deep copy)
	//clone reference 'bodyCondition'
	if(obj.getBodyCondition()!=nullptr)
	{
		m_bodyCondition = std::dynamic_pointer_cast<uml::Constraint>(obj.getBodyCondition()->copy());
	}

	//clone reference 'postcondition'
	std::shared_ptr<Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/>> postconditionList = obj.getPostcondition();
	if(postconditionList)
	{
		/*Subset*/
		m_postcondition.reset(new Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/ >());
		#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising shared pointer Subset: " << "m_postcondition - Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/ >()" << std::endl;
		#endif
		
		/*Subset*/
		getPostcondition()->initSubset(getOwnedRule());
		#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising value Subset: " << "m_postcondition - Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/ >(getOwnedRule())" << std::endl;
		#endif
		
		for(const std::shared_ptr<uml::Constraint>& postconditionindexElem: *postconditionList) 
		{
			std::shared_ptr<uml::Constraint> temp = std::dynamic_pointer_cast<uml::Constraint>((postconditionindexElem)->copy());
			m_postcondition->push_back(temp);
		}
	}
	else
	{
		DEBUG_WARNING("container is nullptr for postcondition.")
	}

	//clone reference 'precondition'
	std::shared_ptr<Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/>> preconditionList = obj.getPrecondition();
	if(preconditionList)
	{
		/*Subset*/
		m_precondition.reset(new Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/ >());
		#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising shared pointer Subset: " << "m_precondition - Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/ >()" << std::endl;
		#endif
		
		/*Subset*/
		getPrecondition()->initSubset(getOwnedRule());
		#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising value Subset: " << "m_precondition - Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/ >(getOwnedRule())" << std::endl;
		#endif
		
		for(const std::shared_ptr<uml::Constraint>& preconditionindexElem: *preconditionList) 
		{
			std::shared_ptr<uml::Constraint> temp = std::dynamic_pointer_cast<uml::Constraint>((preconditionindexElem)->copy());
			m_precondition->push_back(temp);
		}
	}
	else
	{
		DEBUG_WARNING("container is nullptr for precondition.")
	}

	//clone reference 'redefinedOperation'
	std::shared_ptr<Subset<uml::Operation, uml::RedefinableElement>> redefinedOperationList = obj.getRedefinedOperation();
	if(redefinedOperationList)
	{
		/*Subset*/
		m_redefinedOperation.reset(new Subset<uml::Operation, uml::RedefinableElement >());
		#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising shared pointer Subset: " << "m_redefinedOperation - Subset<uml::Operation, uml::RedefinableElement >()" << std::endl;
		#endif
		
		/*Subset*/
		getRedefinedOperation()->initSubset(getRedefinedElement());
		#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising value Subset: " << "m_redefinedOperation - Subset<uml::Operation, uml::RedefinableElement >(getRedefinedElement())" << std::endl;
		#endif
		
		for(const std::shared_ptr<uml::Operation>& redefinedOperationindexElem: *redefinedOperationList) 
		{
			std::shared_ptr<uml::Operation> temp = std::dynamic_pointer_cast<uml::Operation>((redefinedOperationindexElem)->copy());
			m_redefinedOperation->push_back(temp);
		}
	}
	else
	{
		DEBUG_WARNING("container is nullptr for redefinedOperation.")
	}
	
	return *this;
}

std::shared_ptr<ecore::EObject> OperationImpl::copy() const
{
	std::shared_ptr<OperationImpl> element(new OperationImpl());
	*element =(*this);
	element->setThisOperationPtr(element);
	return element;
}

//*********************************
// Operations
//*********************************
int OperationImpl::getLower()
{
	throw std::runtime_error("UnsupportedOperationException: " + std::string(__PRETTY_FUNCTION__));
}

std::shared_ptr<uml::Parameter> OperationImpl::getReturnResult()
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	return this->returnResult();
	//end of body
}



int OperationImpl::getUpper()
{
	throw std::runtime_error("UnsupportedOperationException: " + std::string(__PRETTY_FUNCTION__));
}

bool OperationImpl::isOrdered()
{
	throw std::runtime_error("UnsupportedOperationException: " + std::string(__PRETTY_FUNCTION__));
}

bool OperationImpl::isUnique()
{
	throw std::runtime_error("UnsupportedOperationException: " + std::string(__PRETTY_FUNCTION__));
}

bool OperationImpl::matches(const std::shared_ptr<uml::Operation>& comparedOperation)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	//Checks whether two uml::Operations share the same name and input parameter types (= share same signature)

bool equals = false;

if(this->getName() != comparedOperation->getName()) {return equals;}

std::shared_ptr<Bag<uml::Parameter>> thisParameters = this->getOwnedParameter();
std::shared_ptr<Bag<uml::Parameter>> otherParameters = comparedOperation->getOwnedParameter();

if(thisParameters->size() != otherParameters->size()) {return equals;}

for(unsigned int i = 0; i < thisParameters->size(); i++)
{
	if(thisParameters->at(i)->getType() != otherParameters->at(i)->getType()) {return equals;}
}

equals = true;
return equals;

	//end of body
}

std::shared_ptr<uml::Parameter> OperationImpl::returnResult()
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	std::shared_ptr<Bag<uml::Parameter>> ownedParameters = this->getOwnedParameter();
	std::shared_ptr<uml::Parameter> returnResult;

	for(const std::shared_ptr<uml::Parameter>& p : *ownedParameters)
	{
		if(p->getDirection() == uml::ParameterDirectionKind::RETURN)
		{
				returnResult=p;
				break;
		}
	}
	
	return returnResult;
	//end of body
}

void OperationImpl::setIsOrdered(bool newIsOrdered)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	m_isOrdered = newIsOrdered;
	//end of body
}

void OperationImpl::setIsUnique(bool newIsUnique)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	m_isUnique = newIsUnique;
	//end of body
}

void OperationImpl::setLower(int newLower)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	m_lower = newLower;
	//end of body
}

void OperationImpl::setType(const std::shared_ptr<uml::Type>& newType)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	m_type = newType;
	//end of body
}

void OperationImpl::setUpper(int newUpper)
{
	//ADD_COUNT(__PRETTY_FUNCTION__)
	//generated from body annotation
	m_upper = newUpper;
	//end of body
}

//*********************************
// Attribute Getters & Setters
//*********************************
/* Getter & Setter for attribute isOrdered */
bool OperationImpl::getIsOrdered() const 
{
	return m_isOrdered;
}

/* Getter & Setter for attribute isQuery */
bool OperationImpl::getIsQuery() const 
{
	return m_isQuery;
}
void OperationImpl::setIsQuery(bool _isQuery)
{
	m_isQuery = _isQuery;
	
}

/* Getter & Setter for attribute isUnique */
bool OperationImpl::getIsUnique() const 
{
	return m_isUnique;
}

/* Getter & Setter for attribute lower */
int OperationImpl::getLower() const 
{
	return m_lower;
}

/* Getter & Setter for attribute upper */
int OperationImpl::getUpper() const 
{
	return m_upper;
}

//*********************************
// Reference Getters & Setters
//*********************************
/* Getter & Setter for reference bodyCondition */
const std::shared_ptr<uml::Constraint>& OperationImpl::getBodyCondition() const
{
    return m_bodyCondition;
}
void OperationImpl::setBodyCondition(const std::shared_ptr<uml::Constraint>& _bodyCondition)
{
    m_bodyCondition = _bodyCondition;
	
}

/* Getter & Setter for reference class */
std::weak_ptr<uml::Class> OperationImpl::getClass() const
{
    return m_class;
}
void OperationImpl::setClass(std::weak_ptr<uml::Class> _class)
{
    m_class = _class;
	
}

/* Getter & Setter for reference datatype */
std::weak_ptr<uml::DataType> OperationImpl::getDatatype() const
{
    return m_datatype;
}
void OperationImpl::setDatatype(std::weak_ptr<uml::DataType> _datatype)
{
    m_datatype = _datatype;
	
}

/* Getter & Setter for reference interface */
std::weak_ptr<uml::Interface> OperationImpl::getInterface() const
{
    return m_interface;
}
void OperationImpl::setInterface(std::weak_ptr<uml::Interface> _interface)
{
    m_interface = _interface;
	
}

/* Getter & Setter for reference ownedParameter */
std::shared_ptr<Bag<uml::Parameter>> OperationImpl::getProperty_OwnedParameter() const
{
	//Getter call of redefined container reference BehavioralFeature::ownedParameter 
	return uml::BehavioralFeatureImpl::getOwnedParameter();
}

/* Getter & Setter for reference postcondition */
const std::shared_ptr<Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/>>& OperationImpl::getPostcondition() const
{
	if(m_postcondition == nullptr)
	{
		/*Subset*/
		m_postcondition.reset(new Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/ >());
		#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising shared pointer Subset: " << "m_postcondition - Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/ >()" << std::endl;
		#endif
		
		/*Subset*/
		getPostcondition()->initSubset(getOwnedRule());
		#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising value Subset: " << "m_postcondition - Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/ >(getOwnedRule())" << std::endl;
		#endif
		
	}
    return m_postcondition;
}

/* Getter & Setter for reference precondition */
const std::shared_ptr<Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/>>& OperationImpl::getPrecondition() const
{
	if(m_precondition == nullptr)
	{
		/*Subset*/
		m_precondition.reset(new Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/ >());
		#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising shared pointer Subset: " << "m_precondition - Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/ >()" << std::endl;
		#endif
		
		/*Subset*/
		getPrecondition()->initSubset(getOwnedRule());
		#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising value Subset: " << "m_precondition - Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/ >(getOwnedRule())" << std::endl;
		#endif
		
	}
    return m_precondition;
}

/* Getter & Setter for reference redefinedOperation */
const std::shared_ptr<Subset<uml::Operation, uml::RedefinableElement>>& OperationImpl::getRedefinedOperation() const
{
	if(m_redefinedOperation == nullptr)
	{
		/*Subset*/
		m_redefinedOperation.reset(new Subset<uml::Operation, uml::RedefinableElement >());
		#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising shared pointer Subset: " << "m_redefinedOperation - Subset<uml::Operation, uml::RedefinableElement >()" << std::endl;
		#endif
		
		/*Subset*/
		getRedefinedOperation()->initSubset(getRedefinedElement());
		#ifdef SHOW_SUBSET_UNION
			std::cout << "Initialising value Subset: " << "m_redefinedOperation - Subset<uml::Operation, uml::RedefinableElement >(getRedefinedElement())" << std::endl;
		#endif
		
	}
    return m_redefinedOperation;
}

/* Getter & Setter for reference type */
const std::shared_ptr<uml::Type>& OperationImpl::getType() const
{
    return m_type;
}

//*********************************
// Union Getter
//*********************************

//*********************************
// Container Getter
//*********************************
std::shared_ptr<ecore::EObject> OperationImpl::eContainer() const
{
	if(auto wp = m_class.lock())
	{
		return wp;
	}

	if(auto wp = m_datatype.lock())
	{
		return wp;
	}

	if(auto wp = m_interface.lock())
	{
		return wp;
	}

	if(auto wp = m_namespace.lock())
	{
		return wp;
	}

	if(auto wp = m_owner.lock())
	{
		return wp;
	}

	if(auto wp = m_owningTemplateParameter.lock())
	{
		return wp;
	}
	return nullptr;
}

//*********************************
// Persistence Functions
//*********************************
void OperationImpl::load(std::shared_ptr<persistence::interfaces::XLoadHandler> loadHandler)
{
	std::map<std::string, std::string> attr_list = loadHandler->getAttributeList();
	loadAttributes(loadHandler, attr_list);

	//
	// Create new objects (from references (containment == true))
	//
	// get umlFactory
	int numNodes = loadHandler->getNumOfChildNodes();
	for(int ii = 0; ii < numNodes; ii++)
	{
		loadNode(loadHandler->getNextNodeName(), loadHandler);
	}
}		

void OperationImpl::loadAttributes(std::shared_ptr<persistence::interfaces::XLoadHandler> loadHandler, std::map<std::string, std::string> attr_list)
{
	try
	{
		std::map<std::string, std::string>::const_iterator iter;
	
		iter = attr_list.find("isQuery");
		if ( iter != attr_list.end() )
		{
			// this attribute is a 'bool'
			bool value;
			std::istringstream(iter->second) >> std::boolalpha >> value;
			this->setIsQuery(value);
		}
		std::shared_ptr<ecore::EClass> metaClass = this->eClass(); // get MetaClass
		iter = attr_list.find("bodyCondition");
		if ( iter != attr_list.end() )
		{
			// add unresolvedReference to loadHandler's list
			loadHandler->addUnresolvedReference(iter->second, loadHandler->getCurrentObject(), metaClass->getEStructuralFeature("bodyCondition")); // TODO use getEStructuralFeature() with id, for faster access to EStructuralFeature
		}

		iter = attr_list.find("postcondition");
		if ( iter != attr_list.end() )
		{
			// add unresolvedReference to loadHandler's list
			loadHandler->addUnresolvedReference(iter->second, loadHandler->getCurrentObject(), metaClass->getEStructuralFeature("postcondition")); // TODO use getEStructuralFeature() with id, for faster access to EStructuralFeature
		}

		iter = attr_list.find("precondition");
		if ( iter != attr_list.end() )
		{
			// add unresolvedReference to loadHandler's list
			loadHandler->addUnresolvedReference(iter->second, loadHandler->getCurrentObject(), metaClass->getEStructuralFeature("precondition")); // TODO use getEStructuralFeature() with id, for faster access to EStructuralFeature
		}

		iter = attr_list.find("redefinedOperation");
		if ( iter != attr_list.end() )
		{
			// add unresolvedReference to loadHandler's list
			loadHandler->addUnresolvedReference(iter->second, loadHandler->getCurrentObject(), metaClass->getEStructuralFeature("redefinedOperation")); // TODO use getEStructuralFeature() with id, for faster access to EStructuralFeature
		}
	}
	catch (std::exception& e)
	{
		std::cout << "| ERROR    | " << e.what() << std::endl;
	}
	catch (...) 
	{
		std::cout << "| ERROR    | " <<  "Exception occurred" << std::endl;
	}

	BehavioralFeatureImpl::loadAttributes(loadHandler, attr_list);
	ParameterableElementImpl::loadAttributes(loadHandler, attr_list);
	TemplateableElementImpl::loadAttributes(loadHandler, attr_list);
}

void OperationImpl::loadNode(std::string nodeName, std::shared_ptr<persistence::interfaces::XLoadHandler> loadHandler)
{

	try
	{
		if ( nodeName.compare("ownedParameter") == 0 )
		{
  			std::string typeName = loadHandler->getCurrentXSITypeName();
			if (typeName.empty())
			{
				typeName = "Parameter";
			}
			loadHandler->handleChildContainer<uml::Parameter>(this->getProperty_OwnedParameter());  

			return; 
		}
	}
	catch (std::exception& e)
	{
		std::cout << "| ERROR    | " << e.what() << std::endl;
	}
	catch (...) 
	{
		std::cout << "| ERROR    | " <<  "Exception occurred" << std::endl;
	}
	//load BasePackage Nodes
	BehavioralFeatureImpl::loadNode(nodeName, loadHandler);
	ParameterableElementImpl::loadNode(nodeName, loadHandler);
	TemplateableElementImpl::loadNode(nodeName, loadHandler);
}

void OperationImpl::resolveReferences(const int featureID, std::vector<std::shared_ptr<ecore::EObject> > references)
{
	switch(featureID)
	{
		case uml::umlPackage::OPERATION_ATTRIBUTE_BODYCONDITION:
		{
			if (references.size() == 1)
			{
				// Cast object to correct type
				std::shared_ptr<uml::Constraint> _bodyCondition = std::dynamic_pointer_cast<uml::Constraint>( references.front() );
				setBodyCondition(_bodyCondition);
			}
			
			return;
		}

		case uml::umlPackage::OPERATION_ATTRIBUTE_CLASS:
		{
			if (references.size() == 1)
			{
				// Cast object to correct type
				std::shared_ptr<uml::Class> _class = std::dynamic_pointer_cast<uml::Class>( references.front() );
				setClass(_class);
			}
			
			return;
		}

		case uml::umlPackage::OPERATION_ATTRIBUTE_DATATYPE:
		{
			if (references.size() == 1)
			{
				// Cast object to correct type
				std::shared_ptr<uml::DataType> _datatype = std::dynamic_pointer_cast<uml::DataType>( references.front() );
				setDatatype(_datatype);
			}
			
			return;
		}

		case uml::umlPackage::OPERATION_ATTRIBUTE_INTERFACE:
		{
			if (references.size() == 1)
			{
				// Cast object to correct type
				std::shared_ptr<uml::Interface> _interface = std::dynamic_pointer_cast<uml::Interface>( references.front() );
				setInterface(_interface);
			}
			
			return;
		}

		case uml::umlPackage::OPERATION_ATTRIBUTE_POSTCONDITION:
		{
			const std::shared_ptr<Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/>>& _postcondition = getPostcondition();
			for(std::shared_ptr<ecore::EObject> ref : references)
			{
				std::shared_ptr<uml::Constraint>  _r = std::dynamic_pointer_cast<uml::Constraint>(ref);
				if (_r != nullptr)
				{
					_postcondition->push_back(_r);
				}
			}
			return;
		}

		case uml::umlPackage::OPERATION_ATTRIBUTE_PRECONDITION:
		{
			const std::shared_ptr<Subset<uml::Constraint, uml::Constraint /*Subset does not reference a union*/>>& _precondition = getPrecondition();
			for(std::shared_ptr<ecore::EObject> ref : references)
			{
				std::shared_ptr<uml::Constraint>  _r = std::dynamic_pointer_cast<uml::Constraint>(ref);
				if (_r != nullptr)
				{
					_precondition->push_back(_r);
				}
			}
			return;
		}

		case uml::umlPackage::OPERATION_ATTRIBUTE_REDEFINEDOPERATION:
		{
			const std::shared_ptr<Subset<uml::Operation, uml::RedefinableElement>>& _redefinedOperation = getRedefinedOperation();
			for(std::shared_ptr<ecore::EObject> ref : references)
			{
				std::shared_ptr<uml::Operation>  _r = std::dynamic_pointer_cast<uml::Operation>(ref);
				if (_r != nullptr)
				{
					_redefinedOperation->push_back(_r);
				}
			}
			return;
		}
	}
	BehavioralFeatureImpl::resolveReferences(featureID, references);
	ParameterableElementImpl::resolveReferences(featureID, references);
	TemplateableElementImpl::resolveReferences(featureID, references);
}

void OperationImpl::save(std::shared_ptr<persistence::interfaces::XSaveHandler> saveHandler) const
{
	saveContent(saveHandler);

	BehavioralFeatureImpl::saveContent(saveHandler);
	ParameterableElementImpl::saveContent(saveHandler);
	TemplateableElementImpl::saveContent(saveHandler);
	
	FeatureImpl::saveContent(saveHandler);
	NamespaceImpl::saveContent(saveHandler);
	
	RedefinableElementImpl::saveContent(saveHandler);
	
	NamedElementImpl::saveContent(saveHandler);
	
	ElementImpl::saveContent(saveHandler);
	
	ObjectImpl::saveContent(saveHandler);
	
	ecore::EObjectImpl::saveContent(saveHandler);
}

void OperationImpl::saveContent(std::shared_ptr<persistence::interfaces::XSaveHandler> saveHandler) const
{
	try
	{
		std::shared_ptr<uml::umlPackage> package = uml::umlPackage::eInstance();
		// Add attributes
		if ( this->eIsSet(package->getOperation_Attribute_isQuery()) )
		{
			saveHandler->addAttribute("isQuery", this->getIsQuery());
		}
	// Add references
		saveHandler->addReference(this->getBodyCondition(), "bodyCondition", getBodyCondition()->eClass() != uml::umlPackage::eInstance()->getConstraint_Class()); 
		saveHandler->addReferences<uml::Constraint>("postcondition", this->getPostcondition());
		saveHandler->addReferences<uml::Constraint>("precondition", this->getPrecondition());
		saveHandler->addReferences<uml::Operation>("redefinedOperation", this->getRedefinedOperation());
		//
		// Add new tags (from references)
		//
		std::shared_ptr<ecore::EClass> metaClass = this->eClass();
		// Save 'ownedParameter'

		saveHandler->addReferences<uml::Parameter>("ownedParameter", this->getProperty_OwnedParameter());
	}
	catch (std::exception& e)
	{
		std::cout << "| ERROR    | " << e.what() << std::endl;
	}
}

const std::shared_ptr<ecore::EClass>& OperationImpl::eStaticClass() const
{
	return uml::umlPackage::eInstance()->getOperation_Class();
}

//*********************************
// EStructuralFeature Get/Set/IsSet
//*********************************
std::shared_ptr<Any> OperationImpl::eGet(int featureID, bool resolve, bool coreType) const
{
	switch(featureID)
	{
		case uml::umlPackage::OPERATION_ATTRIBUTE_BODYCONDITION:
			return eAny(getBodyCondition(),uml::umlPackage::CONSTRAINT_CLASS,false); //16730
		case uml::umlPackage::OPERATION_ATTRIBUTE_CLASS:
		{
			std::shared_ptr<ecore::EObject> returnValue=getClass().lock();
			return eEcoreAny(returnValue,uml::umlPackage::CLASS_CLASS); //16731
		}
		case uml::umlPackage::OPERATION_ATTRIBUTE_DATATYPE:
		{
			std::shared_ptr<ecore::EObject> returnValue=getDatatype().lock();
			return eEcoreAny(returnValue,uml::umlPackage::DATATYPE_CLASS); //16732
		}
		case uml::umlPackage::OPERATION_ATTRIBUTE_INTERFACE:
		{
			std::shared_ptr<ecore::EObject> returnValue=getInterface().lock();
			return eEcoreAny(returnValue,uml::umlPackage::INTERFACE_CLASS); //16733
		}
		case uml::umlPackage::OPERATION_ATTRIBUTE_ISORDERED:
			return eAny(getIsOrdered(),ecore::ecorePackage::EBOOLEAN_CLASS,false); //16734
		case uml::umlPackage::OPERATION_ATTRIBUTE_ISQUERY:
			return eAny(getIsQuery(),ecore::ecorePackage::EBOOLEAN_CLASS,false); //16735
		case uml::umlPackage::OPERATION_ATTRIBUTE_ISUNIQUE:
			return eAny(getIsUnique(),ecore::ecorePackage::EBOOLEAN_CLASS,false); //16736
		case uml::umlPackage::OPERATION_ATTRIBUTE_LOWER:
			return eAny(getLower(),ecore::ecorePackage::EINT_CLASS,false); //16737
		case uml::umlPackage::OPERATION_ATTRIBUTE_OWNEDPARAMETER:
			return eEcoreContainerAny(getProperty_OwnedParameter(),uml::umlPackage::PARAMETER_CLASS); //16743
		case uml::umlPackage::OPERATION_ATTRIBUTE_POSTCONDITION:
			return eEcoreContainerAny(getPostcondition(),uml::umlPackage::CONSTRAINT_CLASS); //16738
		case uml::umlPackage::OPERATION_ATTRIBUTE_PRECONDITION:
			return eEcoreContainerAny(getPrecondition(),uml::umlPackage::CONSTRAINT_CLASS); //16739
		case uml::umlPackage::OPERATION_ATTRIBUTE_REDEFINEDOPERATION:
			return eEcoreContainerAny(getRedefinedOperation(),uml::umlPackage::OPERATION_CLASS); //16740
		case uml::umlPackage::OPERATION_ATTRIBUTE_TYPE:
			return eAny(getType(),uml::umlPackage::TYPE_CLASS,false); //16741
		case uml::umlPackage::OPERATION_ATTRIBUTE_UPPER:
			return eAny(getUpper(),0,false); //16742
	}
	std::shared_ptr<Any> result;
	result = BehavioralFeatureImpl::eGet(featureID, resolve, coreType);
	if (result != nullptr && !result->isEmpty())
	{
		return result;
	}
	result = ParameterableElementImpl::eGet(featureID, resolve, coreType);
	if (result != nullptr && !result->isEmpty())
	{
		return result;
	}
	result = TemplateableElementImpl::eGet(featureID, resolve, coreType);
	return result;
}

bool OperationImpl::internalEIsSet(int featureID) const
{
	switch(featureID)
	{
		case uml::umlPackage::OPERATION_ATTRIBUTE_BODYCONDITION:
			return getBodyCondition() != nullptr; //16730
		case uml::umlPackage::OPERATION_ATTRIBUTE_CLASS:
			return getClass().lock() != nullptr; //16731
		case uml::umlPackage::OPERATION_ATTRIBUTE_DATATYPE:
			return getDatatype().lock() != nullptr; //16732
		case uml::umlPackage::OPERATION_ATTRIBUTE_INTERFACE:
			return getInterface().lock() != nullptr; //16733
		case uml::umlPackage::OPERATION_ATTRIBUTE_ISORDERED:
			return getIsOrdered() != false; //16734
		case uml::umlPackage::OPERATION_ATTRIBUTE_ISQUERY:
			return getIsQuery() != false; //16735
		case uml::umlPackage::OPERATION_ATTRIBUTE_ISUNIQUE:
			return getIsUnique() != true; //16736
		case uml::umlPackage::OPERATION_ATTRIBUTE_LOWER:
			return getLower() != 1; //16737
		case uml::umlPackage::OPERATION_ATTRIBUTE_OWNEDPARAMETER:
			return getProperty_OwnedParameter() != nullptr; //16743
		case uml::umlPackage::OPERATION_ATTRIBUTE_POSTCONDITION:
			return getPostcondition() != nullptr; //16738
		case uml::umlPackage::OPERATION_ATTRIBUTE_PRECONDITION:
			return getPrecondition() != nullptr; //16739
		case uml::umlPackage::OPERATION_ATTRIBUTE_REDEFINEDOPERATION:
			return getRedefinedOperation() != nullptr; //16740
		case uml::umlPackage::OPERATION_ATTRIBUTE_TYPE:
			return getType() != nullptr; //16741
		case uml::umlPackage::OPERATION_ATTRIBUTE_UPPER:
			return getUpper() != 1; //16742
	}
	bool result = false;
	result = BehavioralFeatureImpl::internalEIsSet(featureID);
	if (result)
	{
		return result;
	}
	result = ParameterableElementImpl::internalEIsSet(featureID);
	if (result)
	{
		return result;
	}
	result = TemplateableElementImpl::internalEIsSet(featureID);
	return result;
}

bool OperationImpl::eSet(int featureID,  const std::shared_ptr<Any>& newValue)
{
	switch(featureID)
	{
		case uml::umlPackage::OPERATION_ATTRIBUTE_BODYCONDITION:
		{
			std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>(newValue);
			if(ecoreAny)
			{
				try
				{
					std::shared_ptr<ecore::EObject> eObject = ecoreAny->getAsEObject();
					std::shared_ptr<uml::Constraint> _bodyCondition = std::dynamic_pointer_cast<uml::Constraint>(eObject);
					if(_bodyCondition)
					{
						setBodyCondition(_bodyCondition); //16730
					}
					else
					{
						throw "Invalid argument";
					}
				}
				catch(...)
				{
					DEBUG_ERROR("Invalid type stored in 'ecore::ecoreAny' for feature 'bodyCondition'. Failed to set feature!")
					return false;
				}
			}
			else
			{
				DEBUG_ERROR("Invalid instance of 'ecore::ecoreAny' for feature 'bodyCondition'. Failed to set feature!")
				return false;
			}
		return true;
		}
		case uml::umlPackage::OPERATION_ATTRIBUTE_CLASS:
		{
			std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>(newValue);
			if(ecoreAny)
			{
				try
				{
					std::shared_ptr<ecore::EObject> eObject = ecoreAny->getAsEObject();
					std::shared_ptr<uml::Class> _class = std::dynamic_pointer_cast<uml::Class>(eObject);
					if(_class)
					{
						setClass(_class); //16731
					}
					else
					{
						throw "Invalid argument";
					}
				}
				catch(...)
				{
					DEBUG_ERROR("Invalid type stored in 'ecore::ecoreAny' for feature 'class'. Failed to set feature!")
					return false;
				}
			}
			else
			{
				DEBUG_ERROR("Invalid instance of 'ecore::ecoreAny' for feature 'class'. Failed to set feature!")
				return false;
			}
		return true;
		}
		case uml::umlPackage::OPERATION_ATTRIBUTE_DATATYPE:
		{
			std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>(newValue);
			if(ecoreAny)
			{
				try
				{
					std::shared_ptr<ecore::EObject> eObject = ecoreAny->getAsEObject();
					std::shared_ptr<uml::DataType> _datatype = std::dynamic_pointer_cast<uml::DataType>(eObject);
					if(_datatype)
					{
						setDatatype(_datatype); //16732
					}
					else
					{
						throw "Invalid argument";
					}
				}
				catch(...)
				{
					DEBUG_ERROR("Invalid type stored in 'ecore::ecoreAny' for feature 'datatype'. Failed to set feature!")
					return false;
				}
			}
			else
			{
				DEBUG_ERROR("Invalid instance of 'ecore::ecoreAny' for feature 'datatype'. Failed to set feature!")
				return false;
			}
		return true;
		}
		case uml::umlPackage::OPERATION_ATTRIBUTE_INTERFACE:
		{
			std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>(newValue);
			if(ecoreAny)
			{
				try
				{
					std::shared_ptr<ecore::EObject> eObject = ecoreAny->getAsEObject();
					std::shared_ptr<uml::Interface> _interface = std::dynamic_pointer_cast<uml::Interface>(eObject);
					if(_interface)
					{
						setInterface(_interface); //16733
					}
					else
					{
						throw "Invalid argument";
					}
				}
				catch(...)
				{
					DEBUG_ERROR("Invalid type stored in 'ecore::ecoreAny' for feature 'interface'. Failed to set feature!")
					return false;
				}
			}
			else
			{
				DEBUG_ERROR("Invalid instance of 'ecore::ecoreAny' for feature 'interface'. Failed to set feature!")
				return false;
			}
		return true;
		}
		case uml::umlPackage::OPERATION_ATTRIBUTE_ISQUERY:
		{
			try
			{
				bool _isQuery = newValue->get<bool>();
				setIsQuery(_isQuery); //16735
			}
			catch(...)
			{
				DEBUG_ERROR("Invalid type stored in 'Any' for feature 'isQuery'. Failed to set feature!")
				return false;
			}
		return true;
		}
		case uml::umlPackage::OPERATION_ATTRIBUTE_OWNEDPARAMETER:
		{
			std::shared_ptr<ecore::EcoreContainerAny> ecoreContainerAny = std::dynamic_pointer_cast<ecore::EcoreContainerAny>(newValue);
			if(ecoreContainerAny)
			{
				try
				{
					std::shared_ptr<Bag<ecore::EObject>> eObjectList = ecoreContainerAny->getAsEObjectContainer();
	
					if(eObjectList)
					{
						const std::shared_ptr<Bag<uml::Parameter>>& _ownedParameter = getProperty_OwnedParameter();
	
						for(const std::shared_ptr<ecore::EObject>& anEObject: *eObjectList)
						{
							std::shared_ptr<uml::Parameter> valueToAdd = std::dynamic_pointer_cast<uml::Parameter>(anEObject);
	
							if (valueToAdd)
							{
								if(!(_ownedParameter->includes(valueToAdd)))
								{
									_ownedParameter->add(valueToAdd);
								}
								//else, valueToAdd is already present so it won't be added again
							}
							else
							{
								throw "Invalid argument";
							}
						}
					}
				}
				catch(...)
				{
					DEBUG_ERROR("Invalid type stored in 'ecore::ecoreContainerAny' for feature 'ownedParameter'. Failed to set feature!")
					return false;
				}
			}
			else
			{
				DEBUG_ERROR("Invalid instance of 'ecore::ecoreContainerAny' for feature 'ownedParameter'. Failed to set feature!")
				return false;
			}
		return true;
		}
		case uml::umlPackage::OPERATION_ATTRIBUTE_POSTCONDITION:
		{
			std::shared_ptr<ecore::EcoreContainerAny> ecoreContainerAny = std::dynamic_pointer_cast<ecore::EcoreContainerAny>(newValue);
			if(ecoreContainerAny)
			{
				try
				{
					std::shared_ptr<Bag<ecore::EObject>> eObjectList = ecoreContainerAny->getAsEObjectContainer();
	
					if(eObjectList)
					{
						const std::shared_ptr<Bag<uml::Constraint>>& _postcondition = getPostcondition();
	
						for(const std::shared_ptr<ecore::EObject>& anEObject: *eObjectList)
						{
							std::shared_ptr<uml::Constraint> valueToAdd = std::dynamic_pointer_cast<uml::Constraint>(anEObject);
	
							if (valueToAdd)
							{
								if(!(_postcondition->includes(valueToAdd)))
								{
									_postcondition->add(valueToAdd);
								}
								//else, valueToAdd is already present so it won't be added again
							}
							else
							{
								throw "Invalid argument";
							}
						}
					}
				}
				catch(...)
				{
					DEBUG_ERROR("Invalid type stored in 'ecore::ecoreContainerAny' for feature 'postcondition'. Failed to set feature!")
					return false;
				}
			}
			else
			{
				DEBUG_ERROR("Invalid instance of 'ecore::ecoreContainerAny' for feature 'postcondition'. Failed to set feature!")
				return false;
			}
		return true;
		}
		case uml::umlPackage::OPERATION_ATTRIBUTE_PRECONDITION:
		{
			std::shared_ptr<ecore::EcoreContainerAny> ecoreContainerAny = std::dynamic_pointer_cast<ecore::EcoreContainerAny>(newValue);
			if(ecoreContainerAny)
			{
				try
				{
					std::shared_ptr<Bag<ecore::EObject>> eObjectList = ecoreContainerAny->getAsEObjectContainer();
	
					if(eObjectList)
					{
						const std::shared_ptr<Bag<uml::Constraint>>& _precondition = getPrecondition();
	
						for(const std::shared_ptr<ecore::EObject>& anEObject: *eObjectList)
						{
							std::shared_ptr<uml::Constraint> valueToAdd = std::dynamic_pointer_cast<uml::Constraint>(anEObject);
	
							if (valueToAdd)
							{
								if(!(_precondition->includes(valueToAdd)))
								{
									_precondition->add(valueToAdd);
								}
								//else, valueToAdd is already present so it won't be added again
							}
							else
							{
								throw "Invalid argument";
							}
						}
					}
				}
				catch(...)
				{
					DEBUG_ERROR("Invalid type stored in 'ecore::ecoreContainerAny' for feature 'precondition'. Failed to set feature!")
					return false;
				}
			}
			else
			{
				DEBUG_ERROR("Invalid instance of 'ecore::ecoreContainerAny' for feature 'precondition'. Failed to set feature!")
				return false;
			}
		return true;
		}
		case uml::umlPackage::OPERATION_ATTRIBUTE_REDEFINEDOPERATION:
		{
			std::shared_ptr<ecore::EcoreContainerAny> ecoreContainerAny = std::dynamic_pointer_cast<ecore::EcoreContainerAny>(newValue);
			if(ecoreContainerAny)
			{
				try
				{
					std::shared_ptr<Bag<ecore::EObject>> eObjectList = ecoreContainerAny->getAsEObjectContainer();
	
					if(eObjectList)
					{
						const std::shared_ptr<Bag<uml::Operation>>& _redefinedOperation = getRedefinedOperation();
	
						for(const std::shared_ptr<ecore::EObject>& anEObject: *eObjectList)
						{
							std::shared_ptr<uml::Operation> valueToAdd = std::dynamic_pointer_cast<uml::Operation>(anEObject);
	
							if (valueToAdd)
							{
								if(!(_redefinedOperation->includes(valueToAdd)))
								{
									_redefinedOperation->add(valueToAdd);
								}
								//else, valueToAdd is already present so it won't be added again
							}
							else
							{
								throw "Invalid argument";
							}
						}
					}
				}
				catch(...)
				{
					DEBUG_ERROR("Invalid type stored in 'ecore::ecoreContainerAny' for feature 'redefinedOperation'. Failed to set feature!")
					return false;
				}
			}
			else
			{
				DEBUG_ERROR("Invalid instance of 'ecore::ecoreContainerAny' for feature 'redefinedOperation'. Failed to set feature!")
				return false;
			}
		return true;
		}
	}

	bool result = false;
	result = BehavioralFeatureImpl::eSet(featureID, newValue);
	if (result)
	{
		return result;
	}
	result = ParameterableElementImpl::eSet(featureID, newValue);
	if (result)
	{
		return result;
	}
	result = TemplateableElementImpl::eSet(featureID, newValue);
	return result;
}

//*********************************
// EOperation Invoke
//*********************************
std::shared_ptr<Any> OperationImpl::eInvoke(int operationID, const std::shared_ptr<Bag<Any>>& arguments)
{
	std::shared_ptr<Any> result;
 
  	switch(operationID)
	{
		// uml::Operation::getLower() : int: 2432712746
		case umlPackage::OPERATION_OPERATION_GETLOWER:
		{
			result = eAny(this->getLower(), 0, false);
			break;
		}
		// uml::Operation::getReturnResult() : uml::Parameter: 3209085960
		case umlPackage::OPERATION_OPERATION_GETRETURNRESULT:
		{
			result = eEcoreAny(this->getReturnResult(), uml::umlPackage::PARAMETER_CLASS);
			break;
		}
		// uml::Operation::getUpper() : int: 1198605197
		case umlPackage::OPERATION_OPERATION_GETUPPER:
		{
			result = eAny(this->getUpper(), 0, false);
			break;
		}
		// uml::Operation::isOrdered() : bool: 2709191195
		case umlPackage::OPERATION_OPERATION_ISORDERED:
		{
			result = eAny(this->isOrdered(), 0, false);
			break;
		}
		// uml::Operation::isUnique() : bool: 4020565657
		case umlPackage::OPERATION_OPERATION_ISUNIQUE:
		{
			result = eAny(this->isUnique(), 0, false);
			break;
		}
		// uml::Operation::matches(uml::Operation) : bool: 1582514854
		case umlPackage::OPERATION_OPERATION_MATCHES_OPERATION:
		{
			//Retrieve input parameter 'comparedOperation'
			//parameter 0
			std::shared_ptr<uml::Operation> incoming_param_comparedOperation;
			Bag<Any>::const_iterator incoming_param_comparedOperation_arguments_citer = std::next(arguments->begin(), 0);
			{
				std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>((*incoming_param_comparedOperation_arguments_citer));
				if(ecoreAny)
				{
					try
					{
						std::shared_ptr<ecore::EObject> _temp = ecoreAny->getAsEObject();
						incoming_param_comparedOperation = std::dynamic_pointer_cast<uml::Operation>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreAny' for parameter 'comparedOperation'. Failed to invoke operation 'matches'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreAny' for parameter 'comparedOperation'. Failed to invoke operation 'matches'!")
					return nullptr;
				}
			}
		
			result = eAny(this->matches(incoming_param_comparedOperation), 0, false);
			break;
		}
		// uml::Operation::returnResult() : uml::Parameter: 3088060264
		case umlPackage::OPERATION_OPERATION_RETURNRESULT:
		{
			result = eEcoreAny(this->returnResult(), uml::umlPackage::PARAMETER_CLASS);
			break;
		}
		// uml::Operation::setIsOrdered(bool): 563533641
		case umlPackage::OPERATION_OPERATION_SETISORDERED_BOOLEAN:
		{
			//Retrieve input parameter 'newIsOrdered'
			//parameter 0
			bool incoming_param_newIsOrdered;
			Bag<Any>::const_iterator incoming_param_newIsOrdered_arguments_citer = std::next(arguments->begin(), 0);
			try
			{
				incoming_param_newIsOrdered = (*incoming_param_newIsOrdered_arguments_citer)->get<bool>();
			}
			catch(...)
			{
				DEBUG_ERROR("Invalid type stored in 'Any' for parameter 'newIsOrdered'. Failed to invoke operation 'setIsOrdered'!")
				return nullptr;
			}
		
			this->setIsOrdered(incoming_param_newIsOrdered);
			break;
		}
		// uml::Operation::setIsUnique(bool): 1317393399
		case umlPackage::OPERATION_OPERATION_SETISUNIQUE_BOOLEAN:
		{
			//Retrieve input parameter 'newIsUnique'
			//parameter 0
			bool incoming_param_newIsUnique;
			Bag<Any>::const_iterator incoming_param_newIsUnique_arguments_citer = std::next(arguments->begin(), 0);
			try
			{
				incoming_param_newIsUnique = (*incoming_param_newIsUnique_arguments_citer)->get<bool>();
			}
			catch(...)
			{
				DEBUG_ERROR("Invalid type stored in 'Any' for parameter 'newIsUnique'. Failed to invoke operation 'setIsUnique'!")
				return nullptr;
			}
		
			this->setIsUnique(incoming_param_newIsUnique);
			break;
		}
		// uml::Operation::setLower(int): 3045305040
		case umlPackage::OPERATION_OPERATION_SETLOWER_INTEGER:
		{
			//Retrieve input parameter 'newLower'
			//parameter 0
			int incoming_param_newLower;
			Bag<Any>::const_iterator incoming_param_newLower_arguments_citer = std::next(arguments->begin(), 0);
			try
			{
				incoming_param_newLower = (*incoming_param_newLower_arguments_citer)->get<int>();
			}
			catch(...)
			{
				DEBUG_ERROR("Invalid type stored in 'Any' for parameter 'newLower'. Failed to invoke operation 'setLower'!")
				return nullptr;
			}
		
			this->setLower(incoming_param_newLower);
			break;
		}
		// uml::Operation::setType(uml::Type): 295406386
		case umlPackage::OPERATION_OPERATION_SETTYPE_TYPE:
		{
			//Retrieve input parameter 'newType'
			//parameter 0
			std::shared_ptr<uml::Type> incoming_param_newType;
			Bag<Any>::const_iterator incoming_param_newType_arguments_citer = std::next(arguments->begin(), 0);
			{
				std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>((*incoming_param_newType_arguments_citer));
				if(ecoreAny)
				{
					try
					{
						std::shared_ptr<ecore::EObject> _temp = ecoreAny->getAsEObject();
						incoming_param_newType = std::dynamic_pointer_cast<uml::Type>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'ecore::EcoreAny' for parameter 'newType'. Failed to invoke operation 'setType'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'ecore::EcoreAny' for parameter 'newType'. Failed to invoke operation 'setType'!")
					return nullptr;
				}
			}
		
			this->setType(incoming_param_newType);
			break;
		}
		// uml::Operation::setUpper(int): 1811197491
		case umlPackage::OPERATION_OPERATION_SETUPPER_UNLIMITEDNATURAL:
		{
			//Retrieve input parameter 'newUpper'
			//parameter 0
			int incoming_param_newUpper;
			Bag<Any>::const_iterator incoming_param_newUpper_arguments_citer = std::next(arguments->begin(), 0);
			try
			{
				incoming_param_newUpper = (*incoming_param_newUpper_arguments_citer)->get<int>();
			}
			catch(...)
			{
				DEBUG_ERROR("Invalid type stored in 'Any' for parameter 'newUpper'. Failed to invoke operation 'setUpper'!")
				return nullptr;
			}
		
			this->setUpper(incoming_param_newUpper);
			break;
		}

		default:
		{
			// call superTypes
			result = TemplateableElementImpl::eInvoke(operationID, arguments);
			if (result && !result->isEmpty())
				break;
			result = ParameterableElementImpl::eInvoke(operationID, arguments);
			if (result && !result->isEmpty())
				break;
			result = BehavioralFeatureImpl::eInvoke(operationID, arguments);
			if (result && !result->isEmpty())
				break;
			break;
		}
  	}

	return result;
}

std::shared_ptr<uml::Operation> OperationImpl::getThisOperationPtr() const
{
	return m_thisOperationPtr.lock();
}
void OperationImpl::setThisOperationPtr(std::weak_ptr<uml::Operation> thisOperationPtr)
{
	m_thisOperationPtr = thisOperationPtr;
	setThisBehavioralFeaturePtr(thisOperationPtr);
	setThisParameterableElementPtr(thisOperationPtr);
	setThisTemplateableElementPtr(thisOperationPtr);
}


