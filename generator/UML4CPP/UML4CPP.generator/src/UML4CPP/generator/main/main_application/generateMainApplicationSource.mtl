[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 ****************************************************************************************************************************************************************
 * 
 * module for generation of source file for main application
 * 
 */]
[module generateMainApplicationSource('http://www.eclipse.org/uml2/5.0.0/UML')]

[import UML4CPP::generator::main::components::generateParameter /]
[import UML4CPP::generator::main::components::generateType /]
[import UML4CPP::generator::main::components::generateOpaqueBehavior /]
[import UML4CPP::generator::main::helpers::generalHelper /]
[import UML4CPP::generator::main::helpers::nameHelper /]
[import UML4CPP::generator::main::helpers::keywords /]
[import UML4CPP::generator::main::profiles::uml4CPPProfileHelper /]
[import UML4CPP::generator::main::profiles::strategyHelper /]


[template public generateMainApplicationSourceFromOpaqueBehavior(aPackage : Package) { packageName : String = getPackageName(); }]
[file ('../application/src/main.cpp', false, 'UTF-8')]
[let mainOpaqueBehavior : OpaqueBehavior = aPackage.getMainBehavior().oclAsType(OpaqueBehavior)]

#include <iostream>

#include "abstractDataTypes/SubsetUnion.hpp"
#include "[aPackage.generateNamespacePath(false)/]/[packageName/]Factory.hpp"
#include "[aPackage.generateNamespacePath(false)/]/[packageName/]Package.hpp"

[for (aClass : Class | aPackage.allOwnedElements()->filter(Class)->reject(oclIsKindOf(Behavior))->reject(isDoNotGenerateElement())->reject(isStrategyClass())->sortedBy(name))]
#include "[aClass.getNearestPackage().generateNamespacePath(false)/]/[aClass.name.toUpperFirst()/].hpp"
[/for]
[for (anInterface : Interface | aPackage.allOwnedElements()->filter(Interface)->reject(isDoNotGenerateElement())->sortedBy(name))]
#include "[anInterface.getNearestPackage().generateNamespacePath(false)/]/[anInterface.name.toUpperFirst()/].hpp"
[/for]
[for (anEnumeration : Enumeration | aPackage.ownedMember->filter(Enumeration)->reject(isDoNotGenerateElement()))]
#include "[anEnumeration.getNearestPackage().generateNamespacePath(false)/]/[anEnumeration.name/].hpp"
[/for]

[if (mainOpaqueBehavior.hasLanguage(keyInclude()))]
//Includes from main behavior [mainOpaqueBehavior.name/]
[mainOpaqueBehavior.getEntryForLanguage(keyInclude())/]
[/if]

// [protected ('includes')] 
// You may manually edit additional includes, won't be overwritten upon generation.

// [/protected]

[if (not aPackage.isIgnoreNamespace())]using namespace [aPackage.generateNamespace(false)/];[/if]

// [protected ('functions')] 
// You may manually edit additional functions, won't be overwritten upon generation.

// [/protected]

int main ()
{
	//Create Model Factory and Package
	std::shared_ptr<[packageName/]Factory> factory = [packageName/]Factory::eInstance();
	std::shared_ptr<[packageName/]Package> package = [packageName/]Package::eInstance();

[if (mainOpaqueBehavior.hasLanguage(keyCPP()))]
	[mainOpaqueBehavior.getEntryForLanguage(keyCPP())/]
[else]
	//No source code found for behavior '[mainOpaqueBehavior.name/]'
	//Make sure that '[keyCPP()/]' is contained in the 'language' property of behavior '[mainOpaqueBehavior.name/]'
[/if]	

	// [protected ('main')]
	// You may manually edit the following lines, won't be overwritten upon generation.

	// [/protected]

    return 0;
}
[/let]
[/file]
[/template]

[template public generateMainApplicationSourceFromActivity(aPackage : Package) { packageName : String = getPackageName(); }]
[file ('../application/src/main.cpp', false, 'UTF-8')]
[let mainActivity : Activity = aPackage.getMainBehavior().oclAsType(Activity)]
#include <iostream>
#include <memory>
#include <vector>

#include "abstractDataTypes/Bag.hpp"
#include "abstractDataTypes/Any.hpp"
#include "uml/UMLAny.hpp"
#include "abstractDataTypes/SubsetUnion.hpp"
[if (mainActivity.owner.oclIsKindOf(Classifier))]
#include "[mainActivity.owner.oclAsType(Classifier).getNearestPackage().generateNamespacePath(false)/]/[mainActivity.owner.oclAsType(Classifier).name.toUpperFirst()/].hpp"
#include "[mainActivity.owner.oclAsType(Classifier).getNearestPackage().generateNamespacePath(false)/]/[mainActivity.owner.oclAsType(Classifier).getNearestPackage().getPackageName()/]Package.hpp"
#include "[mainActivity.owner.oclAsType(Classifier).getNearestPackage().generateNamespacePath(false)/]/[mainActivity.owner.oclAsType(Classifier).getNearestPackage().getPackageName()/]Factory.hpp"
[else]
#include "[mainActivity.getNearestPackage().generateNamespacePath(false)/]/[mainActivity.getNearestPackage().getPackageName()/]Package.hpp"
[/if]
[for ( type : Type | mainActivity.ownedParameter.type->reject(isDoNotGenerateElement())->asOrderedSet())]
#include "[type.getNearestPackage().generateNamespacePath(false)/]/[type.name/].hpp"
[/for]
#include "pluginFramework/PluginFramework.hpp"
#include "pluginFramework/UMLExecutionModelPlugin.hpp"

using namespace [aPackage.generateNamespace(false)/];

int main()
{	
    //executing main activity
	[mainActivity.generateParameterInstances(aPackage)/]
	std::shared_ptr<[if (mainActivity.owner.oclIsKindOf(Classifier))][mainActivity.owner.oclAsType(Classifier).generateNamespaceName(false)/][else]fUML::MDE4CPP_Extensions::FUML_Object[/if]> element = [if (mainActivity.owner.oclIsKindOf(Classifier))][mainActivity.owner.oclAsType(Classifier).generateNamespace(false)/]::[mainActivity.owner.oclAsType(Classifier).getNearestPackage().getPackageName()/]Factory::eInstance()->create[mainActivity.owner.oclAsType(Classifier).name.toUpperFirst()/]()[else]nullptr[/if];

	std::shared_ptr<PluginFramework> pluginFramework = PluginFramework::eInstance();
	std::string pluginName = "[mainActivity.getRootPackage().getPackageName()/]Exec";
	std::shared_ptr<MDE4CPPPlugin> plugin = pluginFramework->findPluginByName(pluginName);
	if (plugin)
	{
		DEBUG_INFO("Plugin '" << plugin->eNAME() << "' found.")

		std::shared_ptr<UMLExecutionModelPlugin> executionPlugin = std::dynamic_pointer_cast<UMLExecutionModelPlugin>(plugin);
		if (executionPlugin)
		{
			DEBUG_INFO("Execution plugin '" << executionPlugin->eNAME() << "' is accessable.")

			std::shared_ptr<Bag<Any>> parameterList(new Bag<Any>());
			[for (aParameter : Parameter | mainActivity.ownedParameter->select((direction = ParameterDirectionKind::inout) or (direction = ParameterDirectionKind::_in)))]
			parameterList->add([aParameter.generateAnyCreationFromParameter()/]);
			[/for]
			std::shared_ptr<Any> activityResult = executionPlugin->executeActivity([mainActivity.generatePackageGetterCall()/], parameterList, element);


			[if (mainActivity.ownedParameter->select(p :Parameter | p.direction = ParameterDirectionKind::return)->notEmpty())]
			[let returnParameter : Parameter = mainActivity.ownedParameter->select(p :Parameter | p.direction = ParameterDirectionKind::return)->first()]
			[returnParameter.type.generateCppRawType(false)/] returnValue = activityResult->get<[returnParameter.type.generateCppRawType(false)/]>();
			DEBUG_INFO("Activity '[mainActivity.name/]' has a return parameter named '[returnParameter.name/]'.")
			
			if(returnValue == nullptr)
			{
				DEBUG_WARNING("The returned value was nullptr!")
			}
			else
			{
				DEBUG_INFO("The returned value was " << returnValue << ".")
			}
			[/let]
			[else]
			DEBUG_INFO("Activity '[mainActivity.name/] does not have any return parameter.")
			[/if]
		}
		else
		{
			std::cout << "Plugin '" << plugin->eNAME() << "' is not an execution plugin!" << std::endl;
		}
	}
	else
	{ 
		std::cout << "Plugin '" << pluginName << "' not found!" << std::endl;
	}
    return EXIT_SUCCESS;
}
[/let]
[/file]
[/template]

[template public generateMainApplicationSourceFromStateMachine(aPackage : Package) { packageName : String = getPackageName(); }]
[file ('../application/src/main.cpp', false, 'UTF-8')]
[let mainStateMachine : StateMachine = aPackage.getMainBehavior().oclAsType(StateMachine)]

#include <iostream>
#include <memory>
#include <vector>

#include "abstractDataTypes/Bag.hpp"
#include "abstractDataTypes/Any.hpp"
#include "uml/UMLAny.hpp"
#include "abstractDataTypes/SubsetUnion.hpp"
[if (mainStateMachine.owner.oclIsKindOf(Classifier))]
#include "[mainStateMachine.owner.oclAsType(Classifier).getNearestPackage().generateNamespacePath(false)/]/[mainStateMachine.owner.oclAsType(Classifier).name.toUpperFirst()/].hpp"
#include "[mainStateMachine.owner.oclAsType(Classifier).getNearestPackage().generateNamespacePath(false)/]/[mainStateMachine.owner.oclAsType(Classifier).getNearestPackage().getPackageName()/]Package.hpp"
#include "[mainStateMachine.owner.oclAsType(Classifier).getNearestPackage().generateNamespacePath(false)/]/[mainStateMachine.owner.oclAsType(Classifier).getNearestPackage().getPackageName()/]Factory.hpp"
[else]
#include "[mainStateMachine.getNearestPackage().generateNamespacePath(false)/]/[mainStateMachine.getNearestPackage().getPackageName()/]Package.hpp"
[/if]
[for ( type : Type | mainStateMachine.ownedParameter.type->reject(isDoNotGenerateElement())->asOrderedSet())]
#include "[type.getNearestPackage().generateNamespacePath(false)/]/[type.name/].hpp"
[/for]
#include "pluginFramework/PluginFramework.hpp"
#include "pluginFramework/UMLExecutionModelPlugin.hpp"

using namespace [aPackage.generateNamespace(false)/];

int main()
{	
    //executing main State Machine
	std::shared_ptr<[if (mainStateMachine.owner.oclIsKindOf(Classifier))][mainStateMachine.owner.oclAsType(Classifier).generateNamespaceName(false)/][else]fUML::MDE4CPP_Extensions::FUML_Object[/if]> element = [if (mainStateMachine.owner.oclIsKindOf(Classifier))][mainStateMachine.owner.oclAsType(Classifier).generateNamespace(false)/]::[mainStateMachine.owner.oclAsType(Classifier).getNearestPackage().getPackageName()/]Factory::eInstance()->create[mainStateMachine.owner.oclAsType(Classifier).name.toUpperFirst()/]()[else]nullptr[/if];

	std::shared_ptr<PluginFramework> pluginFramework = PluginFramework::eInstance();
	std::string pluginName = "[mainStateMachine.getRootPackage().getPackageName()/]Exec";
	std::shared_ptr<MDE4CPPPlugin> plugin = pluginFramework->findPluginByName(pluginName);
	if (plugin)
	{
		DEBUG_INFO("Plugin '" << plugin->eNAME() << "' found.")

		std::shared_ptr<UMLExecutionModelPlugin> executionPlugin = std::dynamic_pointer_cast<UMLExecutionModelPlugin>(plugin);
		if (executionPlugin)
		{
			DEBUG_INFO("Execution plugin '" << executionPlugin->eNAME() << "' is accessable.")

			std::shared_ptr<Bag<Any>> parameterList(new Bag<Any>());
			[for (aParameter : Parameter | mainStateMachine.ownedParameter->select((direction = ParameterDirectionKind::inout) or (direction = ParameterDirectionKind::_in)))]
			parameterList->add([aParameter.generateAnyCreationFromParameter()/]);
			[/for]
			std::shared_ptr<Any> StateMachineResult = executionPlugin->executeStateMachine([mainStateMachine.generatePackageGetterCall()/], parameterList, element);


			[if (mainStateMachine.ownedParameter->select(p :Parameter | p.direction = ParameterDirectionKind::return)->notEmpty())]
			[let returnParameter : Parameter = mainStateMachine.ownedParameter->select(p :Parameter | p.direction = ParameterDirectionKind::return)->first()]
			[returnParameter.type.generateCppRawType(false)/] returnValue = StateMachineResult->get<[returnParameter.type.generateCppRawType(false)/]>();
			DEBUG_INFO("State Machine '[mainStateMachine.name/]' has a return parameter named '[returnParameter.name/]'.")
			
			if(returnValue == nullptr)
			{
				DEBUG_WARNING("The returned value was nullptr!")
			}
			else
			{
				DEBUG_INFO("The returned value was " << returnValue << ".")
			}
			[/let]
			[else]
			DEBUG_INFO("State Machine '[mainStateMachine.name/] does not have any return parameter.")
			[/if]
		}
		else
		{
			std::cout << "Plugin '" << plugin->eNAME() << "' is not an execution plugin!" << std::endl;
		}
	}
	else
	{ 
		std::cout << "Plugin '" << pluginName << "' not found!" << std::endl;
	}
    return EXIT_SUCCESS;
}
[/let]
[/file]
[/template]