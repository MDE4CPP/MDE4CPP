<?xml version="1.0" encoding="UTF-8"?>
<ecore:EPackage xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore" name="PSSM" nsURI="http://www.omg.org/spec/PSSM/20161101" nsPrefix="PSSM">
  <eSubpackages name="Semantics" nsURI="http:///PSSM/Semantics.ecore" nsPrefix="PSSM.Semantics">
    <eSubpackages name="Values" nsURI="http:///PSSM/Semantics/Values.ecore" nsPrefix="PSSM.Semantics.Values">
      <eClassifiers xsi:type="ecore:EClass" name="SM_OpaqueExpressionEvaluation">
        <eOperations name="executeExpressionBehavior" ordered="false" upperBound="-1"
            eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// An opaque expression can have an associated behavior. If this is the case&#xD;&#xA;// this behavior is executed. Values produced by the execution of the behavior&#xD;&#xA;// are the result of the evaluation of the opaque expression &#xD;&#xA;//List&lt;Value> evaluation = new ArrayList&lt;Value>();&#xD;&#xA;//OpaqueExpression expression = (OpaqueExpression)this.specification;&#xD;&#xA;//Behavior behavior = expression.getBehavior();&#xD;&#xA;//if(behavior != null) {&#xD;&#xA;//&#x9;List&lt;ParameterValue> results = this.locus.executor.execute(behavior, context, this.parameterValues);&#xD;&#xA;//&#x9;for(int i = 0; i &lt; results.size(); i++) { // results.size should be 1&#xD;&#xA;//&#x9;&#x9;ParameterValue parameterValue = results.get(i);&#xD;&#xA;//&#x9;&#x9;List&lt;Value> values = parameterValue.values;&#xD;&#xA;//&#x9;&#x9;for(int j = 0; j &lt; values.size(); j++) {&#xD;&#xA;//&#x9;&#x9;&#x9;evaluation.add(values.get(j));&#xD;&#xA;//&#x9;&#x9;}&#xD;&#xA;//&#x9;}&#xD;&#xA;//}&#xD;&#xA;//return evaluation;&#xD;&#xA;&#x9;return nullptr;&#xD;&#xA;&#x9;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="initialize" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// The event occurrence that is about or is currently dispatched can&#xA;// have data. In such situation if the behavior that is associated&#xA;// to the OpaqueExpression input conforms with the proposed signal&#xA;// event occurrence or the input parameters of the call event occurrence&#xA;// then event occurrence data are passed to this behavior and used&#xA;// to produce the guard verdict.&#xA;//this.parameterValues.clear();&#xA;//OpaqueExpression expression = (OpaqueExpression)this.specification;&#xA;//if(expression.getBehavior().getOwnedParameters().size() > 0){&#xA;//&#x9;Behavior behavior = expression.getBehavior();&#xA;//&#x9;if(eventOccurrence instanceof SignalEventOccurrence){&#xA;//&#x9;&#x9;SignalEventOccurrence signalEventOccurrence = (SignalEventOccurrence) eventOccurrence;&#xA;//&#x9;&#x9;if(behavior.inputParameters().size() == 1){&#xA;//&#x9;&#x9;&#x9;Parameter parameter = behavior.inputParameters().get(0);&#xA;//&#x9;&#x9;&#x9;ParameterValue parameterValue = new ParameterValue();&#xA;//&#x9;&#x9;&#x9;parameterValue.parameter = parameter;&#xA;//&#x9;&#x9;&#x9;List&lt;Value> values = new ArrayList&lt;Value>();&#xA;//&#x9;&#x9;&#x9;values.add(signalEventOccurrence.signalInstance);&#xA;//&#x9;&#x9;&#x9;parameterValue.values = values;&#xA;//&#x9;&#x9;&#x9;this.setParameterValue(parameterValue);&#xA;//&#x9;&#x9;}&#xA;//&#x9;}else if(eventOccurrence instanceof CallEventOccurrence){&#xA;//&#x9;&#x9;CallEventOccurrence callEventOccurrence = (CallEventOccurrence) eventOccurrence;&#xA;//&#x9;&#x9;List&lt;Parameter> behaviorInputParameters = behavior.inputParameters();&#xA;//&#x9;&#x9;List&lt;ParameterValue> inputParameterValues = callEventOccurrence.execution.getInputParameterValues();&#xA;//&#x9;&#x9;if(behaviorInputParameters.size() == inputParameterValues.size()){&#xA;//&#x9;&#x9;&#x9;int i = 1;&#xA;//&#x9;&#x9;&#x9;while(i &lt;= behaviorInputParameters.size()){&#xA;//&#x9;&#x9;&#x9;&#x9;ParameterValue parameterValue = new ParameterValue();&#xA;//&#x9;&#x9;&#x9;&#x9;parameterValue.parameter = behaviorInputParameters.get(i - 1);&#xA;//&#x9;&#x9;&#x9;&#x9;parameterValue.values = inputParameterValues.get(i - 1).values;&#xA;//&#x9;&#x9;&#x9;&#x9;this.setParameterValue(parameterValue);&#xA;//&#x9;&#x9;&#x9;&#x9;i++;&#xA;//&#x9;&#x9;&#x9;}&#xA;//&#x9;&#x9;}&#xA;//&#x9;}&#xA;//}&#xA;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="getParameterValue" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/ParameterValue">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Return the parameter value corresponding to the given parameter.&#xD;&#xA;&#x9;// Null is returned if no parameter value associated with the parameter&#xD;&#xA;&#x9;// is found.&#xD;&#xA;&#x9;//int i = 0;&#xD;&#xA;&#x9;//ParameterValue parameterValue = null;&#xD;&#xA;&#x9;//while(parameterValue == null &amp;&amp; i &lt; this.parameterValues.size()){&#xD;&#xA;&#x9;//&#x9;if(this.parameterValues.get(i).parameter == parameter){&#xD;&#xA;&#x9;//&#x9;&#x9;parameterValue = this.parameterValues.get(i);&#xD;&#xA;&#x9;//&#x9;}&#xD;&#xA;&#x9;//&#x9;i++;&#xD;&#xA;&#x9;//}&#xD;&#xA;&#x9;//return parameterValue;&#xD;&#xA;&#x9;return nullptr;"/>
          </eAnnotations>
          <eParameters name="parameter" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Parameter"/>
        </eOperations>
        <eOperations name="setParameterValue" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// If this parameter value does not exist then it is added&#xA;// to the list parameter values&#xA;//if(this.getParameterValue(parameterValue.parameter) == null){&#xA;//&#x9;this.parameterValues.add(parameterValue);&#xA;//}&#xA;"/>
          </eAnnotations>
          <eParameters name="parameterValue" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/ParameterValue"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="context" ordered="false"
            eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/ParameterValue"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="parameterValues" ordered="false"
            upperBound="-1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/ParameterValue"/>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="StructuredClassifiers" nsURI="http:///PSSM/Semantics/StructuredClassifiers.ecore"
        nsPrefix="PSSM.Semantics.StructuredClassifiers">
      <eClassifiers xsi:type="ecore:EClass" name="SM_Object" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/StructuredClassifiers/Object">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="doNotGenerate" value="Class 'SM_Object' is excluded from generation because it is obsolete.&#xA;Objects are represented by class uml::Element in this fUML implementation.&#xA;This is possible because in MDE4CPP, all C++ classes generated from UML classes inherit from uml::Element."/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="SM_RedefinitionBasedDispatchStrategy">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;fUML/Semantics/Loci/Locus.hpp&quot;&#xD;&#xA;#include &quot;fUML/Semantics/Loci/ExecutionFactory.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="getMethod" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Behavior">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Behaves as in fUML and PSCS except that if no method is declared&#xD;&#xA;&#x9;// for the operation then null is returned.&#xD;&#xA;&#x9;/*auto method = std::make_shared&lt;uml::Behavior>();&#xD;&#xA;&#x9;for (auto type : *(object->getTypes()))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;for (auto memberOperation : *(type->getAllOperations()))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;if (memberOperation == operation)&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;method = memberOperation->getMethod()->operator[](0);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return method;*/&#xD;&#xA;&#x9;return nullptr;&#xD;&#xA;&#xD;&#xA;&#x9;/*Behavior method = null;&#xD;&#xA;&#x9;int i = 1;&#xD;&#xA;&#x9;while (method == null &amp; i &lt;= object.types.size()) {&#xD;&#xA;&#x9;&#x9;Class type = object.types.get(i - 1);&#xD;&#xA;&#x9;&#x9;List&lt;NamedElement> members = type.getMembers();&#xD;&#xA;&#x9;&#x9;int j = 1;&#xD;&#xA;&#x9;&#x9;while (method == null &amp; j &lt;= members.size()) {&#xD;&#xA;&#x9;&#x9;&#x9;NamedElement member = members.get(j - 1);&#xD;&#xA;&#x9;&#x9;&#x9;if (member instanceof Operation) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;Operation memberOperation = (Operation) member;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (this.operationsMatch(memberOperation, operation)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(memberOperation.getMethods().size() > 0){&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;method = memberOperation.getMethods().get(0);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;j = j + 1;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;i = i + 1;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return method;*/"/>
          </eAnnotations>
          <eParameters name="object" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//MDE4CPP_Extensions/FUML_Object"/>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
        </eOperations>
        <eOperations name="dispatch" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/Execution">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Try to dispatch the operation has specified in fUML. If no method is defined&#xD;&#xA;&#x9;// for the dispatched operation then null is returned. In this situation, the&#xD;&#xA;&#x9;// dispatching of the operation is computed as being by with using the&#xD;&#xA;&#x9;// call event semantics.&#xD;&#xA;&#x9;auto method = this->getMethod(object, operation);&#xD;&#xA;&#x9;if (method != nullptr)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;auto execution = object->getLocus()->getFactory()->createExecution(method, object);&#xD;&#xA;&#x9;&#x9;return execution;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;else&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;/*auto execution = std::make_shared&lt;PSSM::Semantics::CommonBehavior::CallEventExecution>();&#xD;&#xA;&#x9;&#x9;execution->setContext(object);&#xD;&#xA;&#x9;&#x9;execution->setOperation(operation);&#xD;&#xA;&#x9;&#x9;return execution;*/&#xD;&#xA;&#x9;&#x9;return nullptr;&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;/*Execution execution = null;&#xD;&#xA;&#x9;Behavior method = this.getMethod(object, operation);&#xD;&#xA;&#x9;if(method == null){&#xD;&#xA;&#x9;&#x9;execution = new CallEventExecution();&#xD;&#xA;&#x9;&#x9;execution.context = object;&#xD;&#xA;&#x9;&#x9;((CallEventExecution)execution).operation = operation;&#xD;&#xA;&#x9;}else{&#xD;&#xA;&#x9;&#x9;execution = object.locus.factory.createExecution(method, object);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return execution;*/"/>
          </eAnnotations>
          <eParameters name="object" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//MDE4CPP_Extensions/FUML_Object"/>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
        </eOperations>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="CommonBehavior" nsURI="http:///PSSM/Semantics/CommonBehavior.ecore"
        nsPrefix="PSSM.Semantics.CommonBehavior">
      <eClassifiers xsi:type="ecore:EClass" name="SM_ObjectActivation" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/ObjectActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;fUML/FUMLFactory.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="getNextCompletionEvent" ordered="false" lowerBound="1"
            eType="#//Semantics/StateMachines/CompletionEventOccurrence">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="for (auto event : *(m_eventPool))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (auto completionEvent = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::CompletionEventOccurrence>(event))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;return completionEvent;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return nullptr;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getDeferredEventInsertionIndex" ordered="false" lowerBound="1"
            eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Integer">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Deferred events are always registered after completion events if any.&#xD;&#xA;&#x9;// Return the insertion point for deferred events.&#xD;&#xA;&#x9;for (auto event : *(m_eventPool))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (auto deferredEvent = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::DeferredEventOccurrence>(event)) &#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;return m_eventPool->index_of(event);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return -1;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="registerCompletionEvent" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Create a CompletionEvent for the given StateActivation and place it in the event pool.&#xD;&#xA;&#x9;auto completionEventOccurrence(PSSM::Semantics::StateMachines::StateMachinesFactory::eInstance()->createCompletionEventOccurrence_as_eventPool_in_ObjectActivation(this->getThisObjectActivationPtr()));&#xD;&#xA;&#x9;completionEventOccurrence->setStateActivation(stateActivation);&#xD;&#xA;&#x9;DEBUG_INFO(&quot;StateActivation &quot; &lt;&lt; stateActivation &lt;&lt; &quot; registered an CompletionEventOccurrence!&quot;)&#xD;&#xA;&#xD;&#xA;&#x9;// As there is currently no dispatch loop running asynchronously, try dispatching this Event immediateley&#xD;&#xA;&#x9;DEBUG_INFO(&quot;Dispatching Event immediateley:&quot;);&#xD;&#xA;&#x9;this->dispatchNextEvent();"/>
          </eAnnotations>
          <eParameters name="stateActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateActivation"/>
        </eOperations>
        <eOperations name="releaseDeferredEvents" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// The release of event occurrence(s) deferred by the deferring state implIncludes the following step:..."/>
          </eAnnotations>
          <eParameters name="deferringState" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateActivation"/>
        </eOperations>
        <eOperations name="registerDeferredEvent" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// An event occurrence registered as being deferred is registered within the deferred event pool.&#xA;//DeferredEventOccurrence deferredEventOccurrence = new DeferredEventOccurrence();&#xA;//deferredEventOccurrence.constrainingStateActivation = deferringState;&#xA;//deferredEventOccurrence.deferredEventOccurrence = eventOccurrence;&#xA;//this.deferredEventPool.add(deferredEventOccurrence);&#xA;&#xA;//std::shared_ptr&lt;PSSM::Semantics::StateMachines::DeferredEventOccurrence> deferredEventOccurrence = new PSSM::Semantics::StateMachines::DeferredEventOccurrence();&#xA;//deferredEventOccurrence->setDeferredEventOccurrence(eventOccurrence);&#xA;//this->m_deferredEventPool->add(deferredEventOccurrence);"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="stateActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateActivation"/>
        </eOperations>
        <eOperations name="retrieveNextEvent" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Redefinition of fUML::ObjectActivation to accommodate to priorities of PSSM-specific EventOccurrences:&#xD;&#xA;&#x9;// All CompletionEventOccurrences are dispatched first. They are dispatched according to their order of arrival in the pool. &#xD;&#xA;&#x9;// Only if no CompletionEventOccurrences are in the pool, then regular EventOccurrences are dispatched according to the set dispatching policy. &#xD;&#xA;&#x9;// Note that if the currently dispatched EventOccurrence was previously deferred, &#xD;&#xA;&#x9;// then it is unwrapped and its encapsulated 'deferredEventOccurrence' is actually dispatched.&#xD;&#xA;&#x9;auto nextEvent = std::dynamic_pointer_cast&lt;fUML::Semantics::CommonBehavior::EventOccurrence>(this->getNextCompletionEvent());&#xD;&#xA;&#x9;if(nextEvent == nullptr)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;nextEvent = this->getThisObjectActivationPtr()->retrieveNextEvent();&#xD;&#xA;&#xD;&#xA;&#x9;&#x9;auto deferredEvent = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::DeferredEventOccurrence>(nextEvent);&#xD;&#xA;&#xD;&#xA;&#x9;&#x9;if( deferredEvent != nullptr)&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;nextEvent =  deferredEvent->getDeferredEventOccurrence();&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;return nextEvent;"/>
          </eAnnotations>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="deferredEventPool"
            ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/DeferredEventOccurrence"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="EventTriggeredExecution" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/Execution">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;fUML/FUMLFactory.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="finalize" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Transfer output parameter values (produced by the wrapped execution) back to&#xA;// the execution associated t the call event.&#xA;// If an effect, entry or exit Behavior is not just input-conforming, then the&#xA;// values of its output Parameters are passed out of its Behavior Execution on&#xA;// its completion as potential values for the output Parameters of the called &#xA;// Operation.&#xA;// &#xA;// Notes: &#xA;//    If the CallEvent is for a synchronous call, then the call ends at the end&#xA;//    of the triggered run-to-completion (RTC) step. If the called Operation has&#xA;//    output Parameters, then the values returned for those parameters are those&#xA;//    produced by the last effect, entry or exit Behavior to complete its execution&#xA;//    during the RTC step. Since some or all of those Behaviors may execute concurrently,&#xA;//    which one completes last may be only partially determined by the specified semantics.&#xA;//    The values returned may legally be those produced any Behavior that produces potential&#xA;//    output values and is the last to complete in any execution trace for the RTC&#xA;//    step consistent with the specified StateMachine semantics.&#xA;this->_beginIsolation();&#xA;if(PSSM::Semantics::CommonBehavior::CallEventOccurrence callEventOccurrence = dynamic_cast&lt;PSSM::Semantics::CommonBehavior::CallEventOccurrence>(this->getTriggeringEventOccurrence())){&#xA;&#x9;uml::Behavior behavior = this->getWrappedExecution()->getBehavior();&#xA;&#x9;auto outputParameterValues = this->getWrappedExecution()->getOutputParameterValues();&#xA;&#x9;if(behavior.outputParameters().size() == outputParameterValues.size()){&#xA;&#x9;&#x9;int i = 1;&#xA;&#x9;&#x9;auto behaviorOutputParameters = callEventOccurrence->getExecution()->getBehavior()->getOutputParameterValues();&#xA;&#x9;&#x9;while(i &lt;= behaviorOutputParameters.size()){&#xA;&#x9;&#x9;&#x9;ParameterValue parameterValue;&#xA;&#x9;&#x9;&#x9;parameterValue.parameter = behaviorOutputParameters.get(i - 1);&#xA;&#x9;&#x9;&#x9;parameterValue.values = outputParameterValues.get(i - 1).values;&#xA;&#x9;&#x9;&#x9;callEventOccurrence->execution->setParameterValue(parameterValue);&#xA;&#x9;&#x9;&#x9;++i;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;this->_endIsolation();&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="execute" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="documentation" value="Execute the behavior given by the type of this execution. &#xD;&#xA;The parameterValues for any input (in or in-out) parameters of the behavior should be set before the execution.&#xD;&#xA;The parameteValues for any output (in-out, out or return) parameters of the behavior will be set by the execution.&#xD;&#xA;"/>
            <details key="body" value="// First the behavior handled by the wrapped execution is parameterized&#xA;// with parameter input values provided by the triggering event occurrence.&#xA;// The behavior handled by the wrapped Execution is executed and finally outputs&#xA;// are passed out to the triggering event occurrence (only occurs in the case of&#xA;// a call event occurrence).&#xA;&#x9;if(this->getWrappedExecution() != nullptr &amp;&amp; this->getTriggeringEventOccurrence() != nullptr)&#xA;&#x9;{&#xA;&#x9;&#x9;this->initialize();&#xA;&#x9;&#x9;this->getWrappedExecution()->execute();&#xA;&#x9;&#x9;this->finalize();&#xA;&#x9;}&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="initialize" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Transfer input parameter values of the call event execution&#xA;// to the wrapped execution if possible. Two situations are considered&#xA;// 1. If the triggering EventOccurrence is for a SignalEvent, then all&#xA;//    executed behavior will have either one parameter or no parameters.&#xA;//    If a behavior has a Parameter, the SignalInstance corresponding to&#xA;//    the SignalEventOccurrence is passed into the behavior Execution as&#xA;//    the value of its parameter.&#xA;// 2. If the triggering EventOccurrence is for a CallEvent, then all executed&#xA;//    behaviors will have either no Parameters or signatures that conform or&#xA;//    input conform to the operation being called.&#xA;//    If a Behavior has Parameters, then the values of the input Parameters&#xA;//    of for the call are passed into the Behavior Execution as the values&#xA;//    of the corresponding input Parameters of the Behavior.&#xA;this._beginIsolation();&#xA;if(this.wrappedExecution.getBehavior().getOwnedParameters().size() > 0){&#xA;&#x9;Behavior behavior = this.wrappedExecution.getBehavior();&#xA;&#x9;if(this.triggeringEventOccurrence instanceof SignalEventOccurrence){&#xA;&#x9;&#x9;SignalEventOccurrence signalEventOccurrence = (SignalEventOccurrence) this.triggeringEventOccurrence;&#xA;&#x9;&#x9;if(behavior.inputParameters().size() == 1){&#xA;&#x9;&#x9;&#x9;Parameter parameter = behavior.inputParameters().get(0);&#xA;&#x9;&#x9;&#x9;ParameterValue parameterValue = new ParameterValue();&#xA;&#x9;&#x9;&#x9;parameterValue.parameter = parameter;&#xA;&#x9;&#x9;&#x9;List&lt;Value> values = new ArrayList&lt;Value>();&#xA;&#x9;&#x9;&#x9;values.add(signalEventOccurrence.signalInstance);&#xA;&#x9;&#x9;&#x9;parameterValue.values = values;&#xA;&#x9;&#x9;&#x9;this.wrappedExecution.setParameterValue(parameterValue);&#xA;&#x9;&#x9;}&#xA;&#x9;}else if(this.triggeringEventOccurrence instanceof CallEventOccurrence){&#xA;&#x9;&#x9;CallEventOccurrence callEventOccurrence = (CallEventOccurrence) this.triggeringEventOccurrence;&#xA;&#x9;&#x9;List&lt;Parameter> behaviorInputParameters = behavior.inputParameters();&#xA;&#x9;&#x9;List&lt;ParameterValue> inputParameterValues = callEventOccurrence.execution.getInputParameterValues();&#xA;&#x9;&#x9;if(behaviorInputParameters.size() == inputParameterValues.size()){&#xA;&#x9;&#x9;&#x9;int i = 1;&#xA;&#x9;&#x9;&#x9;while(i &lt;= behaviorInputParameters.size()){&#xA;&#x9;&#x9;&#x9;&#x9;ParameterValue parameterValue = new ParameterValue();&#xA;&#x9;&#x9;&#x9;&#x9;parameterValue.parameter = behaviorInputParameters.get(i - 1);&#xA;&#x9;&#x9;&#x9;&#x9;parameterValue.values = inputParameterValues.get(i - 1).values;&#xA;&#x9;&#x9;&#x9;&#x9;this.wrappedExecution.setParameterValue(parameterValue);&#xA;&#x9;&#x9;&#x9;&#x9;i++;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;this._endIsolation();&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="copy" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="auto copy = std::shared_ptr&lt;EventTriggeredExecutionImpl>(new EventTriggeredExecutionImpl);&#xA;&#x9;copy->setTriggeringEventOccurrence(this->getTriggeringEventOccurrence());&#xA;&#x9;copy->setWrappedExecution(this->getWrappedExecution());&#xA;&#x9;return std::make_shared&lt;Any>(copy);&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="new_" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="documentation" value="Create a new execution with no behavior or parameterValues.&#xD;&#xA;"/>
            <details key="body" value="return std::make_shared&lt;Any>(new EventTriggeredExecution());&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="wrappedExecution" ordered="false"
            lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/Execution"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="triggeringEventOccurrence"
            ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CallEventExecution" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/Execution">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;PSSM/Semantics/CommonBehavior/CallEventOccurrence.hpp&quot;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/CommonBehaviorFactory.hpp&quot;&#xA;#include &quot;fUML/FUMLFactory.hpp&quot;&#xA;#include &quot;uml/ParameterDirectionKind.hpp&quot;&#xA;#include &quot;uml/Parameter.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="_send" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Place the call event occurrence within the event pool of&#xA;// the target object&#xA;//if(this.context.objectActivation != null){&#xA;//&#x9;this.context.objectActivation.eventPool.add(eventOccurrence);&#xA;//&#x9;this.context.objectActivation._send(new ArrivalSignal());&#xA;//}&#xA;&#x9;// empty body because:&#xA;&#x9;// a) fUML::ObjectActivation::eventPool contains fUML::SignalInstance, not fUML::EventOccurrence (no common parent classes)&#xA;&#x9;// b) fUML::ObjectActvation::_send has an empty body too"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="#//Semantics/CommonBehavior/CallEventOccurrence"/>
        </eOperations>
        <eOperations name="_suspend" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="while(this->m_callerSuspended);"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="execute" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="documentation" value="Execute the behavior given by the type of this execution. &#xD;&#xA;The parameterValues for any input (in or in-out) parameters of the behavior should be set before the execution.&#xD;&#xA;The parameteValues for any output (in-out, out or return) parameters of the behavior will be set by the execution.&#xD;&#xA;"/>
            <details key="body" value="// The execution consists in placing a new CallEventOccurrence&#xA;// within the event pool of the target active object. Not that&#xA;// the call will not be executed if the target is not an active&#xA;// object. This is due to the fact that the call event could&#xA;// not placed anywhere since a passive object has no event pool.&#xA;// The caller is expected to be suspended until the RTC step using&#xA;// the event occurrence terminates.&#xA;//CallEventOccurrence eventOccurrence = new CallEventOccurrence();&#xA;//eventOccurrence.execution = this;&#xA;//this.callerSuspended = true;&#xA;//this._send(eventOccurrence);&#xA;//this._suspend();&#xA;&#x9;std::shared_ptr&lt;PSSM::Semantics::CommonBehavior::CallEventOccurrence> eventOccurrence = PSSM::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createCallEventOccurrence();&#xA;&#x9;eventOccurrence->setExecution(this->getThisCallEventExecutionPtr());&#xA;&#x9;this->m_callerSuspended = true;&#xA;&#x9;this->_send(eventOccurrence);&#xA;&#x9;this->_suspend();"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getBehavior" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Behavior">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value=""/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Compute a behavior signature corresponding to the operation&#xA;if(this.behavior == null){&#xA;&#x9;this.behavior = UMLFactory.eINSTANCE.createFunctionBehavior();&#xA;&#x9;for(int i = 0; i &lt; this.operation.getOwnedParameters().size(); i++){&#xA;&#x9;&#x9;Parameter operationParameter = this.operation.getOwnedParameters().get(i);&#xA;&#x9;&#x9;Parameter parameter = UMLFactory.eINSTANCE.createParameter();&#xA;&#x9;&#x9;parameter.setName(operationParameter.getName());&#xA;&#x9;&#x9;parameter.setType(operationParameter.getType());&#xA;&#x9;&#x9;parameter.setLower(operationParameter.getLower());&#xA;&#x9;&#x9;parameter.setUpper(operationParameter.getUpper());&#xA;&#x9;&#x9;parameter.setDirection(operationParameter.getDirection());&#xA;&#x9;&#x9;this.behavior.getOwnedParameters().add(parameter);&#xA;&#x9;}&#xA;}&#xA;return this.behavior;&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="new_" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <eAnnotations source="http://tu-ilmenau.de/see/codegen">
              <details key="documentation" value="Create a new execution with no behavior or parameterValues.&#xD;&#xA;"/>
              <details key="body" value="return PSSM::PSSMFactory::eInstance()->createCallEventExecution();"/>
            </eAnnotations>
            <details key="documentation" value="Create a new execution with no behavior or parameterValues.&#xD;&#xA;"/>
            <details key="body" value="return eEcoreAny(PSSM::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createCallEventExecution(), PSSM::Semantics::CommonBehavior::CommonBehaviorPackage::CALLEVENTEXECUTION_CLASS);"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="releaseCaller" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="this->m_callerSuspended = false;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getInputParameterValues" ordered="false" upperBound="-1"
            eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/ParameterValue">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Return input parameter values for this execution&#xA;//List&lt;ParameterValue> parameterValues = new ArrayList&lt;ParameterValue>();&#xA;//for(int i=0; i &lt; this.parameterValues.size(); i++){&#xA;//&#x9;ParameterValue parameterValue = this.parameterValues.get(i);&#xA;//&#x9;if(parameterValue.parameter.getDirection() == ParameterDirectionKind.IN_LITERAL&#xA;//&#x9;&#x9;&#x9;| parameterValue.parameter.getDirection() == ParameterDirectionKind.INOUT_LITERAL){&#xA;//&#x9;&#x9;parameterValues.add(parameterValue);&#xA;//&#x9;}&#xA;//}&#xA;//return parameterValues;&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::CommonBehavior::ParameterValue>> parameterValues(new Bag&lt;fUML::Semantics::CommonBehavior::ParameterValue>());&#xA;&#x9;for(int i=0; i &lt; int(this->m_parameterValues->size()); i++) {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::CommonBehavior::ParameterValue> parameterValue = this->m_parameterValues->at(i);&#xA;&#x9;&#x9;if((parameterValue->getParameter()->getDirection() == uml::ParameterDirectionKind::IN) |&#xA;&#x9;&#x9;&#x9;&#x9;(parameterValue->getParameter()->getDirection() == uml::ParameterDirectionKind::INOUT)) {&#xA;&#x9;&#x9;&#x9;parameterValues->add(parameterValue);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return parameterValues;&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="callerSuspended" ordered="false"
            lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="callerContext" ordered="false"
            lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//MDE4CPP_Extensions/FUML_Object"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="operation" ordered="false"
            lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="behavior" ordered="false"
            lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Behavior"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CallEventOccurrence" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;fUML/FUMLFactory.hpp&quot;"/>
        </eAnnotations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="execution" ordered="false"
            lowerBound="1" eType="#//Semantics/CommonBehavior/CallEventExecution"/>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="StateMachines" nsURI="http:///PSSM/Semantics/StateMachines.ecore"
        nsPrefix="PSSM.Semantics.StateMachines">
      <eClassifiers xsi:type="ecore:EClass" name="RegionActivation" eSuperTypes="#//Semantics/StateMachines/StateMachineSemanticVisitor">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;uml/State.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="terminate" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Capture the semantics related to the termination of a Region. Regions typically&#xA;&#x9;// get terminated when the owning StateMachine terminates.&#xA;&#x9;for (auto&amp; vertexActivation : *m_vertexActivations) &#xA;&#x9;{&#xA;&#x9;&#x9;vertexActivation->terminate();&#xA;&#x9;}&#xA;&#x9;m_vertexActivations->clear();&#xA;&#x9;m_transitionActivations->clear();"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getOrigin" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/InitialPseudostateActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Return, if any, the initial pseudo-state activation directly&#xD;&#xA;&#x9;// owned by this region.&#xD;&#xA;&#x9;for (auto&amp; vertexActivation : *(this->m_vertexActivations))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (auto initialPSActivation = std::dynamic_pointer_cast&lt;InitialPseudostateActivation>(vertexActivation))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;return initialPSActivation;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return nullptr;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getVertexActivations" ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/VertexActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="&#x9;return m_vertexActivations;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getTransitionActivations" ordered="false" upperBound="-1"
            eType="#//Semantics/StateMachines/TransitionActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="&#x9;return m_transitionActivations;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getVertexActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Recursive search through the hierarchy of Visitors materializing&#xA;&#x9;// the subset of the StateMachine represented by this Region.&#xA;&#x9;// The search is realized similar to a breadth-first search:&#xA;&#x9;// &#x9;1 - Search a matching Activation in set of VertexActivations owned by this RegionActivation&#xA;&#x9;//  2 - If no match, then the search call is propagated to each VertexActivation owned by this RegionActivation&#xA;&#x9;// Matching rules (or):&#xA;&#x9;//  1 - The node for which this Activation is an interpreter is the Vertex.&#xA;&#x9;//  2 - The node for which this Activation is an interpreter redefines the Vertex &#xA;&#x9;for (auto&amp; vertexActivation : *(this->m_vertexActivations))&#xA;&#x9;{&#xA;&#x9;&#x9;if(vertexActivation->isVisitorFor(vertex))&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return vertexActivation;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;for (auto&amp; vertexActivation : *(this->m_vertexActivations))&#xA;&#x9;{&#xA;&#x9;&#x9;if(vertexActivation->isVisitorFor(vertex))&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;vertexActivation->getVertexActivation(vertex);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return nullptr;"/>
          </eAnnotations>
          <eParameters name="vertex" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Vertex"/>
        </eOperations>
        <eOperations name="isRedefined" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Depth-first Check if given Vertex is redefined by another Vertex of given list. The only redefinable Vertex is the State.&#xD;&#xA;&#x9;for (auto&amp; currentVertex : *vertices)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (auto currentState = std::dynamic_pointer_cast&lt;uml::State>(currentVertex))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;auto redefinedState = currentState->getRedefinedState();&#xD;&#xA;&#x9;&#x9;&#x9;while (redefinedState != nullptr) &#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (redefinedState == vertex) &#xD;&#xA;&#x9;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return true;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return false;"/>
          </eAnnotations>
          <eParameters name="vertices" ordered="false" upperBound="-1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Vertex"/>
          <eParameters name="vertex" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Vertex"/>
        </eOperations>
        <eOperations name="isRedefined" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Depth-first Check if given Transition is redefined by another Transition of given list.&#xA;&#x9;for (auto&amp; currentTransition : *transitions)&#xA;&#x9;{&#xA;&#x9;&#x9;auto redefinedTransition = currentTransition->getRedefinedTransition();&#xA;&#x9;&#x9;while (redefinedTransition != nullptr) &#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if (redefinedTransition == transition) &#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return false;"/>
          </eAnnotations>
          <eParameters name="transitions" ordered="false" upperBound="-1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Transition"/>
          <eParameters name="transition" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Transition"/>
        </eOperations>
        <eOperations name="enter" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// If a Region is entered implicitly, its execution will start at the InitialPseudoState it owns by fireing the transition to the InitialPseudoState. If no such InitialPseudoState exists, the propagation of the Transition path is invalid for this region, thus it will not be entered. &#xD;&#xA;&#x9;// In case the Region is not entered, its Activation will be removed from an owning State's set of RegionActivations to complete. Should this be the last Region to be completed, the State will be notified as completed itself.&#xD;&#xA;&#x9;auto initialPSActivation = this->getOrigin();&#xD;&#xA;&#x9;if (initialPSActivation != nullptr) &#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;initialPSActivation->enter(enteringTransition, eventOccurrence, nullptr);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;else&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (auto parentStateActivation = std::dynamic_pointer_cast&lt;StateActivation>(this->getParent()))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;parentStateActivation->getRegionActivations()->erase(this->getThisRegionActivationPtr());&#xD;&#xA;&#x9;&#x9;&#x9;if(parentStateActivation->hasCompleted())&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;parentStateActivation->notifyCompletion();&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="exit" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Exiting a Region implies exiting all of is active Vertices.&#xA;&#x9;// Note: There is always a single active Vertex for a given Region.&#xA;&#x9;for (int i = 0; i &lt; int(m_vertexActivations->size()); ++i)&#xA;&#x9;//for (auto&amp; vertexActivation : this->getVertexActivations())&#xA;&#x9;{&#xA;&#x9;&#x9;auto vertexActivation = m_vertexActivations->at(i);&#xA;&#x9;&#x9;if (vertexActivation->isActive())&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;vertexActivation->exit(exitingTransition, eventOccurrence, nullptr);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;this->setIsCompleted(false);"/>
          </eAnnotations>
          <eParameters name="exitingTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="canPropagateExecution" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="bool propagate = true;&#xD;&#xA;&#x9;// Check if given Transition enters a Vertex of this Regionsharedptr&lt;DerivedAbstract> name = std::dynamic_pointer_cast&lt;Vertex>(einSharedPointer)&#xD;&#xA;&#x9;if (this->getVertexActivation(std::dynamic_pointer_cast&lt;uml::Vertex>(enteringTransition->getTargetActivation()->getNode())) == nullptr)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;auto initialPSActivation = this->getOrigin();&#xD;&#xA;&#x9;&#x9;if (initialPSActivation != nullptr)&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;propagate = initialPSActivation->canPropagateExecution(enteringTransition, eventOccurrence, nullptr);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return propagate;"/>
          </eAnnotations>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="transitionActivations"
            ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/TransitionActivation"
            containment="true"/>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="isCompleted" ordered="false"
            lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="vertexActivations"
            ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/VertexActivation"
            containment="true"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="history" ordered="false"
            eType="#//Semantics/StateMachines/StateActivation"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="StateMachineSemanticVisitor" abstract="true"
          eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/Loci/SemanticVisitor">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;PSSM/Semantics/CommonBehavior/EventTriggeredExecution.hpp&quot;&#xD;&#xA;#include &quot;fUML/FUMLFactory.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/StateMachineExecution.hpp&quot;&#xD;&#xA;#include &quot;uml/CallEvent.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/ExitPointPseudostateActivation.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/EntryPointPseudostateActivation.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/CallEventOccurrence.hpp&quot;&#xD;&#xA;#include &quot;fUML/Semantics/Loci/ExecutionFactory.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/CallEventExecution.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/CommonBehaviorFactory.hpp&quot;&#xD;&#xA;#include &quot;PSSM/PSSMFactory.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="activate" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// This operation is intended to be overridden by sub-classes. For required sub-classes&#xA;// (e.g., RegionActivation, StateActivation) it will initiate the instantiation phase of&#xA;// child semantic visitors. By default activate does nothing.&#xA;return;&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="activateTransitions" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// ActivateTransition is intended to be overridden by sub-classes. It will capture the instantiation&#xA;// of transitions visitors as well as the linking between these visitors and the required vertices&#xA;// activation. By default activate does nothing.&#xA;return;&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getNode" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//NamedElement">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="true"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return node;&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getExecutionLocus" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Loci/Locus">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return this->getStateMachineExecution()->getLocus();"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getParent" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Loci/SemanticVisitor">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="true"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return parent;&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getExecutionContext" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//MDE4CPP_Extensions/FUML_Object">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="//return this->getStateMachineExecution()->getContext();&#xD;&#xA;&#x9;return this->getStateMachineExecution(); // Execution::getContext returns uml::Element instead of FUML_Object???"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="setParent" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Loci/SemanticVisitor">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="Obsolete due to automatic Reference Getters &amp; Setters Generation //this.parent = parent;&#xA;"/>
          </eAnnotations>
          <eParameters name="parent" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
        </eOperations>
        <eOperations name="setNode" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="Obsolete due to automatic Reference Getters &amp; Setters Generation //this.node = node;&#xA;"/>
          </eAnnotations>
          <eParameters name="node" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//NamedElement"/>
        </eOperations>
        <eOperations name="getStateMachineExecution" ordered="false" lowerBound="1"
            eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/Execution">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Return the state-machine execution from which the caller of this operation belongs&#xD;&#xA;&#x9;//if(this.parent!=null &amp;&amp; this.parent instanceof StateMachineExecution){&#xD;&#xA;&#x9;//&#x9;return (Execution)this.parent;&#xD;&#xA;&#x9;//}else{&#xD;&#xA;&#x9;//&#x9;return ((StateMachineSemanticVisitor)this.parent).getStateMachineExecution();&#xD;&#xA;&#x9;//}&#xD;&#xA;&#xD;&#xA;&#x9;std::shared_ptr&lt;PSSM::Semantics::StateMachines::StateMachineExecution> exec = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::StateMachineExecution>(this->m_parent);&#xD;&#xA;&#xD;&#xA;&#x9;if(this->m_parent != nullptr &amp;&amp; exec != nullptr)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;return std::dynamic_pointer_cast&lt;fUML::Semantics::CommonBehavior::Execution>(this->m_parent);&#xD;&#xA;&#x9;} else&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;return (std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::StateMachineSemanticVisitor>(this->m_parent))->getStateMachineExecution();&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getContextChain" ordered="false" upperBound="-1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Loci/SemanticVisitor">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Return the hierarchy of visitors that need to be traversed to access&#xA;&#x9;// the visitor that called context chain. The caller is part of the returned&#xA;&#x9;// context chain.&#xA;&#x9;//&#x9;List&lt;SemanticVisitor> contextChain = new ArrayList&lt;SemanticVisitor>();&#xA;&#x9;//&#x9;if(!(this instanceof ExitPointPseudostateActivation) &amp;&amp; !(this instanceof EntryPointPseudostateActivation)){&#xA;&#x9;//&#x9;&#x9;contextChain.add(this);&#xA;&#x9;//&#x9;}&#xA;&#x9;//&#x9;if(this.parent!=null){&#xA;&#x9;//&#x9;&#x9;if(this.parent instanceof StateMachineExecution){&#xA;&#x9;//&#x9;&#x9;&#x9;contextChain.add(this.parent);&#xA;&#x9;//&#x9;&#x9;}else{&#xA;&#x9;//&#x9;&#x9;&#x9;contextChain.addAll(((StateMachineSemanticVisitor)this.parent).getContextChain());&#xA;&#x9;//&#x9;&#x9;}&#xA;&#x9;//&#x9;}&#xA;&#x9;//&#x9;return contextChain;&#xA;&#x9;auto bag = new Bag&lt;fUML::Semantics::Loci::SemanticVisitor>();&#xA;&#x9;auto contextChain = std::make_shared&lt;Bag&lt;fUML::Semantics::Loci::SemanticVisitor>>(*(bag));&#xA;&#xA;&#x9;std::shared_ptr&lt;PSSM::Semantics::StateMachines::EntryPointPseudostateActivation> entryPointActivation = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::EntryPointPseudostateActivation>(this->getThisStateMachineSemanticVisitorPtr());&#xA;&#x9;std::shared_ptr&lt;PSSM::Semantics::StateMachines::ExitPointPseudostateActivation> exitPointActivation = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::ExitPointPseudostateActivation>(this->getThisStateMachineSemanticVisitorPtr());&#xA;&#xA;&#x9;std::shared_ptr&lt;PSSM::Semantics::StateMachines::StateMachineExecution> parentStateMachineExecution = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::StateMachineExecution>(this->getParent());&#xA;&#xA;&#x9;if(entryPointActivation == nullptr &amp;&amp; exitPointActivation == nullptr) {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::Loci::SemanticVisitor> tmp = this->getThisSemanticVisitorPtr();&#xA;&#x9;&#x9;contextChain->add(tmp);&#xA;&#x9;}&#xA;&#x9;if(this->getParent() != nullptr) {&#xA;&#x9;&#x9;if(parentStateMachineExecution != nullptr) {&#xA;&#x9;&#x9;&#x9;contextChain->add(this->getParent());&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Loci::SemanticVisitor>> parentContextChain = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::StateMachineSemanticVisitor>(this->getParent())->getContextChain();&#xA;&#x9;&#x9;&#x9;contextChain->insert(*parentContextChain);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return contextChain;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="isVisitorFor" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="//return this.node == node;&#xA;&#x9;return this->m_node == node;"/>
          </eAnnotations>
          <eParameters name="node" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//NamedElement"/>
        </eOperations>
        <eOperations name="match" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;&#x9;// Check if the event occurrence matches one of the trigger in the list.&#xD;&#xA;// The matching rule are the following:&#xD;&#xA;// &#x9;&#x9;1. If the event occurrence is a signal event occurrence then type&#xD;&#xA;//&#x9;&#x9;   of the signal must conforms to the type referenced by the event&#xD;&#xA;//&#x9;&#x9;   In addition, if the trigger defines ports through wich the event occurrence&#xD;&#xA;//         is allowed to arrive then the arrival port of the event occurrence&#xD;&#xA;//&#x9;&#x9;   must be one the referenced port.&#xD;&#xA;// &#x9;&#x9;2. If the event occurrence is a call event occurrence then the operation&#xD;&#xA;// &#x9;&#x9;   that is referenced must be the same than the one specified in the call&#xD;&#xA;//&#x9;&#x9;   event.&#xD;&#xA;// NOTE: CallEventOccurrence are not related to an arrival port. This limitation is&#xD;&#xA;// introduced by a limitation in the current PSCS semantic model.&#xD;&#xA;// &#xD;&#xA;// If a match is found then true is returned, false otherwise.&#xD;&#xA;&#x9;bool match = false;&#xD;&#xA;&#x9;int i = 0;&#xD;&#xA;&#x9;std::shared_ptr&lt;PSSM::Semantics::CommonBehavior::CallEventOccurrence> callEventOccurrence = std::dynamic_pointer_cast&lt;PSSM::Semantics::CommonBehavior::CallEventOccurrence>(eventOccurrence);&#xD;&#xA;&#x9;while(!match &amp;&amp; i &lt; int(triggers->size())) {&#xD;&#xA;&#x9;&#x9;std::shared_ptr&lt;uml::Trigger> trigger = triggers->at(i);&#xD;&#xA;&#x9;&#x9;//TODO: add SignaEventOCcurrence check as per commented Java code, once fUML is implemented&#xD;&#xA;&#x9;&#x9;//if(eventOccurrence instanceof SignalEventOccurrence&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;&#x9;&amp;&amp; trigger.getEvent() instanceof SignalEvent){&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;SignalEventOccurrence signalEventOccurrence = (SignalEventOccurrence) eventOccurrence;&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;SignalEvent event = (SignalEvent) trigger.getEvent();&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;if(event.getSignal() == signalEventOccurrence.signalInstance.type){&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;&#x9;match = true;&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;if(match  &amp;&amp; trigger.getPorts().size() > 0){&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;&#x9;int j = 0;&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;&#x9;boolean matchingPort = false;&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;&#x9;while(j &lt; trigger.getPorts().size() &amp; !matchingPort){&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;&#x9;&#x9;if(((CS_SignalInstance)signalEventOccurrence.signalInstance).interactionPoint.definingPort == trigger.getPorts().get(j)){&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;&#x9;&#x9;&#x9;matchingPort = true;&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;&#x9;&#x9;j = j + 1;&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;&#x9;if(!matchingPort){&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;&#x9;&#x9;match = matchingPort;&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;//&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;if(callEventOccurrence != nullptr) {&#xD;&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::CallEvent> triggerEvent = std::dynamic_pointer_cast&lt;uml::CallEvent>(trigger->getEvent());&#xD;&#xA;&#x9;&#x9;&#x9;if(triggerEvent != nullptr) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSSM::Semantics::CommonBehavior::CallEventOccurrence> callEventOccurrence = std::dynamic_pointer_cast&lt;PSSM::Semantics::CommonBehavior::CallEventOccurrence>(eventOccurrence);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if(triggerEvent->getOperation() == callEventOccurrence->getExecution()->getOperation()) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;match = true;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;i++;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return match;&#xD;&#xA;//boolean match = false;&#xD;&#xA;//int i = 0;&#xD;&#xA;//while(!match &amp;&amp; i &lt; triggers.size()){&#xD;&#xA;//&#x9;Trigger trigger = triggers.get(i);&#xD;&#xA;//&#x9;if(eventOccurrence instanceof SignalEventOccurrence&#xD;&#xA;//&#x9;&#x9;&#x9;&amp;&amp; trigger.getEvent() instanceof SignalEvent){&#xD;&#xA;//&#x9;&#x9;SignalEventOccurrence signalEventOccurrence = (SignalEventOccurrence) eventOccurrence;&#xD;&#xA;//&#x9;&#x9;SignalEvent event = (SignalEvent) trigger.getEvent();&#xD;&#xA;//&#x9;&#x9;if(event.getSignal() == signalEventOccurrence.signalInstance.type){&#xD;&#xA;//&#x9;&#x9;&#x9;match = true;&#xD;&#xA;//&#x9;&#x9;}&#xD;&#xA;//&#x9;&#x9;if(match  &amp;&amp; trigger.getPorts().size() > 0){&#xD;&#xA;//&#x9;&#x9;&#x9;int j = 0;&#xD;&#xA;//&#x9;&#x9;&#x9;boolean matchingPort = false;&#xD;&#xA;//&#x9;&#x9;&#x9;while(j &lt; trigger.getPorts().size() &amp; !matchingPort){&#xD;&#xA;//&#x9;&#x9;&#x9;&#x9;if(((CS_SignalInstance)signalEventOccurrence.signalInstance).interactionPoint.definingPort == trigger.getPorts().get(j)){&#xD;&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;matchingPort = true;&#xD;&#xA;//&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;//&#x9;&#x9;&#x9;&#x9;j = j + 1;&#xD;&#xA;//&#x9;&#x9;&#x9;}&#xD;&#xA;//&#x9;&#x9;&#x9;if(!matchingPort){&#xD;&#xA;//&#x9;&#x9;&#x9;&#x9;match = matchingPort;&#xD;&#xA;//&#x9;&#x9;&#x9;}&#xD;&#xA;//&#x9;&#x9;}&#xD;&#xA;//&#x9;}else if(eventOccurrence instanceof CallEventOccurrence&#xD;&#xA;//&#x9;&#x9;&#x9;&amp;&amp; trigger.getEvent() instanceof CallEvent){&#xD;&#xA;//&#x9;&#x9;CallEvent event = (CallEvent) trigger.getEvent();&#xD;&#xA;//&#x9;&#x9;CallEventOccurrence callEventOccurrence = (CallEventOccurrence) eventOccurrence;&#xD;&#xA;//&#x9;&#x9;if(event.getOperation() == callEventOccurrence.execution.operation){&#xD;&#xA;//&#x9;&#x9;&#x9;match = true;&#xD;&#xA;//&#x9;&#x9;}&#xD;&#xA;//&#x9;}&#xD;&#xA;//&#x9;i++;&#xD;&#xA;//}&#xD;&#xA;//return match;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="triggers" ordered="false" upperBound="-1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Trigger"/>
        </eOperations>
        <eOperations name="getExecutionFor" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/Execution">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="std::shared_ptr&lt;fUML::Semantics::CommonBehavior::Execution> execution = nullptr;&#xD;&#xA;&#x9;if(behavior != nullptr) &#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::CommonBehavior::Execution> originalExecution = this->getExecutionLocus()->getFactory()->createExecution(behavior, this->getExecutionContext());&#xD;&#xA;&#x9;&#x9;if(eventOccurrence != nullptr) &#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSSM::Semantics::CommonBehavior::EventTriggeredExecution> containerExecution = PSSM::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createEventTriggeredExecution();&#xD;&#xA;&#x9;&#x9;&#x9;containerExecution->setTriggeringEventOccurrence(eventOccurrence);&#xD;&#xA;&#x9;&#x9;&#x9;containerExecution->setWrappedExecution(originalExecution);&#xD;&#xA;&#x9;&#x9;&#x9;containerExecution->setContext(originalExecution->getContext());&#xD;&#xA;&#xD;&#xA;&#x9;&#x9;} &#xD;&#xA;&#x9;&#x9;else &#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;execution = originalExecution;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return execution;&#xD;&#xA;&#x9;//Execution execution = null;&#xD;&#xA;&#x9;//if(behavior != null){&#xD;&#xA;&#x9;//&#x9;Execution originalExecution = this.getExecutionLocus().factory.createExecution(behavior, this.getExecutionContext());&#xD;&#xA;&#x9;//&#x9;if(eventOccurrence != null){&#xD;&#xA;&#x9;//&#x9;&#x9;EventTriggeredExecution containerExecution = new EventTriggeredExecution();&#xD;&#xA;&#x9;//&#x9;&#x9;containerExecution.triggeringEventOccurrence = eventOccurrence;&#xD;&#xA;&#x9;//&#x9;&#x9;containerExecution.wrappedExecution = originalExecution;&#xD;&#xA;&#x9;//&#x9;&#x9;containerExecution.context = originalExecution.context;&#xD;&#xA;&#x9;//&#x9;&#x9;execution = containerExecution;&#xD;&#xA;&#x9;//&#x9;}else{&#xD;&#xA;&#x9;//&#x9;&#x9;execution = originalExecution;&#xD;&#xA;&#x9;//&#x9;}&#xD;&#xA;&#x9;//}&#xD;&#xA;&#x9;// return execution;"/>
          </eAnnotations>
          <eParameters name="behavior" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Behavior"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="node" ordered="false"
            lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//NamedElement"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="parent" ordered="false"
            eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Loci/SemanticVisitor"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="TransitionActivation" abstract="true"
          eSuperTypes="#//Semantics/StateMachines/StateMachineSemanticVisitor">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;uml/Transition.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/CompletionEventOccurrence.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/CallEventOccurrence.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/VertexActivation.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/StateActivation.hpp&quot;&#xD;&#xA;#include &quot;uml/ValueSpecification.hpp&quot;&#xD;&#xA;#include &quot;uml/Constraint.hpp&quot;&#xD;&#xA;#include &quot;fUML/Semantics/Loci/ExecutionFactory.hpp&quot;&#xD;&#xA;#include &quot;fUML/Semantics/Loci/Executor.hpp&quot;&#xD;&#xA;#include &quot;uml/OpaqueExpression.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/Values/SM_OpaqueExpressionEvaluation.hpp&quot;&#xD;&#xA;#include &quot;fUML/FUMLFactory.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/TransitionMetadata.hpp&quot;&#xD;&#xA;#include &quot;uml/Behavior.hpp&quot;&#xD;&#xA;#include &quot;fUML/Semantics/CommonBehavior/Execution.hpp&quot;&#xD;&#xA;#include &quot;fUML/Semantics/Loci/Locus.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="isReached" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;/// Convenience operation which returns true if the status of this transition&#xA;// is REACHED; false otherwise.&#xA;//boolean reached = true;&#xA;//if(staticCheck){&#xA;//&#x9;reached = this.analyticalStatus.equals(TransitionMetadata.REACHED);&#xA;//}else{&#xA;//&#x9;reached = this.status.equals(TransitionMetadata.REACHED);&#xA;//}&#xA;//return reached;&#xA;&#x9;return this->getStatus() == PSSM::Semantics::StateMachines::TransitionMetadata::REACHED;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="isGuarded" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Check if the transition is guarded. A transition is guarded if it declares&#xA;// a guard or if a redefine transition that itself declares a guar. This check&#xA;// applies recursively on the redefinition hierarchy&#xA;//Transition transition = (Transition) this.node;&#xA;//boolean isGuarded = false;&#xA;//if(transition.getGuard() != null){&#xA;//&#x9;isGuarded = true;&#xA;//}&#xA;//while(!isGuarded &amp;&amp; transition.getRedefinedTransition() != null){&#xA;//&#x9;transition = transition.getRedefinedTransition();&#xA;//&#x9;if(transition.getGuard() != null){&#xA;//&#x9;&#x9;isGuarded = true;&#xA;//&#x9;}&#xA;//}&#xA;//return isGuarded;&#xA;&#x9;std::shared_ptr&lt;uml::Transition> transition = std::dynamic_pointer_cast&lt;uml::Transition>(this->getNode());&#xA;&#x9;bool isGuarded = false;&#xA;&#x9;if(transition->getGuard() != nullptr) {&#xA;&#x9;&#x9;isGuarded = true;&#xA;&#x9;}&#xA;&#x9;while(!isGuarded &amp;&amp; transition->getRedefinedTransition() != nullptr) {&#xA;&#x9;&#x9;transition = transition->getRedefinedTransition();&#xA;&#x9;&#x9;if(transition->getGuard() != nullptr) {&#xA;&#x9;&#x9;&#x9;isGuarded = true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return isGuarded;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getStatus" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionMetadata">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="true"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return status;&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="setStatus" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="Obsolete due to automatic Reference Getters &amp; Setters Generation //this.status = state;&#xA;"/>
          </eAnnotations>
          <eParameters name="status" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionMetadata"/>
        </eOperations>
        <eOperations name="getSourceActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="//&#x9;return vertexSourceActivation;&#xA;&#x9;return this->m_sourceVertexActivation;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getTargetActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="//&#x9;return vertexTargetActivation;&#xA;&#x9;return this->m_targetVertexActivation;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="fire" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// The fire sequence is broken into the following set of actions&#xA;// 1 - Exit the source (depends on the kind of transition that is currently used)&#xA;// 2 - Execute the effect (if one exists for that transition)&#xA;// 3 - Enter the target (depends on the kind of transition that is currently used)&#xA;//this.exitSource(eventOccurrence);&#xA;//FUMLExecutionEngine.eInstance.getControlDelegate().control(this);&#xA;//this.tryExecuteEffect(eventOccurrence);&#xA;//this.setStatus(TransitionMetadata.TRAVERSED);&#xA;//logger.info(this.getNode().getName()+&quot; => TRAVERSED&quot;);&#xA;//this.enterTarget(eventOccurrence);&#xA;&#x9;this->exitSource(eventOccurrence);&#xA;&#x9;//ExecutionEngine ?&#xA;&#x9;this->tryExecuteEffect(eventOccurrence);&#xA;&#x9;this->setStatus(PSSM::Semantics::StateMachines::TransitionMetadata::TRAVERSED);&#xA;&#x9;this->enterTarget(eventOccurrence);"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="isTraversed" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Convenience operation which returns true if the status of this transition&#xA;// is TRAVERSED; false otherwise.&#xA;//boolean traversed = true;&#xA;//if(staticCheck){&#xA;//&#x9;traversed = this.analyticalStatus.equals(TransitionMetadata.TRAVERSED);&#xA;//}else{&#xA;//&#x9;traversed = this.status.equals(TransitionMetadata.TRAVERSED);&#xA;//}&#xA;//return traversed;&#xA;&#x9;bool traversed = true;&#xA;&#x9;if(staticCheck) {&#xA;&#x9;&#x9;traversed = this->getAnalyticalStatus() == PSSM::Semantics::StateMachines::TransitionMetadata::TRAVERSED;&#xA;&#x9;} else {&#xA;&#x9;&#x9;traversed = this->getStatus() == PSSM::Semantics::StateMachines::TransitionMetadata::TRAVERSED;&#xA;&#x9;}&#xA;&#x9;return traversed;"/>
          </eAnnotations>
          <eParameters name="staticCheck" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean"/>
        </eOperations>
        <eOperations name="isTriggered" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Check if the transition is triggered. A transition is triggered&#xD;&#xA;// if it declares triggers or if it redefines a transition that itself&#xD;&#xA;// declares triggers. This check applies recursively on the redefinition&#xD;&#xA;// hierarchy.&#xD;&#xA;//Transition transition = (Transition) this.node;&#xD;&#xA;//boolean isTriggered = false;&#xD;&#xA;//if(!transition.getTriggers().isEmpty()){&#xD;&#xA;//&#x9;isTriggered = true;&#xD;&#xA;//}&#xD;&#xA;//while(!isTriggered &amp;&amp; transition.getRedefinedTransition() != null){&#xD;&#xA;//&#x9;transition = transition.getRedefinedTransition();&#xD;&#xA;//&#x9;if(!transition.getTriggers().isEmpty()){&#xD;&#xA;//&#x9;&#x9;isTriggered = true;&#xD;&#xA;//&#x9;}&#xD;&#xA;//}&#xD;&#xA;//return isTriggered;&#xD;&#xA;&#x9;std::shared_ptr&lt;uml::Transition> transition = std::dynamic_pointer_cast&lt;uml::Transition>(this->m_node);&#xD;&#xA;&#x9;bool isTriggered = false;&#xD;&#xA;&#xD;&#xA;&#x9;if(transition->getTrigger()->size() != 0) {&#xD;&#xA;&#x9;&#x9;isTriggered = true;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;while(!isTriggered &amp;&amp; transition->getRedefinedTransition() != nullptr) {&#xD;&#xA;&#x9;&#x9;transition = transition->getRedefinedTransition();&#xD;&#xA;&#x9;&#x9;if(transition->getTrigger()->size() != 0) {&#xD;&#xA;&#x9;&#x9;&#x9;isTriggered = true;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return isTriggered;"/>
          </eAnnotations>
          <eParameters name="staticCheck" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean"/>
        </eOperations>
        <eOperations name="exitSource" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Exit the sourceVertexActivation of this TransitionActivation as the prior sequence of entering its targetVertexActivation.&#xD;&#xA;&#x9;// The source must have already been checked for exitability.&#xD;&#xA;&#x9;auto leastCommonAncestor = this->m_sourceVertexActivation->getLeastCommonAncestor(this->m_targetVertexActivation);&#xD;&#xA;&#x9;this->m_sourceVertexActivation->exit(this->getThisTransitionActivationPtr(), eventOccurrence, leastCommonAncestor);"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="getLeastCommonAncestor" ordered="false" lowerBound="1"
            eType="#//Semantics/StateMachines/RegionActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Return the common ancestor of the source and the target. This common ancestor is&#xA;// a region activation&#xA;//if(this.vertexSourceActivation.getParentVertexActivation()!=this.vertexTargetActivation.getParentVertexActivation()){&#xA;//&#x9;if(this.leastCommonAncestor==null){&#xA;//&#x9;&#x9;this.leastCommonAncestor = this.vertexSourceActivation.getLeastCommonAncestor(this.vertexTargetActivation, ((Transition)this.getNode()).getKind());&#xA;//&#x9;}&#xA;//}&#xA;//return this.leastCommonAncestor;&#xA;&#x9;if(this->getSourceVertexActivation()->getParentVertexActivation() != this->getTargetVertexActivation()->getParentVertexActivation()){&#xA;&#x9;&#x9;if(this->getLeastCommonAncestor() == nullptr) {&#xA;&#x9;&#x9;&#x9;uml::TransitionKind transitionKind = std::dynamic_pointer_cast&lt;uml::Transition>(this->getNode())->getKind();&#xA;&#x9;&#x9;&#x9;this->setLeastCommonAncestor(this->getSourceVertexActivation()->getLeastCommonAncestor(this->getTargetVertexActivation()));&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return this->m_leastCommonAncestor;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="enterTarget" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Enter the targetVertexActivation of this TransitionActivation after executing the transition's Effect Behavior.&#xD;&#xA;&#x9;// The target must have already been checked for enterability.&#xD;&#xA;&#x9;auto leastCommonAncestor = this->m_sourceVertexActivation->getLeastCommonAncestor(this->m_targetVertexActivation);&#xD;&#xA;&#x9;this->m_targetVertexActivation->enter(this->getThisTransitionActivationPtr(), eventOccurrence, leastCommonAncestor);"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="tryExecuteEffect" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Execute the effect owned by the transition (if any). If there// Execute the effect owned by the transition (if any). If there&#xD;&#xA;&#x9;// is no effect but the transition redefines another transition, then&#xD;&#xA;&#x9;// the effect of this transition is executed instead. This rule&#xD;&#xA;&#x9;// applies recursively.&#xD;&#xA;&#x9;//Transition transition = (Transition) this.getNode();&#xD;&#xA;&#x9;//Behavior effect = transition.getEffect();&#xD;&#xA;&#x9;//while(effect == null &amp;&amp; transition.getRedefinedTransition() != null){&#xD;&#xA;&#x9;//&#x9;transition = transition.getRedefinedTransition();&#xD;&#xA;&#x9;//&#x9;effect = transition.getEffect();&#xD;&#xA;&#x9;//}&#xD;&#xA;&#x9;//if(effect != null){&#xD;&#xA;&#x9;//&#x9;Execution execution = this.getExecutionFor(transition.getEffect(), eventOccurrence);&#xD;&#xA;&#x9;//&#x9;if(execution!=null){&#xD;&#xA;&#x9;//&#x9;&#x9;execution.execute();&#xD;&#xA;&#x9;//&#x9;}&#xD;&#xA;&#x9;//}&#xD;&#xA;&#x9;std::shared_ptr&lt;uml::Transition> transition = std::dynamic_pointer_cast&lt;uml::Transition>(this->getNode());&#xD;&#xA;&#x9;std::shared_ptr&lt;uml::Behavior> effect = transition->getEffect();&#xD;&#xA;&#xD;&#xA;&#x9;while(effect == nullptr &amp;&amp; transition->getRedefinedTransition() != nullptr) {&#xD;&#xA;&#x9;&#x9;transition = transition->getRedefinedTransition();&#xD;&#xA;&#x9;&#x9;effect = transition->getEffect();&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;if(effect != nullptr) {&#xD;&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::CommonBehavior::Execution> execution = this->getExecutionFor(transition->getEffect(), eventOccurrence);&#xD;&#xA;&#x9;&#x9;if(execution != nullptr) {&#xD;&#xA;&#x9;&#x9;&#x9;execution->execute();&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="setSourceActivation" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="//&#x9;this.vertexSourceActivation = vertexSourceActivation;&#xA;&#x9;this->m_sourceVertexActivation = _;"/>
          </eAnnotations>
          <eParameters name="_" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"/>
        </eOperations>
        <eOperations name="setTargetActivation" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="//&#x9;this.vertexTargetActivation = vertexTargetActivation;&#xA;&#x9;this->m_targetVertexActivation = _;"/>
          </eAnnotations>
          <eParameters name="_" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"/>
        </eOperations>
        <eOperations name="canFireOn" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// A transition is can fire when:&#xA;//&#xA;// A completion event is being dispatched and this transition has no trigger&#xA;// but its eventual guard evaluates to true. Note: the scope of a completion&#xA;// event is the state from which it was generated&#xA;//&#xA;// A signal event is being dispatched and this transition has a trigger&#xA;// that matches the signal and its eventual guard evaluates to true&#xA;//boolean reactive = true;&#xA;//if(eventOccurrence instanceof CompletionEventOccurrence){&#xA;//&#x9;reactive = !this.isTriggered() &amp;&amp;&#xA;//&#x9;&#x9;&#x9;&#x9;this.getSourceActivation()==((CompletionEventOccurrence)eventOccurrence).stateActivation &amp;&amp;&#xA;//&#x9;&#x9;&#x9;&#x9;this.evaluateGuard(eventOccurrence) &amp;&amp;&#xA;//&#x9;&#x9;&#x9;&#x9;this.canPropagateExecution(eventOccurrence);&#xA;//}else if(eventOccurrence instanceof SignalEventOccurrence | eventOccurrence instanceof CallEventOccurrence){&#xA;//&#x9;reactive = this.hasTrigger(eventOccurrence) &amp;&amp;&#xA;//&#x9;&#x9;&#x9;   this.evaluateGuard(eventOccurrence) &amp;&amp;&#xA;//&#x9;&#x9;&#x9;   this.canPropagateExecution(eventOccurrence);&#xA;//}else{&#xA;//&#x9;reactive = false;&#xA;//}&#xA;//return reactive;&#xA;&#x9;bool reactive = true;&#xA;&#x9;std::shared_ptr&lt;PSSM::Semantics::CommonBehavior::CallEventOccurrence> callEventOccurrence = std::dynamic_pointer_cast&lt;PSSM::Semantics::CommonBehavior::CallEventOccurrence>(eventOccurrence);&#xA;&#x9;std::shared_ptr&lt;PSSM::Semantics::StateMachines::CompletionEventOccurrence> completionEventOccurrence = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::CompletionEventOccurrence>(eventOccurrence);&#xA;&#x9;if(completionEventOccurrence != nullptr) {&#xA;&#xA;&#x9;&#x9;reactive = !this->isTriggered(false) &amp;&amp;&#xA;&#x9;&#x9;&#x9;&#x9;this->getSourceActivation() == std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::VertexActivation>(completionEventOccurrence->getStateActivation()) &amp;&amp;&#xA;&#x9;&#x9;&#x9;&#x9;this->evaluateGuard(eventOccurrence) &amp;&amp;&#xA;&#x9;&#x9;&#x9;&#x9;this->canPropagateExecution(eventOccurrence);&#xA;&#x9;} else if(callEventOccurrence != nullptr) {&#xA;&#x9;&#x9;reactive = this->hasTrigger(eventOccurrence) &amp;&amp;&#xA;&#x9;&#x9;&#x9;&#x9;this->evaluateGuard(eventOccurrence) &amp;&amp;&#xA;&#x9;&#x9;&#x9;&#x9;this->canPropagateExecution(eventOccurrence);&#xA;&#x9;}&#xA;&#xA;&#x9;return reactive;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="hasTrigger" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Return true if the event occurrence matches a trigger of this transition.&#xA;// false otherwise. If the transition declares no trigger but redefines another&#xA;// transition then if that transition has a trigger that matches the event occurrence&#xA;// the redefining transition is considered has being able to react to the event occurrence.&#xA;// The rule applies recursively.&#xA;//Transition transition = (Transition) this.node;&#xA;//boolean match = this.match(eventOccurrence, transition.getTriggers());&#xA;//while(!match &amp;&amp; transition.getRedefinedTransition() != null){&#xA;//&#x9;transition = transition.getRedefinedTransition();&#xA;//&#x9;match = this.match(eventOccurrence, transition.getTriggers());&#xA;//}&#xA;//return match;&#xA;&#x9;std::shared_ptr&lt;uml::Transition> transition = std::dynamic_pointer_cast&lt;uml::Transition>(this->getNode());&#xA;&#x9;bool match = this->match(eventOccurrence, std::dynamic_pointer_cast&lt;Bag&lt;uml::Trigger>>(transition->getTrigger()));&#xA;&#x9;while(!match &amp;&amp; transition->getRedefinedTransition() != nullptr) {&#xA;&#x9;&#x9;transition = transition->getRedefinedTransition();&#xA;&#x9;&#x9;match = this->match(eventOccurrence, std::dynamic_pointer_cast&lt;Bag&lt;uml::Trigger>>(transition->getTrigger()));&#xA;&#x9;}&#xA;&#x9;return match;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="evaluateGuard" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Evaluate the guard specification thanks to an evaluation.&#xD;&#xA;// The evaluation does not presume of the type of the guard specification.&#xD;&#xA;//boolean result = true;&#xD;&#xA;//Transition transition = (Transition) this.node;&#xD;&#xA;//Constraint guard = transition.getGuard();&#xD;&#xA;//while(guard == null &amp;&amp; transition.getRedefinedTransition() != null){&#xD;&#xA;//&#x9;transition = transition.getRedefinedTransition();&#xD;&#xA;//&#x9;guard = transition.getGuard();&#xD;&#xA;//}&#xD;&#xA;//if (guard != null) {&#xD;&#xA;//&#x9;ValueSpecification specification = guard.getSpecification() ;&#xD;&#xA;//&#x9;if(specification!=null){&#xD;&#xA;//&#x9;&#x9;Evaluation evaluation = this.getExecutionLocus().factory.createEvaluation(specification);&#xD;&#xA;//&#x9;&#x9;if (specification instanceof OpaqueExpression) {&#xD;&#xA;//&#x9;&#x9;&#x9;((SM_OpaqueExpressionEvaluation)evaluation).context = this.getExecutionContext() ;&#xD;&#xA;//&#x9;&#x9;&#x9;((SM_OpaqueExpressionEvaluation)evaluation).initialize(eventOccurrence);&#xD;&#xA;//&#x9;&#x9;}&#xD;&#xA;//&#x9;&#x9;if(evaluation!=null){&#xD;&#xA;//&#x9;&#x9;&#x9;BooleanValue evaluationResult = (BooleanValue)evaluation.evaluate() ;&#xD;&#xA;//&#x9;&#x9;&#x9;result = evaluationResult.value ;&#xD;&#xA;//&#x9;&#x9;}&#xD;&#xA;//&#x9;}&#xD;&#xA;//&#xD;&#xA;//}&#xD;&#xA;//return result;&#xD;&#xA;&#xD;&#xA;&#x9;bool result = true;&#xD;&#xA;&#x9;std::shared_ptr&lt;uml::Transition> transition = std::dynamic_pointer_cast&lt;uml::Transition>(this->getNode());&#xD;&#xA;&#x9;std::shared_ptr&lt;uml::Constraint> guard = transition->getGuard();&#xD;&#xA;&#x9;while(guard == nullptr &amp;&amp; transition->getRedefinedTransition() != nullptr) {&#xD;&#xA;&#x9;&#x9;transition = transition->getRedefinedTransition();&#xD;&#xA;&#x9;&#x9;guard = transition->getGuard();&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;if(guard != nullptr) {&#xD;&#xA;&#x9;&#x9;std::shared_ptr&lt;uml::ValueSpecification> specification =  guard->getSpecification();&#xD;&#xA;&#x9;&#x9;if(specification != nullptr) {&#xD;&#xA;&#x9;&#x9;&#x9;auto evaluation = this->getExecutionLocus()->getExecutor()->evaluate(specification);&#xD;&#xA;&#x9;&#x9;&#x9;//std::shared_ptr&lt;fUML::Evaluation> evaluation = this->getExecutionLocus()->getFactory()->createEvaluation(specification); - IN MDE4CPP ABER SCHON FERTIGER WERT STATT EINE EVALUATION!&#xD;&#xA;&#x9;&#x9;&#x9;auto opaqueExpression = std::dynamic_pointer_cast&lt;uml::OpaqueExpression>(specification);&#xD;&#xA;&#x9;&#x9;&#x9;if(opaqueExpression != nullptr) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;auto opaqueExpressionEvaluation = std::dynamic_pointer_cast&lt;PSSM::Semantics::Values::SM_OpaqueExpressionEvaluation>(evaluation);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;//opaqueExpressionEvaluation->setContext(this->getExecutionContext());&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;opaqueExpressionEvaluation->initialize(eventOccurrence);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;if(evaluation != nullptr) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;//std::shared_ptr&lt;fUML::BooleanValue> evaluationResult = std::dynamic_pointer_cast&lt;fUML::BooleanValue>(evaluation->evaluate());&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;//result = evaluationResult->isValue();&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return result;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="canPropagateExecution" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Evaluate the possibility to propagate the static analysis through this transition activation.&#xA;// Two situations can occur:&#xA;// 1. The transition has already been &quot;traversed&quot; with using the same event occurrence. This means&#xA;//    we already know the execution can be propagated through the transiton activation. Hence true&#xA;//    is returned and the propagation stops.&#xA;// 2. The transition has not already been &quot;traversed&quot; using this event occurrence. The consequence&#xA;//    is that the analysis is propagated through the target vertex activation. &#xA;//boolean propagate = true;&#xA;//if(this.lastTriggeringEventOccurrence != eventOccurrence){&#xA;//&#x9;propagate = this.vertexTargetActivation.canPropagateExecution(this, eventOccurrence, this.getLeastCommonAncestor());&#xA;//&#x9;this.lastTriggeringEventOccurrence = eventOccurrence;&#xA;//&#x9;this.lastPropagation = propagate;&#xA;//}else{&#xA;//&#x9;propagate = this.lastPropagation;&#xA;//}&#xA;//return propagate;&#xA;&#x9;bool propagate = true;&#xA;&#x9;if(this->getLastTriggeringEventOccurrence() != eventOccurrence) {&#xA;&#x9;&#x9;propagate = this->getTargetVertexActivation()->canPropagateExecution(this->getThisTransitionActivationPtr(), eventOccurrence, this->getLeastCommonAncestor());&#xA;&#x9;&#x9;this->setLastTriggeringEventOccurrence(eventOccurrence);&#xA;&#x9;&#x9;this->setLastPropagation(propagate);&#xA;&#x9;} else {&#xA;&#x9;&#x9;propagate = this->getLastPropagation();&#xA;&#x9;}&#xA;&#xA;&#x9;return propagate;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="status" ordered="false"
            lowerBound="1" eType="#//Semantics/StateMachines/TransitionMetadata"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="sourceVertexActivation"
            ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"
            eOpposite="#//Semantics/StateMachines/VertexActivation/outgoingTransitionActivations"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="targetVertexActivation"
            ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"
            eOpposite="#//Semantics/StateMachines/VertexActivation/incomingTransitionActivations"/>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="analyticalStatus" ordered="false"
            lowerBound="1" eType="#//Semantics/StateMachines/TransitionMetadata"/>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="lastPropagation" ordered="false"
            lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="leastCommonAncestor"
            ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/RegionActivation"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="lastTriggeringEventOccurrence"
            ordered="false" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EEnum" name="TransitionMetadata">
        <eLiterals name="none"/>
        <eLiterals name="reached" value="1"/>
        <eLiterals name="traversed" value="2"/>
        <eLiterals name="completed" value="3"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="VertexActivation" abstract="true"
          eSuperTypes="#//Semantics/StateMachines/StateMachineSemanticVisitor">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;PSSM/Semantics/StateMachines/TransitionMetadata.hpp&quot;&#xA;#include &quot;PSSM/Semantics/StateMachines/StateMetadata.hpp&quot;&#xA;#include &quot;PSSM/Semantics/StateMachines/StateMachineExecution.hpp&quot;&#xA;#include &quot;PSSM/Semantics/StateMachines/StateActivation.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="terminate" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Terminate applied by a vertex activation does nothing by default. However it is intended&#xA;// to be overridden by sub-classe(s)  &#xA;return;&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="isActive" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// By default is is possible to assess if a vertex is active by checking&#xA;// if its status is ACTIVE. Note this operation is overriden in the context&#xA;// of state activations which require a presence within the state-machine&#xA;// configuration.&#xA;return this->getStatus() == PSSM::Semantics::StateMachines::StateMetadata::ACTIVE;&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getStatus" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateMetadata">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="true"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return this.status;&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="setStatus" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="Obsolete due to automatic Reference Getters &amp; Setters Generation //this.status = state;&#xA;"/>
          </eAnnotations>
          <eParameters name="status" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateMetadata"/>
        </eOperations>
        <eOperations name="getParentVertexActivation" ordered="false" lowerBound="1"
            eType="#//Semantics/StateMachines/VertexActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// The parent state of a vertex is either a StateMachineExecution or a StateActivation&#xA;//RegionActivation regionActivation = (RegionActivation)this.getParent();&#xA;//if(regionActivation!=null){&#xA;//&#x9;if(regionActivation.getParent() instanceof StateMachineExecution){&#xA;//&#x9;&#x9;return null;&#xA;//&#x9;}else{&#xA;//&#x9;&#x9;return (VertexActivation) regionActivation.getParent();&#xA;//&#x9;}&#xA;//}&#xA;//return null;&#xA;&#x9;std::shared_ptr&lt;PSSM::Semantics::StateMachines::RegionActivation> regionActivation = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::RegionActivation>(this->m_parent);&#xA;&#x9;if(regionActivation != nullptr) {&#xA;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::StateMachineExecution>(regionActivation->getParent()) != nullptr) {&#xA;&#x9;&#x9;&#x9;return nullptr;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;return std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::VertexActivation>(regionActivation->getParent());&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return nullptr;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getAscendingHierarchy" ordered="false" upperBound="-1"
            eType="#//Semantics/StateMachines/VertexActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Provides the hierarchy of State Activations starting from the current&#xD;&#xA;&#x9;// element. This list is ordered from the innermost element to the outermost element&#xD;&#xA;&#x9;//List&lt;VertexActivation> hierarchy = new ArrayList&lt;VertexActivation>();&#xD;&#xA;&#x9;//List&lt;SemanticVisitor> contextChain = this.getContextChain();&#xD;&#xA;&#x9;//for(SemanticVisitor element : contextChain){&#xD;&#xA;&#x9;//&#x9;if(element instanceof StateActivation){&#xD;&#xA;&#x9;//&#x9;&#x9;hierarchy.add((StateActivation)element);&#xD;&#xA;&#x9;//&#x9;}&#xD;&#xA;&#x9;//}&#xD;&#xA;&#x9;//return hierarchy;&#xD;&#xA;&#x9;std::shared_ptr&lt;Bag&lt;PSSM::Semantics::StateMachines::VertexActivation> > hierarchy(new Bag&lt;PSSM::Semantics::StateMachines::VertexActivation>());&#xD;&#xA;&#x9;for (auto element : *(this->getContextChain()))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::StateActivation>(element) != nullptr) &#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;hierarchy->add(std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::VertexActivation>(element));&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return hierarchy;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getOwningRegionActivation" ordered="false" lowerBound="1"
            eType="#//Semantics/StateMachines/RegionActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::RegionActivation>(this->m_parent);"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getIncomingTransitions" ordered="false" upperBound="-1"
            eType="#//Semantics/StateMachines/TransitionActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;return this->m_incomingTransitionActivations;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getOutgoingTransitions" ordered="false" upperBound="-1"
            eType="#//Semantics/StateMachines/TransitionActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;return this->m_outgoingTransitionActivations;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getVertexActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return nullptr;"/>
          </eAnnotations>
          <eParameters name="vertex" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Vertex"/>
        </eOperations>
        <eOperations name="addIncomingTransition" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;this->getIncomingTransitionActivations()->add(transitionActivation);"/>
          </eAnnotations>
          <eParameters name="transitionActivation" ordered="false" lowerBound="1"
              eType="#//Semantics/StateMachines/TransitionActivation"/>
        </eOperations>
        <eOperations name="addOutgoingTransition" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;this->getOutgoingTransitionActivations()->add(transitionActivation);"/>
          </eAnnotations>
          <eParameters name="transitionActivation" ordered="false" lowerBound="1"
              eType="#//Semantics/StateMachines/TransitionActivation"/>
        </eOperations>
        <eOperations name="tagOutgoingTransition" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Tags all outgoingTransitionActivations as the given value. StaticCheck is currently not supported.&#xD;&#xA;&#x9;if (this->m_outgoingTransitionActivations != nullptr) &#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;for (auto outgoingTransitionActivation : *(this->m_outgoingTransitionActivations))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;outgoingTransitionActivation->setStatus(status);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="status" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionMetadata"/>
          <eParameters name="staticCheck" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean"/>
        </eOperations>
        <eOperations name="tagIncomingTransition" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Tags all incomingTransitionActivations as the given value. StaticCheck is currently not supported.&#xD;&#xA;&#x9;if (this->m_incomingTransitionActivations != nullptr) &#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;for (auto incomingTransitionActivation : *(this->m_incomingTransitionActivations))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;incomingTransitionActivation->setStatus(status);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="status" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionMetadata"/>
          <eParameters name="staticCheck" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean"/>
        </eOperations>
        <eOperations name="getLeastCommonAncestor" ordered="false" lowerBound="1"
            eType="#//Semantics/StateMachines/RegionActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Determine the semantic visitor being the least common ancestor between&#xA;&#x9;// the current vertex activation and the target vertex activation (provided as&#xA;&#x9;// a parameter). The analysis is based on a comparative analysis vertices (source and&#xA;&#x9;// target) hierarchies.&#xA;&#x9;//RegionActivation leastCommonAncestor = null;&#xA;&#x9;//SemanticVisitor sourceHierachyNode =  null;&#xA;&#x9;//SemanticVisitor targetHierarchyNode = null;&#xA;&#x9;//List&lt;SemanticVisitor> sourceHierarchy = this.getContextChain();&#xA;&#x9;//List&lt;SemanticVisitor> targetHierarchy = targetVertexActivation.getContextChain();&#xA;&#x9;//int sourceHierarchyIndex = sourceHierarchy.size();&#xA;&#x9;//int targetHierarchyIndex = targetHierarchy.size();&#xA;&#x9;std::shared_ptr&lt;PSSM::Semantics::StateMachines::RegionActivation> leastCommonAncestor = nullptr;&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::Loci::SemanticVisitor> sourceHierarchyNode = nullptr;&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::Loci::SemanticVisitor> targetHierarchyNode = nullptr;&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Loci::SemanticVisitor>> sourceHierarchy = this->getContextChain();&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Loci::SemanticVisitor>> targetHierarchy = vertexActivation->getContextChain();&#xA;&#x9;int sourceHierarchyIndex = sourceHierarchy->size();&#xA;&#x9;int targetHierarchyIndex = targetHierarchy->size();&#xA;&#x9;// Check if a difference can be found in between the two subsets&#xA;&#x9;// delimited by the common index. Iterate until the least common&#xA;&#x9;// ancestor is found or the two subsets have been reviewed&#xA;&#x9;//while(leastCommonAncestor == null &amp;&amp; sourceHierarchyIndex > 0 &amp;&amp; targetHierarchyIndex > 0){&#xA;&#x9;//&#x9;sourceHierachyNode = sourceHierarchy.get(sourceHierarchyIndex - 1);&#xA;&#x9;//&#x9;targetHierarchyNode = targetHierarchy.get(targetHierarchyIndex - 1);&#xA;&#x9;//&#x9;if(sourceHierachyNode != targetHierarchyNode){&#xA;&#x9;//&#x9;&#x9;leastCommonAncestor = this.getRegionActivation(sourceHierachyNode);&#xA;&#x9;//&#x9;}else{&#xA;&#x9;//&#x9;&#x9;sourceHierarchyIndex = sourceHierarchyIndex - 1;&#xA;&#x9;//&#x9;&#x9;targetHierarchyIndex = targetHierarchyIndex - 1;&#xA;&#x9;//&#x9;}&#xA;&#x9;//}&#xA;&#x9;while(leastCommonAncestor == nullptr &amp;&amp; sourceHierarchyIndex > 0 &amp;&amp; targetHierarchyIndex > 0) {&#xA;&#x9;&#x9;sourceHierarchyNode = sourceHierarchy->at(sourceHierarchyIndex - 1);&#xA;&#x9;&#x9;targetHierarchyNode = targetHierarchy->at(targetHierarchyIndex - 1);&#xA;&#x9;&#x9;if(sourceHierarchyNode != targetHierarchyNode) {&#xA;&#x9;&#x9;&#x9;leastCommonAncestor = this->getRegionActivation(sourceHierarchyNode);&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;sourceHierarchyIndex = sourceHierarchyIndex -1;&#xA;&#x9;&#x9;&#x9;targetHierarchyIndex = targetHierarchyIndex - 1;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;// It may happen than no difference could found in the hierarchy subsets&#xA;&#x9;// previously reviewed. This indicate two possible situations:&#xA;&#x9;// 1. The source and the target are the same.&#xA;&#x9;// 2. There is containing / container relationship existing between&#xA;&#x9;//    the source and the target.&#xA;&#x9;//if(leastCommonAncestor == null){&#xA;&#x9;//&#x9;if(sourceHierarchyIndex == 0 &amp;&amp; targetHierarchyIndex == 0){&#xA;&#x9;//&#x9;&#x9;leastCommonAncestor = this.getRegionActivation(sourceHierarchy.get(sourceHierarchyIndex + 1));&#xA;&#x9;//&#x9;}else{&#xA;&#x9;//&#x9;&#x9;if(this.getVertexActivation((Vertex)targetVertexActivation.getNode()) != null){&#xA;&#x9;//&#x9;&#x9;&#x9;if(transitionKind == TransitionKind.EXTERNAL_LITERAL){&#xA;&#x9;//&#x9;&#x9;&#x9;&#x9;leastCommonAncestor = this.getRegionActivation(sourceHierarchy.get(sourceHierarchyIndex));&#xA;&#x9;//&#x9;&#x9;&#x9;}else{&#xA;&#x9;//&#x9;&#x9;&#x9;&#x9;leastCommonAncestor = this.getRegionActivation(targetHierarchy.get(targetHierarchyIndex - 1));&#xA;&#x9;//&#x9;&#x9;&#x9;}&#xA;&#x9;//&#x9;&#x9;}else{&#xA;&#x9;//&#x9;&#x9;&#x9;leastCommonAncestor = this.getRegionActivation(sourceHierarchy.get(sourceHierarchyIndex - 1));&#xA;&#x9;//&#x9;&#x9;}&#xA;&#x9;//&#x9;}&#xA;&#x9;//}&#xA;&#x9;if(leastCommonAncestor == nullptr) {&#xA;&#x9;&#x9;if(sourceHierarchyIndex == 0 &amp;&amp; targetHierarchyIndex == 0) {&#xA;&#x9;&#x9;&#x9;leastCommonAncestor = this->getRegionActivation(sourceHierarchy->at(sourceHierarchyIndex +1));&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;if(this->getVertexActivation(std::dynamic_pointer_cast&lt;uml::Vertex>(vertexActivation->getNode())) != nullptr) {&#xA;&#x9;&#x9;&#x9;&#x9;//transitionKind ??&#xA;&#x9;&#x9;&#x9;&#x9;leastCommonAncestor = this->getRegionActivation(sourceHierarchy->at(sourceHierarchyIndex - 1));&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return leastCommonAncestor;"/>
          </eAnnotations>
          <eParameters name="vertexActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"/>
        </eOperations>
        <eOperations name="isExitable" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// By default a vertex has no prerequisites that need to be full-filled to be entered&#xA;// Nevertheless some vertex (e.g., Fork) have such prerequisite. Therefore this method&#xA;// is intended to be overridden in vertex activation sub-classes.&#xA;return true;&#xA;"/>
          </eAnnotations>
          <eParameters name="exitingTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="staticCheck" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean"/>
        </eOperations>
        <eOperations name="isEnterable" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// By default a vertex has no prerequisites that need to be full-filled&#xA;// to be entered. Nevertheless some vertex (e.g., join or exit) have such&#xA;// prerequisites. Therefore this method is intended to be overridden in vertex&#xA;// activation sub-classes. &#xA;return true;&#xA;"/>
          </eAnnotations>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="staticCheck" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean"/>
        </eOperations>
        <eOperations name="exit" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// When a vertex is exited its parent may need to be exited too. Such situation typically&#xA;// occurs when the current vertex is exited through a transition that cross boundaries of&#xA;// the parent state (and maybe also border its own parent). This implies that from the current&#xA;// vertex and until the least common ancestor is reached all states are exited recursively.&#xA;//this.tagIncomingTransitions(TransitionMetadata.NONE, false);&#xA;//this.setStatus(StateMetadata.IDLE);&#xA;//logger.info(this.getNode().getName()+&quot; => IDLE&quot;);&#xA;//RegionActivation owningRegionActivation = this.getOwningRegionActivation();&#xA;//if(leastCommonAncestor != null &amp;&amp; owningRegionActivation != null &amp;&amp; leastCommonAncestor != owningRegionActivation){&#xA;//&#x9;VertexActivation vertexActivation = (VertexActivation) owningRegionActivation.getParent();&#xA;//&#x9;if(vertexActivation != null){&#xA;//&#x9;&#x9;vertexActivation.exit(exitingTransition, eventOccurrence, leastCommonAncestor);&#xA;//&#x9;}&#xA;//}&#xA;&#x9;this->tagIncomingTransition(PSSM::Semantics::StateMachines::TransitionMetadata::NONE, false);&#xA;&#x9;this->setStatus(PSSM::Semantics::StateMachines::StateMetadata::IDLE);&#xA;&#x9;std::shared_ptr&lt;PSSM::Semantics::StateMachines::RegionActivation> owningRegionActivation = this->getOwningRegionActivation();&#xA;&#x9;if(leastCommonAncestor != nullptr &amp;&amp; owningRegionActivation != nullptr &amp;&amp; leastCommonAncestor != owningRegionActivation) {&#xA;&#x9;&#x9;std::shared_ptr&lt;PSSM::Semantics::StateMachines::VertexActivation> vertexActivation = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::VertexActivation>(owningRegionActivation->getParent());&#xA;&#x9;&#x9;if(vertexActivation != nullptr) {&#xA;&#x9;&#x9;&#x9;vertexActivation->exit(exitingTransition, eventOccurrence, leastCommonAncestor);&#xA;&#x9;&#x9;}&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="exitingTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="leastCommonAncestor" ordered="false" eType="#//Semantics/StateMachines/RegionActivation"/>
        </eOperations>
        <eOperations name="enter" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// When a vertex is entered its parent may need to be entered as well. Such situation&#xD;&#xA;&#x9;// occurs when the parent is not active while there is an attempt to enter the current&#xD;&#xA;&#x9;// vertex activation. What is important here is that entry rule is applied recursively&#xD;&#xA;&#x9;// until the least common ancestor is reached.&#xD;&#xA;&#x9;//RegionActivation owningRegionActivation = this.getOwningRegionActivation();&#xD;&#xA;&#x9;//if(leastCommonAncestor != null &amp;&amp; owningRegionActivation != null &amp;&amp; leastCommonAncestor != owningRegionActivation){&#xD;&#xA;&#x9;//&#x9;VertexActivation vertexActivation = (VertexActivation) owningRegionActivation.getParent();&#xD;&#xA;&#x9;//&#x9;if(vertexActivation != null){&#xD;&#xA;&#x9;//&#x9;&#x9;vertexActivation.enter(enteringTransition, eventOccurrence, leastCommonAncestor);&#xD;&#xA;&#x9;//&#x9;}&#xD;&#xA;&#x9;//}&#xD;&#xA;&#x9;//logger.info(this.getNode().getName()+&quot; => ACTIVE&quot;);&#xD;&#xA;&#x9;//this.setStatus(StateMetadata.ACTIVE);&#xD;&#xA;&#x9;//this.tagOutgoingTransitions(TransitionMetadata.REACHED, false);&#xD;&#xA;&#x9;//FUMLExecutionEngine.eInstance.getControlDelegate().control(this);&#xD;&#xA;&#x9;std::shared_ptr&lt;PSSM::Semantics::StateMachines::RegionActivation> owningRegionActivation = this->getOwningRegionActivation();&#xD;&#xA;&#x9;if(leastCommonAncestor != nullptr &amp;&amp; owningRegionActivation != nullptr &amp;&amp; leastCommonAncestor != owningRegionActivation) {&#xD;&#xA;&#x9;&#x9;std::shared_ptr&lt;PSSM::Semantics::StateMachines::VertexActivation> vertexActivation = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::VertexActivation>(owningRegionActivation->getParent());&#xD;&#xA;&#x9;&#x9;if(vertexActivation != nullptr) {&#xD;&#xA;&#x9;&#x9;&#x9;vertexActivation->enter(enteringTransition, eventOccurrence, leastCommonAncestor);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;this->setStatus(PSSM::Semantics::StateMachines::StateMetadata::ACTIVE);&#xD;&#xA;&#x9;this->tagOutgoingTransition(PSSM::Semantics::StateMachines::TransitionMetadata::REACHED, false);"/>
          </eAnnotations>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="leastCommonAncestor" ordered="false" eType="#//Semantics/StateMachines/RegionActivation"/>
        </eOperations>
        <eOperations name="canPropagateExecution" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// The common behavior of all kind of vertices is that when the propagation analysis is done&#xA;// if a the target is a vertex that is nested within a hierarchy then the analysis&#xA;// must be recursively propagated to the parent vertices.&#xA;//boolean propagate = true;&#xA;//if(leastCommonAncestor != null){&#xA;//&#x9;RegionActivation parentRegionActivation = this.getOwningRegionActivation();&#xA;//&#x9;if(leastCommonAncestor!=parentRegionActivation){&#xA;//&#x9;&#x9;VertexActivation vertexActivation = (VertexActivation) parentRegionActivation.getParent();&#xA;//&#x9;&#x9;if(vertexActivation != null){&#xA;//&#x9;&#x9;&#x9;propagate = vertexActivation.canPropagateExecution(enteringTransition, eventOccurrence, leastCommonAncestor);&#xA;//&#x9;&#x9;}&#xA;//&#x9;}&#xA;//}&#xA;//return propagate;&#xA;&#x9;bool propagate = true;&#xA;&#x9;if(leastCommonAncestor != nullptr) {&#xA;&#x9;&#x9;std::shared_ptr&lt;PSSM::Semantics::StateMachines::RegionActivation> parentRegionActivation = this->getOwningRegionActivation();&#xA;&#x9;&#x9;if(leastCommonAncestor != parentRegionActivation) {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSSM::Semantics::StateMachines::VertexActivation> vertexActivation = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::VertexActivation>(parentRegionActivation->getParent());&#xA;&#x9;&#x9;&#x9;if(vertexActivation != nullptr) {&#xA;&#x9;&#x9;&#x9;&#x9;propagate = vertexActivation->canPropagateExecution(enteringTransition, eventOccurrence, leastCommonAncestor);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return propagate;"/>
          </eAnnotations>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="leastCommonAncestor" ordered="false" eType="#//Semantics/StateMachines/RegionActivation"/>
        </eOperations>
        <eOperations name="getRegionActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/RegionActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// If the given semantic visitor is a region activation then this activation&#xA;// is returned. Otherwise if the visitor is a vertex activation  then its&#xA;// parent region activation is returned.&#xA;//RegionActivation regionActivation = null;&#xA;//if(semanticVisitor instanceof RegionActivation){&#xA;//&#x9;regionActivation = (RegionActivation) semanticVisitor;&#xA;//}else if(semanticVisitor instanceof VertexActivation){&#xA;//&#x9;regionActivation = (RegionActivation)((VertexActivation)semanticVisitor).getParent();&#xA;//}&#xA;//return regionActivation;&#xA;&#x9;std::shared_ptr&lt;PSSM::Semantics::StateMachines::RegionActivation> regionActivation = nullptr;&#xA;&#x9;if(std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::RegionActivation>(semanticVisitor) != nullptr) {&#xA;&#x9;&#x9;regionActivation = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::RegionActivation>(semanticVisitor);&#xA;&#x9;} else if(std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::VertexActivation>(semanticVisitor) != nullptr) {&#xA;&#x9;&#x9;regionActivation = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::RegionActivation>(std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::VertexActivation>(semanticVisitor)->getParent());&#xA;&#x9;}&#xA;&#x9;return regionActivation;"/>
          </eAnnotations>
          <eParameters name="semanticVisitor" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Loci/SemanticVisitor"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="status" ordered="false"
            lowerBound="1" eType="#//Semantics/StateMachines/StateMetadata"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="incomingTransitionActivations"
            ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/TransitionActivation"
            eOpposite="#//Semantics/StateMachines/TransitionActivation/targetVertexActivation"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="outgoingTransitionActivations"
            ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/TransitionActivation"
            eOpposite="#//Semantics/StateMachines/TransitionActivation/sourceVertexActivation"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EEnum" name="StateMetadata">
        <eLiterals name="idle"/>
        <eLiterals name="active" value="1"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="StateActivation" eSuperTypes="#//Semantics/StateMachines/VertexActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;uml/Trigger.hpp&quot;&#xA;#include &quot;uml/State.hpp&quot;&#xA;#include &quot;fUML/MDE4CPP_Extensions/FUML_Object.hpp&quot;&#xA;#include &quot;PSSM/Semantics/StateMachines/StateMachineExecution.hpp&quot;&#xA;#include &quot;PSSM/Semantics/StateMachines/StateMachineConfiguration.hpp&quot;&#xA;#include &quot;PSSM/Semantics/Loci/SM_Locus.hpp&quot;&#xA;#include &quot;fUML/Semantics/Loci/Executor.hpp&quot;&#xA;#include &quot;PSSM/Semantics/StateMachines/StateMetadata.hpp&quot;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/SM_ObjectActivation.hpp&quot;&#xA;#include &quot;PSSM/Semantics/StateMachines/EntryPointPseudostateActivation.hpp&quot;&#xA;#include &quot;uml/Pseudostate.hpp&quot;&#xA;#include &quot;uml/Transition.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="notifyCompletion" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// When a State completes (i.e. its entry and doActivity Behaviors have been executed completeley),&#xD;&#xA;&#x9;// an CompletionEventOccurrence is sent to the StateMachine owning this State. &#xD;&#xA;&#x9;// EventOccurrences of this type are prioritized to others in the Dispatch Loop.&#xD;&#xA;&#x9;std::dynamic_pointer_cast&lt;PSSM::Semantics::CommonBehavior::SM_ObjectActivation>(this->getExecutionContext()->getObjectActivation())->registerCompletionEvent(this->getThisStateActivationPtr());"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="releaseDeferredEvents" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// If events have been deferred by that state then these latter return to the&#xA;// regular event pool.&#xA;//Object_ context = this.getExecutionContext();&#xA;//if(context.objectActivation != null){&#xA;//&#x9;((SM_ObjectActivation)context.objectActivation).releaseDeferredEvents(this); &#xA;//}&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="hasCompleted" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// A state is considered completed under the following circumstances:&#xD;&#xA;&#x9;// 1 - If the State is simple, both its entry and doActivity Behaviors have finished their execution&#xD;&#xA;&#x9;// 2 - If the State is composite, all its owned Regions must have completed (by reaching their FinalStates) additionally&#xD;&#xA;&#x9;// When this operation returns 'true', then the generation of a CompletionEventOccurrence is allowed for this particular State&#xD;&#xA;&#x9;bool stateHasCompleted = this->m_isEntryCompleted &amp;&amp; this->m_isDoActivityCompleted;&#xD;&#xA;&#x9;if (std::dynamic_pointer_cast&lt;uml::State>(this->getNode())->getIsComposite())&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;for (auto ownedRegionActivation : *(this->getRegionActivations()))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;stateHasCompleted = stateHasCompleted &amp;&amp; ownedRegionActivation->getIsCompleted();&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return stateHasCompleted;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="defer" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Postpone the time at which this Event Occurrence will be available in the event pool.&#xD;&#xA;&#x9;// The given Event Occurrence is placed in the deferred event pool and will be released&#xD;&#xA;&#x9;// only when the current State Activation leaves the State Machine configuration.&#xD;&#xA;&#x9;//Object_ context = this.getExecutionContext();&#xD;&#xA;&#x9;//if(context.objectActivation != null){&#xD;&#xA;&#x9;//&#x9;((SM_ObjectActivation)context.objectActivation).registerDeferredEvent(eventOccurrence, this); &#xD;&#xA;&#x9;//}&#xD;&#xA;&#x9;auto context = this->getExecutionContext();&#xD;&#xA;&#x9;if(context->getObjectActivation() != nullptr) {&#xD;&#xA;&#x9;&#x9;std::dynamic_pointer_cast&lt;PSSM::Semantics::CommonBehavior::SM_ObjectActivation>(context->getObjectActivation())->registerDeferredEvent(eventOccurrence, this->getThisStateActivationPtr());&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="getRegionActivation" ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/RegionActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="//return this.regionActivation;&#xA;return nullptr;&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="tryExecuteEntry" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Execute the State's entry Behavior if specified.&#xD;&#xA;&#x9;// If not, but the State redefines another State which itself has an entry Behavior specified, then this Behavior is executed.&#xD;&#xA;&#x9;// This rule applies recursively.&#xD;&#xA;&#x9;if (!this->m_isEntryCompleted)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (auto entryBehavior = this->getEntry()) // != nullptr&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;/*if (auto entryBehaviorExecution = this->getExecutionFor(entryBehavior, eventOccurrence)) // != nullptr&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;entryBehaviorExecution->execute();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;this->setIsEntryCompleted(true);&#xD;&#xA;&#x9;&#x9;&#x9;}*/&#xD;&#xA;&#x9;&#x9;&#x9;this->getExecutionLocus()->getExecutor()->execute(entryBehavior, this->getExecutionContext(), std::shared_ptr&lt;Bag&lt;fUML::Semantics::CommonBehavior::ParameterValue>>(new Bag&lt;fUML::Semantics::CommonBehavior::ParameterValue>()));&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;this->setIsEntryCompleted(true);&#xD;&#xA;&#x9;&#x9;if (this->hasCompleted())&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;this->notifyCompletion();&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="tryExecuteExit" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Execute the State's exit Behavior if specified.&#xD;&#xA;&#x9;// If not, but the State redefines another State which itself has an exit Behavior specified, then this Behavior is executed.&#xD;&#xA;&#x9;// This rule applies recursively.&#xD;&#xA;&#x9;if (auto exitBehavior = this->getExit()) // != nullptr&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;/*if (auto exitBehaviorExecution = this->getExecutionFor(exitBehavior, eventOccurrence)) // != nullptr&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;exitBehaviorExecution->execute();&#xD;&#xA;&#x9;&#x9;}*/&#xD;&#xA;&#x9;&#x9;this->getExecutionLocus()->getExecutor()->execute(exitBehavior, this->getExecutionContext(), std::shared_ptr&lt;Bag&lt;fUML::Semantics::CommonBehavior::ParameterValue>>(new Bag&lt;fUML::Semantics::CommonBehavior::ParameterValue>()));&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;//super.exit(null, eventOccurrence, null);"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="tryInvokeDoActivity" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// If an doActivity behavior is specified for that state then it is executed.&#xD;&#xA;&#x9;// If no doActivity is specified but the state redefines another state which&#xD;&#xA;&#x9;// provides a doActivity then this latter is executed instead. The rule applies&#xD;&#xA;&#x9;// recursively.&#xD;&#xA;&#x9;//if(!this.isDoActivityCompleted){&#xD;&#xA;&#x9;//&#x9;Behavior doActivity = this.getDoActivity();&#xD;&#xA;&#x9;//&#x9;if(doActivity!=null){&#xD;&#xA;&#x9;//&#x9;&#x9;// Create, initialize and register to the locus the doActivityContextObject.&#xD;&#xA;&#x9;//&#x9;&#x9;this.doActivityContextObject = new DoActivityContextObject();&#xD;&#xA;&#x9;//&#x9;&#x9;this.getExecutionLocus().add(this.doActivityContextObject);&#xD;&#xA;&#x9;//&#x9;&#x9;this.doActivityContextObject.initialize(this.getExecutionContext());&#xD;&#xA;&#x9;//&#x9;&#x9;this.doActivityContextObject.owner = this;&#xD;&#xA;&#x9;//&#x9;&#x9;// Extract data from triggering event occurrence if possible. Reuse event occurrence&#xD;&#xA;&#x9;//&#x9;&#x9;// embedded data extraction logic provided by EventTriggeredExecution.&#xD;&#xA;&#x9;//&#x9;&#x9;List&lt;ParameterValue> inputs = null;&#xD;&#xA;&#x9;//&#x9;&#x9;Execution doActivityExecution = this.getExecutionFor(doActivity, eventOccurrence);&#xD;&#xA;&#x9;//&#x9;&#x9;if(doActivityExecution instanceof EventTriggeredExecution){&#xD;&#xA;&#x9;//&#x9;&#x9;&#x9;((EventTriggeredExecution)doActivityExecution).initialize();&#xD;&#xA;&#x9;//&#x9;&#x9;&#x9;inputs = new ArrayList&lt;ParameterValue>(((EventTriggeredExecution)doActivityExecution).wrappedExecution.parameterValues);&#xD;&#xA;&#x9;//&#x9;&#x9;}&#xD;&#xA;&#x9;//&#x9;&#x9;// Start doActivity execution on its own thread of execution (i.e., this&#xD;&#xA;&#x9;//&#x9;&#x9;// a different thread of execution than the one used for the state machine).&#xD;&#xA;&#x9;//&#x9;&#x9;this.doActivityContextObject.startBehavior(doActivity, inputs);&#xD;&#xA;&#x9;//&#x9;}&#xD;&#xA;&#x9;//}&#xD;&#xA;&#x9;if (!this->m_isDoActivityCompleted)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (auto doActivityBehavior = this->getDoActivity()) // != nullptr&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;// tbd&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;this->setIsDoActivityCompleted(true);&#xD;&#xA;&#x9;&#x9;if (this->hasCompleted())&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;this->notifyCompletion();&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="canDefer" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Return true if current state activation is capable of deferring the given&#xD;&#xA;&#x9;// event occurrence; false otherwise. Note that false is returned in case where&#xD;&#xA;&#x9;// the deferring constraint is overridden by an outgoing transition&#xD;&#xA;&#x9;// &#xD;&#xA;&#x9;// Note: for the moment the evaluation is done with the assumption that the&#xD;&#xA;&#x9;// received event occurrence is a signal event occurrence. This will change&#xD;&#xA;&#x9;// as soon as other kind of event (e.g. call event) will be supported in fUML.&#xD;&#xA;&#x9;//State state = (State) this.node;&#xD;&#xA;&#x9;//boolean deferred = this.match(eventOccurrence, state.getDeferrableTriggers());&#xD;&#xA;&#x9;//while(!deferred &amp;&amp; state.getRedefinedState() != null){&#xD;&#xA;&#x9;//&#x9;state = state.getRedefinedState();&#xD;&#xA;&#x9;//&#x9;deferred = this.match(eventOccurrence, state.getDeferrableTriggers());&#xD;&#xA;&#x9;//}&#xD;&#xA;&#x9;//if(deferred){&#xD;&#xA;&#x9;//&#x9;int i = 0;&#xD;&#xA;&#x9;//&#x9;TransitionActivation overridingTransitionActivation = null;&#xD;&#xA;&#x9;//&#x9;while(overridingTransitionActivation == null &amp;&amp; i &lt; this.outgoingTransitionActivations.size()){&#xD;&#xA;&#x9;//&#x9;&#x9;TransitionActivation currentTransitionActivation = this.outgoingTransitionActivations.get(i);&#xD;&#xA;&#x9;//&#x9;&#x9;if(currentTransitionActivation.canFireOn(eventOccurrence)){&#xD;&#xA;&#x9;//&#x9;&#x9;&#x9;overridingTransitionActivation = currentTransitionActivation;&#xD;&#xA;&#x9;//&#x9;&#x9;}&#xD;&#xA;&#x9;//&#x9;&#x9;i++;&#xD;&#xA;&#x9;//&#x9;}&#xD;&#xA;&#x9;//&#x9;deferred = overridingTransitionActivation == null;&#xD;&#xA;&#x9;//}&#xD;&#xA;&#x9;//return deferred;&#xD;&#xA;&#x9;std::shared_ptr&lt;uml::State> state = std::dynamic_pointer_cast&lt;uml::State>(this->getNode());&#xD;&#xA;&#xD;&#xA;&#x9;bool deferred = this->match(eventOccurrence, std::dynamic_pointer_cast&lt;Bag&lt;uml::Trigger>>(state->getDeferrableTrigger()));&#xD;&#xA;&#xD;&#xA;&#x9;while(!deferred &amp;&amp; state->getRedefinedState() != nullptr) &#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;state = state->getRedefinedState();&#xD;&#xA;&#x9;&#x9;deferred = this->match(eventOccurrence, std::dynamic_pointer_cast&lt;Bag&lt;uml::Trigger>>(state->getDeferrableTrigger()));&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;if(deferred)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;deferred = false;&#xD;&#xA;&#x9;&#x9;for (auto outgoingTransitionActivation : *m_outgoingTransitionActivations)&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;if (outgoingTransitionActivation->canFireOn(eventOccurrence))&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;deferred = true;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;/*std::shared_ptr&lt;PSSM::Semantics::StateMachines::TransitionActivation> overridingTransitionActivation = nullptr;&#xD;&#xA;&#x9;&#x9;while(overridingTransitionActivation == nullptr &amp;&amp; i &lt; this->m_outgoingTransitionActivations->size()) {&#xD;&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSSM::Semantics::StateMachines::TransitionActivation> currentTransitionActivation = this->m_outgoingTransitionActivations->at(i);&#xD;&#xA;&#x9;&#x9;&#x9;if(currentTransitionActivation->canFireOn(eventOccurrence)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;overridingTransitionActivation = currentTransitionActivation;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;i++;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;deferred = overridingTransitionActivation == nullptr;*/&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return deferred;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="getConnectionPointActivation" ordered="false" upperBound="-1"
            eType="#//Semantics/StateMachines/ConnectionPointActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Return the activation for the exit point or the entry point.&#xA;//ConnectionPointActivation activation = null;&#xA;//int i = 0;&#xA;//while(i &lt; this.connectionPointActivation.size() &amp;&amp; activation==null){&#xA;//&#x9;if(this.connectionPointActivation.get(i).getNode()==vertex){&#xA;//&#x9;&#x9;activation = this.connectionPointActivation.get(i);&#xA;//&#x9;}&#xA;//&#x9;i++;&#xA;//}&#xA;&#x9;return nullptr;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getConnectionPointActivation" ordered="false" eType="#//Semantics/StateMachines/ConnectionPointActivation">
          <eParameters name="vertex" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Vertex"/>
        </eOperations>
        <eOperations name="getFireableTransitions" ordered="false" upperBound="-1"
            eType="#//Semantics/StateMachines/TransitionActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Return the set of transitions that can fire using the the given event occurrence&#xA;//List&lt;TransitionActivation> fireableTransitions = new ArrayList&lt;TransitionActivation>();&#xA;//for(int i=0; i &lt; this.outgoingTransitionActivations.size(); i++){&#xA;//&#x9;TransitionActivation outgoingTransitionActivation = this.outgoingTransitionActivations.get(i);&#xA;//&#x9;if(outgoingTransitionActivation.canFireOn(eventOccurrence)){&#xA;//&#x9;&#x9;fireableTransitions.add(outgoingTransitionActivation);&#xA;//&#x9;}&#xA;//}&#xA;//return fireableTransitions;&#xA;&#x9;return nullptr;&#xA;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="enterRegions" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Regions can be entered either implicitly or explicitly. &#xD;&#xA;&#x9;// A Region is typically entered implicitly when its Activation is triggered&#xD;&#xA;&#x9;// by a Transition terminating on the edge of its containing State.&#xD;&#xA;&#x9;// A Region is typically entered explicitly when one of its contained&#xD;&#xA;&#x9;// States is targeted by a Transition coming from the outside.&#xD;&#xA;&#x9;// *** Regions are entered concurrently ***&#xD;&#xA;&#x9;//List&lt;Vertex> targetedVertices = new ArrayList&lt;Vertex>();&#xD;&#xA;&#x9;//VertexActivation sourceActivation = enteringTransition.getSourceActivation();&#xD;&#xA;&#x9;//if(sourceActivation instanceof ForkPseudostateActivation){&#xD;&#xA;&#x9;//&#x9;Pseudostate fork = (Pseudostate)sourceActivation.getNode();&#xD;&#xA;&#x9;//&#x9;for(int i = 0; i &lt; fork.getOutgoings().size(); i++){&#xD;&#xA;&#x9;//&#x9;&#x9;targetedVertices.add(fork.getOutgoings().get(i).getTarget());&#xD;&#xA;&#x9;//&#x9;}&#xD;&#xA;&#x9;//}else{&#xD;&#xA;&#x9;//&#x9;VertexActivation targetActivation = enteringTransition.getTargetActivation();&#xD;&#xA;&#x9;//&#x9;if(targetActivation instanceof EntryPointPseudostateActivation){&#xD;&#xA;&#x9;//&#x9;&#x9;Pseudostate entryPoint = (Pseudostate)targetActivation.getNode();&#xD;&#xA;&#x9;//&#x9;&#x9;for(int i = 0; i &lt; entryPoint.getOutgoings().size(); i++){&#xD;&#xA;&#x9;//&#x9;&#x9;&#x9;targetedVertices.add(entryPoint.getOutgoings().get(i).getTarget());&#xD;&#xA;&#x9;//&#x9;&#x9;}&#xD;&#xA;&#x9;//&#x9;}else{&#xD;&#xA;&#x9;//&#x9;&#x9;if(!(targetActivation instanceof HistoryPseudostateActivation)){&#xD;&#xA;&#x9;//&#x9;&#x9;&#x9;targetedVertices.add((Vertex)targetActivation.getNode());&#xD;&#xA;&#x9;//&#x9;&#x9;}&#xD;&#xA;&#x9;//&#x9;}&#xD;&#xA;&#x9;//}&#xD;&#xA;&#x9;//for(int i=0; i &lt; this.regionActivation.size(); i++){&#xD;&#xA;&#x9;//&#x9;RegionActivation regionActivation = this.regionActivation.get(i);&#xD;&#xA;&#x9;//&#x9;int j = 0;&#xD;&#xA;&#x9;//&#x9;boolean found = false;&#xD;&#xA;&#x9;//&#x9;while(j &lt; targetedVertices.size() &amp;&amp; !found){&#xD;&#xA;&#x9;//&#x9;&#x9;found = regionActivation.getVertexActivation(targetedVertices.get(j)) != null;&#xD;&#xA;&#x9;//&#x9;&#x9;j++;&#xD;&#xA;&#x9;//&#x9;}&#xD;&#xA;&#x9;//&#x9;if(!found){&#xD;&#xA;&#x9;//&#x9;&#x9;regionActivation.enter(enteringTransition, eventOccurrence);&#xD;&#xA;&#x9;//&#x9;}&#xD;&#xA;&#x9;//}&#xD;&#xA;&#x9;std::shared_ptr&lt;Bag&lt;uml::Vertex>> targetedVertices(new Bag&lt;uml::Vertex>());&#xD;&#xA;&#x9;auto sourceActivation = enteringTransition->getSourceActivation();&#xD;&#xA;&#xD;&#xA;&#x9;//Fork&#xD;&#xA;&#xD;&#xA;&#x9;//Else&#xD;&#xA;&#x9;auto targetActivation = enteringTransition->getTargetActivation();&#xD;&#xA;&#xD;&#xA;&#x9;if (std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::EntryPointPseudostateActivation>(targetActivation) != nullptr) &#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;auto entryPoint = std::dynamic_pointer_cast&lt;uml::Pseudostate>(targetActivation->getNode());&#xD;&#xA;&#x9;&#x9;for (auto outgoingTransition : *(entryPoint->getOutgoings())) &#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;targetedVertices->add(outgoingTransition->getTarget());&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;} // else history&#xD;&#xA;&#xD;&#xA;&#x9;for (auto regionActivation : *m_regionActivations)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;int j=0;&#xD;&#xA;&#x9;&#x9;bool found = false;&#xD;&#xA;&#x9;&#x9;while (j &lt; int(targetedVertices->size()) &amp;&amp; !found) &#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;found = regionActivation->getVertexActivation(targetedVertices->at(j)) != nullptr;&#xD;&#xA;&#x9;&#x9;&#x9;j++;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;if (!found) &#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;regionActivation->enter(enteringTransition, eventOccurrence);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="getEntry" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Behavior">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Return the Entry Behavior of the State or one inherited&#xD;&#xA;&#x9;// from a Redefined State. If no Entry Behavior can be found, null is&#xD;&#xA;&#x9;// returned.&#xD;&#xA;&#x9;auto state = std::dynamic_pointer_cast&lt;uml::State>(this->getNode());&#xD;&#xA;&#x9;auto entryBehavior = state->getEntry();&#xD;&#xA;&#x9;while(entryBehavior == nullptr &amp;&amp; state->getRedefinedState() != nullptr){&#xD;&#xA;&#x9;&#x9;state = state->getRedefinedState();&#xD;&#xA;&#x9;&#x9;entryBehavior = state->getEntry();&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return entryBehavior;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getExit" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Behavior">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Return the Exit Behavior of the State or one inherited&#xD;&#xA;&#x9;// from a Redefined State. If no Exit Behavior can be found, null is&#xD;&#xA;&#x9;// returned.&#xD;&#xA;&#x9;auto state = std::dynamic_pointer_cast&lt;uml::State>(this->getNode());&#xD;&#xA;&#x9;auto exitBehavior = state->getExit();&#xD;&#xA;&#x9;while(exitBehavior == nullptr &amp;&amp; state->getRedefinedState() != nullptr){&#xD;&#xA;&#x9;&#x9;state = state->getRedefinedState();&#xD;&#xA;&#x9;&#x9;exitBehavior = state->getExit();&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return exitBehavior;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getDoActivity" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Behavior">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Return the DoActivity Behavior of the State or one inherited&#xD;&#xA;&#x9;// from a Redefined State. If no DoActivity Behavior can be found, null is&#xD;&#xA;&#x9;// returned.&#xD;&#xA;&#x9;auto state = std::dynamic_pointer_cast&lt;uml::State>(this->getNode());&#xD;&#xA;&#x9;auto doActivityBehavior = state->getDoActivity();&#xD;&#xA;&#x9;while(doActivityBehavior == nullptr &amp;&amp; state->getRedefinedState() != nullptr){&#xD;&#xA;&#x9;&#x9;state = state->getRedefinedState();&#xD;&#xA;&#x9;&#x9;doActivityBehavior = state->getDoActivity();&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return doActivityBehavior;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="enter">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Enter this State by executing its entry Behavior if one is specified, invoke its doActivity Behavior if one is specified and, if composite, all owned RegionActivations are entered.&#xD;&#xA;&#x9;// As the State is now active, it registers itself in the StateMachineConfiguration of the owning StateMachine and sets itself as the history of its owning RegionActivation.&#xD;&#xA;&#x9;// All parent Vertices must be entered beforehand until the least common ancestor of this StateActivation and the source StateActivation of the entering Transition is reached.&#xD;&#xA;&#x9;// NOTE: Due to the unability of MDE4CPP to invoke behaviors asynchronously, the sequence order has been altered compared to the specification.&#xD;&#xA;&#x9;if (this->getStatus() == StateMetadata::IDLE) {&#xD;&#xA;&#x9;&#x9;this->getThisVertexActivationPtr()->enter(enteringTransition, eventOccurrence, leastCommonAncestor);&#xD;&#xA;&#x9;&#x9;if (std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::RegionActivation>(this->m_parent) != leastCommonAncestor) {&#xD;&#xA;&#x9;&#x9;&#x9;if (auto parentVertexActivation = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::VertexActivation>(this->m_parent)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;parentVertexActivation->enter(enteringTransition, eventOccurrence, leastCommonAncestor);&#xD;&#xA;&#x9;&#x9;&#x9;}&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;this->tryExecuteEntry(eventOccurrence);&#xD;&#xA;&#x9;&#x9;//this->tryInvokeDoActivity(eventOccurrence);&#xD;&#xA;&#x9;&#x9;/*if (std::dynamic_pointer_cast&lt;uml::State>(this->getNode())->getIsComposite())&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;this->enterRegions(nullptr, eventOccurrence);&#xD;&#xA;&#x9;&#x9;}*/&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::StateMachineExecution>(this->getStateMachineExecution())->getConfiguration()->_register(this->getThisStateActivationPtr());&#xD;&#xA;&#x9;&#x9;this->getOwningRegionActivation()->setHistory(this->getThisStateActivationPtr());&#xD;&#xA;&#xD;&#xA;&#x9;&#x9;this->tryInvokeDoActivity(eventOccurrence);&#xD;&#xA;&#x9;&#x9;if (std::dynamic_pointer_cast&lt;uml::State>(this->getNode())->getIsComposite())&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;this->enterRegions(nullptr, eventOccurrence);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="leastCommonAncestor" ordered="false" eType="#//Semantics/StateMachines/RegionActivation"/>
        </eOperations>
        <eOperations name="exit">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Exit this StateActivation by exiting all owned RegionActivations if the State is composite, abort its doActivtiy Behavior if one is specified and running&#xD;&#xA;&#x9;// and execute its exit Behavior synchonously if one is specified.&#xD;&#xA;&#x9;// As the State is now idle, it unregisters itself in the StateMachineConfiguration of the owning StateMachine.&#xD;&#xA;&#x9;if (std::dynamic_pointer_cast&lt;uml::State>(this->getNode())->getIsComposite())&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;for (auto ownedRegionActivation : *(this->m_regionActivations))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;ownedRegionActivation->exit(nullptr, eventOccurrence);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;//this->setIsDoActivityCompleted(true); tbd&#xD;&#xA;&#x9;this->tryExecuteExit(eventOccurrence);&#xD;&#xA;&#x9;this->setStatus(PSSM::Semantics::StateMachines::StateMetadata::IDLE);&#xD;&#xA;&#x9;std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::StateMachineExecution>(this->getStateMachineExecution())->getConfiguration()->unregister(this->getThisStateActivationPtr());"/>
          </eAnnotations>
          <eParameters name="exitingTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="leastCommonAncestor" ordered="false" eType="#//Semantics/StateMachines/RegionActivation"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="connectionPointActivations"
            ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/ConnectionPointActivation"
            containment="true"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="regionActivations"
            ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/RegionActivation"
            containment="true"/>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="isDoActivityCompleted"
            ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean"/>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="isEntryCompleted" ordered="false"
            lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean"/>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="isExitCompleted" ordered="false"
            lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="doActivityContextObject"
            ordered="false" eType="#//Semantics/StateMachines/DoActivityContextObject"
            eOpposite="#//Semantics/StateMachines/DoActivityContextObject/owner"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="ConnectionPointActivation" abstract="true"
          eSuperTypes="#//Semantics/StateMachines/PseudostateActivation"/>
      <eClassifiers xsi:type="ecore:EClass" name="PseudostateActivation" abstract="true"
          eSuperTypes="#//Semantics/StateMachines/VertexActivation">
        <eOperations name="evaluateAllGuards" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Evaluate all guards of outgoing transitions of the pseudo-state.&#xA;&#x9;// Guard evaluation populate the set of fireable transitions with&#xA;&#x9;// transitions whith guard evaluating to true. Not that this evaluation&#xA;&#x9;// is not done at the time the where this pseudo-state is entered. Instead&#xA;&#x9;// it is done statically when the compound transition leading to this&#xA;&#x9;// pseudo-state is evaluated.&#xA;&#x9;this->m_fireableTransitions->clear();&#xA;&#x9;for(int i=0; i &lt; int(this->getOutgoingTransitions()->size()); ++i){&#xA;&#x9;&#x9;auto transitionActivation = this->getOutgoingTransitions()->at(i);&#xA;&#x9;&#x9;if(transitionActivation->evaluateGuard(eventOccurrence)){&#xA;&#x9;&#x9;&#x9;this->m_fireableTransitions->add(transitionActivation);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="fireableTransitions"
            ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/TransitionActivation"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="DoActivityContextObject">
        <eOperations name="getFeatureValue" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Delegate read of a particular feature to the state-machine context&#xA;FeatureValue featureValue = null;&#xA;if(this.context!=null){&#xA;&#x9;featureValue = this.context.getFeatureValue(feature);&#xA;}&#xA;return featureValue;&#xA;"/>
          </eAnnotations>
          <eParameters name="feature" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//StructuralFeature"/>
        </eOperations>
        <eOperations name="setFeatureValue" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Delegate write of particular feature to the state-machine context&#xA;if(this.context!=null){&#xA;&#x9;this.context.setFeatureValue(feature, values, position);&#xA;}&#xA;"/>
          </eAnnotations>
          <eParameters name="feature" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//StructuralFeature"/>
          <eParameters name="values" ordered="false" upperBound="-1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject"/>
          <eParameters name="position" ordered="false" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Integer"/>
        </eOperations>
        <eOperations name="dispatch" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/Execution">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Delegate operation call to the state-machine context&#xA;Execution execution = null;&#xA;if(this.context!=null){&#xA;&#x9;execution = this.context.dispatch(operation);&#xA;}&#xA;return execution;&#xA;"/>
          </eAnnotations>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
        </eOperations>
        <eOperations name="send" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Delegate the reception of a signal to the state-machine context&#xA;if(this.context!=null){&#xA;&#x9;this.context.send(signalInstance);&#xA;}&#xA;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="unregister" ordered="false" lowerBound="1">
          <eParameters name="accepter" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventAccepter"/>
        </eOperations>
        <eOperations name="_register" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// When the executing doActivity registers an accepter it searches through the deferred event&#xA;// pool of the object activation associated to the state-machine context.&#xA;// 1. If the accepter being registered matches one of the deferred events then this event is&#xA;//    transferred into the event pool of the doActivity object activation. This implies the&#xA;//    event will be dispatched in a RTC step performed by the doActivity object activation. &#xA;// 2. If the accepter being registered does not match one of the deferred events then this latter&#xA;//    is wrapped in another accepter which is registered by the state machine context object activation.&#xA;//    This is realized in order to guarantee that the doActivity will have a chance to match an event&#xA;//    received by the state-machine context object.&#xA;super.register(accepter);&#xA;SM_ObjectActivation contextObjectActivation = (SM_ObjectActivation) this.context.objectActivation;&#xA;int i = 1;&#xA;DeferredEventOccurrence matchedDeferredEvent = null; &#xA;while(matchedDeferredEvent == null &amp;&amp; i &lt;= contextObjectActivation.deferredEventPool.size()){&#xA;&#x9;DeferredEventOccurrence eventOccurrence = contextObjectActivation.deferredEventPool.get(i-1);&#xA;&#x9;if(this.owner == eventOccurrence.constrainingStateActivation  &amp;&amp; accepter.match(eventOccurrence.deferredEventOccurrence)){&#xA;&#x9;&#x9;matchedDeferredEvent = eventOccurrence;&#xA;&#x9;}&#xA;&#x9;i++;&#xA;}&#xA;if(matchedDeferredEvent == null){&#xA;&#x9;DoActivityExecutionEventAccepter encapsulatingAccepter = new DoActivityExecutionEventAccepter();&#xA;&#x9;encapsulatingAccepter.encapsulatedAccepter = accepter;&#xA;&#x9;encapsulatingAccepter.context = this;&#xA;&#x9;this.context.register(encapsulatingAccepter);&#xA;}else{&#xA;&#x9;contextObjectActivation.deferredEventPool.remove(matchedDeferredEvent);&#xA;&#x9;this.objectActivation.eventPool.add(matchedDeferredEvent.deferredEventOccurrence);&#xA;&#x9;this.objectActivation._send(new ArrivalSignal());&#xA;}&#xA;"/>
          </eAnnotations>
          <eParameters name="accepter" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventAccepter"/>
        </eOperations>
        <eOperations name="destroy" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// When destroyed in addition to the usual behavior, the do activity context object&#xA;// has to remove the encapsulating accepters it may have registered.&#xA;for(int i=0; i &lt; this.objectActivation.waitingEventAccepters.size(); i++){&#xA;&#x9;this.unregisterFromContext(this.objectActivation.waitingEventAccepters.get(i));&#xA;}&#xA;super.destroy();&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="unregisterFromContext" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Unregister in the context of this do activity context the encapsulating&#xA;// event accepter.&#xA;ObjectActivation contextObjectActivation = this.context.objectActivation;&#xA;if(contextObjectActivation!=null){&#xA;&#x9;DoActivityExecutionEventAccepter encapsulatingAccepter = null;&#xA;&#x9;int i = 0;&#xA;&#x9;while(encapsulatingAccepter==null &amp;&amp; i &lt; contextObjectActivation.waitingEventAccepters.size()){&#xA;&#x9;&#x9;EventAccepter currentAccepter = contextObjectActivation.waitingEventAccepters.get(i);&#xA;&#x9;&#x9;if(currentAccepter instanceof DoActivityExecutionEventAccepter&#xA;&#x9;&#x9;&#x9;&#x9;&amp;&amp; ((DoActivityExecutionEventAccepter)currentAccepter).encapsulatedAccepter==encapsulatedAccepter){&#xA;&#x9;&#x9;&#x9;encapsulatingAccepter = (DoActivityExecutionEventAccepter) currentAccepter;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;i++;&#xA;&#x9;}&#xA;&#x9;if(encapsulatingAccepter!=null){&#xA;&#x9;&#x9;contextObjectActivation.unregister(encapsulatingAccepter);&#xA;&#x9;}&#xA;}&#xA;"/>
          </eAnnotations>
          <eParameters name="encapsulatedAccepter" ordered="false" lowerBound="1"
              eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventAccepter"/>
        </eOperations>
        <eOperations name="initialize" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Context object of this DoActivityContextObject is the context&#xA;// of the state machine which has invoked the doActivity.&#xA;if(context!=null){&#xA;&#x9;this.context = context;&#xA;}&#xA;"/>
          </eAnnotations>
          <eParameters name="context" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//MDE4CPP_Extensions/FUML_Object"/>
        </eOperations>
        <eOperations name="startBehavior" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Starts the behavior of a DoActivityContextObject. It behaves the&#xA;// same than in fUML except that for object is associated to a specific&#xA;// type of object activation: DoActivityContextObjectActivation&#xA;if(this.objectActivation == null){&#xA;&#x9;this.objectActivation = new DoActivityContextObjectActivation();&#xA;&#x9;this.objectActivation.object = this;&#xA;}&#xA;this.objectActivation.startBehavior(classifier, inputs);&#xA;"/>
          </eAnnotations>
          <eParameters name="classifier" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class"/>
          <eParameters name="inputs" ordered="false" upperBound="-1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/ParameterValue"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="context" ordered="false"
            lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//MDE4CPP_Extensions/FUML_Object"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="owner" ordered="false"
            lowerBound="1" eType="#//Semantics/StateMachines/StateActivation" eOpposite="#//Semantics/StateMachines/StateActivation/doActivityContextObject"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="InitialPseudostateActivation" eSuperTypes="#//Semantics/StateMachines/PseudostateActivation">
        <eOperations name="enter">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Entering an InitialPseudostateActivation results in firing its outgoing TransitionActivation immediately without the use of Events (therefore &quot;nullptr&quot;).&#xD;&#xA;&#x9;// This is because all InitialPSActivations are traversed during the first RTC Step of entering their Region instead of being triggered by any accepted EventOccurrence.&#xD;&#xA;&#x9;// Also, a InitialPS must have exactly one outgoing TransitionActivation which must not have Triggers and guards, therefore checking for fireable TransitionActivations can be omitted.&#xD;&#xA;&#x9;this->getThisVertexActivationPtr()->enter(enteringTransition, eventOccurrence, leastCommonAncestor);&#xD;&#xA;&#x9;if (this->m_outgoingTransitionActivations->size() == 1)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;this->m_outgoingTransitionActivations->at(0)->fire(eventOccurrence);&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="leastCommonAncestor" ordered="false" eType="#//Semantics/StateMachines/RegionActivation"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="StateMachineExecution" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/Execution">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;PSSM/Semantics/CommonBehavior/SM_ObjectActivation.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/Loci/SM_ExecutionFactory.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/StateMachineEventAccepter.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/CommonBehaviorFactory.hpp&quot;&#xD;&#xA;#include &quot;uml/StateMachine.hpp&quot;&#xD;&#xA;#include &quot;uml/Region.hpp&quot;&#xD;&#xA;#include &quot;fUML/Semantics/CommonBehavior/EventAccepter.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="execute" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="documentation" value="Execute the behavior given by the type of this execution. &#xD;&#xA;The parameterValues for any input (in or in-out) parameters of the behavior should be set before the execution.&#xD;&#xA;The parameteValues for any output (in-out, out or return) parameters of the behavior will be set by the execution.&#xD;&#xA;"/>
            <details key="body" value="// The execution of state-machine is realized as described below&#xD;&#xA;&#x9;// 1 - An event accepter is placed in the list of waiting event accepters for this state-machine&#xD;&#xA;&#x9;// 2 - All visitors required to interpret the state-machine are instantiated and link together&#xD;&#xA;&#x9;// 3 - All top level regions (i.e. those directly owned by the executed state-machine) are entered&#xD;&#xA;&#x9;//     concurrently. Since they are top regions then there is no transition used to enter them&#xD;&#xA;&#x9;// Note: a state-machine always has at runtime a single event accepter&#xD;&#xA;&#x9;/*if(this.context!=null &amp;&amp; this.context.objectActivation!=null){&#xD;&#xA;&#x9;&#x9;this.context.register(new StateMachineEventAccepter(this));&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;this.initRegions();&#xD;&#xA;&#x9;for(RegionActivation activation: this.regionActivation){&#xD;&#xA;&#x9;&#x9;activation.activate();&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;for(RegionActivation activation: this.regionActivation){&#xD;&#xA;&#x9;&#x9;activation.activateTransitions();&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;for(RegionActivation regionActivation: this.regionActivation){&#xD;&#xA;&#x9;&#x9;regionActivation.enter(null, null);&#xD;&#xA;&#x9;}*/&#xD;&#xA;&#xD;&#xA;&#x9;if (this->m_context != nullptr &amp;&amp; this->m_objectActivation != nullptr)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;auto smEventAccepter = PSSM::Semantics::StateMachines::StateMachinesFactory::eInstance()->createStateMachineEventAccepter();&#xD;&#xA;&#x9;&#x9;smEventAccepter->setRegistrationContext(this->getThisStateMachineExecutionPtr());&#xD;&#xA;&#x9;&#x9;this->_register(smEventAccepter);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;this->initRegions();&#xD;&#xA;&#x9;for (auto regionActivation : *(this->m_regionActivations))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;regionActivation->activate();&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;for (auto regionActivation : *(this->m_regionActivations))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;regionActivation->activateTransitions();&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;for (auto regionActivation : *(this->m_regionActivations))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;regionActivation->enter(nullptr, nullptr);&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="new_" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="documentation" value="Create a new execution with no behavior or parameterValues.&#xD;&#xA;"/>
            <details key="body" value="/*if(this.context!=null){&#xD;&#xA;&#x9;&#x9;return new StateMachineExecution(this.context);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return new StateMachineExecution();&#xD;&#xA;&#xD;&#xA;&#x9;if (this->m_context != nullptr)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;return std::shared_ptr&lt;Any>(new StateMachineExecutionImpl());&#xD;&#xA;&#x9;}*/&#xD;&#xA;&#x9;return nullptr;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="initRegions" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// OBSOLETE BECAUSE REGION INITIALIZATION IS HANDLED IN MODEL EXECUTIONFACTORY&#xA;&#x9;// Instantiate activations for regions owned by the state machine.&#xA;&#x9;// The parent of these activations is this state machine execution.&#xA;&#x9;/*StateMachine machine = null;&#xA;&#x9;if(!this.getTypes().isEmpty()){&#xA;&#x9;&#x9;machine = (StateMachine) this.getTypes().get(0);&#xA;&#x9;}&#xA;&#x9;if(machine!=null){&#xA;&#x9;&#x9;for(Region region: machine.getRegions()){&#xA;&#x9;&#x9;&#x9;RegionActivation activation = (RegionActivation) this.locus.factory.instantiateVisitor(region);&#xA;&#x9;&#x9;&#x9;activation.setParent(this);&#xA;&#x9;&#x9;&#x9;activation.setNode(region);&#xA;&#x9;&#x9;&#x9;this.regionActivation.add(activation);&#xA;&#x9;&#x9;}&#xA;&#x9;}*/&#xA;&#xA;&#x9;/*std::shared_ptr&lt;uml::StateMachine> stateMachine = nullptr;&#xA;&#x9;if (!this->getTypes()->empty())&#xA;&#x9;{&#xA;&#x9;&#x9;stateMachine = std::dynamic_pointer_cast&lt;uml::StateMachine>(this->getTypes()->at(0));&#xA;&#x9;}&#xA;&#x9;if (stateMachine != nullptr)&#xA;&#x9;{&#xA;&#x9;&#x9;for (auto region : *(stateMachine->getRegion()))&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;auto regionActivation = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::RegionActivation>(this->m_locus->getFactory()->instantiateVisitor(region));&#xA;&#x9;&#x9;&#x9;regionActivation->setParent(this->getThisSemanticVisitorPtr());&#xA;&#x9;&#x9;&#x9;regionActivation->setNode(region);&#xA;&#x9;&#x9;&#x9;this->m_regionActivations->add(regionActivation);&#xA;&#x9;&#x9;}&#xA;&#x9;}*/"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getVertexActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Find the vertex activation corresponding to the given vertex.&#xA;&#x9;// Search goes through the overall hierarchy of visitors until&#xA;&#x9;// the activation is found. Null is returned if no activation&#xA;&#x9;// could be found.&#xA;&#x9;/*int i = 0;&#xA;&#x9;VertexActivation vertexActivation = null;&#xA;&#x9;while(vertexActivation==null &amp;&amp; i &lt; this.regionActivation.size()){&#xA;&#x9;&#x9;vertexActivation = this.regionActivation.get(i).getVertexActivation(vertex);&#xA;&#x9;&#x9;i++;&#xA;&#x9;}&#xA;&#x9;return vertexActivation;*/&#xA;&#xA;&#x9;std::shared_ptr&lt;PSSM::Semantics::StateMachines::VertexActivation> vertexActivation = nullptr;&#xA;&#x9;for (auto regionActivation : *(this->m_regionActivations))&#xA;&#x9;{&#xA;&#x9;&#x9;if (vertexActivation = regionActivation->getVertexActivation(vertex)) break;&#xA;&#x9;}&#xA;&#x9;return vertexActivation;"/>
          </eAnnotations>
          <eParameters name="vertex" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Vertex"/>
        </eOperations>
        <eOperations name="getRegionActivation" ordered="false" lowerBound="1" upperBound="-1"
            eType="#//Semantics/StateMachines/RegionActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="return this->m_regionActivations;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="terminate" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// The termination of a State Machine consists in aborting all &quot;ongoing&quot; DoActivity Behaviors&#xD;&#xA;&#x9;// started by States owned by this State Machine. States that are currently active (i.e. registered&#xD;&#xA;&#x9;// in the State Machine configuration) are not exited (i.e. their Exit Behaviors  are not executed).&#xD;&#xA;&#x9;for (auto regionActivation : *(this->m_regionActivations))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;regionActivation->terminate();&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;this->m_regionActivations->clear();"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="startBehavior" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// The behavior captured here is almost identical to the one provide by Object_.&#xD;&#xA;&#x9;// If not already done, a SM_ObjectActivation which allows the registering of an StateMachineEventAccepter is instantiated here and its Event Dispatch Loop is started.&#xD;&#xA;&#x9;/*if (this.objectActivation == null) {&#xD;&#xA;&#x9;&#x9;this.objectActivation = new SM_ObjectActivation();&#xD;&#xA;&#x9;&#x9;this.objectActivation.object = this;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;this.objectActivation.startBehavior(classifier, inputs);*/&#xD;&#xA;&#xD;&#xA;&#x9;if (this->m_objectActivation == nullptr)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;auto objectActivation(PSSM::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createSM_ObjectActivation_as_objectActivation_in_FUML_Object(this->getThisFUML_ObjectPtr()));&#xD;&#xA;&#x9;&#x9;this->setObjectActivation(objectActivation);&#xD;&#xA;&#x9;&#x9;this->m_objectActivation->setObject(this->getThisFUML_ObjectPtr());&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;// Event Dispatch Loop currently not supported&#xD;&#xA;&#x9;// this->m_objectActivation->startBehavior(classifier, inputs);"/>
          </eAnnotations>
          <eParameters name="classifier" ordered="false" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class"/>
          <eParameters name="inputs" ordered="false" upperBound="-1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/ParameterValue"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="regionActivations"
            ordered="false" lowerBound="1" upperBound="-1" eType="#//Semantics/StateMachines/RegionActivation"
            containment="true"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="configuration" ordered="false"
            lowerBound="1" eType="#//Semantics/StateMachines/StateMachineConfiguration"
            containment="true" eOpposite="#//Semantics/StateMachines/StateMachineConfiguration/execution"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="StateMachineConfiguration">
        <eOperations name="getRoot" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateConfiguration">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="return this->m_rootConfiguration;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getExecution" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateMachineExecution">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="//return this->m_execution;&#xD;&#xA;&#x9;return nullptr;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getVertexActivationsAtLevel" ordered="false" upperBound="-1"
            eType="#//Semantics/StateMachines/VertexActivation">
          <eParameters name="level" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Integer"/>
        </eOperations>
        <eOperations name="_register" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Register the given StateActivation in the Configuration of its StateMachine as a StateConfiguration. This occurs when the StateActivation is entered.&#xD;&#xA;&#x9;// If the Configuration does not contain any StateConfigurations yet, the given one is referenced to as the rootConfiguration of the StateConfiguration tree.&#xD;&#xA;&#x9;if (this->m_rootConfiguration == nullptr)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;auto rootStateConfig = PSSM::Semantics::StateMachines::StateMachinesFactory::eInstance()->createStateConfiguration();&#xD;&#xA;&#x9;&#x9;rootStateConfig->setVertexActivation(stateActivation);&#xD;&#xA;&#x9;&#x9;rootStateConfig->setLevel(0);&#xD;&#xA;&#x9;&#x9;this->setRootConfiguration(rootStateConfig);&#xD;&#xA;&#x9;&#x9;return true;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return this->add(stateActivation);"/>
          </eAnnotations>
          <eParameters name="stateActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateActivation"/>
        </eOperations>
        <eOperations name="unregister" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Unregister the given StateActivation in the Configuration of its StateMachine as a StateConfiguration. This occurs when the StateActivation is exited.&#xD;&#xA;&#x9;// If the last remaining StateConfiguration is to be removed, the reference to it as the rootConfiguration must be reset.&#xD;&#xA;&#x9;// If the removal process is successful, all possibly deferred events related to that state activation are released.&#xD;&#xA;&#x9;if (this->m_rootConfiguration->getChildren()->empty())&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;stateActivation->releaseDeferredEvents();&#xD;&#xA;&#x9;&#x9;this->setRootConfiguration(nullptr);&#xD;&#xA;&#x9;&#x9;return true;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;else&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;bool removed = this->remove(stateActivation);&#xD;&#xA;&#x9;&#x9;if (removed) stateActivation->releaseDeferredEvents();&#xD;&#xA;&#x9;&#x9;return removed;&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="stateActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateActivation"/>
        </eOperations>
        <eOperations name="isStable" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean"/>
        <eOperations name="isActive" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// A vertex that is currently active is part of the state-machine configuration&#xD;&#xA;&#x9;/*boolean found = false;&#xD;&#xA;&#x9;Iterator&lt;Integer> levelsIterator = this.cartorgraphy.keySet().iterator();&#xD;&#xA;&#x9;while(!found &amp;&amp; levelsIterator.hasNext()){&#xD;&#xA;&#x9;&#x9;found = this.cartorgraphy.get(levelsIterator.next()).contains(activation);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return found;*/&#xD;&#xA;&#x9;return false;"/>
          </eAnnotations>
          <eParameters name="activation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"/>
        </eOperations>
        <eOperations name="remove" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return this->m_rootConfiguration->removeChild(vertexActivation);"/>
          </eAnnotations>
          <eParameters name="vertexActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"/>
        </eOperations>
        <eOperations name="add" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return this->m_rootConfiguration->addChild(activation);"/>
          </eAnnotations>
          <eParameters name="activation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="rootConfiguration"
            ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateConfiguration"
            eOpposite="#//Semantics/StateMachines/StateConfiguration/completeConfiguration"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="execution" ordered="false"
            lowerBound="1" eType="#//Semantics/StateMachines/StateMachineExecution"
            eOpposite="#//Semantics/StateMachines/StateMachineExecution/configuration"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="StateConfiguration">
        <eOperations name="getLevel" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Integer">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="return m_level;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getChildren" ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/StateConfiguration">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="true"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return m_children;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getParent" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateConfiguration">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return this.parent;&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getVertexActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate" value="return m_vertexActivation;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="setParent" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="this->setParent(stateConfiguration);"/>
          </eAnnotations>
          <eParameters name="stateConfiguration" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateConfiguration"/>
        </eOperations>
        <eOperations name="getContext" ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/VertexActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="/*List&lt;VertexActivation> context = new ArrayList&lt;VertexActivation>();&#xD;&#xA;&#x9;List&lt;VertexActivation> hierarchy = activation.getAscendingHierarchy();&#xD;&#xA;&#x9;int i = hierarchy.size();&#xD;&#xA;&#x9;int j = 0;&#xD;&#xA;&#x9;boolean found = false;&#xD;&#xA;&#x9;while(i >= 1 &amp;&amp; !found){&#xD;&#xA;&#x9;&#x9;while(j &lt; this.children.size() &amp;&amp; !found){&#xD;&#xA;&#x9;&#x9;&#x9;if(this.children.get(j).vertexActivation==hierarchy.get(i-1)){&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;found = true;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;context = hierarchy.subList(1, i);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;j++;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;j = 0;&#xD;&#xA;&#x9;&#x9;i--;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return context;*/&#xD;&#xA;&#x9;return nullptr;"/>
          </eAnnotations>
          <eParameters name="activation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"/>
        </eOperations>
        <eOperations name="removeChild" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return this->remove(activation, this->getContext(activation));"/>
          </eAnnotations>
          <eParameters name="activation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"/>
        </eOperations>
        <eOperations name="remove" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="/*boolean removed = false;&#xD;&#xA;&#x9;if(!context.isEmpty()){&#xD;&#xA;&#x9;&#x9;VertexActivation current = context.get(context.size()-1);&#xD;&#xA;&#x9;&#x9;StateConfiguration selectedStateConfiguration = null; &#xD;&#xA;&#x9;&#x9;int i = 0;&#xD;&#xA;&#x9;&#x9;while(i &lt; this.children.size() &amp;&amp; selectedStateConfiguration==null){&#xD;&#xA;&#x9;&#x9;&#x9;if(this.children.get(i).vertexActivation==current){&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;selectedStateConfiguration = this.children.get(i);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;i++;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;if(selectedStateConfiguration!=null){&#xD;&#xA;&#x9;&#x9;&#x9;removed = selectedStateConfiguration.remove(activation, context.subList(0, context.size()-1));&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}else{&#xD;&#xA;&#x9;&#x9;int i = 0;&#xD;&#xA;&#x9;&#x9;while(i &lt; this.children.size() &amp;&amp; !removed){&#xD;&#xA;&#x9;&#x9;&#x9;if(this.children.get(i).vertexActivation==activation){&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;this.completeConfiguration.deleteFromCartography(this.children.get(i));&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;this.children.remove(i);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;removed = true;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;i++;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return removed;*/&#xD;&#xA;&#xD;&#xA;&#x9;/*if (!context->empty())&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;auto currentVertexActivation = context->at(context->size()-1);&#xD;&#xA;&#x9;&#x9;std::shared_ptr&lt;StateConfiguration> selectedStateConfiguration;&#xD;&#xA;&#x9;&#x9;for (auto child : *m_children)&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;if (child->getVertexActivation() == currentVertexActivation)&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;selectedStateConfiguration = child;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;auto copiedContext = std::make_shared&lt;Bag&lt;PSSM::Semantics::StateMachines::VertexActivation>>(context->copy());&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;copiedContext->erase(context->at(context->size()-1));&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;selectedStateConfiguration->remove(activation, copiedContext);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;else&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;for (auto child : *m_children)&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;if (child->getVertexActivation() == activation)&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;m_completeConfiguration->remove(activation); // this.completeConfiguration.deleteFromCartography(this.children.get(i));&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;m_children->erase(child);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}*/"/>
          </eAnnotations>
          <eParameters name="activation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"/>
          <eParameters name="context" ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/VertexActivation"/>
        </eOperations>
        <eOperations name="addChild" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return this->add(activation, this->getContext(activation));"/>
          </eAnnotations>
          <eParameters name="activation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"/>
        </eOperations>
        <eOperations name="add" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="/*boolean added = false;&#xD;&#xA;&#x9;if(!context.isEmpty()){&#xD;&#xA;&#x9;&#x9;VertexActivation current = context.get(context.size()-1);&#xD;&#xA;&#x9;&#x9;StateConfiguration selectedStateConfiguration = null; &#xD;&#xA;&#x9;&#x9;int i = 0;&#xD;&#xA;&#x9;&#x9;while(i &lt; this.children.size() &amp;&amp; selectedStateConfiguration==null){&#xD;&#xA;&#x9;&#x9;&#x9;if(this.children.get(i).vertexActivation==current){&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;selectedStateConfiguration = this.children.get(i);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;i++;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;if(selectedStateConfiguration!=null){&#xD;&#xA;&#x9;&#x9;&#x9;added = selectedStateConfiguration.add(activation, context.subList(0, context.size()-1));&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}else{&#xD;&#xA;&#x9;&#x9;int i = 0;&#xD;&#xA;&#x9;&#x9;boolean alreadyAdded = false;&#xD;&#xA;&#x9;&#x9;while(i &lt; this.children.size() &amp;&amp; !alreadyAdded){&#xD;&#xA;&#x9;&#x9;&#x9;if(this.children.get(i).vertexActivation==activation){&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;alreadyAdded = true;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;i++;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;if(!alreadyAdded){&#xD;&#xA;&#x9;&#x9;&#x9;StateConfiguration newConfiguration = new StateConfiguration(activation);&#xD;&#xA;&#x9;&#x9;&#x9;newConfiguration.level = this.level + 1;&#xD;&#xA;&#x9;&#x9;&#x9;newConfiguration.completeConfiguration = this.completeConfiguration;&#xD;&#xA;&#x9;&#x9;&#x9;this.completeConfiguration.addToCartography(newConfiguration);&#xD;&#xA;&#x9;&#x9;&#x9;added = this.children.add(newConfiguration);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return added;*/&#xD;&#xA;&#xD;&#xA;&#x9;/*if (!context->empty())&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;auto currentVertexActivation = context->at(context->size()-1);&#xD;&#xA;&#x9;&#x9;std::shared_ptr&lt;StateConfiguration> selectedStateConfiguration;&#xD;&#xA;&#x9;&#x9;for (auto child : *m_children)&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;if (child->getVertexActivation() == currentVertexActivation)&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;selectedStateConfiguration = child;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;auto copiedContext = std::make_shared&lt;Bag&lt;PSSM::Semantics::StateMachines::VertexActivation>>(context->copy());&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;copiedContext->erase(context->at(context->size()-1));&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;selectedStateConfiguration->add(activation, copiedContext);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;else&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;bool alreadyAdded = false;&#xD;&#xA;&#x9;&#x9;for (auto child : *m_children)&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;if (child->getVertexActivation() == activation)&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;alreadyAdded = true;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;if (!alreadyAdded)&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;auto newConfiguration = std::make_shared&lt;StateConfiguration>(activation);&#xD;&#xA;&#x9;&#x9;&#x9;newConfiguration->setLevel(m_level+1);&#xD;&#xA;&#x9;&#x9;&#x9;newConfiguration->setCompleteConfiguration(m_completeConfiguration);&#xD;&#xA;&#x9;&#x9;&#x9;m_completeConfiguration->add(activation); //this.completeConfiguration.addToCartography(newConfiguration);&#xD;&#xA;&#x9;&#x9;&#x9;m_children->add(newConfiguration);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}*/"/>
          </eAnnotations>
          <eParameters name="activation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"/>
          <eParameters name="context" ordered="false" lowerBound="1" upperBound="-1"
              eType="#//Semantics/StateMachines/VertexActivation"/>
        </eOperations>
        <eOperations name="isActive" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean"/>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="level" ordered="false"
            lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Integer"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="vertexActivation" ordered="false"
            lowerBound="1" eType="#//Semantics/StateMachines/VertexActivation"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="children" ordered="false"
            upperBound="-1" eType="#//Semantics/StateMachines/StateConfiguration"
            containment="true"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="completeConfiguration"
            ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateMachineConfiguration"
            eOpposite="#//Semantics/StateMachines/StateMachineConfiguration/rootConfiguration"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="FinalStateActivation" eSuperTypes="#//Semantics/StateMachines/StateActivation">
        <eOperations name="enter">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// The enter routine of a FinalState consists of completing its RegionActivation's execution and clearing its history.&#xD;&#xA;&#x9;// If this RegionActivation is owned by a StateActivation, then remove this RegionActivation from its set of owned RegionActivations to complete.&#xD;&#xA;&#x9;// If all RegionActivations owned by that StateActivation have completed, then a CompletionEventOccurrence is generated for that StateActivation.&#xD;&#xA;&#x9;// As for a regular StateActivation, all parent Vertices must be entered beforehand until the least common ancestor of this StateActivation and the source StateActivation of the entering Transition is reached.&#xD;&#xA;&#x9;this->getThisVertexActivationPtr()->enter(enteringTransition, eventOccurrence, leastCommonAncestor);&#xD;&#xA;&#x9;if (std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::RegionActivation>(this->m_parent) != leastCommonAncestor) {&#xD;&#xA;&#x9;&#x9;if (auto parentVertexActivation = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::VertexActivation>(this->m_parent)) {&#xD;&#xA;&#x9;&#x9;&#x9;parentVertexActivation->enter(enteringTransition, eventOccurrence, leastCommonAncestor);&#xD;&#xA;&#x9;&#x9;}&#x9;&#x9;&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;auto owningRegionActivation = this->getOwningRegionActivation();&#xD;&#xA;&#x9;owningRegionActivation->setIsCompleted(true);&#xD;&#xA;&#x9;owningRegionActivation->setHistory(nullptr);&#xD;&#xA;&#xD;&#xA;&#x9;if (auto parentStateActivation = std::dynamic_pointer_cast&lt;StateActivation>(owningRegionActivation->getParent()))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;parentStateActivation->getRegionActivations()->erase(owningRegionActivation);&#xD;&#xA;&#x9;&#x9;if(parentStateActivation->hasCompleted())&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;parentStateActivation->notifyCompletion();&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="leastCommonAncestor" ordered="false" eType="#//Semantics/StateMachines/RegionActivation"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="ExternalTransitionActivation" eSuperTypes="#//Semantics/StateMachines/TransitionActivation"/>
      <eClassifiers xsi:type="ecore:EClass" name="InternalTransitionActivation" eSuperTypes="#//Semantics/StateMachines/TransitionActivation"/>
      <eClassifiers xsi:type="ecore:EClass" name="LocalTransitionActivation" eSuperTypes="#//Semantics/StateMachines/TransitionActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;PSSM/Semantics/StateMachines/impl/EntryPointPseudostateActivationImpl.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="getContainingState" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// The container of a local transition is determined in the following manner:&#xA;&#x9;// 1 - If the source vertex is an entry point then the containing state is the&#xA;&#x9;//     the state that has this entry point on its edge&#xA;&#x9;// 2 - Else in the case where the source contains the target then the containing&#xA;&#x9;//&#x9;   state is the source itself. Otherwise the source is the target&#xA;&#x9;std::shared_ptr&lt;Any> containingState; &#xA;&#x9;if (auto psActivation = dynamic_cast&lt;EntryPointPseudostateActivationImpl>(this->getSourceActivation()))&#xA;&#x9;{&#xA;&#x9;&#x9;containingState = StateActivation(this->getSourceActivation()->getParentVertexActivation());&#xA;&#x9;}&#xA;&#x9;else&#xA;&#x9;{&#xA;&#x9;&#x9;if (this->getSourceActivation()->getVertexActivation(Vertex(this->getTargetActivation()->getNode()))!=nullptr)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;containingState = StateActivation(this->getSourceActivation());&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;containingState = StateActivation(this->getTargetActivation());&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return containingState;&#xA;"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="EntryPointPseudostateActivation"
          eSuperTypes="#//Semantics/StateMachines/ConnectionPointActivation">
        <eOperations name="_enter" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// When an exit point is entered its owning state is entered. That state maybe located&#xA;// in a nested hierarchy which is not already active. Hence if the hierarchy is not&#xA;// already active then it is entered.&#xA;//super.enter(enteringTransition, eventOccurrence, null);&#xA;//VertexActivation vertexActivation = this.getParentVertexActivation();&#xA;//if(vertexActivation!=null){&#xA;//&#x9;vertexActivation.enter(enteringTransition, eventOccurrence, leastCommonAncestor);&#xA;//}&#xA;&#xA;&#x9;std::shared_ptr&lt;PSSM::Semantics::StateMachines::VertexActivation> vertexActivation = this->getParentVertexActivation();&#xA;&#x9;if (vertexActivation != nullptr)&#xA;&#x9;{&#xA;&#x9;&#x9;vertexActivation->enter(enteringTransition, eventOccurrence, leastCommonAncestor);&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="leastCommonAncestor" ordered="false" eType="#//Semantics/StateMachines/RegionActivation"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="ExitPointPseudostateActivation"
          eSuperTypes="#//Semantics/StateMachines/ConnectionPointActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="doNotGenerate"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="ChoicePseudostateActivation" eSuperTypes="#//Semantics/StateMachines/ConditionalPseudostateActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="doNotGenerate"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="ConditionalPseudostateActivation"
          abstract="true" eSuperTypes="#//Semantics/StateMachines/PseudostateActivation">
        <eOperations name="isElseTransition" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Determine if the given transition materialize the else branch of a conditional pseudo state.&#xA;// A transition materializes an else branch since it has a guard which specification is&#xA;// an Expression that has no operand(s) and whose symbol is &quot;else&quot;&#xA;boolean isElse = false;&#xA;if(transitionActivation!=null){&#xA;&#x9;Transition transition = (Transition)transitionActivation.getNode();&#xA;&#x9;if(transition.getGuard()!=null &amp;&amp; transition.getGuard().getSpecification() instanceof Expression){&#xA;&#x9;&#x9;Expression expression = (Expression) transition.getGuard().getSpecification();&#xA;&#x9;&#x9;isElse = expression.getOperands().isEmpty() &amp;&amp; expression.getSymbol() !=null &amp;&amp; expression.getSymbol().equals(ELSE_OPERATOR);&#xA;&#x9;}&#xA;}&#xA;return isElse;&#xA;"/>
          </eAnnotations>
          <eParameters name="transitionActivation" ordered="false" lowerBound="1"
              eType="#//Semantics/StateMachines/TransitionActivation"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="ForkPseudostateActivation" eSuperTypes="#//Semantics/StateMachines/PseudostateActivation">
        <eOperations name="_canPropagateExecution" ordered="false" lowerBound="1"
            eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Convenience method. Java does no allow a call to an explicit super class method. For documentation&#xA;// developpers must have a look to: VertexActivation::canPropagateExecution(...)&#xA;boolean propagate = true;&#xA;if(leastCommonAncestor != null){&#xA;&#x9;RegionActivation parentRegionActivation = this.getOwningRegionActivation();&#xA;&#x9;if(leastCommonAncestor!=parentRegionActivation){&#xA;&#x9;&#x9;VertexActivation vertexActivation = (VertexActivation) parentRegionActivation.getParent();&#xA;&#x9;&#x9;if(vertexActivation != null){&#xA;&#x9;&#x9;&#x9;propagate = vertexActivation.canPropagateExecution(enteringTransition, eventOccurrence, leastCommonAncestor);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;return propagate;&#xA;"/>
          </eAnnotations>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="leastCommonAncestor" ordered="false" eType="#//Semantics/StateMachines/RegionActivation"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="JoinPseudostateActivation" eSuperTypes="#//Semantics/StateMachines/PseudostateActivation">
        <eOperations name="_canPropagateExecution" ordered="false" lowerBound="1"
            eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Convenience method. Java does no allow a call to an explicit super class method. For documentation&#xA;// developpers must have a look to: VertexActivation::canPropagateExecution(...)&#xA;boolean propagate = true;&#xA;if(leastCommonAncestor != null){&#xA;&#x9;RegionActivation parentRegionActivation = this.getOwningRegionActivation();&#xA;&#x9;if(leastCommonAncestor!=parentRegionActivation){&#xA;&#x9;&#x9;VertexActivation vertexActivation = (VertexActivation) parentRegionActivation.getParent();&#xA;&#x9;&#x9;if(vertexActivation != null){&#xA;&#x9;&#x9;&#x9;propagate = vertexActivation.canPropagateExecution(enteringTransition, eventOccurrence, leastCommonAncestor);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;return propagate;&#xA;"/>
          </eAnnotations>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="leastCommonAncestor" ordered="false" eType="#//Semantics/StateMachines/RegionActivation"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="TerminatePseudostateActivation"
          eSuperTypes="#//Semantics/StateMachines/PseudostateActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="doNotGenerate"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CompletionEventOccurrence" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence">
        <eOperations name="match" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body"/>
          </eAnnotations>
          <eParameters name="trigger" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Trigger"/>
        </eOperations>
        <eOperations name="_register">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;this->setStateActivation(stateActivation);"/>
          </eAnnotations>
          <eParameters name="stateActivation" eType="#//Semantics/StateMachines/StateActivation"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="stateActivation" ordered="false"
            lowerBound="1" eType="#//Semantics/StateMachines/StateActivation"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="StateMachineEventAccepter" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventAccepter">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;PSSM/Semantics/StateMachines/StateActivation.hpp&quot;&#xD;&#xA;#include &quot;fUML/Semantics/Loci/Locus.hpp&quot;&#xD;&#xA;#include &quot;fUML/Semantics/Loci/ExecutionFactory.hpp&quot;&#xD;&#xA;#include &quot;fUML/Semantics/Loci/ChoiceStrategy.hpp&quot;&#xD;&#xA;#include &quot;fUML/Semantics/CommonBehavior/ObjectActivation.hpp&quot;&#xD;&#xA;#include &quot;fUML/Semantics/CommonBehavior/EventAccepter.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/DoActivityExecutionEventAccepter.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/CallEventOccurrence.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/CallEventExecution.hpp&quot;&#xD;&#xA;#include &quot;PSSM/Semantics/StateMachines/StateMachineConfiguration.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="match" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// There are two cases in which the state machine event accepter can match&#xD;&#xA;&#x9;// 1 - In the current state machine configuration the event can be deferred&#xD;&#xA;&#x9;// 2 - In the current state machine configuration the current event can trigger one or more transitions&#xD;&#xA;&#x9;return this->isDeferred(eventOccurrence) | this->isTriggering(eventOccurrence);"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="accept" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// When an event occurrence is accepted this marks the beginning of a new RTC step for&#xD;&#xA;&#x9;// the executed state-machine. The following set of actions takes place:&#xD;&#xA;&#x9;// 1 - The list of transition that can be fired using the given event occurrence is computed&#xD;&#xA;&#x9;// 2 - This list is organized as a different sub-set of transitions that can be fired. One of the&#xD;&#xA;&#x9;//     subset is chosen to be fired. Each transition fires **Concurrently**&#xD;&#xA;&#x9;// 3 - When the RTC step is about to complete a new event accepter for the state-machine&#xD;&#xA;&#x9;//     is registered at the waiting event accepter list handled by the object activation&#xD;&#xA;&#x9;// Note that there always is a single event accepter for a state-machine (this works differently&#xD;&#xA;&#x9;// than for activities).&#xD;&#xA;&#x9;/*if(this.isDeferred(eventOccurrence)){&#xD;&#xA;&#x9;&#x9;this.defer(eventOccurrence);&#xD;&#xA;&#x9;}else{&#xD;&#xA;&#x9;&#x9;List&lt;TransitionActivation> fireableTransitionActivations = this.select(eventOccurrence);&#xD;&#xA;&#x9;&#x9;if(!fireableTransitionActivations.isEmpty()){&#xD;&#xA;&#x9;&#x9;&#x9;for(Iterator&lt;TransitionActivation> fireableTransitionsIterator = fireableTransitionActivations.iterator(); fireableTransitionsIterator.hasNext();){&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;fireableTransitionsIterator.next().fire(eventOccurrence);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;// If the dispatched event was an CallEventOccurrence then check&#xD;&#xA;&#x9;// if the caller need to be released.&#xD;&#xA;&#x9;// FIXME: This moved on further updates to common behavior semantics&#xD;&#xA;&#x9;if(eventOccurrence instanceof CallEventOccurrence){&#xD;&#xA;&#x9;&#x9;CallEventOccurrence callEventOccurrence = (CallEventOccurrence) eventOccurrence;&#xD;&#xA;&#x9;&#x9;callEventOccurrence.execution.releaseCaller();&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;Object_ context = this.registrationContext.context;&#xD;&#xA;&#x9;if(context!=null &amp;&amp; context.objectActivation!=null){&#xD;&#xA;&#x9;&#x9;context.register(new StateMachineEventAccepter(this.registrationContext));&#xD;&#xA;&#x9;}*/&#xD;&#xA;&#xD;&#xA;&#x9;if (this->isDeferred(eventOccurrence))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;this->defer(eventOccurrence);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;else&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;auto fireableTransitionActivations = this->select(eventOccurrence);&#xD;&#xA;&#x9;&#x9;if (!fireableTransitionActivations->empty())&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;for (auto fireableTransitionActivation : *fireableTransitionActivations) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;fireableTransitionActivation->fire(eventOccurrence);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#x9;// If dispatched Event was an CallEventOccurrence, then check if caller needs to be released.&#xD;&#xA;&#x9;if (auto callEventOccurrence = std::dynamic_pointer_cast&lt;PSSM::Semantics::CommonBehavior::CallEventOccurrence>(eventOccurrence))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;callEventOccurrence->getExecution()->releaseCaller();&#xD;&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="select" ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/TransitionActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Find for the given configuration the set of transition that can fire.&#xD;&#xA;&#x9;return this->_select(eventOccurrence, this->m_registrationContext->getConfiguration()->getRootConfiguration());"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="_select" ordered="false" upperBound="-1" eType="#//Semantics/StateMachines/TransitionActivation">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Find all TransitionActivations that can fire on the given EventOccurrence.&#xD;&#xA;&#x9;// The set of TransitionActivations only contains those with the highest priority. In addition,&#xD;&#xA;&#x9;// no conflicting TransitionActivations are added to the set.&#xD;&#xA;&#x9;/*List&lt;TransitionActivation> selectedTransitions = new ArrayList&lt;TransitionActivation>();&#xD;&#xA;&#x9;for(int i = 0; i &lt; stateConfiguration.children.size(); i++){&#xD;&#xA;&#x9;&#x9;selectedTransitions.addAll(this._select(eventOccurrence, stateConfiguration.children.get(i)));&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;if(selectedTransitions.isEmpty() &amp;&amp; stateConfiguration.vertexActivation != null){&#xD;&#xA;&#x9;&#x9;for(int i = 0; i &lt; stateConfiguration.vertexActivation.getOutgoingTransitions().size(); i++){&#xD;&#xA;&#x9;&#x9;&#x9;TransitionActivation transitionActivation = stateConfiguration.vertexActivation.getOutgoingTransitions().get(i);&#xD;&#xA;&#x9;&#x9;&#x9;if(transitionActivation.canFireOn(eventOccurrence)){&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;selectedTransitions.add(transitionActivation);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;if(selectedTransitions.size() > 1){&#xD;&#xA;&#x9;&#x9;&#x9;ChoiceStrategy choiceStrategy = (ChoiceStrategy) this.registrationContext.locus.factory.getStrategy(&quot;choice&quot;);&#xD;&#xA;&#x9;&#x9;&#x9;TransitionActivation electedTransition = selectedTransitions.get(choiceStrategy.choose(selectedTransitions.size()) - 1);&#xD;&#xA;&#x9;&#x9;&#x9;selectedTransitions.clear();&#xD;&#xA;&#x9;&#x9;&#x9;selectedTransitions.add(electedTransition);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return selectedTransitions;*/&#xD;&#xA;&#xD;&#xA;&#x9;std::shared_ptr&lt;Bag&lt;PSSM::Semantics::StateMachines::TransitionActivation>> selectedTransitionActivations(new Bag&lt;PSSM::Semantics::StateMachines::TransitionActivation>());&#xD;&#xA;&#x9;for (auto child : *(stateConfiguration->getChildren()))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;selectedTransitionActivations->insert(*(this->_select(eventOccurrence, child)));&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;if (selectedTransitionActivations->empty() &amp;&amp; stateConfiguration->getVertexActivation() != nullptr)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;for (auto outgoingTransitionActivation : *(stateConfiguration->getVertexActivation()->getOutgoingTransitions()))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;if (outgoingTransitionActivation->canFireOn(eventOccurrence))&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;selectedTransitionActivations->add(outgoingTransitionActivation);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;&#x9;if (selectedTransitionActivations->size() > 1)&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;auto choiceStrategy = std::dynamic_pointer_cast&lt;fUML::Semantics::Loci::ChoiceStrategy>(this->m_registrationContext->getLocus()->getFactory()->getStrategy(&quot;choice&quot;));&#xD;&#xA;&#x9;&#x9;&#x9;auto chosenTransitionActivation = selectedTransitionActivations->at(choiceStrategy->choose(selectedTransitionActivations->size()-1));&#xD;&#xA;&#x9;&#x9;&#x9;selectedTransitionActivations->clear();&#xD;&#xA;&#x9;&#x9;&#x9;selectedTransitionActivations->add(chosenTransitionActivation);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;return selectedTransitionActivations;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="stateConfiguration" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateConfiguration"/>
        </eOperations>
        <eOperations name="isDeferred" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Determine if the dispatched event occurrence is deferred in the&#xD;&#xA;&#x9;// current state machine configuration. An event occurrence can only be deferred&#xD;&#xA;&#x9;// if the following conditions are fulfilled:&#xD;&#xA;&#x9;// 1 - One active state in the hierarchy declares the event types as being deferred.&#xD;&#xA;&#x9;// 2 - No transitions (ready to fire) with a higher priority than the deferring state&#xD;&#xA;&#x9;//     could be found.&#xD;&#xA;&#x9;// 3 - It does not exist any running doActivity having already registered an accepter&#xD;&#xA;&#x9;//     for the given event occurrence&#xD;&#xA;&#x9;/*boolean deferred = this._isDeferred(eventOccurrence, this.registrationContext.getConfiguration().rootConfiguration);&#xD;&#xA;&#x9;if(deferred){&#xD;&#xA;&#x9;&#x9;Object_ context = this.registrationContext.context;&#xD;&#xA;&#x9;&#x9;if(context != null &amp;&amp; context.objectActivation != null){&#xD;&#xA;&#x9;&#x9;&#x9;int  i = 1;&#xD;&#xA;&#x9;&#x9;&#x9;while(deferred &amp;&amp; i &lt;= context.objectActivation.waitingEventAccepters.size()){&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;EventAccepter currentEventAccepter = context.objectActivation.waitingEventAccepters.get(i - 1);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if(currentEventAccepter != this &#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&amp;&amp; currentEventAccepter instanceof DoActivityExecutionEventAccepter&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&amp;&amp; currentEventAccepter.match(eventOccurrence)){&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;deferred = false;;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;i++;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return deferred;*/&#xD;&#xA;&#xD;&#xA;&#x9;bool deferred = this->_isDeferred(eventOccurrence, this->m_registrationContext->getConfiguration()->getRootConfiguration());&#xD;&#xA;&#x9;if (deferred) &#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;auto context = this->m_registrationContext;&#xD;&#xA;&#x9;&#x9;if (context != nullptr &amp;&amp; context->getObjectActivation() != nullptr)&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;for (auto waitingEventAccepter : *(context->getObjectActivation()->getWaitingEventAccepters()))&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (waitingEventAccepter != std::dynamic_pointer_cast&lt;fUML::Semantics::CommonBehavior::EventAccepter>(this->getThisStateMachineEventAccepterPtr()) &amp;&amp; waitingEventAccepter->match(eventOccurrence)) &#xD;&#xA;&#x9;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (auto doActivityExecutionEventAccepter = std::dynamic_pointer_cast&lt;PSSM::Semantics::StateMachines::DoActivityExecutionEventAccepter>(waitingEventAccepter))&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;deferred = false;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return deferred;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="_isDeferred" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Determine if the given state configuration is capable of deferring the given event occurrence.&#xD;&#xA;&#x9;/*int i = 0;&#xD;&#xA;&#x9;boolean deferred = false;&#xD;&#xA;&#x9;while(!deferred &amp;&amp; i &lt; stateConfiguration.children.size()){&#xD;&#xA;&#x9;&#x9;deferred = this._isDeferred(eventOccurrence, stateConfiguration.children.get(i));&#xD;&#xA;&#x9;&#x9;i++;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;if(!deferred &amp;&amp; &#xD;&#xA;&#x9;&#x9;&#x9;stateConfiguration.vertexActivation != null &amp;&amp;&#xD;&#xA;&#x9;&#x9;&#x9;((StateActivation)stateConfiguration.vertexActivation).canDefer(eventOccurrence)){&#xD;&#xA;&#x9;&#x9;if(this._select(eventOccurrence, stateConfiguration).isEmpty()){&#xD;&#xA;&#x9;&#x9;&#x9;deferred = true;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return deferred;*/&#xD;&#xA;&#xD;&#xA;&#x9;bool deferred = false;&#xD;&#xA;&#x9;int i = 0;&#xD;&#xA;&#x9;while (!deferred &amp;&amp; i &lt; int(stateConfiguration->getChildren()->size()))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;deferred = this->_isDeferred(eventOccurrence, stateConfiguration->getChildren()->at(i));&#xD;&#xA;&#x9;&#x9;i++;&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;if (!deferred)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (auto stateActivation = std::dynamic_pointer_cast&lt;StateActivation>(stateConfiguration->getVertexActivation()))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;if (stateActivation->canDefer(eventOccurrence) &amp;&amp; this->_select(eventOccurrence, stateConfiguration)->empty())&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;deferred = true;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return deferred;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="stateConfiguration" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateConfiguration"/>
        </eOperations>
        <eOperations name="defer" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Defers the given event occurrence. A deferred event occurrence is registered in&#xD;&#xA;&#x9;// the deferred event pool. This latter refers to the deferred event as well as to the&#xD;&#xA;&#x9;// the deferring state.&#xD;&#xA;&#x9;return this->_defer(eventOccurrence, this->m_registrationContext->getConfiguration()->getRootConfiguration());"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="_defer" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Defers the given event occurrence in the context of the given state configuration.&#xD;&#xA;&#x9;/*int i = 0;&#xD;&#xA;&#x9;boolean deferred = false;&#xD;&#xA;&#x9;while(!deferred &amp;&amp; i &lt; stateConfiguration.children.size()){&#xD;&#xA;&#x9;&#x9;deferred = this._defer(eventOccurrence, stateConfiguration.children.get(i));&#xD;&#xA;&#x9;&#x9;i++;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;if(!deferred &amp;&amp;&#xD;&#xA;&#x9;&#x9;&#x9;stateConfiguration.vertexActivation != null &amp;&amp;&#xD;&#xA;&#x9;&#x9;&#x9;((StateActivation)stateConfiguration.vertexActivation).canDefer(eventOccurrence)){&#xD;&#xA;&#x9;&#x9;((StateActivation)stateConfiguration.vertexActivation).defer(eventOccurrence);&#xD;&#xA;&#x9;&#x9;deferred = true;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return deferred;*/&#xD;&#xA;&#xD;&#xA;&#x9;bool deferred = false;&#xD;&#xA;&#x9;for (auto child : *(stateConfiguration->getChildren()))&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;deferred = this->_defer(eventOccurrence, child);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;if (!deferred &amp;&amp; stateConfiguration->getVertexActivation() != nullptr)&#xD;&#xA;&#x9;{&#xD;&#xA;&#x9;&#x9;if (auto stateActivation = std::dynamic_pointer_cast&lt;StateActivation>(stateConfiguration->getVertexActivation()))&#xD;&#xA;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;if (stateActivation->canDefer(eventOccurrence))&#xD;&#xA;&#x9;&#x9;&#x9;{&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;stateActivation->defer(eventOccurrence);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;deferred = true;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return deferred;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="stateConfiguration" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateConfiguration"/>
        </eOperations>
        <eOperations name="isTriggering" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Returns true when one or more transition are ready to be fired using this event&#xD;&#xA;&#x9;// occurrence; false otherwise.&#xD;&#xA;&#x9;return !this->select(eventOccurrence)->empty();"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="registrationContext"
            ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateMachineExecution"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="DoActivityExecutionEventAccepter">
        <eOperations name="match" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Simply delegates to the match operation of the encapsulated accepter.&#xA;return this.encapsulatedAccepter.match(eventOccurrence);&#xA;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="accept" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// The event accepted through the state-machine event pool leads&#xA;// to the triggering of a RTC step in the context of the doActivity.&#xA;// As this needs to be realized the execution thread of the doActivity&#xA;// the accepted event occurrence is registered at the event pool of the&#xA;// DoActivityContextObjectActivation. This will trigger a new RTC step&#xA;// that will effectively be realized in the DoActivityContextObject and&#xA;// not in the State Machine context.&#xA;this.context.objectActivation.eventPool.add(eventOccurrence);&#xA;this.context.objectActivation._send(new ArrivalSignal());&#xA;"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="context" ordered="false"
            lowerBound="1" eType="#//Semantics/StateMachines/DoActivityContextObject"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="encapsulatedAccepter"
            ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventAccepter"
            containment="true"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="DoActivityContextObjectActivation">
        <eOperations name="dispatchNextEvent" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// The dispatching behaves exactly the same at it was specified in fUML.&#xA;// In addition to this behavior the dispatch sequence of an object activation&#xA;// for a DoActivityContextObject has the capacity to notify the state having&#xA;// triggered if the executed doActivity has completed. The completion of a&#xA;// do activity is determined based on the absence of any registered event&#xA;// accepter after the current step.&#xA;super.dispatchNextEvent();&#xA;if(this.waitingEventAccepters.size() == 0){&#xA;&#x9;DoActivityContextObject doActivityObject = (DoActivityContextObject)this.object;&#xA;&#x9;if(doActivityObject.owner!=null){&#xA;&#x9;&#x9;doActivityObject.owner.isDoActivityCompleted = true;&#xA;&#x9;&#x9;if(doActivityObject.owner.hasCompleted()){&#xA;&#x9;&#x9;&#x9;doActivityObject.owner.notifyCompletion();&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="startBehavior" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// The expected classifier is the doActivity behavior. The doActivity&#xA;// behavior is executed as if it was the classifier of a class typing&#xA;// the doActivity context object. It only exists one doActivity executed&#xA;// as a classifier behavior for a DoActivityContextObject.&#xA;if(classifier != null &#xA;&#x9;&amp;&amp; classifier instanceof Behavior&#xA;&#x9;&amp;&amp; this.classifierBehaviorInvocations.isEmpty()){&#xA;&#x9;ClassifierBehaviorInvocationEventAccepter newInvocation = new ClassifierBehaviorInvocationEventAccepter();&#xA;&#x9;newInvocation.objectActivation = this;&#xA;&#x9;newInvocation.classifier = classifier;&#xA;&#x9;Execution doActivityExecution = this.object.locus.factory.createExecution((Behavior)classifier, this.object); &#xA;&#x9;if(inputs != null){&#xA;&#x9;&#x9;for(int i = 0; i &lt; inputs.size(); i++){&#xA;&#x9;&#x9;&#x9;doActivityExecution.setParameterValue(inputs.get(i));&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;newInvocation.execution = doActivityExecution;&#xA;&#x9;this.classifierBehaviorInvocations.add(newInvocation);&#xA;&#x9;this.register(newInvocation);&#xA;&#x9;InvocationEventOccurrence invocationEventOccurrence = new InvocationEventOccurrence();&#xA;&#x9;invocationEventOccurrence.execution = newInvocation.execution;&#xA;&#x9;this.eventPool.add(invocationEventOccurrence);&#xA;&#x9;this._send(new ArrivalSignal());&#xA;}&#xA;"/>
          </eAnnotations>
          <eParameters name="classifier" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class"/>
          <eParameters name="inputs" ordered="false" upperBound="-1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/ParameterValue"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="HistoryPseudostateActivation" abstract="true"
          eSuperTypes="#//Semantics/StateMachines/PseudostateActivation">
        <eOperations name="hasDefaultTransition" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Determine if the history pseudo-state activation has default transition.&#xA;// Returns true if it has one, false otherwise&#xA;boolean defaultTransition = false;&#xA;if(this.outgoingTransitionActivations.size()==1){&#xA;&#x9;defaultTransition = true;&#xA;}&#xA;return defaultTransition;&#xA;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="restore" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Restore the state. Restoring a state consists in :&#xA;// 1. Registering the state to the state-machine configuration&#xA;// 2. Complete the state if needs to be completed&#xA;// 3. If the state cannot be completed then execute its entry and its doActivity. Finally,&#xA;//    if it has regions then these regions are restored (in paralell).&#xA;State state = (State) stateActivation.getNode();&#xA;stateActivation.status = StateMetadata.ACTIVE;&#xA;StateMachineExecution smExecution = (StateMachineExecution)this.getStateMachineExecution();&#xA;smExecution.getConfiguration().register(stateActivation);&#xA;stateActivation.isEntryCompleted = state.getEntry() == null;&#xA;stateActivation.isDoActivityCompleted = state.getDoActivity() == null;&#xA;stateActivation.isExitCompleted = state.getExit() == null;&#xA;if(stateActivation.hasCompleted()){&#xA;&#x9;stateActivation.notifyCompletion();&#xA;}else{&#xA;&#x9;stateActivation.tryExecuteEntry(eventOccurrence);&#xA;&#x9;stateActivation.tryInvokeDoActivity(eventOccurrence);&#xA;&#x9;for(Iterator&lt;RegionActivation> regionActivationsIterator = stateActivation.regionActivation.iterator(); regionActivationsIterator.hasNext();){&#xA;&#x9;&#x9;this.restore(regionActivationsIterator.next(), enteringTransition, eventOccurrence);&#xA;&#x9;}&#xA;}&#xA;"/>
          </eAnnotations>
          <eParameters name="stateActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateActivation"/>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="restore" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="regionActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/RegionActivation"/>
          <eParameters name="enteringTransition" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/TransitionActivation"/>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="JunctionPseudostateActivation" eSuperTypes="#//Semantics/StateMachines/ConditionalPseudostateActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="doNotGenerate"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="DeepHistoryPseudostateActivation"
          eSuperTypes="#//Semantics/StateMachines/HistoryPseudostateActivation">
        <eOperations name="canRestore" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/uml2/5.0.0/Types#//Boolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// A state activation can only be restored if it is directly or indirectly&#xA;// by the region containing the history state.&#xA;boolean canRestore = false;&#xA;if(stateActivation != null){&#xA;&#x9;RegionActivation historyRegion = (RegionActivation) this.getParent(); &#xA;&#x9;if(historyRegion.getVertexActivation((Vertex)stateActivation.getNode()) != null){&#xA;&#x9;&#x9;canRestore = true;&#xA;&#x9;}&#xA;}&#xA;return canRestore;&#xA;"/>
          </eAnnotations>
          <eParameters name="stateActivation" ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateActivation"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="ShallowHistoryPseudostateActivation"
          eSuperTypes="#//Semantics/StateMachines/HistoryPseudostateActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="doNotGenerate"/>
        </eAnnotations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="DeferredEventOccurrence" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="//#include &quot;fUML::EventOccurrence.hpp&quot;&#xA;//#include &quot;fUML::FUMLFactory.hpp&quot;&#xA;"/>
        </eAnnotations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="constrainingStateActivation"
            ordered="false" lowerBound="1" eType="#//Semantics/StateMachines/StateActivation"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="deferredEventOccurrence"
            ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="Loci" nsURI="http:///PSSM/Semantics/Loci.ecore" nsPrefix="PSSM.Semantics.Loci">
      <eClassifiers xsi:type="ecore:EClass" name="SM_ExecutionFactory" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/Loci/ExecutionFactory">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;fUML/FUMLFactory.hpp&quot;&#xA;#include &quot;uml/StateMachine.hpp&quot;&#xA;#include &quot;uml/Pseudostate.hpp&quot;&#xA;#include &quot;PSSM/Semantics/StateMachines/StateMachineExecution.hpp&quot;&#xA;#include &quot;uml/State.hpp&quot;&#xA;#include &quot;uml/FinalState.hpp&quot;&#xA;#include &quot;uml/OpaqueExpression.hpp&quot;&#xA;#include &quot;uml/ReadSelfAction.hpp&quot;&#xA;#include &quot;uml/Transition.hpp&quot;&#xA;#include &quot;uml/Region.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="instantiateVisitor" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Loci/SemanticVisitor">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="std::shared_ptr&lt;fUML::Semantics::Loci::SemanticVisitor> visitor = nullptr;&#xD;&#xA;&#xD;&#xA;&#x9;std::shared_ptr&lt;uml::StateMachine> is_sm = std::dynamic_pointer_cast&lt;uml::StateMachine>(element);&#xD;&#xA;&#x9;std::shared_ptr&lt;uml::Pseudostate> is_pseudoState = std::dynamic_pointer_cast&lt;uml::Pseudostate>(element);&#xD;&#xA;&#x9;std::shared_ptr&lt;uml::State> is_state = std::dynamic_pointer_cast&lt;uml::State>(element);&#xD;&#xA;&#x9;std::shared_ptr&lt;uml::FinalState> is_final_state = std::dynamic_pointer_cast&lt;uml::FinalState>(element);&#xD;&#xA;&#x9;std::shared_ptr&lt;uml::Transition> is_transition = std::dynamic_pointer_cast&lt;uml::Transition>(element);&#xD;&#xA;&#x9;std::shared_ptr&lt;uml::Region> is_region = std::dynamic_pointer_cast&lt;uml::Region>(element);&#xD;&#xA;&#x9;std::shared_ptr&lt;uml::OpaqueExpression> is_opaque_expression = std::dynamic_pointer_cast&lt;uml::OpaqueExpression>(element);&#xD;&#xA;&#x9;std::shared_ptr&lt;uml::ReadSelfAction> is_read_self_action = std::dynamic_pointer_cast &lt;uml::ReadSelfAction>(element);&#xD;&#xA;&#xD;&#xA;&#x9;if(is_sm != nullptr) {&#xD;&#xA;&#x9;&#x9;//visitor = new PSSM::Semantics::StateMachines::StateMachineExecution()&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;else if(is_pseudoState != nullptr) {&#xD;&#xA;&#x9;&#x9;std::shared_ptr&lt;uml::Pseudostate> pseudostate = is_pseudoState;&#xD;&#xA;//&#x9;&#x9;switch(pseudostate->getKind()){&#xD;&#xA;//&#x9;&#x9;&#x9;case uml::PseudostateKind::INITIAL: visitor = new PSSM::Semantics::StateMachines::InitialPseudostateActivation(); break;&#xD;&#xA;//&#x9;&#x9;&#x9;case uml::PseudostateKind::ENTRYPOINT:&#xD;&#xA;//&#x9;&#x9;&#x9;case uml::PseudostateKind::EXITPOINT:&#xD;&#xA;//&#x9;&#x9;&#x9;case uml::PseudostateKind::CHOICE:&#xD;&#xA;//&#x9;&#x9;&#x9;case uml::PseudostateKind::FORK:&#xD;&#xA;//&#x9;&#x9;&#x9;case uml::PseudostateKind::JOIN:&#xD;&#xA;//&#x9;&#x9;&#x9;case uml::PseudostateKind::TERMINATE:&#xD;&#xA;//&#x9;&#x9;&#x9;case uml::PseudostateKind::DEEPHISTORY:&#xD;&#xA;//&#x9;&#x9;&#x9;case uml::PseudostateKind::SHALLOWHISTORY:&#xD;&#xA;//&#x9;&#x9;&#x9;case uml::PseudostateKind::JUNCTION:&#xD;&#xA;//&#x9;&#x9;}&#xD;&#xA;&#x9;} else if(is_state != nullptr) {&#xD;&#xA;//&#x9;&#x9;if(is_final_state != nullptr){&#xD;&#xA;//&#x9;&#x9;&#x9;visitor = new PSSM::Semantics::StateMachines::FinalStateActivation();&#xD;&#xA;//&#x9;&#x9;} else {&#xD;&#xA;//&#x9;&#x9;&#x9;visitor = new PSSM::Semantics::StateMachines::StateActivation();&#xD;&#xA;//&#x9;&#x9;}&#xD;&#xA;&#x9;} else if (is_transition != nullptr) {&#xD;&#xA;&#x9;&#x9;std::shared_ptr&lt;uml::Transition> transition = is_transition;&#xD;&#xA;//&#x9;&#x9;switch(transition->getKind()){&#xD;&#xA;//&#x9;&#x9;&#x9;case uml::TransitionKind::EXTERNAL:&#xD;&#xA;//&#x9;&#x9;&#x9;case uml::TransitionKind::INTERNAL:&#xD;&#xA;//&#x9;&#x9;&#x9;case uml::TransitionKind::LOCAL:&#xD;&#xA;//&#x9;&#x9;}&#xD;&#xA;&#x9;} else if(is_region != nullptr) {&#xD;&#xA;&#x9;&#x9;//visitor = new PSSM::Semantics::StateMachines::RegionActivation();&#xD;&#xA;&#x9;} else if(is_opaque_expression != nullptr) {&#xD;&#xA;&#x9;&#x9;//visitor = new PSSM::Semantics::Values::SM_OpaqueExpressionEvaluation();&#xD;&#xA;&#x9;} else if(is_read_self_action) {&#xD;&#xA;&#x9;&#x9;//visitor = new PSSM::Semantics::Actions::SM_ReadSelfActionActivation();&#xD;&#xA;&#x9;} else {&#xD;&#xA;&#x9;&#x9;visitor = this->instantiateVisitor(element);&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;return visitor;&#xD;&#xA;//SemanticVisitor visitor = null ;&#xD;&#xA;//if(element instanceof StateMachine){&#xD;&#xA;//&#x9;visitor = new StateMachineExecution();&#xD;&#xA;//}else if (element instanceof Pseudostate) {&#xD;&#xA;//&#x9;Pseudostate pseudostate = (Pseudostate) element;&#xD;&#xA;//&#x9;switch(pseudostate.getKind()){&#xD;&#xA;//&#x9;&#x9;case INITIAL_LITERAL: visitor = new InitialPseudostateActivation(); break;&#xD;&#xA;//&#x9;&#x9;case ENTRY_POINT_LITERAL: visitor = new EntryPointPseudostateActivation(); break;&#xD;&#xA;//&#x9;&#x9;case EXIT_POINT_LITERAL: visitor = new ExitPointPseudostateActivation(); break;&#xD;&#xA;//&#x9;&#x9;case CHOICE_LITERAL: visitor = new ChoicePseudostateActivation(); break;&#xD;&#xA;//&#x9;&#x9;case FORK_LITERAL: visitor = new ForkPseudostateActivation(); break;&#xD;&#xA;//&#x9;&#x9;case JOIN_LITERAL: visitor = new JoinPseudostateActivation(); break;&#xD;&#xA;//&#x9;&#x9;case TERMINATE_LITERAL: visitor = new TerminatePseudostateActivation(); break;&#xD;&#xA;//&#x9;&#x9;case DEEP_HISTORY_LITERAL: visitor = new DeepHistoryPseudostateActivation(); break;&#xD;&#xA;//&#x9;&#x9;case SHALLOW_HISTORY_LITERAL: visitor = new ShallowHistoryPseudostateActivation(); break;&#xD;&#xA;//&#x9;&#x9;case JUNCTION_LITERAL: visitor = new JunctionPseudostateActivation(); break;&#xD;&#xA;//&#x9;}&#xD;&#xA;//}else if (element instanceof State) {&#xD;&#xA;//&#x9;if(element instanceof FinalState){&#xD;&#xA;//&#x9;&#x9;visitor = new FinalStateActivation();&#xD;&#xA;//&#x9;}else{&#xD;&#xA;//&#x9;&#x9;visitor = new StateActivation() ;&#xD;&#xA;//&#x9;}&#xD;&#xA;//}else if (element instanceof Transition) {&#xD;&#xA;//&#x9;Transition transition = (Transition) element;&#xD;&#xA;//&#x9;switch(transition.getKind()){&#xD;&#xA;//&#x9;&#x9;case EXTERNAL_LITERAL: visitor = new ExternalTransitionActivation(); break;&#xD;&#xA;//&#x9;&#x9;case INTERNAL_LITERAL: visitor = new InternalTransitionActivation(); break;&#xD;&#xA;//&#x9;&#x9;case LOCAL_LITERAL: visitor = new LocalTransitionActivation(); break;&#xD;&#xA;//&#x9;}&#xD;&#xA;//}else if (element instanceof Region) {&#xD;&#xA;//&#x9;visitor = new RegionActivation();&#xD;&#xA;//}else if(element instanceof OpaqueExpression) {&#xD;&#xA;//&#x9;visitor = new SM_OpaqueExpressionEvaluation();&#xD;&#xA;//}else if(element instanceof ReadSelfAction){&#xD;&#xA;//&#x9;visitor = new SM_ReadSelfActionActivation();&#xD;&#xA;//}else {&#xD;&#xA;//&#x9;visitor = super.instantiateVisitor(element);&#xD;&#xA;//}&#xD;&#xA;//return visitor;"/>
          </eAnnotations>
          <eParameters name="element" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Element"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="SM_Locus" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/Loci/Locus">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="&#xA;#include &lt;algorithm>&#xA;#include &quot;uml/Classifier.hpp&quot;&#xA;#include &quot;uml/Behavior.hpp&quot;&#xA;#include &quot;uml/Class.hpp&quot;&#xA;#include &quot;fUML/FUMLFactory.hpp&quot;&#xA;#include &quot;fUML/Semantics/Loci/ExecutionFactory.hpp&quot;&#xA;#include &quot;fUML/Semantics/Loci/Executor.hpp&quot;&#xA;#include &quot;PSSM/MDE4CPP_Extensions/PSSM_Object.hpp&quot;&#xA;#include &quot;fUML/Semantics/CommonBehavior/Execution.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="instantiate" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//MDE4CPP_Extensions/FUML_Object">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="documentation" value="**This method is implemented in every model-specific locus**"/>
            <details key="body" value="/*std::shared_ptr&lt;SM_Object> object = nullptr;&#xA;&#x9;std::shared_ptr&lt;uml::Behavior> behavior = std::dynamic_pointer_cast&lt;uml::Behavior>(type);&#xA;&#x9;if(behavior != nullptr)&#xA;&#x9;{&#xA;&#x9;&#x9;std::shared_ptr&lt;SM_Object>  context = nullptr;&#xA;&#x9;&#x9;object = std::dynamic_pointer_cast&lt;SM_Object>(this->getFactory()->createExecution(behavior, nullptr));&#xA;&#x9;}&#xA;&#x9;else&#xA;&#x9;{&#xA;&#x9;&#x9;object = PSSMFactory::eInstance()->createSM_Object();&#xA;&#x9;&#x9;object->getTypes()->push_back(type);&#xA;&#x9;&#x9;object->createFeatureValues();&#xA;&#x9;&#x9;//this->add(object);&#xA;&#x9;}&#xA;&#xA;&#x9;return object;*/&#xA;&#xA;&#x9;/*&#xA;&#x9; * This method is implemented in every model-specific locus&#xA;&#x9; */&#xA;&#xA;&#x9;return nullptr;"/>
          </eAnnotations>
          <eParameters name="type" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class"/>
        </eOperations>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="Actions" nsURI="http:///PSSM/Semantics/Actions.ecore" nsPrefix="PSSM.Semantics.Actions">
      <eClassifiers xsi:type="ecore:EClass" name="SM_ReadSelfActionActivation">
        <eOperations name="getExecutionContext" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//MDE4CPP_Extensions/FUML_Object">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// The context object can be a DoActivityContextObject. A DoActivityContextObject&#xD;&#xA;&#x9;// is the execution context of a doActivity behavior executed on its own thread of&#xD;&#xA;&#x9;// execution. It references the context object from which the doActivity was invoked.&#xD;&#xA;&#x9;// This context may contains features (e.g. operations, properties) that may be manipulated&#xD;&#xA;&#x9;// by the doActivity. To enable this, in this situation the ReadSelfAction must resolve&#xD;&#xA;&#x9;// to the context of the DoActivityContextObject.&#xD;&#xA;&#x9;/*Object_ context = super.getExecutionContext();&#xD;&#xA;&#x9;if(context instanceof DoActivityContextObject){&#xD;&#xA;&#x9;&#x9;context = ((DoActivityContextObject)context).context;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return context;*/&#xD;&#xA;&#x9;return nullptr;"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
    </eSubpackages>
  </eSubpackages>
  <eSubpackages name="MDE4CPP_Extensions" nsPrefix="PSSM_Semantics.Semantics.MDE4CPP_Extensions">
    <eClassifiers xsi:type="ecore:EClass" name="PSSM_Object" abstract="true" eSuperTypes="../../fuml/model/fUML.ecore#//MDE4CPP_Extensions/FUML_Object">
      <eAnnotations source="MDE4CPP_Substitutes" references="../../fuml/model/fUML.ecore#//Semantics/StructuredClassifiers/Object">
        <details key="doc" value="This class provides an interface defining fUML-specific functionality of PSSM::Semantics::StructuredClassifiers::SM_Object&#xD;&#xA;to generated UML model classes within MDE4CPP. Thus, it can be understood as a substitution of PSSM::Semantics::StructuredClassifiers::SM_Object"/>
      </eAnnotations>
      <eAnnotations source="http://tu-ilmenau.de/see/codegen">
        <details key="implIncludes" value="#include &quot;fUML/FUMLFactory.hpp&quot;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/CommonBehaviorFactory.hpp&quot;&#xA;#include &quot;PSSM/Semantics/CommonBehavior/SM_ObjectActivation.hpp&quot;"/>
      </eAnnotations>
      <eOperations name="startBehavior" ordered="false" lowerBound="1">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="body" value="// The behavior captured here is almost identical to the one provide by Object_.&#xA;&#x9;// Instead of using a simple ObjectActivation we use a StateMachineObjectActivation.&#xA;&#x9;// This specialized kind of ObjectActivation allows the registering of completion events.&#xA;&#x9;//if (this.objectActivation == null) {&#xA;&#x9;//&#x9;this.objectActivation = new SM_ObjectActivation();&#xA;&#x9;//&#x9;this.objectActivation.object = this;&#xA;&#x9;//}&#xA;&#x9;//this.objectActivation.startBehavior(classifier, inputs);&#xA;&#xA;&#x9;if(this->getObjectActivation() == nullptr)&#xA;    {&#xA;        this->setObjectActivation(std::dynamic_pointer_cast&lt;PSSM::Semantics::CommonBehavior::SM_ObjectActivation>(PSSM::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createSM_ObjectActivation()));&#xA;        //this->getObjectActivation()->setObject(getThisObjectPtr());&#xA;    }&#xA;&#xA;    this->getObjectActivation()->startBehavior(classifier, inputs);"/>
        </eAnnotations>
        <eParameters name="classifier" ordered="false" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class"/>
        <eParameters name="inputs" ordered="false" upperBound="-1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/ParameterValue"/>
      </eOperations>
      <eOperations name="destroy" ordered="false" lowerBound="1">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="body" value="// In addition to realize the normal process of stopping the object activation&#xD;&#xA;// as well as removing the current object from the locus, this destruction phase&#xD;&#xA;// also implies removal of all events remaining in the pool. This prevents the&#xD;&#xA;// dispatch loop to actually get the next event (even if at this step there is no&#xD;&#xA;// chance to match an accepter) whereas the current object is not anymore registered.&#xD;&#xA;// in the Locus.&#xD;&#xA;if(this->getObjectActivation() != nullptr)&#xD;&#xA;    {&#xD;&#xA;    &#x9;this->getObjectActivation()->stop();&#xD;&#xA;    &#x9;this->getObjectActivation()->getEventPool()->clear();&#xD;&#xA;    &#x9;this->setObjectActivation(nullptr);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    this->getTypes()->clear();&#xD;&#xA;    //ExtensionalValueImpl::destroy();"/>
        </eAnnotations>
      </eOperations>
    </eClassifiers>
  </eSubpackages>
</ecore:EPackage>
