[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */]
[module generateExecutionGradleFiles('http://www.eclipse.org/uml2/5.0.0/UML')]

[import fUML4CPP::generator::main::build_files::build_files_helper /]

[import UML4CPP::generator::main::helpers::nameHelper /]
[import UML4CPP::generator::main::profiles::uml4CPPProfileHelper /]


[template public generateExecutionGradleFiles(aPackage : Package) { packageName : String = getPackageName(); execPackageName : String = getPackageName().concat('Exec'); }]
[comment ------------------------------------------------------------------- /]
[comment gradle file for build command                                       /]
[comment ------------------------------------------------------------------- /]
[file ('../build.gradle', false, 'UTF-8')]
// DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN
// @generator: fuml4cpp::generator::main::generateExecutionBuildFile

description 'Build tasks for project: [packageName/]'

task build[packageName.toUpperFirst()/]() {
	group '[packageName/]'
	description 'build [packageName/]'

	dependsOn project.tasks.getByPath('model:generate[packageName.toUpperFirst()/]')
	dependsOn project.tasks.getByPath('src_gen:compile[packageName.toUpperFirst()/]')
[if(aPackage.hasMainBehavior())]
	dependsOn project.tasks.getByPath('application:compileApplicationFor[packageName.toUpperFirst()/]')
[/if]
[for (packName : String | aPackage.metaModelLibrariesNames()->reject(name : String | aPackage.getAllSubPackageNames()->includes(name))) ? (not(packName = aPackage.getPackageName()))]
	dependsOn getRootProject().getTasksByName('build[packName.toUpperFirst()/]', true)
[/for]
}

tasks.getByPath('src_gen:compile[packageName.toUpperFirst()/]').mustRunAfter tasks.getByPath('model:generate[packageName.toUpperFirst()/]')
[/file]

[comment ------------------------------------------------------------------- /]
[comment gradle file for generate command                                    /]
[comment ------------------------------------------------------------------- /]
[file ('../model/build.gradle', false, 'UTF-8')]
// DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN
// @generator: fuml4cpp::generator::main::generateExecutionBuildFile
import tui.sse.mde4cpp.MDE4CPPGenerate;

description 'Generate tasks for project: [packageName/]'

task generate[packageName.toUpperFirst()/](type: tui.sse.mde4cpp.MDE4CPPGenerate) {
	group '[packageName/]'
	description 'generate C++ code of [packageName/].uml model'

	modelFilePath = file('.' + File.separator + '[packageName/].uml')
	structureOnly = false

	relatedModels = ['['/][aPackage.generateRelatedModelNameList()/][']'/]

	dependsOn rootProject.tasks.getByPath(':generator:fUML4CPP:buildGenerator_fUML4CPP')
}
[/file]

[comment ------------------------------------------------------------------- /]
[comment gradle file for compile command of model                            /]
[comment ------------------------------------------------------------------- /]
[file ('build.gradle', false, 'UTF-8')]
// DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN
// @generator: fuml4cpp::generator::main::generateExecutionBuildFile
import tui.sse.mde4cpp.MDE4CPPCompile;
import org.gradle.internal.os.OperatingSystem;

description 'Compile tasks for project: [packageName/]'

task compile[packageName.toUpperFirst()/](type: tui.sse.mde4cpp.MDE4CPPCompile) {
	group '[packageName/]'
	description 'compile [packageName/]'

	projectFolder = file('.' + File.separator + '[packageName/]')

	inputs.files(fileTree('.') {
        exclude '[packageName/]/.cmake/**'
        exclude '[execPackageName/]/.cmake/**'
    })

	if(!file('.' + File.separator + '[packageName/]' + File.separator + '.cmake' + File.separator).exists()) {
		outputs.upToDateWhen { false }
	}

	if(!file('.' + File.separator + '[execPackageName/]' + File.separator + '.cmake' + File.separator).exists()) {
		outputs.upToDateWhen { false }
	}

	if(OperatingSystem.current().isWindows()){
		if(project.hasProperty('RELEASE') && !project.property('RELEASE').equals('0')){outputs.file file(['['/]rootDir,'application','bin','[packageName/]' +                '.dll'[']'/].join(File.separator))}
		if(project.hasProperty('DEBUG') && !project.property('DEBUG').equals('0'))  {outputs.file file(['['/]rootDir,'application','bin','[packageName/]' +          'd' + '.dll'[']'/].join(File.separator))}
		if(project.hasProperty('RELEASE') && !project.property('RELEASE').equals('0')){outputs.file file(['['/]rootDir,'application','bin','[packageName/]' + 'Exec' +       '.dll'[']'/].join(File.separator))}
		if(project.hasProperty('DEBUG') && !project.property('DEBUG').equals('0'))  {outputs.file file(['['/]rootDir,'application','bin','[packageName/]' + 'Exec' + 'd' + '.dll'[']'/].join(File.separator))}
	}
	else if(OperatingSystem.current().isLinux()){
		if(project.hasProperty('RELEASE') && !project.property('RELEASE').equals('0')){outputs.file file(['['/]rootDir,'application','bin','[packageName/]' +                '.so'[']'/].join(File.separator))}
		if(project.hasProperty('DEBUG') && !project.property('DEBUG').equals('0'))  {outputs.file file(['['/]rootDir,'application','bin','[packageName/]' +          'd' + '.so'[']'/].join(File.separator))}
		if(project.hasProperty('RELEASE') && !project.property('RELEASE').equals('0')){outputs.file file(['['/]rootDir,'application','bin','[packageName/]' + 'Exec' +       '.so'[']'/].join(File.separator))}
		if(project.hasProperty('DEBUG') && !project.property('DEBUG').equals('0'))  {outputs.file file(['['/]rootDir,'application','bin','[packageName/]' + 'Exec' + 'd' + '.so'[']'/].join(File.separator))}
	}
	else if(OperatingSystem.current().isMacOsX()){
		if(project.hasProperty('RELEASE') && !project.property('RELEASE').equals('0')){outputs.file file(['['/]rootDir,'application','bin','[packageName/]' +                '.dylib'[']'/].join(File.separator))}
		if(project.hasProperty('DEBUG') && !project.property('DEBUG').equals('0'))  {outputs.file file(['['/]rootDir,'application','bin','[packageName/]' +          'd' + '.dylib'[']'/].join(File.separator))}
		if(project.hasProperty('RELEASE') && !project.property('RELEASE').equals('0')){outputs.file file(['['/]rootDir,'application','bin','[packageName/]' + 'Exec' +       '.dylib'[']'/].join(File.separator))}
		if(project.hasProperty('DEBUG') && !project.property('DEBUG').equals('0'))  {outputs.file file(['['/]rootDir,'application','bin','[packageName/]' + 'Exec' + 'd' + '.dylib'[']'/].join(File.separator))}
	}
	else {
	    //not supported os
	}

	outputs.files(fileTree(['['/]rootDir,'application','include','[packageName/]'[']'/].join(File.separator)))
	outputs.files(fileTree(['['/]rootDir,'application','include','[execPackageName/]'[']'/].join(File.separator)))
	outputs.dir(['['/]rootDir,'application','include','[packageName/]'[']'/].join(File.separator))
	outputs.dir(['['/]rootDir,'application','include','[execPackageName/]'[']'/].join(File.separator))
	
	[comment
	// dependency to basic interfaces
	//   - deliverAbstractDataTypes 
    //   - deliverPluginFrameworkInterface
    //   - deliverPersistenceInterface
    //   - deliverUtil
	/]
	dependsOn getRootProject().getTasksByName('deliverBasicInterfaces', true)

[for (packName : String | aPackage.metaModelLibrariesNames()->reject(name : String | aPackage.getAllSubPackageNames()->includes(name))) ? (not(packName = aPackage.getPackageName()))]

	// dependency to model '[packName/]'
	def [packName/] = getRootProject().getTasksByName('compile[packName.toUpperFirst()/]', true)
	dependsOn [packName/]
	inputs.files([packName/].outputs)
[/for]
}

task clean {
	// Extension of gradle built-in task:clean
	doLast {
		def dot_cmake = file('[packageName/]/.cmake')
		if(dot_cmake.exists()){
			delete dot_cmake.absolutePath
			println "deleting: " + dot_cmake.absolutePath
		}

		def dot_cmakeExec = file('[execPackageName/]/.cmake')
		if(dot_cmakeExec.exists()){
			delete dot_cmakeExec.absolutePath
			println "deleting: " + dot_cmakeExec.absolutePath
		}
		
		compile[packageName.toUpperFirst()/].outputs.files.each{
			if(it.exists()){
				delete it.absolutePath
			    println "deleting: " + it
			}
  		}
	}
}
[/file]
[/template]

[template private generateRelatedModelNameList(aPackage : Package) post (trim())]
[for (packName : String | aPackage.metaModelLibrariesNames()->reject(name : String | aPackage.getAllSubPackageNames()->includes(name))) separator (', ') ? (not(packName = aPackage.getPackageName()))]
'[packName/]'[/for]
[/template]