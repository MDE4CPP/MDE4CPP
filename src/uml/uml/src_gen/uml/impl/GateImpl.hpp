//********************************************************************
//*    
//* Warning: This file was generated by ecore4CPP Generator
//*
//********************************************************************

#ifndef UML_GATEGATEIMPL_HPP
#define UML_GATEGATEIMPL_HPP

//*********************************
// generated Includes

// namespace macro header include
#include "uml/uml.hpp" 

// model includes
#include "../Gate.hpp"

#include "uml/impl/MessageEndImpl.hpp"

//*********************************
namespace uml 
{
	class UML_API GateImpl : virtual public MessageEndImpl, virtual public Gate 
	{
		public: 
			GateImpl(const GateImpl & obj);
			virtual std::shared_ptr<ecore::EObject> copy() const;
			GateImpl& operator=(GateImpl const&); 

		protected:
			friend class umlFactoryImpl;
			GateImpl();
			virtual std::shared_ptr<uml::Gate> getThisGatePtr() const;
			virtual void setThisGatePtr(std::weak_ptr<uml::Gate> thisGatePtr);

			//Additional constructors for the containments back reference
			GateImpl(std::weak_ptr<uml::Namespace> par_namespace);
			//Additional constructors for the containments back reference
			GateImpl(std::weak_ptr<uml::Element> par_owner);

		public:
			//destructor
			virtual ~GateImpl();
			
			//*********************************
			// Operations
			//*********************************
			/*!
			This query returns the name of the gate, either the explicit name (.name) or the constructed name ('out_" or 'in_' concatenated in front of .message.name) if the explicit name is not present.
			result = (if name->notEmpty() then name->asOrderedSet()->first()
			else  if isActual() or isOutsideCF() 
			  then if isSend() 
			    then 'out_'.concat(self.message.name->asOrderedSet()->first())
			    else 'in_'.concat(self.message.name->asOrderedSet()->first())
			    endif
			  else if isSend()
			    then 'in_'.concat(self.message.name->asOrderedSet()->first())
			    else 'out_'.concat(self.message.name->asOrderedSet()->first())
			    endif
			  endif
			endif)
			<p>From package UML::Interactions.</p>
			*/
			 
			virtual std::string getName() const ;
			/*!
			If the Gate is an inside Combined Fragment Gate, this operation returns the InteractionOperand that the opposite end of this Gate is included within.
			result = (if isInsideCF() then
			  let oppEnd : MessageEnd = self.oppositeEnd()->asOrderedSet()->first() in
			    if oppEnd.oclIsKindOf(MessageOccurrenceSpecification)
			    then let oppMOS : MessageOccurrenceSpecification = oppEnd.oclAsType(MessageOccurrenceSpecification)
			        in oppMOS.enclosingOperand->asOrderedSet()->first()
			    else let oppGate : Gate = oppEnd.oclAsType(Gate)
			        in oppGate.combinedFragment.enclosingOperand->asOrderedSet()->first()
			    endif
			  else null
			endif)
			<p>From package UML::Interactions.</p>
			*/
			 
			virtual std::shared_ptr<uml::InteractionOperand> getOperand() ;
			/*!
			This query returns true value if this Gate is an actualGate of an InteractionUse.
			result = (interactionUse->notEmpty())
			<p>From package UML::Interactions.</p>
			*/
			 
			virtual bool isActual() ;
			/*!
			This query returns true if this Gate is a formalGate of an Interaction.
			result = (interaction->notEmpty())
			<p>From package UML::Interactions.</p>
			*/
			 
			virtual bool isFormal() ;
			/*!
			This query returns true if this Gate is attached to the boundary of a CombinedFragment, and its other end (if present) is inside of an InteractionOperator of the same CombinedFragment.
			result = (self.oppositeEnd()-> notEmpty() and combinedFragment->notEmpty() implies
			let oppEnd : MessageEnd = self.oppositeEnd()->asOrderedSet()->first() in
			if oppEnd.oclIsKindOf(MessageOccurrenceSpecification)
			then let oppMOS : MessageOccurrenceSpecification
			= oppEnd.oclAsType(MessageOccurrenceSpecification)
			in combinedFragment = oppMOS.enclosingOperand.combinedFragment
			else let oppGate : Gate = oppEnd.oclAsType(Gate)
			in combinedFragment = oppGate.combinedFragment.enclosingOperand.combinedFragment
			endif)
			<p>From package UML::Interactions.</p>
			*/
			 
			virtual bool isInsideCF() ;
			/*!
			This query returns true if this Gate is attached to the boundary of a CombinedFragment, and its other end (if present)  is outside of the same CombinedFragment.
			result = (self.oppositeEnd()-> notEmpty() and combinedFragment->notEmpty() implies
			let oppEnd : MessageEnd = self.oppositeEnd()->asOrderedSet()->first() in
			if oppEnd.oclIsKindOf(MessageOccurrenceSpecification) 
			then let oppMOS : MessageOccurrenceSpecification = oppEnd.oclAsType(MessageOccurrenceSpecification)
			in  self.combinedFragment.enclosingInteraction.oclAsType(InteractionFragment)->asSet()->
			     union(self.combinedFragment.enclosingOperand.oclAsType(InteractionFragment)->asSet()) =
			     oppMOS.enclosingInteraction.oclAsType(InteractionFragment)->asSet()->
			     union(oppMOS.enclosingOperand.oclAsType(InteractionFragment)->asSet())
			else let oppGate : Gate = oppEnd.oclAsType(Gate) 
			in self.combinedFragment.enclosingInteraction.oclAsType(InteractionFragment)->asSet()->
			     union(self.combinedFragment.enclosingOperand.oclAsType(InteractionFragment)->asSet()) =
			     oppGate.combinedFragment.enclosingInteraction.oclAsType(InteractionFragment)->asSet()->
			     union(oppGate.combinedFragment.enclosingOperand.oclAsType(InteractionFragment)->asSet())
			endif)
			<p>From package UML::Interactions.</p>
			*/
			 
			virtual bool isOutsideCF() ;
			/*!
			This query returns true if the name of this Gate matches the name of the in parameter Gate, and the messages for the two Gates correspond. The Message for one Gate (say A) corresponds to the Message for another Gate (say B) if (A and B have the same name value) and (if A is a sendEvent then B is a receiveEvent) and (if A is a receiveEvent then B is a sendEvent) and (A and B have the same messageSort value) and (A and B have the same signature value).
			result = (self.getName() = gateToMatch.getName() and 
			self.message.messageSort = gateToMatch.message.messageSort and
			self.message.name = gateToMatch.message.name and
			self.message.sendEvent->includes(self) implies gateToMatch.message.receiveEvent->includes(gateToMatch)  and
			self.message.receiveEvent->includes(self) implies gateToMatch.message.sendEvent->includes(gateToMatch) and
			self.message.signature = gateToMatch.message.signature)
			<p>From package UML::Interactions.</p>
			*/
			 
			virtual bool matches(const std::shared_ptr<uml::Gate>& gateToMatch) ;
			
			//*********************************
			// Attribute Getters & Setters
			//*********************************
			
			//*********************************
			// Reference Getters & Setters
			//*********************************
			
			//*********************************
			// Union Reference Getters
			//*********************************
			
			//*********************************
			// Container Getter
			//*********************************
			virtual std::shared_ptr<ecore::EObject> eContainer() const ; 

			//*********************************
			// Persistence Functions
			//*********************************
			virtual void load(std::shared_ptr<persistence::interfaces::XLoadHandler> loadHandler) ;
			virtual void loadAttributes(std::shared_ptr<persistence::interfaces::XLoadHandler> loadHandler, std::map<std::string, std::string> attr_list);
			virtual void loadNode(std::string nodeName, std::shared_ptr<persistence::interfaces::XLoadHandler> loadHandler);
			virtual void resolveReferences(const int featureID, std::vector<std::shared_ptr<ecore::EObject>> references) ;
			virtual void save(std::shared_ptr<persistence::interfaces::XSaveHandler> saveHandler) const ;
			virtual void saveContent(std::shared_ptr<persistence::interfaces::XSaveHandler> saveHandler) const;

		protected:
			virtual std::shared_ptr<ecore::EClass> eStaticClass() const;

			//*********************************
			// EStructuralFeature Get/Set/IsSet
			//*********************************
			virtual std::shared_ptr<Any> eGet(int featureID, bool resolve, bool coreType) const ;
			virtual bool eSet(int featureID, const std::shared_ptr<Any>& newValue) ;
			virtual bool internalEIsSet(int featureID) const ;

			//*********************************
			// EOperation Invoke
			//*********************************
			virtual std::shared_ptr<Any> eInvoke(int operationID,const std::shared_ptr<Bag<Any>>& arguments) ;

		private:
			std::weak_ptr<uml::Gate> m_thisGatePtr;
	};
}
#endif /* end of include guard: UML_GATEGATEIMPL_HPP */
