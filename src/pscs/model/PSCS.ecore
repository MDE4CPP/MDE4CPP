<?xml version="1.0" encoding="UTF-8"?>
<ecore:EPackage xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore" name="PSCS" nsURI="http://www.omg.org/spec/PSCS/20180801" nsPrefix="PSCS_Semantics">
  <eSubpackages name="Semantics" nsURI="http:///PSCS_Semantics/Semantics.ecore" nsPrefix="PSCS_Semantics.Semantics">
    <eSubpackages name="Actions" nsURI="http:///PSCS_Semantics/Semantics/Actions.ecore"
        nsPrefix="PSCS_Semantics.Semantics.Actions">
      <eClassifiers xsi:type="ecore:EClass" name="CS_AcceptCallActionActivation" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/Actions/AcceptCallActionActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="/*&#xA;#include &quot;PSCS/Semantics/CommonBehavior/CS_EventOccurrence.hpp&quot;&#xA;#include &quot;fUML/fUMLFactory.hpp&quot;&#xA;#include &quot;fUML/Semantics/Activities/ActivityNodeActivationGroup.hpp&quot;&#xA;*/"/>
          <details key="doNotGenerate" value="Class 'CS_AcceptCallActionActivation' is excluded from generation because event handling is currently not supported."/>
        </eAnnotations>
        <eOperations name="accept" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// If the accepted event occurrence is a CS_EventOccurrence then the wrapped&#xA;&#x9;// event occurrence is extracted. The acceptance process is the one define&#xA;&#x9;// by AcceptCallActionActivation defined in fUML.&#xA;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::CommonBehavior::CS_EventOccurrence>(eventOccurrence) != nullptr) {&#xA;&#x9;&#x9;fUML::Semantics::Actions::AcceptCallActionActivationImpl::accept((std::dynamic_pointer_cast&lt;PSCS::Semantics::CommonBehavior::CS_EventOccurrence>(eventOccurrence))->getWrappedEventOccurrence());&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;fUML::Semantics::Actions::AcceptCallActionActivationImpl::accept(eventOccurrence);&#xA;&#x9;}"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_AcceptEventActionActivation"
          eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/Actions/AcceptEventActionActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="/*&#xA;#include &quot;PSCS/Semantics/CommonBehavior/CS_EventOccurrence.hpp&quot;&#xA;#include &quot;fUML/fUMLFactory.hpp&quot;&#xA;#include &quot;fUML/Semantics/Activities/ActivityNodeActivationGroup.hpp&quot;&#xA;*/"/>
        </eAnnotations>
        <eOperations name="accept" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// If the accepted event occurrence is a CS_EventOccurrence then the wrapped&#xA;&#x9;// event occurrence is extracted. The acceptance process is the one define&#xA;&#x9;// by AcceptEventActionActivation defined in fUML.&#xA;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::CommonBehavior::CS_EventOccurrence>(eventOccurrence) != nullptr) {&#xA;&#x9;&#x9;fUML::Semantics::Actions::AcceptEventActionActivationImpl::accept((std::dynamic_pointer_cast&lt;PSCS::Semantics::CommonBehavior::CS_EventOccurrence>(eventOccurrence))->getWrappedEventOccurrence());&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;fUML::Semantics::Actions::AcceptEventActionActivationImpl::accept(eventOccurrence);&#xA;&#x9;}"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_AddStructuralFeatureValueActionActivation"
          eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/Actions/AddStructuralFeatureValueActionActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="/*&#xA;#include &quot;fUML/Semantics/Activities/ActivityNodeActivationGroup.hpp&quot;&#xA;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/CS_InteractionPoint.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/CS_Reference.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/CS_Link.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/StructuredClassifiersFactory.hpp&quot;&#xA;#include &quot;fUML/Semantics/StructuredClassifiers/StructuredClassifiersPackage.hpp&quot;&#xA;&#xA;#include &quot;uml/AddStructuralFeatureValueAction.hpp&quot;&#xA;#include &quot;uml/Port.hpp&quot;&#xA;#include &quot;uml/StructuralFeature.hpp&quot;&#xA;#include &quot;uml/Association.hpp&quot;&#xA;#include &quot;uml/umlPackage.hpp&quot;&#xA;#include &quot;uml/InputPin.hpp&quot;&#xA;#include &quot;fUML/Semantics/Values/Value.hpp&quot;&#xA;#include &quot;fUML/Semantics/StructuredClassifiers/Reference.hpp&quot;&#xA;#include &quot;fUML/Semantics/SimpleClassifiers/UnlimitedNaturalValue.hpp&quot;&#xA;#include &quot;fUML/Semantics/SimpleClassifiers/FeatureValue.hpp&quot;&#xA;#include &quot;fUML/Semantics/Loci/ChoiceStrategy.hpp&quot;&#xA;#include &quot;fUML/Semantics/Loci/Locus.hpp&quot;&#xA;#include &quot;fUML/Semantics/Loci/ExecutionFactory.hpp&quot;&#xA;#include &quot;fUML/Semantics/StructuredClassifiers/Link.hpp&quot;&#xA;#include &quot;fUML/Semantics/SimpleClassifiers/StructuredValue.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/CS_Object.hpp&quot;&#xA;#include &quot;fUML/Semantics/Activities/ActivityExecution.hpp&quot;&#xA;*/"/>
        </eAnnotations>
        <eOperations name="doAction" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// If the feature is a port and the input value to be added is a&#xA;&#x9;// Reference,&#xA;&#x9;// Replaces this Reference by an InteractionPoint, and then behaves&#xA;&#x9;// as usual.&#xA;&#x9;// If the feature is not a port, behaves as usual&#xA;&#xA;&#x9;std::shared_ptr&lt;uml::AddStructuralFeatureValueAction> action = this->getAddStructuralFeatureValueAction();&#xA;&#x9;std::shared_ptr&lt;uml::StructuralFeature> feature = action->getStructuralFeature();&#xA;&#x9;&#xA;&#x9;if(feature->getMetaElementID() != uml::umlPackage::PORT_CLASS) {&#xA;&#x9;&#x9;// Behaves as usual&#xA;&#x9;&#x9;this->doActionDefault();&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> inputValues = this->takeTokens(action->getValue());&#xA;&#x9;&#x9;// NOTE: Multiplicity of the value input pin is required to be 1..1.&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::Values::Value> inputValue = inputValues->at(0);&#xA;&#x9;&#x9;if(inputValue->getMetaElementID() == fUML::Semantics::StructuredClassifiers::StructuredClassifiersPackage::REFERENCE_CLASS ||&#xA;&#x9;&#x9;   inputValue->getMetaElementID() == PSCS::Semantics::StructuredClassifiers::StructuredClassifiersPackage::CS_REFERENCE_CLASS ||&#xA;&#x9;&#x9;   inputValue->getMetaElementID() == PSCS::Semantics::StructuredClassifiers::StructuredClassifiersPackage::CS_INTERACTIONPOINT_CLASS) {&#xA;&#x9;&#x9;&#x9;// First constructs an InteractionPoint from the inputValue&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Reference> reference = std::dynamic_pointer_cast&lt;fUML::Semantics::StructuredClassifiers::Reference>(inputValue);&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_InteractionPoint> interactionPoint = PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_InteractionPoint();&#xA;&#x9;&#x9;&#x9;interactionPoint->setReferent(reference->getReferent());&#xA;&#x9;&#x9;&#x9;interactionPoint->setDefiningPort(std::dynamic_pointer_cast&lt;uml::Port>(feature));&#xA;&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::Values::Value> value = nullptr;&#x9;&#x9;&#xA;&#xA;&#x9;&#x9;&#x9;/* MDE4CPP specific implementation for handling &quot;self&quot;-Pin */&#xA;&#x9;&#x9;&#x9;std::string targetPinName = action->getObject()->getName();&#xA;&#x9;&#x9;&#x9;if((targetPinName.empty()) || (targetPinName.find(&quot;self&quot;) == 0)){&#xA;&#x9;&#x9;&#x9;&#x9;//target is set to the context of the current activity execution&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference> contextReference = PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_Reference();&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Object> context = this->getActivityExecution()->getContext();&#xA;&#x9;&#x9;&#x9;&#x9;contextReference->setReferent(context);&#xA;&#x9;&#x9;&#x9;&#x9;contextReference->setCompositeReferent(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(context));&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;value = contextReference;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else{&#xA;&#x9;&#x9;&#x9;&#x9;value = this->takeTokens(action->getObject())->at(0);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;/*--------------------------------------------------------*/&#xA;&#xA;&#x9;&#x9;&#x9;// The value on action.object is necessarily instanceof&#xA;&#x9;&#x9;&#x9;// CS_Reference (otherwise, the feature cannot be a port)&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference> owner = std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(value);&#xA;&#x9;&#x9;&#x9;interactionPoint->setOwner(owner);&#xA;&#x9;&#x9;&#x9;// Then replaces the CS_Reference by a CS_InteractionPoint in the inputValues&#xA;&#x9;&#x9;&#x9;inputValues->erase(inputValues->begin());&#xA;&#x9;&#x9;&#x9;inputValues->insert(inputValues->begin(), interactionPoint);&#xA;&#x9;&#x9;&#x9;// Finally concludes with usual fUML behavior of&#xA;&#x9;&#x9;&#x9;// AddStructuralFeatureValueAction (i.e., the usual behavior when&#xA;&#x9;&#x9;&#x9;// the value on action.object pin is a StructuredValue)&#xA;&#x9;&#x9;&#x9;int insertAt = 0;&#xA;&#x9;&#x9;&#x9;if(action->getInsertAt() != nullptr) {&#xA;&#x9;&#x9;&#x9;&#x9;insertAt = (std::dynamic_pointer_cast&lt;fUML::Semantics::SimpleClassifiers::UnlimitedNaturalValue>(this->takeTokens(action->getInsertAt())->at(0)))->getValue();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;if(action->getIsReplaceAll()) {&#xA;&#x9;&#x9;&#x9;&#x9;owner->assignFeatureValue(feature, inputValues, 0);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::FeatureValue> featureValue = owner->retrieveFeatureValue(feature);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if((featureValue->getValues()->size() > 0) &amp;&amp; (insertAt == 0)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// If there is no insertAt pin, then the structural&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// feature must be unordered, and the insertion position is&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// immaterial.&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;insertAt = (std::dynamic_pointer_cast&lt;fUML::Semantics::Loci::ChoiceStrategy>(this->getExecutionLocus()->getFactory()->getStrategy(&quot;choice&quot;)))->choose(featureValue->getValues()->size());&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if(feature->getIsUnique()) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// Remove any existing value that duplicates the input value&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;int j = position(interactionPoint, featureValue->getValues(), 1);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(j > 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;featureValue->getValues()->erase((featureValue->getValues()->begin() + (j-1)));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if((insertAt > 0) &amp;&amp; (j &lt; insertAt)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;insertAt = insertAt - 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;if(insertAt &lt;= 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// Note: insertAt = -1 indicates an unlimited value of&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// &quot;*&quot;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;featureValue->getValues()->add(interactionPoint);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;featureValue->getValues()->insert((featureValue->getValues()->begin() + (insertAt - 1)), interactionPoint);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;if (action->getResult() != nullptr) {&#xA;&#x9;&#x9;&#x9;&#x9;this->putToken(action->getResult(), owner);&#xA;&#x9;&#x9;&#x9;}&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;// Behaves as usual&#xA;&#x9;&#x9;&#x9;this->doActionDefault();&#xA;&#x9;&#x9;}&#xA;&#x9;}"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="doActionDefault" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Get the values of the object and value input pins.&#xA;&#x9;// If the given feature is an association end, then create a link&#xA;&#x9;// between the object and value inputs.&#xA;&#x9;// Otherwise, if the object input is a structural value, then add a&#xA;&#x9;// value to the values for the feature.&#xA;&#x9;// If isReplaceAll is true, first remove all current matching links or&#xA;&#x9;// feature values.&#xA;&#x9;// If isReplaceAll is false and there is an insertAt pin, insert the&#xA;&#x9;// value at the appropriate position.&#xA;&#x9;// This operation captures same semantics as fUML &#xA;&#x9;// AddStructuralFeatureValueActionActivation.doAction(), except that&#xA;&#x9;// when the feature is an association end, a CS_Link will be created instead&#xA;&#x9;// of a Link&#xA;&#xA;&#x9;std::shared_ptr&lt;uml::AddStructuralFeatureValueAction> action = this->getAddStructuralFeatureValueAction();&#xA;&#x9;std::shared_ptr&lt;uml::StructuralFeature> feature = action->getStructuralFeature();&#xA;&#x9;/* Since links are represented implicitly in MDE4CPP, handling of links when adding a structural feature value is bypassed here*/&#xA;&#x9;std::shared_ptr&lt;uml::Association> association = nullptr; //this->getAssociation(feature);&#xA;&#x9;&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::Values::Value> value = nullptr;&#x9;&#x9;&#xA;&#xA;&#x9;/* MDE4CPP specific implementation for handling &quot;self&quot;-Pin */&#xA;&#x9;std::string targetPinName = action->getObject()->getName();&#xA;&#x9;if((targetPinName.empty()) || (targetPinName.find(&quot;self&quot;) == 0)){&#xA;&#x9;&#x9;//target is set to the context of the current activity execution&#xA;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference> contextReference = PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_Reference();&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Object> context = this->getActivityExecution()->getContext();&#xA;&#x9;&#x9;contextReference->setReferent(context);&#xA;&#x9;&#x9;contextReference->setCompositeReferent(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(context));&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;value = contextReference;&#xA;&#x9;}&#xA;&#x9;else{&#xA;&#x9;&#x9;value = this->takeTokens(action->getObject())->at(0);&#xA;&#x9;}&#xA;&#x9;/*--------------------------------------------------------*/&#xA;&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> inputValues = this->takeTokens(action->getValue());&#xA;&#x9;&#xA;&#x9;// NOTE: Multiplicity of the value input pin is required to be 1..1.&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::Values::Value> inputValue = inputValues->at(0);&#xA;&#x9;&#xA;&#x9;int insertAt = 0;&#xA;&#x9;if(action->getInsertAt() != nullptr) {&#xA;&#x9;&#x9;insertAt = (std::dynamic_pointer_cast&lt;fUML::Semantics::SimpleClassifiers::UnlimitedNaturalValue>(this->takeTokens(action->getInsertAt())->at(0)))->getValue();&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if(association != nullptr) {&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Link>> links = this->getMatchingLinks(association, feature, value);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;std::shared_ptr&lt;uml::Property> oppositeEnd = this->getOppositeEnd(association, feature);&#xA;&#x9;&#x9;int position = 0;&#xA;&#x9;&#x9;if(oppositeEnd->getIsOrdered()) {&#xA;&#x9;&#x9;&#x9;position = -1;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;if (action->getIsReplaceAll()){&#xA;&#x9;&#x9;&#x9;for(int unsigned i = 0; i &lt; links->size(); i++) {&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Link> link = links->at(i);&#xA;&#x9;&#x9;&#x9;&#x9;link->destroy();&#xA;&#x9;&#x9;&#x9;}&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (feature->getIsUnique()) {&#xA;&#x9;&#x9;&#x9;for(int unsigned i = 0; i &lt; links->size(); i++) {&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Link> link = links->at(i);&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::FeatureValue> featureValue = link->retrieveFeatureValue(feature);&#xA;&#x9;&#x9;&#x9;&#x9;if(featureValue->getValues()->at(0)->equals(inputValue)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;position = link->retrieveFeatureValue(oppositeEnd)->getPosition();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if((insertAt > 0) &amp;&amp; (featureValue->getPosition() &lt; insertAt)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;insertAt = insertAt - 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;link->destroy();&#xA;&#x9;&#x9;&#x9;&#x9;}&#x9;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Link> newLink = PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_Link();&#xA;&#x9;&#x9;newLink->setType(association);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;// This necessary when setting a feature value with an insertAt&#xA;&#x9;&#x9;// position&#xA;&#x9;&#x9;newLink->setLocus(this->getExecutionLocus());&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;newLink->assignFeatureValue(feature, inputValues, insertAt);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> oppositeValues(new Bag&lt;fUML::Semantics::Values::Value>());&#xA;&#x9;&#x9;oppositeValues->add(value);&#xA;&#x9;&#x9;newLink->assignFeatureValue(oppositeEnd, oppositeValues, position);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;newLink->getLocus()->add(newLink);&#xA;&#x9;}&#xA;&#x9;else if (std::dynamic_pointer_cast&lt;fUML::Semantics::SimpleClassifiers::StructuredValue>(value) != nullptr) {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::StructuredValue> structuredValue = std::dynamic_pointer_cast&lt;fUML::Semantics::SimpleClassifiers::StructuredValue>(value);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;if(action->getIsReplaceAll()) {&#xA;&#x9;&#x9;&#x9;structuredValue->assignFeatureValue(feature, inputValues, 0);&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::FeatureValue> featureValue = structuredValue->retrieveFeatureValue(feature);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if((featureValue->getValues()->size() > 0) &amp;&amp; (insertAt ==0)) {&#xA;&#x9;&#x9;&#x9;&#x9;// *** If there is no insertAt pin, then the structural&#xA;&#x9;&#x9;&#x9;&#x9;// feature must be unordered, and the insertion position is&#xA;&#x9;&#x9;&#x9;&#x9;// immaterial. ***&#xA;&#x9;&#x9;&#x9;&#x9;insertAt = (std::dynamic_pointer_cast&lt;fUML::Semantics::Loci::ChoiceStrategy>(this->getExecutionLocus()->getFactory()->getStrategy(&quot;choice&quot;)))->choose(featureValue->getValues()->size());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if(feature->getIsUnique()) {&#xA;&#x9;&#x9;&#x9;&#x9;// Remove any existing value that duplicates the input value&#xA;&#x9;&#x9;&#x9;&#x9;int j = position(inputValue, featureValue->getValues(), 1);&#xA;&#x9;&#x9;&#x9;&#x9;if(j > 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;featureValue->getValues()->erase(featureValue->getValues()->begin() + (j-1));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(insertAt > 0 &amp;&amp; j &lt; insertAt) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;insertAt = insertAt - 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if(insertAt &lt;= 0) {&#xA;&#x9;&#x9;&#x9;&#x9;// Note: insertAt = -1 indicates an&#xA;&#x9;&#x9;&#x9;&#x9;// unlimited value of &quot;*&quot;&#xA;&#x9;&#x9;&#x9;&#x9;featureValue->getValues()->add(inputValue);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;featureValue->getValues()->insert((featureValue->getValues()->begin() + (insertAt - 1)), inputValue);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;structuredValue->assignFeatureValue(feature, featureValue->getValues(), 0);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if(action->getResult() != nullptr) {&#xA;&#x9;&#x9;this->putToken(action->getResult(), value);&#xA;&#x9;}"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_CallOperationActionActivation"
          eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/Actions/CallOperationActionActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="/*&#xA;#include &quot;fUML/Semantics/Activities/ActivityNodeActivationGroup.hpp&quot;&#xA;&#xA;#include &quot;uml/CallOperationAction.hpp&quot;&#xA;#include &quot;uml/Parameter.hpp&quot;&#xA;#include &quot;uml/ParameterDirectionKind.hpp&quot;&#xA;#include &quot;uml/InputPin.hpp&quot;&#xA;#include &quot;uml/OutputPin.hpp&quot;&#xA;#include &quot;uml/Class.hpp&quot;&#xA;#include &quot;uml/Interface.hpp&quot;&#xA;#include &quot;fUML/Semantics/Values/Value.hpp&quot;&#xA;#include &quot;fUML/Semantics/StructuredClassifiers/Object.hpp&quot;&#xA;#include &quot;fUML/Semantics/Activities/ActivityExecution.hpp&quot;&#xA;#include &quot;fUML/Semantics/Loci/Locus.hpp&quot;&#xA;#include &quot;fUML/Semantics/Loci/ExecutionFactory.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/StructuredClassifiersFactory.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/CS_Reference.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/CS_Object.hpp&quot;&#xA;#include &quot;PSCS/Semantics/Actions/CS_ConstructStrategy.hpp&quot;&#xA;#include &quot;PSCS/Semantics/Loci/CS_ExecutionFactory.hpp&quot;&#xA;*/"/>
        </eAnnotations>
        <eOperations name="getCallExecution" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/Execution">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// If onPort is not specified, behaves like in fUML&#xA;&#x9;// If onPort is specified, and if the value on the target input pin is a &#xA;&#x9;// reference, dispatch the operation &#xA;&#x9;// to it and return the resulting execution object.&#xA;&#x9;// As compared to fUML, instead of dispatching directly to target reference &#xA;&#x9;// by calling operation dispatch:&#xA;&#x9;// - If the invoked BehavioralFeature is on a provided Interface but not on any required Interface, &#xA;&#x9;// then, when the InvocationAction is executed, the invocation is made into the object given on &#xA;&#x9;// the target InputPin through the given Port&#xA;&#x9;// - If the invoked BehavioralFeature is on a required Interface but not on any provided Interface, &#xA;&#x9;// then, if the InvocationAction is being executed inside the object given on the target InputPin, &#xA;&#x9;// the invocation is forwarded out of the target object through the given Port.&#xA;&#x9;// - If the invoked BehavioralFeature is on both a provided and a required Interface, &#xA;&#x9;// then, if the InvocationAction is being executed inside the object given on the target InputPin, &#xA;&#x9;// the invocation is made out of the target object through the given Port. &#xA;&#x9;// Otherwise the invocation is made into the target object through the given Port.&#xA;&#xA;&#x9;std::shared_ptr&lt;uml::CallOperationAction> action = this->getCallOperationAction();&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::CommonBehavior::Execution> execution = nullptr;&#xA;&#x9;if(action->getOnPort() == nullptr) {&#xA;&#x9;&#x9;execution = fUML::Semantics::Actions::CallOperationActionActivationImpl::getCallExecution();&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::Values::Value> target = nullptr;&#x9;&#x9;&#xA;&#xA;&#x9;&#x9;/* MDE4CPP specific implementation for handling &quot;self&quot;-Pin */&#xA;&#x9;&#x9;std::string targetPinName = action->getTarget()->getName();&#xA;&#x9;&#x9;if((targetPinName.empty()) || (targetPinName.find(&quot;self&quot;) == 0)){&#xA;&#x9;&#x9;&#x9;//target is set to the context of the current activity execution&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference> contextReference = PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_Reference();&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Object> context = this->getActivityExecution()->getContext();&#xA;&#x9;&#x9;&#x9;contextReference->setReferent(context);&#xA;&#x9;&#x9;&#x9;contextReference->setCompositeReferent(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(context));&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;target = contextReference;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else{&#xA;&#x9;&#x9;&#x9;target = this->takeTokens(action->getTarget())->at(0);&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;/*--------------------------------------------------------*/&#xA;&#xA;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(target) != nullptr) {&#xA;&#x9;&#x9;&#x9;// Tries to determine if the operation call has to be&#xA;&#x9;&#x9;&#x9;// dispatched to the environment or to the internals of&#xA;&#x9;&#x9;&#x9;// target, through onPort&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference> targetReference = std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(target);&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Object> executionContext = this->getActivityExecution()->getContext();&#xA;&#x9;&#x9;&#x9;bool operationIsOnProvidedInterface = this->isOperationProvided(action->getOnPort(), action->getOperation());&#xA;&#x9;&#x9;&#x9;bool operationIsOnRequiredInterface = this->isOperationRequired(action->getOnPort(), action->getOperation());&#xA;&#x9;&#x9;&#x9;// Operation is on a provided interface only&#xA;&#x9;&#x9;&#x9;if(operationIsOnProvidedInterface &amp;&amp; !operationIsOnRequiredInterface) {&#xA;&#x9;&#x9;&#x9;&#x9;execution = targetReference->dispatchIn(action->getOperation(), action->getOnPort());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;// Operation is on a required interface only&#xA;&#x9;&#x9;&#x9;else if (!operationIsOnProvidedInterface &amp;&amp; operationIsOnRequiredInterface) {&#xA;&#x9;&#x9;&#x9;&#x9;// If not executing in the context of the target,&#xA;&#x9;&#x9;&#x9;&#x9;// Semantics are undefined.&#xA;&#x9;&#x9;&#x9;&#x9;// Otherwise, dispatch outside.&#xA;&#x9;&#x9;&#x9;&#x9;if((executionContext == targetReference->getReferent()) || (targetReference->getCompositeReferent()->contains(executionContext))) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;execution = targetReference->dispatchOut(action->getOperation(), action->getOnPort());&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;// Operation is both on a provided and a required interface&#xA;&#x9;&#x9;&#x9;else if (operationIsOnProvidedInterface &amp;&amp; operationIsOnRequiredInterface) {&#xA;&#x9;&#x9;&#x9;&#x9;if((executionContext == targetReference->getReferent()) || (targetReference->getCompositeReferent()->contains(executionContext))) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;execution = targetReference->dispatchOut(action->getOperation(), action->getOnPort());&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;execution = targetReference->dispatchIn(action->getOperation(), action->getOnPort()); &#xA;&#x9;&#x9;&#x9;&#x9;}&#x9;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return execution;"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="doAction" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// First determines if this is a call to a constructor and if a default&#xA;&#x9;// construction strategy needs to be applied.&#xA;&#x9;// This is a call to a constructor if the called operation has&#xA;&#x9;// stereotype &lt;&lt;Create>> applied.&#xA;&#x9;// The default construction strategy is used if no method is associated with the&#xA;&#x9;// &lt;&lt;Create>> operation.&#xA;&#x9;// Otherwise, behaves like in fUML.&#xA;&#xA;&#x9;std::shared_ptr&lt;uml::CallOperationAction> action = this->getCallOperationAction();&#xA;&#xA;&#x9;if((action->getOnPort() == nullptr) &amp;&amp; (this->_isCreate(action->getOperation())) &amp;&amp; (action->getOperation()->getMethod()->size() == 0)) {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::Loci::Locus> locus = this->getExecutionLocus();&#xA;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::Actions::CS_ConstructStrategy> strategy = std::dynamic_pointer_cast&lt;PSCS::Semantics::Actions::CS_ConstructStrategy>(locus->getFactory()->getStrategy(&quot;constructStrategy&quot;));&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::Values::Value> target = this->takeTokens(action->getTarget())->at(0);&#xA;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(target) != nullptr) {&#xA;&#x9;&#x9;&#x9;strategy->construct(action->getOperation(), (std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(target))->getCompositeReferent());&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;uml::Parameter>> parameters = action->getOperation()->getOwnedParameter();&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;uml::OutputPin>> resultPins = action->getResult();&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> values(new Bag&lt;fUML::Semantics::Values::Value>());&#xA;&#x9;&#x9;&#x9;values->add(target);&#xA;&#x9;&#x9;&#x9;unsigned int i = 1;&#xA;&#x9;&#x9;&#x9;while(i &lt;= parameters->size()) {&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::Parameter> parameter = parameters->at(i-1);&#xA;&#x9;&#x9;&#x9;&#x9;if(parameter->getDirection() == uml::ParameterDirectionKind::RETURN) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::OutputPin> resultPin = resultPins->at(0);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this->putTokens(resultPin, values);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;i = i + 1;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;fUML::Semantics::Actions::CallActionActivationImpl::doAction();&#xA;&#x9;}"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="isOperationProvided" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EBoolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;bool isProvided = false;&#xA;&#x9;/*if(std::dynamic_pointer_cast&lt;uml::Interface>(operation->getOwner().lock()) != nullptr) {*/&#xA;&#x9;// We have to look in provided interfaces of the port if&#xA;&#x9;// they define directly or indirectly the Operation&#xA;&#x9;unsigned int interfaceIndex = 1;&#xA;&#x9;// Iterates on provided interfaces of the port&#xA;&#x9;std::shared_ptr&lt;Bag&lt;uml::Interface>> providedInterfaces = port->getProvideds();&#xA;&#x9;while((interfaceIndex &lt;= providedInterfaces->size()) &amp;&amp; (!isProvided)) {&#xA;&#x9;&#x9;std::shared_ptr&lt;uml::Interface> interface_ = providedInterfaces->at(interfaceIndex-1);&#xA;&#x9;&#x9;// Iterates on members of the current Interface&#xA;&#x9;&#x9;unsigned int memberIndex = 1;&#xA;&#x9;&#x9;while((memberIndex &lt;= interface_->getMember()->size()) &amp;&amp; (!isProvided)) {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::NamedElement> cddOperation = interface_->getMember()->at(memberIndex-1);&#xA;&#x9;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;uml::Operation>(cddOperation) != nullptr) {&#xA;&#x9;&#x9;&#x9;&#x9;//isProvided = (operation == cddOperation);&#xA;&#x9;&#x9;&#x9;&#x9;isProvided = operation->matches(std::dynamic_pointer_cast&lt;uml::Operation>(cddOperation));&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;memberIndex += 1;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;interfaceIndex += 1;&#xA;&#x9;}&#xA;&#x9;/*}*/&#xA;&#x9;return isProvided;"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="port" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
        </eOperations>
        <eOperations name="isOperationRequired" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EBoolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;bool isRequired = false;&#xA;&#x9;unsigned int interfaceIndex = 1;&#xA;&#x9;// Interfaces on provided interfaces of the port&#xA;&#x9;std::shared_ptr&lt;Bag&lt;uml::Interface>> requiredInterfaces = port->getRequireds();&#xA;&#x9;while((interfaceIndex &lt;= requiredInterfaces->size()) &amp;&amp; (!isRequired)) {&#xA;&#x9;&#x9;std::shared_ptr&lt;uml::Interface> interface_ = requiredInterfaces->at(interfaceIndex-1);&#xA;&#x9;&#x9;// Iterates on members of the current Interface&#xA;&#x9;&#x9;unsigned int memberIndex = 1;&#xA;&#x9;&#x9;while((memberIndex &lt;= interface_->getMember()->size()) &amp;&amp; (!isRequired)) {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::NamedElement> cddOperation = interface_->getMember()->at(memberIndex-1);&#xA;&#x9;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;uml::Operation>(cddOperation)) {&#xA;&#x9;&#x9;&#x9;&#x9;//isRequired = (operation == cddOperation);&#xA;&#x9;&#x9;&#x9;&#x9;isRequired = operation->matches(std::dynamic_pointer_cast&lt;uml::Operation>(cddOperation));&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;memberIndex += 1;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;interfaceIndex += 1;&#xA;&#x9;}&#xA;&#x9;return isRequired;"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="port" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
        </eOperations>
        <eOperations name="isCreate" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EBoolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::Loci::CS_ExecutionFactory> executionFactory = std::dynamic_pointer_cast&lt;PSCS::Semantics::Loci::CS_ExecutionFactory>(this->getExecutionLocus()->getFactory());&#xA;&#x9;std::shared_ptr&lt;uml::Class> stereotypeCreate = std::dynamic_pointer_cast&lt;uml::Class>(executionFactory->getStereotypeClass(&quot;StandardProfile&quot;, &quot;Create&quot;));&#xA;&#x9;if(stereotypeCreate == nullptr) {&#xA;&#x9;&#x9;// standard profile is not applied&#xA;&#x9;&#x9;return false;&#xA;&#x9;}&#xA;&#x9;return executionFactory->getStereotypeApplication(stereotypeCreate, operation) != nullptr; "/>
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
        </eOperations>
        <eOperations name="_isCreate" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EBoolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;std::string stereotypeQualifiedName = &quot;StandardProfile::Create&quot;;&#xA;&#x9;std::shared_ptr&lt;uml::Stereotype> stereotypeClass = operation->getAppliedStereotype(stereotypeQualifiedName);&#xA;&#xA;&#x9;if(stereotypeClass != nullptr){&#xA;&#x9;&#x9;DEBUG_MESSAGE(std::cout&lt;&lt;&quot;Stereotype '&quot;&lt;&lt;stereotypeQualifiedName&lt;&lt;&quot;' applied...&quot;&lt;&lt;std::endl;)&#xA;&#x9;&#x9;return true;&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;DEBUG_MESSAGE(std::cout&lt;&lt;&quot;Stereotype '&quot;&lt;&lt;stereotypeQualifiedName&lt;&lt;&quot;' not applied...&quot;&lt;&lt;std::endl;)&#xA;&#x9;&#x9;return false;&#xA;&#x9;}"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="operation" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_ClearStructuralFeatureActionActivation"
          eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/Actions/ClearStructuralFeatureActionActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="/*&#xA;#include &quot;fUML/Semantics/Activities/ActivityNodeActivationGroup.hpp&quot;&#xA;&#xA;#include &quot;uml/ClearStructuralFeatureAction.hpp&quot;&#xA;#include &quot;uml/Association.hpp&quot;&#xA;#include &quot;uml/Port.hpp&quot;&#xA;#include &quot;fUML/Semantics/SimpleClassifiers/FeatureValue.hpp&quot;&#xA;#include &quot;fUML/Semantics/StructuredClassifiers/Object.hpp&quot;&#xA;#include &quot;fUML/Semantics/StructuredClassifiers/ExtensionalValue.hpp&quot;&#xA;#include &quot;fUML/Semantics/Loci/Locus.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/CS_InteractionPoint.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/CS_Object.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/StructuredClassifiersFactory.hpp&quot;&#xA;#include &quot;fUML/Semantics/Activities/ActivityExecution.hpp&quot;&#xA;#include &quot;uml/InputPin.hpp&quot;&#xA;*/"/>
        </eAnnotations>
        <eOperations name="doAction" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Get the value of the object input pin.&#xA;&#x9;// If the given feature is an association end, then&#xA;&#x9;// destroy all links that have the object input on the opposite end.&#xA;&#x9;// Otherwise, if the object input is a structured value, then&#xA;&#x9;// set the appropriate feature of the input value to be empty.&#xA;&#xA;&#x9;std::shared_ptr&lt;uml::ClearStructuralFeatureAction> action = std::dynamic_pointer_cast&lt;uml::ClearStructuralFeatureAction>(this->getNode());&#xA;&#x9;std::shared_ptr&lt;uml::StructuralFeature> feature = action->getStructuralFeature();&#xA;&#x9;std::shared_ptr&lt;uml::Association> association = this->getAssociation(feature);&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::Values::Value> value = nullptr;&#x9;&#x9;&#xA;&#xA;&#x9;/* MDE4CPP specific implementation for handling &quot;self&quot;-Pin */&#xA;&#x9;std::string targetPinName = action->getObject()->getName();&#xA;&#x9;if((targetPinName.empty()) || (targetPinName.find(&quot;self&quot;) == 0)){&#xA;&#x9;&#x9;//target is set to the context of the current activity execution&#xA;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference> contextReference = PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_Reference();&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Object> context = this->getActivityExecution()->getContext();&#xA;&#x9;&#x9;contextReference->setReferent(context);&#xA;&#x9;&#x9;contextReference->setCompositeReferent(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(context));&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;value = contextReference;&#xA;&#x9;}&#xA;&#x9;else{&#xA;&#x9;&#x9;value = this->takeTokens(action->getObject())->at(0);&#xA;&#x9;}&#xA;&#x9;/*--------------------------------------------------------*/&#xA;&#xA;&#x9;if(association != nullptr) {&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Link>> links = this->getMatchingLinks(association, feature, value);&#xA;&#x9;&#x9;for(unsigned int i = 0; i &lt; links->size(); i++) {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Link> link = links->at(i);&#xA;&#x9;&#x9;&#x9;link->destroy();&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else if(std::dynamic_pointer_cast&lt;fUML::Semantics::SimpleClassifiers::StructuredValue>(value) != nullptr){&#xA;&#x9;&#x9;// If the value is a data value, then it must be copied before&#xA;&#x9;&#x9;// any change is made.&#xA;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;fUML::Semantics::StructuredClassifiers::Reference>(value) == nullptr) {&#xA;&#x9;&#x9;&#x9;value = std::dynamic_pointer_cast&lt;fUML::Semantics::Values::Value>(value->copy());&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;// extension to fUML&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;PSCS::Semantics::StructuredClassifiers::CS_Link>> linksToDestroy = this->getLinksToDestroy(std::dynamic_pointer_cast&lt;fUML::Semantics::SimpleClassifiers::StructuredValue>(value), feature);&#xA;&#x9;&#x9;&#x9;for(unsigned int i = 0; i &lt; linksToDestroy->size(); i++) {&#xA;&#x9;&#x9;&#x9;&#x9;linksToDestroy->at(i)->destroy();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;//&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> newValueList(new Bag&lt;fUML::Semantics::Values::Value>());&#xA;&#x9;&#x9;(std::dynamic_pointer_cast&lt;fUML::Semantics::SimpleClassifiers::StructuredValue>(value))->assignFeatureValue(action->getStructuralFeature(), newValueList, 0);&#xA;&#x9;}&#xA;&#x9;if(action->getResult() != nullptr) {&#xA;&#x9;&#x9;this->putToken(action->getResult(), value);&#xA;&#x9;}"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getLinksToDestroy" upperBound="-1" eType="#//Semantics/StructuredClassifiers/CS_Link">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Retrieves links that must be destroyed when the given feature&#xA;&#x9;// is cleared in the context of the given value&#xA;&#x9;std::shared_ptr&lt;Bag&lt;PSCS::Semantics::StructuredClassifiers::CS_Link>> linksToDestroy(new Bag&lt;PSCS::Semantics::StructuredClassifiers::CS_Link>);&#xA;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(value) != nullptr) {&#xA;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference> context = std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(value);&#xA;&#x9;&#x9;// Retrieves the feature values for the structural feature associated with this action,&#xA;&#x9;&#x9;// in the context of this reference&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::FeatureValue> featureValue = context->retrieveFeatureValue(feature);&#xA;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;uml::Port>(feature) != nullptr) {&#xA;&#x9;&#x9;&#x9;// all values are interaction points&#xA;&#x9;&#x9;&#x9;// any link targeting this interaction point must be destroyed&#xA;&#x9;&#x9;&#x9;for(unsigned int i = 0; i &lt; featureValue->getValues()->size(); i++) {&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_InteractionPoint> interactionPoint = std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_InteractionPoint>(featureValue->getValues()->at(i));&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;PSCS::Semantics::StructuredClassifiers::CS_Link>> connectorInstances = context->getCompositeReferent()->getLinks(interactionPoint);&#xA;&#x9;&#x9;&#x9;&#x9;for(unsigned int j = 0; j &lt; connectorInstances->size(); j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Link> link = connectorInstances->at(j);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;linksToDestroy->add(link);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;// feature is an attribute&#xA;&#x9;&#x9;&#x9;// Retrieve all potential link ends,&#xA;&#x9;&#x9;&#x9;// separating potential link ends corresponding to the given feature,&#xA;&#x9;&#x9;&#x9;// and potential link ends corresponding to other features.&#xA;&#x9;&#x9;&#x9;// By &quot;potential link ends&quot;, we refer to the values of a given feature,&#xA;&#x9;&#x9;&#x9;// as well as interaction points associated with this value, if any.&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> allValuesForFeature(new Bag&lt;fUML::Semantics::Values::Value>());&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> allOtherValues(new Bag&lt;fUML::Semantics::Values::Value>());&#xA;&#x9;&#x9;&#x9;for(unsigned int i = 0; i &lt; context->getReferent()->getFeatureValues()->size(); i++) {&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::StructuralFeature> currentFeature = context->getReferent()->getFeatureValues()->at(i)->getFeature();&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> values = this->getPotentialLinkEnds(context, currentFeature);&#xA;&#x9;&#x9;&#x9;&#x9;for(unsigned int j = 0; j &lt; values->size(); j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::Values::Value> v = values->at(j);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(currentFeature != feature) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;allOtherValues->add(v);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;allValuesForFeature->add(v);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;// Retrieves all links available at the locus&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::ExtensionalValue>> extensionalValues = this->getExecutionLocus()->getExtensionalValues();&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;PSCS::Semantics::StructuredClassifiers::CS_Link>> allLinks(new Bag&lt;PSCS::Semantics::StructuredClassifiers::CS_Link>());&#xA;&#x9;&#x9;&#x9;for(unsigned int i = 0; i &lt; extensionalValues->size(); i++) {&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::ExtensionalValue> extensionalValue = extensionalValues->at(i);&#xA;&#x9;&#x9;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Link>(extensionalValue) != nullptr) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;allLinks->add(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Link>(extensionalValue));&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;//Retrieves links representing connector instances in the context object&#xA;&#x9;&#x9;&#x9;for(unsigned int i = 0; i &lt; allLinks->size(); i++) {&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Link> link = allLinks->at(i);&#xA;&#x9;&#x9;&#x9;&#x9;bool linkHasToBeDestroyed = false;&#xA;&#x9;&#x9;&#x9;&#x9;for(unsigned int j = 0; j &lt; allValuesForFeature->size() &amp;&amp; !linkHasToBeDestroyed; j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::Values::Value> v = allValuesForFeature->at(j);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::StructuralFeature> featureForV = link->getFeature(v);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(featureForV != nullptr) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// Check if feature values of this link for other features&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// contains elements identified in allOtherValue&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for(unsigned int k = 0; k &lt; link->retrieveFeatureValues()->size() &amp;&amp; !linkHasToBeDestroyed; k++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::FeatureValue> otherFeatureValue = link->retrieveFeatureValues()->at(k);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(otherFeatureValue->getFeature() != featureForV) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (unsigned int l = 0; l &lt; otherFeatureValue->getValues()->size() &amp;&amp; !linkHasToBeDestroyed; l++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for(unsigned int m = 0; m &lt; allOtherValues->size() &amp;&amp; !linkHasToBeDestroyed; m++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(otherFeatureValue->getValues()->at(l) == allOtherValues->at(m)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;linkHasToBeDestroyed = true;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if(linkHasToBeDestroyed) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;linksToDestroy->add(link);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return linksToDestroy;"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="value" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/SimpleClassifiers/StructuredValue"/>
          <eParameters name="feature" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//StructuralFeature"/>
        </eOperations>
        <eOperations name="getPotentialLinkEnds" upperBound="-1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Values/Value">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Retrieves all feature values for the context object for the given feature,&#xA;&#x9;// as well as all interaction point for these values&#xA;&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> potentialLinkEnds(new Bag&lt;fUML::Semantics::Values::Value>);&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::FeatureValue> featureValue = context->retrieveFeatureValue(feature);&#xA;&#x9;for(unsigned int i = 0; i &lt; featureValue->getValues()->size(); i++) {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::Values::Value> v = featureValue->getValues()->at(i);&#xA;&#x9;&#x9;potentialLinkEnds->add(v);&#xA;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(v)) {&#xA;&#x9;&#x9;&#x9;// add all interaction points associated with va_arg&#xA;&#x9;&#x9;&#x9;for (unsigned int j = 0; j &lt; (std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(v))->getReferent()->getFeatureValues()->size(); j++) {&#xA;&#x9;&#x9;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;uml::Port>((std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(v))->getReferent()->getFeatureValues()->at(j)->getFeature())) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> interactionPoints = ((std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(v))->getReferent()->getFeatureValues()->at(j))->getValues();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for(unsigned int k = 0; k &lt; interactionPoints->size(); k++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;potentialLinkEnds->add(interactionPoints->at(k));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return potentialLinkEnds;"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="context" eType="#//Semantics/StructuredClassifiers/CS_Reference"/>
          <eParameters name="feature" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//StructuralFeature"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_CreateLinkActionActivation" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/Actions/CreateLinkActionActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="/*&#xA;#include &quot;fUML/Semantics/Activities/ActivityNodeActivationGroup.hpp&quot;&#xA;&#xA;#include &quot;uml/CreateLinkAction.hpp&quot;&#xA;#include &quot;uml/LinkEndCreationData.hpp&quot;&#xA;#include &quot;uml/Association.hpp&quot;&#xA;#include &quot;uml/Property.hpp&quot;&#xA;#include &quot;fUML/Semantics/StructuredClassifiers/Link.hpp&quot;&#xA;#include &quot;fUML/Semantics/StructuredClassifiers/ExtensionalValue.hpp&quot;&#xA;#include &quot;fUML/Semantics/Loci/Locus.hpp&quot;&#xA;#include &quot;fUML/Semantics/SimpleClassifiers/UnlimitedNaturalValue.hpp&quot;&#xA;#include &quot;fUML/Semantics/SimpleClassifiers/FeatureValue.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/CS_Link.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/StructuredClassifiersFactory.hpp&quot;&#xA;*/"/>
        </eAnnotations>
        <eOperations name="doAction" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Get the extent at the current execution locus of the association for&#xA;&#x9;// which a link is being created.&#xA;&#x9;// Destroy all links that have a value for any end for which&#xA;&#x9;// isReplaceAll is true.&#xA;&#x9;// Create a new link for the association, at the current locus, with the&#xA;&#x9;// given end data values,&#xA;&#x9;// inserted at the given insertAt position (for ordered ends).&#xA;&#x9;// fUML semantics is extended in the sense that a CS_Link is created instead of&#xA;&#x9;// a Link&#xA;&#xA;&#x9;std::shared_ptr&lt;uml::CreateLinkAction> action = std::dynamic_pointer_cast&lt;uml::CreateLinkAction>(this->getNode());&#xA;&#x9;std::shared_ptr&lt;Bag&lt;uml::LinkEndCreationData>> endDataList = std::dynamic_pointer_cast&lt;Bag&lt;uml::LinkEndCreationData>>(action->getEndData());&#xA;&#x9;&#xA;&#x9;std::shared_ptr&lt;uml::Association> linkAssociation = this->getAssociation();&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::ExtensionalValue>> extent = this->getExecutionLocus()->retrieveExtent(linkAssociation);&#xA;&#x9;&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Link> oldLink = nullptr;&#xA;&#x9;for(unsigned int i = 0; i &lt; extent->size(); i++) {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::ExtensionalValue> value = extent->at(i);&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Link> link = std::dynamic_pointer_cast&lt;fUML::Semantics::StructuredClassifiers::Link>(value);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;bool noMatch = true;&#xA;&#x9;&#x9;unsigned int j = 1;&#xA;&#x9;&#x9;while ((noMatch) &amp;&amp; (j &lt;= endDataList->size())) {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::LinkEndCreationData> endData = endDataList->at(j-1);&#xA;&#x9;&#x9;&#x9;if((endData->getIsReplaceAll()) &amp;&amp; (this->endMatchesEndData(link, endData))) {&#xA;&#x9;&#x9;&#x9;&#x9;oldLink = link;&#xA;&#x9;&#x9;&#x9;&#x9;link->destroy();&#xA;&#x9;&#x9;&#x9;&#x9;noMatch = false;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;j += 1;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Link> newLink = PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_Link();&#xA;&#x9;newLink->setType(linkAssociation);&#xA;&#x9;// This is necessary when setting a feature value with an insertAt position&#xA;&#x9;newLink->setLocus(this->getExecutionLocus());&#xA;&#x9;&#xA;&#x9;for(unsigned int i = 0; i &lt; endDataList->size(); i++) {&#xA;&#x9;&#x9;std::shared_ptr&lt;uml::LinkEndCreationData> endData = endDataList->at(i);&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;int insertAt;&#xA;&#x9;&#x9;if (endData->getInsertAt() == nullptr) {&#xA;&#x9;&#x9;&#x9;insertAt = 0;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;insertAt = (std::dynamic_pointer_cast&lt;fUML::Semantics::SimpleClassifiers::UnlimitedNaturalValue>(this->takeTokens(endData->getInsertAt())->at(0)))->getValue();&#xA;&#x9;&#x9;&#x9;if(oldLink != nullptr) {&#xA;&#x9;&#x9;&#x9;&#x9;if(oldLink->retrieveFeatureValue(endData->getEnd())->getPosition() &lt; insertAt) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;insertAt = insertAt - 1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;newLink->assignFeatureValue(endData->getEnd(), this->takeTokens(endData->getValue()), insertAt);&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;this->getExecutionLocus()->add(newLink);"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_CreateObjectActionActivation"
          eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/Actions/CreateObjectActionActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="/*&#xA;#include &quot;fUML/Semantics/Activities/ActivityNodeActivationGroup.hpp&quot;&#xA;&#xA;#include &quot;uml/CreateObjectAction.hpp&quot;&#xA;#include &quot;uml/Class.hpp&quot;&#xA;#include &quot;fUML/Semantics/StructuredClassifiers/Reference.hpp&quot;&#xA;#include &quot;fUML/Semantics/StructuredClassifiers/Object.hpp&quot;&#xA;#include &quot;fUML/Semantics/Loci/Locus.hpp&quot;&#xA;#include &quot;fUML/Semantics/StructuredClassifiers/StructuredClassifiersFactory.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/CS_Object.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/CS_Reference.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/StructuredClassifiersFactory.hpp&quot;&#xA;*/"/>
        </eAnnotations>
        <eOperations name="doAction" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Create an object with the given classifier (which must be a class) as&#xA;&#x9;// its type, at the same locus as the action activation.&#xA;&#x9;// Place a reference to the object on the result pin of the action.&#xA;&#x9;// Extends fUML semantics in the sense that the reference placed&#xA;&#x9;// on the result pin is a CS_Reference (in the case where the instantiated object&#xA;&#x9;// is a CS_Object) not a Reference&#xA;&#x9;// Note that Locus.instantiate(Class) is extended in this specification&#xA;&#x9;// to produce a CS_Object instead of an Object in the case where the class&#xA;&#x9;// to be instantiated is not a behavior&#xA;&#xA;&#x9;std::shared_ptr&lt;uml::CreateObjectAction> action = this->getCreateObjectAction();&#xA;&#x9;&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Reference> reference;&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Object> referent = this->getExecutionLocus()->instantiate(std::dynamic_pointer_cast&lt;uml::Class>(action->getClassifier()));&#xA;&#x9;&#xA;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(referent) != nullptr) {&#xA;&#x9;&#x9;reference = PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_Reference();&#xA;&#x9;&#x9;(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(reference))->setCompositeReferent(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(referent));&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;reference = fUML::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createReference();&#xA;&#x9;}&#xA;&#x9;reference->setReferent(referent);&#xA;&#x9;&#xA;&#x9;this->putToken(action->getResult(), reference);"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_ConstructStrategy" abstract="true"
          eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/Loci/SemanticStrategy">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value=""/>
        </eAnnotations>
        <eOperations name="getName" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EString">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;&#x9;// a CS_ConstructionStrategy is always named &quot;constructStrategy&quot;&#xA;&#x9;return &quot;constructStrategy&quot;;"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="construct" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/StructuredClassifiers/Object">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="constructor" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
          <eParameters name="context" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Object"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_DefaultConstructStrategy" eSuperTypes="#//Semantics/Actions/CS_ConstructStrategy">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="/*&#xA;#include &quot;fUML/fUMLFactory.hpp&quot;&#xA;#include &lt;stdexcept>&#xA;&#xA;#include &quot;uml/Port.hpp&quot;&#xA;#include &quot;uml/TypedElement.hpp&quot;&#xA;#include &quot;uml/ValueSpecification.hpp&quot;&#xA;#include &quot;uml/InterfaceRealization.hpp&quot;&#xA;#include &quot;uml/umlFactory.hpp&quot;&#xA;#include &quot;uml/umlPackage.hpp&quot;&#xA;#include &quot;fUML/Semantics/SimpleClassifiers/FeatureValue.hpp&quot;&#xA;#include &quot;fUML/Semantics/Values/Evaluation.hpp&quot;&#xA;#include &quot;fUML/Semantics/Loci/ExecutionFactory.hpp&quot;&#xA;#include &quot;fUML/Semantics/CommonBehavior/ParameterValue.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/CS_InteractionPoint.hpp&quot;&#xA;#include &quot;PSCS/Semantics/Values/CS_OpaqueExpressionEvaluation.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/CS_Link.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/StructuredClassifiersFactory.hpp&quot;&#xA;*/"/>
        </eAnnotations>
        <eOperations name="addStructuralFeatureValue" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::FeatureValue> featureValue = context->retrieveFeatureValue(feature);&#xA;&#x9;if(featureValue != nullptr) {&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> values = featureValue->getValues();&#xA;&#xA;&#x9;&#x9;/*&#xA;&#x9;&#x9; * MDE4CPP-specific implementation: Since specialized references (i.e. CS_References vs. CS_InteractionPoints) are handled on a lower level,&#xA;&#x9;&#x9; * it is sufficient to just insert a CS_Reference at this point.&#xA;&#x9;&#x9; */&#xA;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference> reference = PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_Reference();&#xA;&#x9;&#x9;reference->setCompositeReferent(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(value));&#xA;&#x9;&#x9;reference->setReferent(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(value));&#xA;&#x9;&#x9;values->add(reference);&#xA;&#x9;&#x9;context->assignFeatureValue(feature, values, -1);&#xA;&#xA;&#x9;&#x9;/*ORIGINAL IMPLEMENTATION&#xA;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;uml::Port>(feature) != nullptr)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;// insert an interaction point&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_InteractionPoint> interactionPoint = PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_InteractionPoint();&#xA;&#x9;&#x9;&#x9;interactionPoint->setDefiningPort(std::dynamic_pointer_cast&lt;uml::Port>(feature));&#xA;&#x9;&#x9;&#x9;interactionPoint->setReferent(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(value));&#xA;&#x9;&#x9;&#x9;interactionPoint->setOwner(context);&#xA;&#x9;&#x9;&#x9;values->add(interactionPoint);&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(value) != nullptr)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;// insert a reference&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference> reference = PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_Reference();&#xA;&#x9;&#x9;&#x9;reference->setCompositeReferent(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(value));&#xA;&#x9;&#x9;&#x9;reference->setReferent(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(value));&#xA;&#x9;&#x9;&#x9;values->add(reference);&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;values->add(value);&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;*/&#xA;&#x9;}"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="context" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Reference"/>
          <eParameters name="feature" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Property"/>
          <eParameters name="value" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Values/Value"/>
        </eOperations>
        <eOperations name="canInstantiate" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EBoolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Instantiate is possible if:&#xA;&#x9;// - p is composite&#xA;&#x9;// - p is typed&#xA;&#x9;// - This type is a Class and it is not abstract&#xA;&#x9;// - Or p is a Port and the type is an Interface&#xA;&#xA;&#x9;if(p->isComposite()) {&#xA;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;uml::TypedElement>(p) != nullptr) {&#xA;&#x9;&#x9;&#x9;if(p->getType() != nullptr) {&#xA;&#x9;&#x9;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;uml::Class>(p->getType()) != nullptr) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return !((std::dynamic_pointer_cast&lt;uml::Class>(p->getType()))->getIsAbstract());&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if(std::dynamic_pointer_cast&lt;uml::Interface>(p->getType()) != nullptr) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return ((std::dynamic_pointer_cast&lt;uml::Port>(p)) != nullptr);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return false;"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="p" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Property"/>
        </eOperations>
        <eOperations name="constructObject" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/StructuredClassifiers/Object">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference> referenceToContext = PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_Reference();&#xA;&#x9;referenceToContext->setReferent(context);&#xA;&#x9;referenceToContext->setCompositeReferent(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(context));&#xA;&#x9;// FIXME detect infinite recursive instantiation&#xA;&#x9;std::shared_ptr&lt;Bag&lt;uml::Property>> allAttributes = type->getAttribute();&#xA;&#x9;unsigned int i = 1;&#xA;&#x9;// Instantiate ports and parts&#xA;&#x9;while(i &lt;= allAttributes->size()) {&#xA;&#x9;&#x9;std::shared_ptr&lt;uml::Property> p = allAttributes->at(i-1);&#xA;&#x9;&#x9;if(p->getDefaultValue() != nullptr) {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::ValueSpecification> defaultValueSpecification = p->getDefaultValue();&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::Values::Evaluation> evaluation = std::dynamic_pointer_cast&lt;fUML::Semantics::Values::Evaluation>(context->getLocus()->getFactory()->instantiateVisitor(defaultValueSpecification));&#xA;&#x9;&#x9;&#x9;evaluation->setSpecification(defaultValueSpecification);&#xA;&#x9;&#x9;&#x9;evaluation->setLocus(context->getLocus());&#xA;&#x9;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::Values::CS_OpaqueExpressionEvaluation>(evaluation) != nullptr) {&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> evaluations = (std::dynamic_pointer_cast&lt;PSCS::Semantics::Values::CS_OpaqueExpressionEvaluation>(evaluation))->executeExpressionBehavior();&#xA;&#x9;&#x9;&#x9;&#x9;for(unsigned int j = 0; j &lt; evaluations->size(); j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this->addStructuralFeatureValue(referenceToContext, p, evaluations->at(j));&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::Values::Value> defaultValue = evaluation->evaluate();&#xA;&#x9;&#x9;&#x9;&#x9;this->addStructuralFeatureValue(referenceToContext, p, defaultValue);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (this->canInstantiate(p)) {&#xA;&#x9;&#x9;&#x9;int j = 1;&#xA;&#x9;&#x9;&#x9;while(j &lt;= p->getLower()){&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Object> value;&#xA;&#x9;&#x9;&#x9;&#x9;// if p is a Port typed by an Interface&#xA;&#x9;&#x9;&#x9;&#x9;// creates an Object without type, but with FeatureValues corresponding to&#xA;&#x9;&#x9;&#x9;&#x9;// structural features of the interface.&#xA;&#x9;&#x9;&#x9;&#x9;if((std::dynamic_pointer_cast&lt;uml::Port>(p) != nullptr) &amp;&amp; (std::dynamic_pointer_cast&lt;uml::Interface>(p->getType()) != nullptr)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;value = this->instantiateInterface(std::dynamic_pointer_cast&lt;uml::Interface>(p->getType()), this->getLocus());&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this->addStructuralFeatureValue(referenceToContext, p, value);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;value = context->getLocus()->instantiate(std::dynamic_pointer_cast&lt;uml::Class>(p->getType()));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// TODO account for existing constructors&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;value = this->constructObject(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(value), std::dynamic_pointer_cast&lt;uml::Class>(p->getType()));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this->addStructuralFeatureValue(referenceToContext, p, std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(value));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if((std::dynamic_pointer_cast&lt;uml::Class>(p->getType()))->getIsActive()) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::CommonBehavior::ParameterValue>> parameterValues(new Bag&lt;fUML::Semantics::CommonBehavior::ParameterValue>());&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;value->startBehavior(std::dynamic_pointer_cast&lt;uml::Class>(p->getType()), parameterValues);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;j += 1;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;i += 1;&#xA;&#x9;}&#xA;&#x9;// Instantiate connectors&#xA;&#xA;&#x9;/*&#xA;&#x9; * MDE4CPP-specific implementation: We can directly access the types owned connectors rather than iterating over all members and&#xA;&#x9; * searching for owned connectors.&#xA;&#x9; */&#xA;&#x9;std::shared_ptr&lt;Bag&lt;uml::Connector>> allConnectors = type->getOwnedConnector();&#xA;&#x9;i = 1;&#xA;&#x9;unsigned int numberOfConnectors = allConnectors->size();&#xA;&#x9;while(i &lt;= numberOfConnectors) {&#xA;&#x9;&#x9;std::shared_ptr&lt;uml::Connector> connector = allConnectors->at(i-1);&#xA;&#x9;&#x9;&#x9;if(this->isArrayPattern(connector)) {&#xA;&#x9;&#x9;&#x9;&#x9;this->generateArrayPattern(referenceToContext, connector);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if(this->isStarPattern(connector)) {&#xA;&#x9;&#x9;&#x9;&#x9;this->generateStarPattern(referenceToContext, connector);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;i += 1;&#xA;&#x9;}&#xA;&#xA;&#x9;/*ORIGINAL IMPLEMENTATION&#xA;&#x9;std::shared_ptr&lt;Bag&lt;uml::NamedElement>> allMembers = type->getMember();&#xA;&#x9;i = 1;&#xA;&#x9;while(i &lt;= allMembers->size()) {&#xA;&#x9;&#x9;std::shared_ptr&lt;uml::NamedElement> member = allMembers->at(i-1);&#xA;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;uml::Connector>(member) != nullptr) {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::Connector> connector = std::dynamic_pointer_cast&lt;uml::Connector>(member);&#xA;&#x9;&#x9;&#x9;if(this->isArrayPattern(connector)) {&#xA;&#x9;&#x9;&#x9;&#x9;this->generateArrayPattern(referenceToContext, connector);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if(this->isStarPattern(connector)) {&#xA;&#x9;&#x9;&#x9;&#x9;this->generateStarPattern(referenceToContext, connector);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;i += 1;&#xA;&#x9;}&#xA;&#x9; */&#xA;&#x9;return referenceToContext->getReferent();"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="context" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Object"/>
          <eParameters name="type" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class"/>
        </eOperations>
        <eOperations name="generateArrayPattern" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;std::shared_ptr&lt;uml::ConnectorEnd> end1 = connector->getEnd()->at(0);&#xA;&#x9;std::shared_ptr&lt;uml::ConnectorEnd> end2 = connector->getEnd()->at(1);&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> end1Values =&#xA;&#x9;&#x9;&#x9;this->getValuesFromConnectorEnd(context, end1);&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> end2Values =&#xA;&#x9;&#x9;&#x9;this->getValuesFromConnectorEnd(context, end2);&#xA;&#x9;for (unsigned int i = 0; i &lt; end1Values->size(); i++) {&#xA;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Link> link =&#xA;&#x9;&#x9;&#x9;&#x9;PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_Link();&#xA;&#x9;&#x9;if (connector->getType() == nullptr) {&#xA;&#x9;&#x9;&#x9;link->setType(this->getDefaultAssociation());&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;link->setType(connector->getType());&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> valuesForEnd1(&#xA;&#x9;&#x9;&#x9;&#x9;new Bag&lt;fUML::Semantics::Values::Value>());&#xA;&#x9;&#x9;valuesForEnd1->add(end1Values->at(i));&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> valuesForEnd2(&#xA;&#x9;&#x9;&#x9;&#x9;new Bag&lt;fUML::Semantics::Values::Value>());&#xA;&#x9;&#x9;valuesForEnd2->add(end2Values->at(i));&#xA;&#x9;&#x9;link->assignFeatureValue(link->getType()->getMemberEnd()->at(0),&#xA;&#x9;&#x9;&#x9;&#x9;valuesForEnd1, -1);&#xA;&#x9;&#x9;link->assignFeatureValue(link->getType()->getMemberEnd()->at(1),&#xA;&#x9;&#x9;&#x9;&#x9;valuesForEnd2, -1);&#xA;&#x9;&#x9;link->addTo(context->getReferent()->getLocus());&#xA;&#x9;}"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="context" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Reference"/>
          <eParameters name="connector" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Connector"/>
        </eOperations>
        <eOperations name="generateStarPattern" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="std::shared_ptr&lt;uml::ConnectorEnd> end1 = connector->getEnd()->at(0);&#xA;&#x9;std::shared_ptr&lt;uml::ConnectorEnd> end2 = connector->getEnd()->at(1);&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> end1Values =&#xA;&#x9;&#x9;&#x9;this->getValuesFromConnectorEnd(context, end1);&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> end2Values =&#xA;&#x9;&#x9;&#x9;this->getValuesFromConnectorEnd(context, end2);&#xA;&#x9;for (unsigned int i = 0; i &lt; end1Values->size(); i++) {&#xA;&#x9;&#x9;for (unsigned int j = 0; j &lt; end2Values->size(); j++) {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Link> link =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_Link();&#xA;&#x9;&#x9;&#x9;if (connector->getType() == nullptr) {&#xA;&#x9;&#x9;&#x9;&#x9;link->setType(this->getDefaultAssociation());&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;link->setType(connector->getType());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> valuesForEnd1(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;new Bag&lt;fUML::Semantics::Values::Value>());&#xA;&#x9;&#x9;&#x9;valuesForEnd1->add(end1Values->at(i));&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> valuesForEnd2(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;new Bag&lt;fUML::Semantics::Values::Value>());&#xA;&#x9;&#x9;&#x9;valuesForEnd2->add(end2Values->at(j));&#xA;&#x9;&#x9;&#x9;link->assignFeatureValue(link->getType()->getMemberEnd()->at(0),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;valuesForEnd1, -1);&#xA;&#x9;&#x9;&#x9;link->assignFeatureValue(link->getType()->getMemberEnd()->at(1),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;valuesForEnd2, -1);&#xA;&#x9;&#x9;&#x9;link->addTo(context->getReferent()->getLocus());&#xA;&#x9;&#x9;}&#xA;&#x9;}"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="context" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Reference"/>
          <eParameters name="connector" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Connector"/>
        </eOperations>
        <eOperations name="getCardinality" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EInt">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;&#x9;int lowerOfRole;&#xA;&#x9;if(std::dynamic_pointer_cast&lt;uml::MultiplicityElement>(end->getRole()) != nullptr){&#xA;&#x9;&#x9;lowerOfRole = (std::dynamic_pointer_cast&lt;uml::MultiplicityElement>(end->getRole()))->getLower();&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;std::string errorMessage = &quot;UnexpectedTypeException in PSCS::Semantics::Actions::CS_DefaultConstructStrategyImpl::getCardinality(): unexpected type '&quot;&#xA;&#x9;&#x9;+ end->getRole()->eClass()->getName() + &quot;' is not an instance of uml::MultiplicityElement\n&quot;;&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;throw std::runtime_error(errorMessage);&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;if(lowerOfRole == 0) {&#xA;&#x9;&#x9;return 0;&#xA;&#x9;}&#xA;&#x9;else if (end->getPartWithPort() == nullptr) {&#xA;&#x9;&#x9;return lowerOfRole;&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;int lowerOfPart = end->getPartWithPort()->getLower();&#xA;&#x9;&#x9;return (lowerOfRole * lowerOfPart);&#xA;&#x9;}"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="end" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//ConnectorEnd"/>
        </eOperations>
        <eOperations name="getValuesFromConnectorEnd" ordered="false" upperBound="-1"
            eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Values/Value">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> endValues(new Bag&lt;fUML::Semantics::Values::Value>());&#xA;&#x9;if(end->getPartWithPort() != nullptr) {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::FeatureValue> valueForPart = context->retrieveFeatureValue(end->getPartWithPort());&#xA;&#x9;&#x9;if(valueForPart != nullptr) {&#xA;&#x9;&#x9;&#x9;for(unsigned int i = 0; i &lt; valueForPart->getValues()->size(); i++) {&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Reference> reference = std::dynamic_pointer_cast&lt;fUML::Semantics::StructuredClassifiers::Reference>(valueForPart->getValues()->at(i));&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::FeatureValue> valueForPort = reference->retrieveFeatureValue(std::dynamic_pointer_cast&lt;uml::Port>(end->getRole()));&#xA;&#x9;&#x9;&#x9;&#x9;if(valueForPort != nullptr) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for(unsigned int j = 0; j &lt; valueForPort->getValues()->size(); j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;endValues->add(valueForPort->getValues()->at(j));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::FeatureValue> valueForRole = context->retrieveFeatureValue(std::dynamic_pointer_cast&lt;uml::Property>(end->getRole()));&#xA;&#x9;&#x9;if(valueForRole != nullptr) {&#xA;&#x9;&#x9;&#x9;for (unsigned int i = 0; i &lt; valueForRole->getValues()->size(); i++) {&#xA;&#x9;&#x9;&#x9;&#x9;endValues->add(valueForRole->getValues()->at(i));&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return endValues;"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="context" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Reference"/>
          <eParameters name="end" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//ConnectorEnd"/>
        </eOperations>
        <eOperations name="isArrayPattern" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EBoolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// This is an array pattern if:&#xA;&#x9;// - c is binary&#xA;&#x9;// - lower bound of the two connector ends is 1&#xA;&#x9;// - Cardinality of ends are equals&#xA;&#xA;&#x9;if (c->getEnd()->size() == 2) {&#xA;&#x9;&#x9;if (std::dynamic_pointer_cast&lt;uml::MultiplicityElement>(&#xA;&#x9;&#x9;&#x9;&#x9;c->getEnd()->at(0)->getRole()) != nullptr) {&#xA;&#x9;&#x9;&#x9;if (c->getEnd()->at(0)->getLower() == 1) {&#xA;&#x9;&#x9;&#x9;&#x9;if (std::dynamic_pointer_cast&lt;uml::MultiplicityElement>(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;c->getEnd()->at(1)->getRole()) != nullptr) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (c->getEnd()->at(1)->getLower() == 1) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if ((this->canInstantiate(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;std::dynamic_pointer_cast&lt;uml::Property>(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;c->getEnd()->at(0)->getRole())))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&amp;&amp; (this->canInstantiate(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;std::dynamic_pointer_cast&lt;uml::Property>(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;c->getEnd()->at(1)->getRole())))) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;int cardinality1 = this->getCardinality(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;c->getEnd()->at(0));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;int cardinality2 = this->getCardinality(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;c->getEnd()->at(1));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return (cardinality1 == cardinality2);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;std::string errorMessage =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&quot;UnexpectedTypeException in PSCS::Semantics::Actions::CS_DefaultConstructStrategyImpl::isArrayPattern(): unexpected type '&quot;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;+ c->getEnd()->at(1)->getRole()->eClass()->getName()&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;+ &quot;' is not an instance of uml::MultiplicityElement\n&quot;;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;throw std::runtime_error(errorMessage);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;std::string errorMessage =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&quot;UnexpectedTypeException in PSCS::Semantics::Actions::CS_DefaultConstructStrategyImpl::isArrayPattern(): unexpected type '&quot;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;+ c->getEnd()->at(0)->getRole()->eClass()->getName()&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;+ &quot;' is not an instance of uml::MultiplicityElement\n&quot;;&#xA;&#xA;&#x9;&#x9;&#x9;throw std::runtime_error(errorMessage);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return false;"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="c" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Connector"/>
        </eOperations>
        <eOperations name="isStarPattern" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EBoolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;&#x9;// This is a star pattern if:&#xA;&#x9;// - c is binary&#xA;&#x9;// - lower bound of end1 equals cardinality of end1&#xA;&#x9;// - lower bound of end2 equals cardinality of end2&#x9;&#xA;&#xA;&#x9; if(c->getEnd()->size() == 2) {&#xA;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;uml::MultiplicityElement>(c->getEnd()->at(0)->getRole())) {&#xA;&#x9;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;uml::MultiplicityElement>(c->getEnd()->at(1)->getRole())) {&#xA;&#x9;&#x9;&#x9;&#x9;if((this->canInstantiate(std::dynamic_pointer_cast&lt;uml::Property>(c->getEnd()->at(0)->getRole()))) &amp;&amp; (this->canInstantiate(std::dynamic_pointer_cast&lt;uml::Property>(c->getEnd()->at(1)->getRole())))) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;int cardinalityOfEnd1 = this->getCardinality(c->getEnd()->at(0));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;int lowerBoundofEnd1 = std::dynamic_pointer_cast&lt;uml::MultiplicityElement>(c->getEnd()->at(0)->getRole())->getLower();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (cardinalityOfEnd1 == lowerBoundofEnd1) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;int cardinalityOfEnd2 = this->getCardinality(c->getEnd()->at(1));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;int lowerBoundofEnd2 = std::dynamic_pointer_cast&lt;uml::MultiplicityElement>(c->getEnd()->at(1)->getRole())->getLower();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return (cardinalityOfEnd2 == lowerBoundofEnd2);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;std::string errorMessage = &quot;UnexpectedTypeException in PSCS::Semantics::Actions::CS_DefaultConstructStrategyImpl::isStarPattern(): unexpected type '&quot;&#xA;&#x9;&#x9;&#x9;&#x9;+ c->getEnd()->at(1)->getRole()->eClass()->getName() + &quot;' is not an instance of uml::MultiplicityElement\n&quot;;&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;throw std::runtime_error(errorMessage);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;std::string errorMessage = &quot;UnexpectedTypeException in PSCS::Semantics::Actions::CS_DefaultConstructStrategyImpl::isStarPattern(): unexpected type '&quot;&#xA;&#x9;&#x9;&#x9;+ c->getEnd()->at(0)->getRole()->eClass()->getName() + &quot;' is not an instance of uml::MultiplicityElement\n&quot;;&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;throw std::runtime_error(errorMessage);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;return false;"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="c" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Connector"/>
        </eOperations>
        <eOperations name="getDefaultAssociation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Association">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;&#x9;// Computes an returns an Association with two untyped owned ends,&#xA;&#x9;// with multiplicity [*].&#xA;&#x9;// This association can be used to type links instantiated from untyped connec&#xA;&#x9;&#xA;&#x9;if(m_defaultAssociation == nullptr) {&#xA;&#x9;&#x9;m_defaultAssociation = uml::umlFactory::eInstance()->createAssociation();&#xA;&#x9;&#x9;m_defaultAssociation->setName(&quot;DefaultGeneratedAssociation&quot;);&#xA;&#x9;&#x9;std::shared_ptr&lt;uml::Property> end1 = uml::umlFactory::eInstance()->createProperty();&#xA;&#x9;&#x9;end1->setName(&quot;x&quot;);&#xA;&#x9;&#x9;end1->setLower(0);&#xA;&#x9;&#x9;end1->setUpper(-1);&#xA;&#x9;&#x9;end1->setIsOrdered(true);&#xA;&#x9;&#x9;end1->setIsUnique(true);&#xA;&#x9;&#x9;m_defaultAssociation->getOwnedEnd()->add(end1);&#xA;&#x9;&#x9;std::shared_ptr&lt;uml::Property> end2 = uml::umlFactory::eInstance()->createProperty();&#xA;&#x9;&#x9;end2->setName(&quot;y&quot;);&#xA;&#x9;&#x9;end2->setLower(0);&#xA;&#x9;&#x9;end2->setUpper(-1);&#xA;&#x9;&#x9;end2->setIsOrdered(true);&#xA;&#x9;&#x9;end2->setIsUnique(true);&#xA;&#x9;&#x9;m_defaultAssociation->getOwnedEnd()->add(end2);&#xA;&#x9;}&#xA;&#x9;return m_defaultAssociation;"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="instantiateInterface" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/StructuredClassifiers/Object">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;&#x9;std::shared_ptr&lt;uml::Class> realizingClass = this->getRealizingClass(interface);&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Object> object = locus->instantiate(realizingClass);&#xA;&#x9;return object;"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="interface" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Interface"/>
          <eParameters name="locus" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Loci/Locus"/>
        </eOperations>
        <eOperations name="getRealizingClass" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;&#x9;std::shared_ptr&lt;uml::Class> realizingClass = nullptr;&#xA;&#x9;// TODO For cached RealizingClasses, search based on InterfaceRealizations rather than name&#xA;&#x9;std::string realizingClassName = interface_->getQualifiedName() + &quot;GeneratedRealizingClass&quot;;&#xA;&#x9;unsigned int i = 0;&#xA;&#x9;while((i &lt;= m_generatedRealizingClasses->size()) &amp;&amp; (realizingClass == nullptr)) {&#xA;&#x9;&#x9;std::shared_ptr&lt;uml::Class> cddRealizingClass = m_generatedRealizingClasses->at(i-1);&#xA;&#x9;&#x9;if(cddRealizingClass->getName() == realizingClassName) {&#xA;&#x9;&#x9;&#x9;realizingClass = cddRealizingClass;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;i += 1;&#xA;&#x9;}&#xA;&#x9;if(realizingClass == nullptr) {&#xA;&#x9;&#x9;realizingClass = this->generateRealizingClass(interface_, realizingClassName);&#xA;&#x9;&#x9;m_generatedRealizingClasses->add(realizingClass);&#xA;&#x9;}&#xA;&#x9;return realizingClass;"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="interface_" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Interface"/>
        </eOperations>
        <eOperations name="generateRealizingClass" ordered="false" lowerBound="1"
            eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;&#x9;std::shared_ptr&lt;uml::Class> realizingClass = uml::umlFactory::eInstance()->createClass();&#xA;&#x9;realizingClass->setName(className);&#xA;&#x9;std::shared_ptr&lt;uml::InterfaceRealization> realization = uml::umlFactory::eInstance()->createInterfaceRealization();&#xA;&#x9;realization->setContract(interface_);&#xA;&#x9;realization->setImplementingClassifier(realizingClass);&#xA;&#x9;realizingClass->getInterfaceRealization()->add(realization);&#xA;&#x9;// TODO Deal with structural features of the interface&#xA;&#x9;// TODO Make a test case for reading/writing structural features of an interface&#xA;&#x9;return realizingClass;"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="interface_" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Interface"/>
          <eParameters name="className" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EString"/>
        </eOperations>
        <eOperations name="construct" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/StructuredClassifiers/Object">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;this->setLocus(context->getLocus());&#xA;&#x9;return this->constructObject(context, std::dynamic_pointer_cast&lt;uml::Class>(constructor->getType()));"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="constructor" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
          <eParameters name="context" eType="#//Semantics/StructuredClassifiers/CS_Object"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="locus" ordered="false"
            lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Loci/Locus"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="defaultAssociation"
            ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Association"
            containment="true"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="generatedRealizingClasses"
            ordered="false" upperBound="-1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class"
            containment="true"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_ReadExtentActionActivation" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/Actions/ReadExtentActionActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="/*&#xA;#include &quot;fUML/Semantics/Activities/ActivityNodeActivationGroup.hpp&quot;&#xA;&#xA;#include &quot;uml/ReadExtentAction.hpp&quot;&#xA;#include &quot;fUML/Semantics/Values/Value.hpp&quot;&#xA;#include &quot;fUML/Semantics/StructuredClassifiers/Object.hpp&quot;&#xA;#include &quot;fUML/Semantics/StructuredClassifiers/Reference.hpp&quot;&#xA;#include &quot;fUML/Semantics/StructuredClassifiers/StructuredClassifiersFactory.hpp&quot;&#xA;#include &quot;fUML/Semantics/Loci/Locus.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/CS_Object.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/CS_Reference.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/StructuredClassifiersFactory.hpp&quot;&#xA;*/"/>
        </eAnnotations>
        <eOperations name="doAction" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Get the extent, at the current execution locus, of the classifier&#xA;&#x9;// (which must be a class) identified in the action.&#xA;&#x9;// Place references to the resulting set of objects on the result pin.&#xA;&#x9;// Extends default fUML semantics in the sense that produced tokens contain&#xA;&#x9;// CS_References instead of References, in the case where the object is a&#xA;&#x9;// CS_Object&#xA;&#xA;&#x9;std::shared_ptr&lt;uml::ReadExtentAction> action = std::dynamic_pointer_cast&lt;uml::ReadExtentAction>(this->getNode());&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::ExtensionalValue>> objects = this->getExecutionLocus()->retrieveExtent(action->getClassifier());&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> references(new Bag&lt;fUML::Semantics::Values::Value>());&#xA;&#x9;&#xA;&#x9;for(unsigned int i = 0; i &lt; objects->size(); i++) {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::Values::Value> object = objects->at(i);&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Reference> reference = nullptr;&#xA;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(object) != nullptr) {&#xA;&#x9;&#x9;&#x9;reference = PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_Reference();&#xA;&#x9;&#x9;&#x9;(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(reference))->setCompositeReferent(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(object));&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;reference = fUML::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createReference();&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;reference->setReferent(std::dynamic_pointer_cast&lt;fUML::Semantics::StructuredClassifiers::Object>(object));&#xA;&#x9;&#x9;references->add(reference);&#xA;&#x9;}&#x9;&#xA;&#x9;this->putTokens(action->getResult(), references);"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_ReadSelfActionActivation" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/Actions/ReadSelfActionActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="/*&#xA;#include &quot;fUML/Semantics/Activities/ActivityNodeActivationGroup.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/CS_Object.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/CS_Reference.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/StructuredClassifiersFactory.hpp&quot;&#xA;#include &quot;uml/OutputPin.hpp&quot;&#xA;#include &quot;uml/ReadSelfAction.hpp&quot;&#xA;*/"/>
        </eAnnotations>
        <eOperations name="doAction" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Get the context object of the activity execution containing this&#xA;&#x9;// action activation and place a reference to it on the result output&#xA;&#x9;// pin.&#xA;&#x9;// Extends fUML semantics in the sense that the reference placed on&#xA;&#x9;// the result pin is a CS_Reference, not a Reference&#xA;&#xA;&#x9;//DEBUG_MESSAGE(std::cout &lt;&lt; &quot;[ReadSelfActionActivation] Start...&quot; &lt;&lt; std::endl;)&#xA;&#x9;&#xA;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference> context = PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_Reference();&#xA;&#x9;context->setReferent(this->getExecutionContext());&#xA;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(context->getReferent()) != nullptr) {&#xA;&#x9;&#x9;// i.e. alternatively, it can be an execution&#xA;&#x9;&#x9;context->setCompositeReferent(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(context->getReferent()));&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;//DEBUG_MESSAGE(std::cout &lt;&lt; &quot;[ReadSelfActionActivation] context object = &quot; &lt;&lt; context->getReferent()->toString() &lt;&lt; std::endl;)&#xA;&#x9;&#xA;&#x9;std::shared_ptr&lt;uml::OutputPin> resultPin = this->getReadSelfAction()->getResult();&#xA;&#x9;this->putToken(resultPin, context);"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_RemoveStructuralFeatureValueActionActivation"
          eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/Actions/RemoveStructuralFeatureValueActionActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="/*&#xA;#include &quot;fUML/Semantics/Activities/ActivityNodeActivationGroup.hpp&quot;&#xA;&#xA;#include &quot;uml/RemoveStructuralFeatureValueAction.hpp&quot;&#xA;#include &quot;uml/Association.hpp&quot;&#xA;#include &quot;uml/Port.hpp&quot;&#xA;#include &quot;fUML/Semantics/SimpleClassifiers/UnlimitedNaturalValue.hpp&quot;&#xA;#include &quot;fUML/Semantics/Loci/Locus.hpp&quot;&#xA;#include &quot;fUML/Semantics/Loci/ExecutionFactory.hpp&quot;&#xA;#include &quot;fUML/Semantics/Loci/ChoiceStrategy.hpp&quot;&#xA;#include &quot;fUML/Semantics/StructuredClassifiers/Reference.hpp&quot;&#xA;#include &quot;fUML/Semantics/SimpleClassifiers/FeatureValue.hpp&quot;&#xA;#include &quot;fUML/Semantics/StructuredClassifiers/ExtensionalValue.hpp&quot;&#xA;#include &quot;fUML/Semantics/StructuredClassifiers/StructuredClassifiersFactory.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/StructuredClassifiersFactory.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/CS_InteractionPoint.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/CS_Object.hpp&quot;&#xA;#include &quot;fUML/Semantics/Activities/ActivityExecution.hpp&quot;&#xA;#include &quot;uml/InputPin.hpp&quot;&#xA;*/"/>
        </eAnnotations>
        <eOperations name="doAction" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Get the values of the object and value input pins.&#xA;&#x9;// If the given feature is an association end, then destroy any&#xA;&#x9;// matching links. Otherwise, if the object input is a structural&#xA;&#x9;// value, remove values from the given feature and destroy all links&#xA;&#x9;// in which the removed values are involved.&#xA;&#x9;// If isRemoveDuplicates is true, then destroy all current matching&#xA;&#x9;// links or remove all values equal to the input value.&#xA;&#x9;// If isRemoveDuplicates is false and there is no removeAt input pin,&#xA;&#x9;// remove any one feature value equal to the input value (if there are&#xA;&#x9;// any that are equal).&#xA;&#x9;// If isRemoveDuplicates is false, and there is a removeAt input pin&#xA;&#x9;// remove the feature value at that position.&#xA;&#xA;&#x9;std::shared_ptr&lt;uml::RemoveStructuralFeatureValueAction> action = this->getRemoveStructuralFeatureValueAction();&#xA;&#x9;std::shared_ptr&lt;uml::StructuralFeature> feature = action->getStructuralFeature();&#xA;&#x9;/* Since links are represented implicitly in MDE4CPP, handling of links when adding a structural feature value is bypassed here*/&#xA;&#x9;std::shared_ptr&lt;uml::Association> association = nullptr; //this->getAssociation(feature);&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::Values::Value> value = nullptr;&#x9;&#x9;&#xA;&#xA;&#x9;/* MDE4CPP specific implementation for handling &quot;self&quot;-Pin */&#xA;&#x9;std::string targetPinName = action->getObject()->getName();&#xA;&#x9;if((targetPinName.empty()) || (targetPinName.find(&quot;self&quot;) == 0)){&#xA;&#x9;&#x9;//target is set to the context of the current activity execution&#xA;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference> contextReference = PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_Reference();&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Object> context = this->getActivityExecution()->getContext();&#xA;&#x9;&#x9;contextReference->setReferent(context);&#xA;&#x9;&#x9;contextReference->setCompositeReferent(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(context));&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;value = contextReference;&#xA;&#x9;}&#xA;&#x9;else{&#xA;&#x9;&#x9;value = this->takeTokens(action->getObject())->at(0);&#xA;&#x9;}&#xA;&#x9;/*--------------------------------------------------------*/&#xA;&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::Values::Value> inputValue = nullptr;&#xA;&#x9;if(action->getValue() != nullptr) {&#xA;&#x9;&#x9;// NOTE: Multiplicity of the value input pin is required to be 1..1.&#xA;&#x9;&#x9;inputValue = this->takeTokens(action->getValue())->at(0);&#xA;&#x9;}&#xA;&#xA;&#x9;int removeAt = 0;&#xA;&#x9;if(action->getRemoveAt() != nullptr) {&#xA;&#x9;&#x9;removeAt = (std::dynamic_pointer_cast&lt;fUML::Semantics::SimpleClassifiers::UnlimitedNaturalValue>(this->takeTokens(action->getRemoveAt())->at(0)))->getValue();&#xA;&#x9;}&#xA;&#x9;if(association != nullptr) {&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Link>> links = this->getMatchingLinksForEndValue(association, feature, value, inputValue);&#xA;&#x9;&#x9;if(action->getIsRemoveDuplicates()) {&#xA;&#x9;&#x9;&#x9;for(unsigned int i = 0; i &lt; links->size(); i++) {&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Link> link = links->at(i);&#xA;&#x9;&#x9;&#x9;&#x9;link->destroy();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if(action->getRemoveAt() == nullptr) {&#xA;&#x9;&#x9;&#x9;// *** If there is more than one matching link,&#xA;&#x9;&#x9;&#x9;// non-deterministically choose one. ***&#xA;&#x9;&#x9;&#x9;if(links->size() > 0) {&#xA;&#x9;&#x9;&#x9;&#x9;int i = (std::dynamic_pointer_cast&lt;fUML::Semantics::Loci::ChoiceStrategy>(this->getExecutionLocus()->getFactory()->getStrategy(&quot;choice&quot;)))->choose(links->size());&#xA;&#x9;&#x9;&#x9;&#x9;links->at(i-1)->destroy();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;bool notFound = true;&#xA;&#x9;&#x9;&#x9;unsigned int i = 1;&#xA;&#x9;&#x9;&#x9;while((notFound) &amp;&amp; (i &lt;= links->size())) {&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Link> link = links->at(i-1);&#xA;&#x9;&#x9;&#x9;&#x9;if(link->retrieveFeatureValue(feature)->getPosition() == removeAt) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;notFound = false;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;link->destroy();&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else if (std::dynamic_pointer_cast&lt;fUML::Semantics::SimpleClassifiers::StructuredValue>(value) != nullptr) {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::StructuredValue> structuredValue = std::dynamic_pointer_cast&lt;fUML::Semantics::SimpleClassifiers::StructuredValue>(value);&#xA;&#xA;&#x9;&#x9;// If the value is a data value, then it must be copied before&#xA;&#x9;&#x9;// any change is made.&#xA;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;fUML::Semantics::StructuredClassifiers::Reference>(value) == nullptr) {&#xA;&#x9;&#x9;&#x9;value = std::dynamic_pointer_cast&lt;fUML::Semantics::Values::Value>(value->copy());&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::FeatureValue> featureValue = structuredValue->retrieveFeatureValue(feature);&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> removedValues(new Bag&lt;fUML::Semantics::Values::Value>());&#xA;&#xA;&#x9;&#x9;if(action->getIsRemoveDuplicates()) {&#xA;&#x9;&#x9;&#x9;unsigned int j = this->position(inputValue, featureValue->getValues(), 1);&#xA;&#x9;&#x9;&#x9;while(j > 0) {&#xA;&#x9;&#x9;&#x9;&#x9;removedValues->add(featureValue->getValues()->at(j-1));&#xA;&#x9;&#x9;&#x9;&#x9;//featureValue->getValues()->erase(featureValue->getValues()->begin() + (j-1));&#xA;&#x9;&#x9;&#x9;&#x9;structuredValue->removeValue(feature, featureValue->getValues()->at(j-1));&#xA;&#x9;&#x9;&#x9;&#x9;j = this->position(inputValue, featureValue->getValues(), j);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if(action->getRemoveAt() == nullptr) {&#xA;&#x9;&#x9;&#x9;std::vector&lt;unsigned int> positions;&#xA;&#x9;&#x9;&#x9;/*!&#xA;&#x9;&#x9;&#x9;Hier sitzt das Problem: in position() liefert der Vergleich zwischen inputValue und dem Value im extrahierten FeatureValue ungleich (msste gleich sein)&#xA;&#x9;&#x9;&#x9;--> da ohnehin bisher als ChoiceStrategy nur die FirstChoiceStrategy in der fUML implementiert ist wird dieser Code vorerst ersetzt durch die fUML-Funktionalitt&#xA;&#x9;&#x9;&#x9;*/&#xA;&#x9;&#x9;&#x9;/*&#xA;&#x9;&#x9;&#x9;unsigned int j = this->position(inputValue, featureValue->getValues(), 1);&#xA;&#xA;&#x9;&#x9;&#x9;std::cout&lt;&lt;&quot;inputValue* : &quot;&lt;&lt;inputValue.get()&lt;&lt;std::endl;&#xA;&#x9;&#x9;&#x9;std::cout&lt;&lt;&quot;retrievedValue* : &quot;&lt;&lt;featureValue->getValues()->at(0).get()&lt;&lt;std::endl;&#xA;&#xA;&#x9;&#x9;&#x9;while(j > 0) {&#xA;&#x9;&#x9;&#x9;&#x9;positions.push_back(j);&#xA;&#x9;&#x9;&#x9;&#x9;j = this->position(inputValue, featureValue->getValues(), j);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;if(positions.size() > 0) {&#xA;&#x9;&#x9;&#x9;&#x9;// *** Nondeterministically choose which value to remove.&#xA;&#x9;&#x9;&#x9;&#x9;// ***&#xA;&#x9;&#x9;&#x9;&#x9;int k = (std::dynamic_pointer_cast&lt;fUML::Semantics::Loci::ChoiceStrategy>(this->getExecutionLocus()->getFactory()->getStrategy(&quot;choice&quot;)))->choose(positions.size());&#xA;&#x9;&#x9;&#x9;&#x9;removedValues->add(featureValue->getValues()->at(positions.at(k-1)-1));&#xA;&#x9;&#x9;&#x9;&#x9;//featureValue->getValues()->erase(featureValue->getValues()->begin() + (positions.at(k-1)-1));&#xA;&#x9;&#x9;&#x9;&#x9;structuredValue->removeValue(feature, featureValue->getValues()->at(positions.at(k-1)-1));&#xA;&#x9;&#x9;&#x9;}*/&#xA;&#x9;&#x9;&#x9;removedValues->add(inputValue);&#xA;&#x9;&#x9;&#x9;structuredValue->removeValue(feature, inputValue);&#xA;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;if((int)featureValue->getValues()->size() >= removeAt) {&#xA;&#x9;&#x9;&#x9;&#x9;removedValues->add(featureValue->getValues()->at(removeAt-1));&#xA;&#x9;&#x9;&#x9;&#x9;//featureValue->getValues()->erase(featureValue->getValues()->begin() + (removeAt-1));&#xA;&#x9;&#x9;&#x9;&#x9;structuredValue->removeValue(feature, featureValue->getValues()->at(removeAt-1));&#xA;&#x9;&#x9;&#x9;&#x9;featureValue = structuredValue->retrieveFeatureValue(feature);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;// When values are removed from the list of values associated to the feature&#xA;&#x9;&#x9;// (in the context of the target), these latter may be involved in links representing&#xA;&#x9;&#x9;// instance of connectors. If this is the case, links in which the removed values are&#xA;&#x9;&#x9;// involved are destroyed.&#xA;&#x9;&#x9;/*!&#xA;&#x9;&#x9;&#x9;This functionality is excluded from PSCS in MDE4CPP because link destruction is handled on model level, not execution level.&#xA;&#x9;&#x9;*/&#xA;&#x9;&#x9;/*for(unsigned int i = 0; i &lt; removedValues->size(); i++) {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;PSCS::Semantics::StructuredClassifiers::CS_Link>> linkToDestroy = this->getLinksToDestroy(std::dynamic_pointer_cast&lt;fUML::Semantics::SimpleClassifiers::StructuredValue>(value), feature, removedValues->at(i));&#xA;&#x9;&#x9;&#x9;for(unsigned int j = 0; j &lt; linkToDestroy->size(); j++) {&#xA;&#x9;&#x9;&#x9;&#x9;linkToDestroy->at(j)->destroy();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}*/&#xA;&#x9;}&#xA;&#x9;if(action->getResult() != nullptr) {&#xA;&#x9;&#x9;this->putToken(action->getResult(), value);&#xA;&#x9;}"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="getLinksToDestroy" ordered="false" upperBound="-1" eType="#//Semantics/StructuredClassifiers/CS_Link">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Get all links that are required to be destroyed due to the removal of the removedValue&#xA;&#x9;std::shared_ptr&lt;Bag&lt;PSCS::Semantics::StructuredClassifiers::CS_Link>> linksToDestroy(new Bag&lt;PSCS::Semantics::StructuredClassifiers::CS_Link>());&#xA;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(value) != nullptr) {&#xA;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference> context = std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(value);&#xA;&#x9;&#x9;// Retrieves the feature values for the structural feature associated with this action,&#xA;&#x9;&#x9;// in the context of this reference&#xA;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;uml::Port>(feature) != nullptr) {&#xA;&#x9;&#x9;&#x9;// The removed value is an interaction point.&#xA;&#x9;&#x9;&#x9;// All links in which this interaction is involved must be destroyed.&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_InteractionPoint> interactionPoint = std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_InteractionPoint>(removedValue);&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;PSCS::Semantics::StructuredClassifiers::CS_Link>> connectorInstances = context->getCompositeReferent()->getLinks(interactionPoint);&#xA;&#x9;&#x9;&#x9;for(unsigned int j = 0; j &lt; connectorInstances->size(); j++) {&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Link> link = connectorInstances->at(j);&#xA;&#x9;&#x9;&#x9;&#x9;linksToDestroy->add(link);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;// Feature is not a Port. Search for all potential link&#xA;&#x9;&#x9;&#x9;// ends existing in the context of this object.&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> allValuesForFeature(new Bag&lt;fUML::Semantics::Values::Value>());&#xA;&#x9;&#x9;&#x9;for(unsigned int i = 0; i &lt; context->getReferent()->retrieveFeatureValues()->size(); i++) {&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::StructuralFeature> currentFeature = context->getReferent()->retrieveFeatureValues()->at(i)->getFeature();&#xA;&#x9;&#x9;&#x9;&#x9;if(feature != currentFeature) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> values = this->getPotentialLinkEnds(context, currentFeature);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for(unsigned int j = 0; j &lt; values->size(); j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;allValuesForFeature->add(values->at(j));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;// Retrieves all links available at the locus&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::ExtensionalValue>> extensionalValues = this->getExecutionLocus()->getExtensionalValues();&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;PSCS::Semantics::StructuredClassifiers::CS_Link>> allLinks(new Bag&lt;PSCS::Semantics::StructuredClassifiers::CS_Link>());&#xA;&#x9;&#x9;&#x9;for(unsigned int i = 0; i &lt; extensionalValues->size(); i++) {&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::ExtensionalValue> extensionalValue = extensionalValues->at(i);&#xA;&#x9;&#x9;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Link>(extensionalValue) != nullptr) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;allLinks->add(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Link>(extensionalValue));&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;// In the set of links involving potential link ends. Search for all&#xA;&#x9;&#x9;&#x9;// links that involve the removed value in other end. Any link in that&#xA;&#x9;&#x9;&#x9;// fulfill this condition is registered in the set of link to be destroyed.&#xA;&#x9;&#x9;&#x9;for(unsigned int i = 0; i &lt; allLinks->size(); i++) {&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Link> link = allLinks->at(i);&#xA;&#x9;&#x9;&#x9;&#x9;bool linkHasToBeDestroyed = false;&#xA;&#x9;&#x9;&#x9;&#x9;for(unsigned int j = 0; (j &lt; allValuesForFeature->size()) &amp;&amp; (!linkHasToBeDestroyed); j++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::Values::Value> v = allValuesForFeature->at(j);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::StructuralFeature> featureForV = link->getFeature(v);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(featureForV != nullptr) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for(unsigned int k = 0; (k &lt; link->getFeatureValues()->size()) &amp;&amp; (!linkHasToBeDestroyed); k++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::FeatureValue> otherFeatureValue = link->getFeatureValues()->at(k);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(otherFeatureValue->getFeature() != featureForV) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for(unsigned int l = 0; (l &lt; otherFeatureValue->getValues()->size()) &amp;&amp; (!linkHasToBeDestroyed); l++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(otherFeatureValue->getValues()->at(l) == removedValue) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;linkHasToBeDestroyed = true;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if(linkHasToBeDestroyed) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;linksToDestroy->add(link);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return linksToDestroy;"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="value" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/SimpleClassifiers/StructuredValue"/>
          <eParameters name="feature" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//StructuralFeature"/>
          <eParameters name="removedValue" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Values/Value"/>
        </eOperations>
        <eOperations name="getPotentialLinkEnds" ordered="false" upperBound="-1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Values/Value">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;&#x9;// Retrieves all feature values for the context object for the given feature,&#xA;&#x9;// as well as all interaction point for these values&#xA;&#x9;&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> potentialLinkEnds(new Bag&lt;fUML::Semantics::Values::Value>());&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::FeatureValue> featureValue = context->retrieveFeatureValue(feature);&#xA;&#x9;for(unsigned int i = 0; i &lt; featureValue->getValues()->size(); i++) {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::Values::Value> v = featureValue->getValues()->at(i);&#xA;&#x9;&#x9;potentialLinkEnds->add(v);&#xA;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(v) != nullptr) {&#xA;&#x9;&#x9;&#x9;// add all interaction points associated with v&#xA;&#x9;&#x9;&#x9;for(unsigned int j = 0; j &lt; (std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(v))->getReferent()->retrieveFeatureValues()->size(); j++) {&#xA;&#x9;&#x9;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;uml::Port>((std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(v))->getReferent()->retrieveFeatureValues()->at(j)->getFeature()) != nullptr) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> interactionPoints = ((std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(v))->getReferent()->retrieveFeatureValues()->at(j))->getValues();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for(unsigned int k = 0; k &lt; interactionPoints->size(); k++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;potentialLinkEnds->add(interactionPoints->at(k));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return potentialLinkEnds;"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="context" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Reference"/>
          <eParameters name="feature" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//StructuralFeature"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_SendSignalActionActivation" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/Actions/SendSignalActionActivation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="/*&#xA;#include &quot;fUML/Semantics/Activities/ActivityNodeActivationGroup.hpp&quot;&#xA;&#xA;#include &quot;uml/SendSignalAction.hpp&quot;&#xA;#include &quot;fUML/Semantics/Values/Value.hpp&quot;&#xA;#include &quot;uml/Port.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/CS_Reference.hpp&quot;&#xA;#include &quot;PSCS/Semantics/CommonBehavior/CS_EventOccurrence.hpp&quot;&#xA;#include &quot;PSCS/Semantics/CommonBehavior/CommonBehaviorFactory.hpp&quot;&#xA;#include &quot;uml/Signal.hpp&quot;&#xA;#include &quot;uml/Property.hpp&quot;&#xA;#include &quot;uml/InputPin.hpp&quot;&#xA;#include &quot;fUML/Semantics/SimpleClassifiers/SignalInstance.hpp&quot;&#xA;#include &quot;fUML/Semantics/SimpleClassifiers/SimpleClassifiersFactory.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/CS_Object.hpp&quot;&#xA;#include &quot;fUML/Semantics/CommonBehavior/SignalEventOccurrence.hpp&quot;&#xA;#include &quot;fUML/Semantics/CommonBehavior/CommonBehaviorFactory.hpp&quot;&#xA;#include &quot;fUML/Semantics/Activities/ActivityExecution.hpp&quot;&#xA;*/"/>
        </eAnnotations>
        <eOperations name="doAction" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// If onPort is not specified, behaves like in fUML&#xA;&#x9;// If onPort is specified,&#xA;&#x9;// Get the value from the target pin. If the value is not a reference,&#xA;&#x9;// then do nothing.&#xA;&#x9;// Otherwise, construct a signal using the values from the argument pins&#xA;&#x9;// As compared to fUML, instead of sending directly to target reference&#xA;&#x9;// by calling operation send:&#xA;&#x9;// - if the target is to be the same as or a container of (directly or indirectly)&#xA;&#x9;// the object executing the Action, the Signal shall be related to a Reception belonging&#xA;&#x9;// to a required interface of onPort, and sendOut is called on the target reference&#xA;&#x9;// so that the signal will be sent to the environment&#xA;&#x9;// - if the target is NOT to be the same as or a container of (directly or indirectly)&#xA;&#x9;// the object executing the Action, the Signal shall be related to a Reception belonging&#xA;&#x9;// to a provided Interface of onPort, and operation sendIn is called so that the signal&#xA;&#x9;// will be sent to the internals of the target object&#xA;&#x9;// through the given Port.&#xA;&#x9;// - Otherwise the invocation is made into the target object through the&#xA;&#x9;// given Port.&#xA;&#x9;&#xA;&#x9;std::shared_ptr&lt;uml::SendSignalAction> action = std::dynamic_pointer_cast&lt;uml::SendSignalAction>(this->getNode());&#xA;&#x9;if(action->getOnPort() == nullptr) {&#xA;&#x9;&#x9;// Behaves like in fUML&#xA;&#x9;&#x9;fUML::Semantics::Actions::SendSignalActionActivationImpl::doAction();&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::Values::Value> target = this->takeTokens(action->getTarget())->at(0);&#xA;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(target) != nullptr) {&#xA;&#x9;&#x9;&#x9;// Constructs the signal instance&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::Signal> signal = action->getSignal();&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::SignalInstance> signalInstance = fUML::Semantics::SimpleClassifiers::SimpleClassifiersFactory::eInstance()->createSignalInstance();&#xA;&#x9;&#x9;&#x9;signalInstance->setType(signal);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;uml::Property>> attributes = signal->getOwnedAttribute();&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;uml::InputPin>> argumentPins = action->getArgument();&#xA;&#x9;&#x9;&#x9;unsigned int i = 0;&#xA;&#x9;&#x9;&#x9;while(i &lt; attributes->size()) {&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::Property> attribute = attributes->at(i);&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::InputPin> argumentPin = argumentPins->at(i);&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> values = this->takeTokens(argumentPin);&#xA;&#x9;&#x9;&#x9;&#x9;signalInstance->assignFeatureValue(attribute, values, 0);&#xA;&#x9;&#x9;&#x9;&#x9;i += 1;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;// Construct the signal event occurrence&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::CommonBehavior::SignalEventOccurrence> signalEventOccurrence = fUML::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createSignalEventOccurrence();&#xA;&#x9;&#x9;&#x9;signalEventOccurrence->setSignalInstance(std::dynamic_pointer_cast&lt;fUML::Semantics::SimpleClassifiers::SignalInstance>(signalInstance->copy()));&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::CommonBehavior::CS_EventOccurrence> wrappingEventOccurence = PSCS::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createCS_EventOccurrence();&#xA;&#x9;&#x9;&#x9;wrappingEventOccurence->setWrappedEventOccurrence(signalEventOccurrence);&#xA;&#x9;&#x9;&#x9;// Tries to determine if the signal has to be&#xA;&#x9;&#x9;&#x9;// sent to the environment or to the internals of&#xA;&#x9;&#x9;&#x9;// target, through onPort&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference> targetReference = std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(target);&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Object> executionContext = this->getActivityExecution()->getContext();&#xA;&#x9;&#x9;&#x9;if((executionContext == targetReference->getReferent()) || (targetReference->getCompositeReferent()->contains(executionContext))) {&#xA;&#x9;&#x9;&#x9;&#x9;wrappingEventOccurence->sendOutTo(targetReference, action->getOnPort());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;wrappingEventOccurence->sendInTo(targetReference, action->getOnPort());&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="StructuredClassifiers" nsURI="http:///PSCS_Semantics/Semantics/StructuredClassifiers.ecore"
        nsPrefix="PSCS_Semantics.Semantics.StructuredClassifiers">
      <eAnnotations source="http://tu-ilmenau.de/see/codegen">
        <details key="doNotGenerate"/>
      </eAnnotations>
      <eClassifiers xsi:type="ecore:EClass" name="CS_DispatchOperationOfInterfaceStrategy"
          eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/StructuredClassifiers/RedefinitionBasedDispatchStrategy">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;fUML/fUMLFactory.hpp&quot;&#xA;&#xA;#include &quot;uml/umlPackage.hpp&quot;&#xA;#include &quot;uml/Namespace.hpp&quot;&#xA;#include &quot;uml/Interface.hpp&quot;&#xA;#include &quot;uml/Parameter.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="operationsMatch" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EBoolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Override operationsMatch, in the case where baseOperation belongs &#xA;&#x9;// to an Interface.&#xA;&#x9;// In this case, ownedOperation matches baseOperation if it has the same name and signature&#xA;&#x9;// Otherwise, behaves like fUML RedefinitionBasedDispatchStrategy&#xA;&#xA;&#x9;bool matches = true;&#xA;&#x9;if(baseOperation->getNamespace().lock()->getMetaElementID() == uml::umlPackage::INTERFACE_CLASS) {&#xA;&#x9;&#x9;matches = (baseOperation->getName()) == (ownedOperation->getName());&#xA;&#x9;&#x9;matches = matches &amp;&amp; ((baseOperation->getOwnedParameter()->size()) == (ownedOperation->getOwnedParameter()->size()));&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;uml::Parameter>> ownedOperationParameters = ownedOperation->getOwnedParameter();&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;uml::Parameter>> baseOperationParameters = baseOperation->getOwnedParameter();&#xA;&#x9;&#x9;for(unsigned int i=0; (matches==true) &amp;&amp; (i &lt; ownedOperationParameters->size()); i++) {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::Parameter> ownedParameter = ownedOperationParameters->at(i);&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::Parameter> baseParameter = baseOperationParameters->at(i);&#xA;&#x9;&#x9;&#x9;matches = (ownedParameter->getType()) == (baseParameter->getType());&#xA;&#x9;&#x9;&#x9;matches = (matches) &amp;&amp; ((ownedParameter->getLower()) == (baseParameter->getLower()));&#xA;&#x9;&#x9;&#x9;matches = (matches) &amp;&amp; ((ownedParameter->getUpper()) == (baseParameter->getUpper()));&#xA;&#x9;&#x9;&#x9;matches = (matches) &amp;&amp; ((ownedParameter->getDirection()) == (baseParameter->getDirection()));&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;matches = fUML::Semantics::StructuredClassifiers::RedefinitionBasedDispatchStrategyImpl::operationsMatch(ownedOperation, baseOperation);&#xA;&#x9;}&#xA;&#x9;return matches;"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="ownedOperation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
          <eParameters name="baseOperation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_NameBased_StructuralFeatureOfInterfaceAccessStrategy"
          eSuperTypes="#//Semantics/StructuredClassifiers/CS_StructuralFeatureOfInterfaceAccessStrategy">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;fUML/Semantics/SimpleClassifiers/SimpleClassifiersFactory.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="read" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/SimpleClassifiers/FeatureValue">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;&#x9;// returns a copy of the first feature value of cs_Object where the name&#xA;&#x9;// of the corresponding feature matches the name of the feature given as a parameter&#xA;&#x9;// Otherwise, returns an empty feature value&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::SimpleClassifiers::FeatureValue>> featureValues = cs_Object->getFeatureValues();&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::FeatureValue> matchingFeatureValue = nullptr;&#xA;&#x9;for(unsigned int i = 0; (i &lt; featureValues->size()) &amp;&amp; (matchingFeatureValue == nullptr); i++) {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::FeatureValue> featureValue = featureValues->at(i);&#xA;&#x9;&#x9;if(featureValue->getFeature()->getName() == feature->getName()) {&#xA;&#x9;&#x9;&#x9;matchingFeatureValue = featureValue;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;if(matchingFeatureValue != nullptr) {&#xA;&#x9;&#x9;matchingFeatureValue = std::dynamic_pointer_cast&lt;fUML::Semantics::SimpleClassifiers::FeatureValue>(matchingFeatureValue->copy());&#xA;&#x9;&#x9;matchingFeatureValue->setFeature(feature);&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;matchingFeatureValue = fUML::Semantics::SimpleClassifiers::SimpleClassifiersFactory::eInstance()->createFeatureValue();&#xA;&#x9;&#x9;matchingFeatureValue->setFeature(feature);&#xA;&#x9;&#x9;matchingFeatureValue->setPosition(0);&#xA;&#x9;}&#xA;&#x9;return matchingFeatureValue;"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="cs_Object" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Object"/>
          <eParameters name="feature" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//StructuralFeature"/>
        </eOperations>
        <eOperations name="write" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;&#x9;// returns a copy of the first feature value of cs_Object where the name&#xA;&#x9;// of the corresponding feature matches the name of the feature given as a parameter&#xA;&#x9;// Otherwise, returns an empty feature value&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::SimpleClassifiers::FeatureValue>> featureValues = cs_Object->getFeatureValues();&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::FeatureValue> matchingFeatureValue = nullptr;&#xA;&#x9;for(unsigned int i = 0; (i &lt; featureValues->size()) &amp;&amp; (matchingFeatureValue == nullptr); i++) {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::FeatureValue> featureValue = featureValues->at(i);&#xA;&#x9;&#x9;if(featureValue->getFeature()->getName() == feature->getName()) {&#xA;&#x9;&#x9;&#x9;matchingFeatureValue = featureValue;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;if(matchingFeatureValue != nullptr) {&#xA;&#x9;&#x9;cs_Object->assignFeatureValue(matchingFeatureValue->getFeature(), values, position);&#xA;&#x9;}"/>
            <details key="doNotGenerate"/>
          </eAnnotations>
          <eParameters name="cs_Object" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Object"/>
          <eParameters name="feature" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//StructuralFeature"/>
          <eParameters name="values" upperBound="-1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Values/Value"/>
          <eParameters name="position" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EInt"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_StructuralFeatureOfInterfaceAccessStrategy"
          abstract="true" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/Loci/SemanticStrategy">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;fUML/fUMLFactory.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="getName" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EString">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// StructuralFeatureAccessStrategy are always named &quot;structuralFeature&quot;&#xA;&#x9;return &quot;structuralFeature&quot;;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="read" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/SimpleClassifiers/FeatureValue">
          <eParameters name="cs_Object" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Object"/>
          <eParameters name="feature" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//StructuralFeature"/>
        </eOperations>
        <eOperations name="write" ordered="false" lowerBound="1">
          <eParameters name="cs_Object" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Object"/>
          <eParameters name="feature" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//StructuralFeature"/>
          <eParameters name="values" ordered="false" upperBound="-1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Values/Value"/>
          <eParameters name="position" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.uml2.types/model/Types.ecore#//Integer"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_Object" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/StructuredClassifiers/Object">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;PSCS/Semantics/StructuredClassifiers/CS_Reference.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/CS_RequestPropagationStrategy.hpp&quot;&#xA;#include &quot;PSCS/Semantics/CommonBehavior/CS_CallEventExecution.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/CS_StructuralFeatureOfInterfaceAccessStrategy.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/CS_DispatchOperationOfInterfaceStrategy.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/CS_LinkKind.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/StructuredClassifiersFactory.hpp&quot;&#xA;#include &quot;uml/ConnectorKind.hpp&quot;&#xA;#include &quot;uml/InterfaceRealization.hpp&quot;&#xA;#include &quot;fUML/Semantics/Loci/ExecutionFactory.hpp&quot;&#xA;#include &quot;fUML/Semantics/Actions/CallOperationActionActivation.hpp&quot;&#xA;#include &quot;fUML/Semantics/Actions/SendSignalActionActivation.hpp&quot;&#xA;#include &quot;fUML/Semantics/Actions/ActionsFactory.hpp&quot;&#xA;#include &quot;fUML/Semantics/Loci/ChoiceStrategy.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="dispatchIn" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/Execution">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// If the interaction point refers to a behavior port, does nothing [for the moment... ?], &#xA;&#x9;// since the only kind of event supported in fUML is SignalEvent&#xA;&#x9;// If it does not refer to a behavior port, select appropriate delegation links &#xA;&#x9;// from interactionPoint, and propagates the operation call through &#xA;&#x9;// these links&#xA;&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::CommonBehavior::Execution> execution = nullptr;&#xA;&#x9;if(interactionPoint->getDefiningPort()->getIsBehavior()) {&#xA;&#x9;&#x9;execution = this->dispatch(operation);&#xA;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::CommonBehavior::CS_CallEventExecution>(execution) != nullptr) {&#xA;&#x9;&#x9;&#x9;(std::dynamic_pointer_cast&lt;PSCS::Semantics::CommonBehavior::CS_CallEventExecution>(execution))->setInteractionPoint(interactionPoint);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;bool operationIsProvided = true;&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>> potentialTargets(new Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>());&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;PSCS::Semantics::StructuredClassifiers::CS_Link>> cddLinks = this->getLinks(interactionPoint);&#xA;&#x9;&#x9;unsigned int linkIndex = 1;&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;while(linkIndex &lt;= cddLinks->size()) {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>> validTargets = this->selectTargetsForDispatching(cddLinks->at(linkIndex-1), interactionPoint, uml::ConnectorKind::DELEGATION, operation, operationIsProvided);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;unsigned int targetIndex = 1;&#xA;&#x9;&#x9;&#x9;while(targetIndex &lt;= validTargets->size()) {&#xA;&#x9;&#x9;&#x9;&#x9;potentialTargets->add(validTargets->at(targetIndex-1));&#xA;&#x9;&#x9;&#x9;&#x9;targetIndex +=1 ;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;linkIndex += 1;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;// If potentialTargets is empty, no delegation target have been found,&#xA;&#x9;&#x9;// and the operation call will be lost&#xA;&#x9;&#x9;if(potentialTargets->size() != 0) {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_RequestPropagationStrategy> strategy = std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_RequestPropagationStrategy>(this->getLocus()->getFactory()->getStrategy(&quot;requestPropagation&quot;));&#xA;&#x9;&#x9;&#x9;// Choose one target non-deterministically&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>> targets = strategy->select(potentialTargets, fUML::Semantics::Actions::ActionsFactory::eInstance()->createCallOperationActionActivation());&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Reference> target = targets->at(0);&#xA;&#x9;&#x9;&#x9;execution = target->dispatch(operation);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return execution;"/>
          </eAnnotations>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
          <eParameters name="interactionPoint" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
        </eOperations>
        <eOperations name="sendIn" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// 1] If the interaction is a behavior port then sends the event occurrence to the // target object using operation send.&#xA;&#x9;// 2] If this is not a behavior port, select appropriate delegation targets from // interactionPoint and propagates the event occurrence to these target&#xA;&#xA;&#x9;if(interactionPoint->getDefiningPort()->getIsBehavior()) {&#xA;&#x9;&#x9;this->send(eventOccurrence);&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;bool receptionIsProvided = true;&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>> potentialTargets(new Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>());&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;PSCS::Semantics::StructuredClassifiers::CS_Link>> cddLinks = this->getLinks(interactionPoint);&#xA;&#x9;&#x9;unsigned int linkIndex = 1;&#xA;&#x9;&#x9;while(linkIndex &lt;= cddLinks->size()) {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>> validTargets = this->selectTargetsForSending(cddLinks->at(linkIndex-1), interactionPoint, uml::ConnectorKind::DELEGATION, receptionIsProvided);&#xA;&#x9;&#x9;&#x9;unsigned int targetIndex = 1;&#xA;&#x9;&#x9;&#x9;while(targetIndex &lt;= validTargets->size()) {&#xA;&#x9;&#x9;&#x9;&#x9;potentialTargets->add(validTargets->at(targetIndex-1));&#xA;&#x9;&#x9;&#x9;&#x9;targetIndex += 1;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;linkIndex += 1;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;// If potential targets is empty, no delegation target has been found,&#xA;&#x9;&#x9;// and the event occurrence is lost&#xA;&#x9;&#x9;// Otherwise, do the following concurrently&#xA;&#x9;&#x9;for(unsigned int i =0; i &lt; potentialTargets->size(); i++) {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Reference> target = potentialTargets->at(i);&#xA;&#x9;&#x9;&#x9;target->send(eventOccurrence);&#xA;&#x9;&#x9;}&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="interactionPoint" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
        </eOperations>
        <eOperations name="selectTargetsForSending" ordered="false" upperBound="-1"
            eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/StructuredClassifiers/Reference">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// From the given link, signal and interaction point, retrieves potential targets (i.e. end values of link) &#xA;&#x9;// through which request can be propagated&#xA;&#x9;// These targets are attached to interaction point through the given link, and respect the following rules:&#xA;&#x9;// - if toInternal is true, connectorKind must be Delegation, the given link has to target the internals of this CS_Object&#xA;&#x9;// - if toInternal is false, the given link has to target the environment of this CS_Object&#xA;&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>> potentialTargets(new Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>());&#xA;&#x9;if((toInternal) &amp;&amp; (connectorKind == uml::ConnectorKind::DELEGATION)) {&#xA;&#x9;&#x9;if(this->getLinkKind(link, interactionPoint) == PSCS::Semantics::StructuredClassifiers::CS_LinkKind::TOINTERNAL) {&#xA;&#x9;&#x9;&#x9;unsigned int i = 1;&#xA;&#x9;&#x9;&#x9;while(i &lt;= link->retrieveFeatureValues()->size()) {&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> values = link->retrieveFeatureValues()->at(i-1)->getValues();&#xA;&#x9;&#x9;&#x9;&#x9;if(!values->empty()) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;unsigned int j = 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;while(j &lt;= values->size()) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Reference> cddTarget = std::dynamic_pointer_cast&lt;fUML::Semantics::StructuredClassifiers::Reference>(values->at(j-1));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(!cddTarget->equals(interactionPoint)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;potentialTargets->add(cddTarget);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;j += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;i += 1;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else { // to Environment&#xA;&#x9;&#x9;if(this->getLinkKind(link, interactionPoint) == PSCS::Semantics::StructuredClassifiers::CS_LinkKind::TOENVIRONMENT) {&#xA;&#x9;&#x9;&#x9;unsigned int i = 1;&#xA;&#x9;&#x9;&#x9;while(i &lt;= link->retrieveFeatureValues()->size()) {&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> values = link->retrieveFeatureValues()->at(i-1)->getValues();&#xA;&#x9;&#x9;&#x9;&#x9;if((!values->empty()) &amp;&amp; (std::dynamic_pointer_cast&lt;fUML::Semantics::StructuredClassifiers::Reference>(values->at(0)) != nullptr)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Reference> cddTarget = std::dynamic_pointer_cast&lt;fUML::Semantics::StructuredClassifiers::Reference>(values->at(0));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(connectorKind == uml::ConnectorKind::ASSEMBLY) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_InteractionPoint>(cddTarget) == nullptr) { // This is an assembly link&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;potentialTargets->add(cddTarget);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// This is an assembly if the interaction point is not a feature value&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// for a container of this CS_Object&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>> directContainers = this->getDirectContainers();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;bool isAssembly = true;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;unsigned int j = 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(!this->hasValueForAFeature(cddTarget)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;while((isAssembly) &amp;&amp; (j &lt;= directContainers->size())) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Object> container = directContainers->at(j-1);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(container->hasValueForAFeature(cddTarget)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;isAssembly = false;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;j += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;isAssembly = false;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(isAssembly) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;potentialTargets->add(cddTarget);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;else { // delegation&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// This is a delegation if the target is an interaction point&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// and if this interaction is a feature value for a container of this CS_Object&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_InteractionPoint>(cddTarget) != nullptr) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>> directContainers = this->getDirectContainers();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;bool isDelegation = false;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;unsigned int j = 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;while((!isDelegation) &amp;&amp; (j &lt;= directContainers->size())) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Object> container = directContainers->at(j-1);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(container->hasValueForAFeature(cddTarget)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;isDelegation = true;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;j += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(isDelegation) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;potentialTargets->add(cddTarget);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;i += 1;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return potentialTargets;"/>
          </eAnnotations>
          <eParameters name="link" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Link"/>
          <eParameters name="interactionPoint" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
          <eParameters name="connectorKind" ordered="false" lowerBound="1" eType="ecore:EEnum http://www.eclipse.org/uml2/5.0.0/UML#//ConnectorKind"/>
          <eParameters name="toInternal" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EBoolean"/>
        </eOperations>
        <eOperations name="selectTargetsForDispatching" ordered="false" upperBound="-1"
            eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/StructuredClassifiers/Reference">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// From the given link, operation and interaction point, retrieves potential targets (i.e. end values of link) &#xA;&#x9;// through which request can be propagated&#xA;&#x9;// These targets are attached to interaction point through the given link, and respect the following rules:&#xA;&#x9;// - if toInternal is true, connectorKind must be Delegation, the given link has to target the internals of this CS_Object, &#xA;&#x9;// and a valid target must provide the Operation &#xA;&#x9;// - if toInternal is false, the given link has to target the environment of this CS_Object.&#xA;&#x9;//&#x9;&#x9;- if connectorKind is assembly, a valid target has to provide the operation&#xA;&#x9;// &#x9;&#x9;- if connectorKind is delegation, a valid target has to require the operation&#xA;&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>> potentialTargets(new Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>());&#xA;&#x9;if((toInternal) &amp;&amp; (connectorKind == uml::ConnectorKind::DELEGATION)) {&#xA;&#x9;&#x9;if(this->getLinkKind(link, interactionPoint) == PSCS::Semantics::StructuredClassifiers::CS_LinkKind::TOINTERNAL) {&#xA;&#x9;&#x9;&#x9;unsigned int i = 1;&#xA;&#x9;&#x9;&#x9;while(i &lt;= link->retrieveFeatureValues()->size()) {&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> values = link->retrieveFeatureValues()->at(i-1)->getValues();&#xA;&#x9;&#x9;&#x9;&#x9;if((!values->empty()) &amp;&amp; (std::dynamic_pointer_cast&lt;fUML::Semantics::StructuredClassifiers::Reference>(values->at(0)) != nullptr)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Reference> cddTarget = std::dynamic_pointer_cast&lt;fUML::Semantics::StructuredClassifiers::Reference>(values->at(0));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if((cddTarget != interactionPoint) &amp;&amp; (this->isOperationProvided(cddTarget, operation))) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;potentialTargets->add(cddTarget);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;i += 1;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else { //to environment&#xA;&#x9;&#x9;if (this->getLinkKind(link, interactionPoint) == PSCS::Semantics::StructuredClassifiers::CS_LinkKind::TOENVIRONMENT) {&#xA;&#x9;&#x9;&#x9;unsigned int i = 1;&#xA;&#x9;&#x9;&#x9;while(i &lt;= link->retrieveFeatureValues()->size()) {&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> values = link->retrieveFeatureValues()->at(i-1)->getValues();&#xA;&#x9;&#x9;&#x9;&#x9;if((!values->empty()) &amp;&amp; (std::dynamic_pointer_cast&lt;fUML::Semantics::StructuredClassifiers::Reference>(values->at(0)) != nullptr)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Reference> cddTarget = std::dynamic_pointer_cast&lt;fUML::Semantics::StructuredClassifiers::Reference>(values->at(0));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(connectorKind == uml::ConnectorKind::ASSEMBLY) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_InteractionPoint>(cddTarget) == nullptr) { // This is an assembly link&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(this->isOperationProvided(cddTarget, operation)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;potentialTargets->add(cddTarget);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// This is an assembly if the interaction point is not a feature value&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// for a container of this CS_Object&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>> directContainers = this->getDirectContainers();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;bool isAssembly = true;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;unsigned int j = 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(!this->hasValueForAFeature(cddTarget)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;while((isAssembly) &amp;&amp; (j &lt;= directContainers->size())) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Object> container = directContainers->at(j-1);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(container->hasValueForAFeature(cddTarget)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;isAssembly = false;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;j += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;isAssembly = false;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (isAssembly) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(this->isOperationProvided(cddTarget, operation)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;potentialTargets->add(cddTarget);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;else { // delegation&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// This is a delegation if the target is an interaction point&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// and if this interaction is a feature value for a container of this CS_Object&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_InteractionPoint>(cddTarget) != nullptr) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>> directContainers = this->getDirectContainers();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;bool isDelegation = false;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;unsigned int j = 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;while ((!isDelegation) &amp;&amp; (j &lt;= directContainers->size())) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Object> container = directContainers->at(j-1);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(container->hasValueForAFeature(cddTarget)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;isDelegation = true;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;j += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(isDelegation) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(this->isOperationRequired(cddTarget, operation)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;potentialTargets->add(cddTarget);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;i += 1;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return potentialTargets;"/>
          </eAnnotations>
          <eParameters name="link" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Link"/>
          <eParameters name="interactionPoint" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
          <eParameters name="connectorKind" ordered="false" lowerBound="1" eType="ecore:EEnum http://www.eclipse.org/uml2/5.0.0/UML#//ConnectorKind"/>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
          <eParameters name="toInternal" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EBoolean"/>
        </eOperations>
        <eOperations name="sendOut" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Select appropriate delegation links from interactionPoint, &#xA;&#x9;// and propagates the event occurrence through these links&#xA;&#x9;// Appropriate links are links which target elements&#xA;&#x9;// in the environment of this CS_Object.&#xA;&#x9;// These can be delegation links (i.e, the targeted elements must&#xA;&#x9;// require a reception for the signal) or assembly links (i.e., the target elements&#xA;&#x9;// must provide a reception for the signal)&#xA;&#xA;&#x9;bool receptionIsNotProvided = false; // i.e. it is required&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>> allPotentialTargets(new Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>());&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>> targetsForSendingIn(new Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>());&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>> targetsForSendingOut(new Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>());&#xA;&#xA;&#x9;std::shared_ptr&lt;Bag&lt;PSCS::Semantics::StructuredClassifiers::CS_Link>> cddLinks = this->getLinks(interactionPoint);&#xA;&#x9;unsigned int linkIndex = 1;&#xA;&#xA;&#x9;while(linkIndex &lt;= cddLinks->size()) {&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>> validAssemblyTargets = this->selectTargetsForSending(cddLinks->at(linkIndex-1), interactionPoint, uml::ConnectorKind::ASSEMBLY, receptionIsNotProvided);&#xA;&#x9;&#x9;unsigned int targetIndex = 1;&#xA;&#x9;&#x9;while(targetIndex &lt;= validAssemblyTargets->size()) {&#xA;&#x9;&#x9;&#x9;allPotentialTargets->add(validAssemblyTargets->at(targetIndex-1));&#xA;&#x9;&#x9;&#x9;targetsForSendingIn->add(validAssemblyTargets->at(targetIndex-1));&#xA;&#x9;&#x9;&#x9;targetIndex += 1;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>> validDelegationTargets = this->selectTargetsForSending(cddLinks->at(linkIndex-1), interactionPoint, uml::ConnectorKind::DELEGATION, receptionIsNotProvided);&#xA;&#x9;&#x9;targetIndex = 1;&#xA;&#x9;&#x9;while(targetIndex &lt;= validDelegationTargets->size()) {&#xA;&#x9;&#x9;&#x9;allPotentialTargets->add(validDelegationTargets->at(targetIndex-1));&#xA;&#x9;&#x9;&#x9;targetsForSendingIn->add(validDelegationTargets->at(targetIndex-1));&#xA;&#x9;&#x9;&#x9;targetIndex += 1;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;linkIndex += 1;&#xA;&#x9;}&#xA;&#xA;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_RequestPropagationStrategy> strategy = std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_RequestPropagationStrategy>(this->getLocus()->getFactory()->getStrategy(&quot;requestPropagation&quot;));&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>> selectedTargets = strategy->select(allPotentialTargets, fUML::Semantics::Actions::ActionsFactory::eInstance()->createSendSignalActionActivation());&#xA;&#xA;&#x9;for(unsigned int j = 0; j &lt; selectedTargets->size(); j++) {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Reference> target = selectedTargets->at(j);&#xA;&#x9;&#x9;for(unsigned int k = 0; k &lt; targetsForSendingIn->size(); k++) {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Reference> cddTarget = targetsForSendingIn->at(k);&#xA;&#x9;&#x9;&#x9;if(cddTarget == target) {&#xA;&#x9;&#x9;&#x9;&#x9;target->send(eventOccurrence);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;for(unsigned int k = 0; k &lt; targetsForSendingOut->size(); k++) {&#xA;&#x9;&#x9;&#x9;// The target must be an interaction point&#xA;&#x9;&#x9;&#x9;// i.e. a delegation connector for a required reception can only target a port&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_InteractionPoint> cddTarget = std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_InteractionPoint>(targetsForSendingOut->at(k));&#xA;&#x9;&#x9;&#x9;if(cddTarget == target) {&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference> owner = cddTarget->getOwner();&#xA;&#x9;&#x9;&#x9;&#x9;owner->sendOut(eventOccurrence, cddTarget);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="interactionPoint" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
        </eOperations>
        <eOperations name="dispatchOut" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/Execution">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Select appropriate delegation links from interactionPoint, &#xA;&#x9;// and propagates the operation call through these links&#xA;&#x9;// Appropriate links are either links which target elements&#xA;&#x9;// in the environment of this CS_Object.&#xA;&#x9;// These can be delegation links (i.e, the targeted elements must&#xA;&#x9;// require the operation) or assembly links (i.e., the target elements&#xA;&#x9;// must provide the operation)&#xA;&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::CommonBehavior::Execution> execution = nullptr;&#xA;&#x9;bool operationIsNotProvided = false; // i.e. it is required&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>> allPotentialTargets(new Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>());&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>> targetsForDispatchingIn(new Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>());&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>> targetsForDispatchingOut(new Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>());&#xA;&#x9;std::shared_ptr&lt;Bag&lt;PSCS::Semantics::StructuredClassifiers::CS_Link>> cddLinks = this->getLinks(interactionPoint);&#xA;&#x9;unsigned int linkIndex = 1;&#xA;&#xA;&#x9;while(linkIndex &lt;= cddLinks->size()) {&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>> validAssemblyTargets = this->selectTargetsForDispatching(cddLinks->at(linkIndex-1), interactionPoint, uml::ConnectorKind::ASSEMBLY, operation, operationIsNotProvided);&#xA;&#x9;&#x9;unsigned int targetIndex = 1;&#xA;&#x9;&#x9;while(targetIndex &lt;= validAssemblyTargets->size()) {&#xA;&#x9;&#x9;&#x9;allPotentialTargets->add(validAssemblyTargets->at(targetIndex-1));&#xA;&#x9;&#x9;&#x9;targetsForDispatchingIn->add(validAssemblyTargets->at(targetIndex-1));&#xA;&#x9;&#x9;&#x9;targetIndex += 1;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>> validDelegationTargets = this->selectTargetsForDispatching(cddLinks->at(linkIndex-1), interactionPoint, uml::ConnectorKind::DELEGATION, operation, operationIsNotProvided);&#xA;&#x9;&#x9;targetIndex = 1;&#xA;&#x9;&#x9;while(targetIndex &lt;= validDelegationTargets->size()) {&#xA;&#x9;&#x9;&#x9;allPotentialTargets->add(validDelegationTargets->at(targetIndex-1));&#xA;&#x9;&#x9;&#x9;targetsForDispatchingOut->add(validDelegationTargets->at(targetIndex-1));&#xA;&#x9;&#x9;&#x9;targetIndex += 1;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;linkIndex += 1;&#xA;&#x9;}&#xA;&#xA;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_RequestPropagationStrategy> strategy = std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_RequestPropagationStrategy>(this->getLocus()->getFactory()->getStrategy(&quot;requestPropagation&quot;));&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>> selectedTargets = strategy->select(allPotentialTargets, fUML::Semantics::Actions::ActionsFactory::eInstance()->createSendSignalActionActivation());&#xA;&#xA;&#x9;for(unsigned int j = 0; j &lt; selectedTargets->size(); j++) {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Reference> target = selectedTargets->at(j);&#xA;&#x9;&#x9;for(unsigned int k = 0; (k &lt; targetsForDispatchingIn->size()) &amp;&amp; (execution == nullptr); k++) {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Reference> cddTarget = targetsForDispatchingIn->at(k);&#xA;&#x9;&#x9;&#x9;if(cddTarget == target) {&#xA;&#x9;&#x9;&#x9;&#x9;execution = target->dispatch(operation);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;for(unsigned int k = 0; (k &lt; targetsForDispatchingOut->size()) &amp;&amp; (execution == nullptr); k++) {&#xA;&#x9;&#x9;&#x9;// The target must be an interaction point&#xA;&#x9;&#x9;&#x9;// i.e. a delegation connector for a required operation can only target a port&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_InteractionPoint> cddTarget = std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_InteractionPoint>(targetsForDispatchingOut->at(k));&#xA;&#x9;&#x9;&#x9;if(cddTarget == target) {&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference> owner = cddTarget->getOwner();&#xA;&#x9;&#x9;&#x9;&#x9;execution = owner->dispatchOut(operation, cddTarget);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return execution;"/>
          </eAnnotations>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
          <eParameters name="interactionPoint" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
        </eOperations>
        <eOperations name="getFeatureValue" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/SimpleClassifiers/FeatureValue">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// In the case where the feature belongs to an Interface,&#xA;&#x9;// fUML semantics is extended in the sense that reading is &#xA;&#x9;// delegated to a CS_StructuralFeatureOfInterfaceAccessStrategy&#xA;&#xA;&#x9;if(std::dynamic_pointer_cast&lt;uml::Interface>(feature->getNamespace().lock()) != nullptr) {&#xA;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_StructuralFeatureOfInterfaceAccessStrategy> readStrategy = std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_StructuralFeatureOfInterfaceAccessStrategy>(this->getLocus()->getFactory()->getStrategy(&quot;structuralFeature&quot;));&#xA;&#x9;&#x9;return readStrategy->read(this->getThisCS_ObjectPtr(), feature);&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;return fUML::Semantics::StructuredClassifiers::ObjectImpl::retrieveFeatureValue(feature);&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="feature" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//StructuralFeature"/>
        </eOperations>
        <eOperations name="setFeatureValue" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// In the case where the feature belongs to an Interface,&#xA;&#x9;// fUML semantics is extended in the sense that writing is &#xA;&#x9;// delegated to a CS_StructuralFeatureOfInterfaceAccessStrategy&#xA;&#xA;&#x9;if(std::dynamic_pointer_cast&lt;uml::Interface>(feature->getNamespace().lock()) != nullptr) {&#xA;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_StructuralFeatureOfInterfaceAccessStrategy> writeStrategy = std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_StructuralFeatureOfInterfaceAccessStrategy>(this->getLocus()->getFactory()->getStrategy(&quot;structuralFeature&quot;));&#xA;&#x9;&#x9;writeStrategy->write(this->getThisCS_ObjectPtr(), feature, values, position);&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;fUML::Semantics::StructuredClassifiers::ObjectImpl::assignFeatureValue(feature, values, position);&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="feature" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//StructuralFeature"/>
          <eParameters name="values" ordered="false" upperBound="-1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Values/Value"/>
          <eParameters name="position" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EInt"/>
        </eOperations>
        <eOperations name="contains" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EBoolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Determines if the object given as a parameter is directly&#xA;&#x9;// or indirectly contained by this CS_Object&#xA;&#xA;&#x9;bool objectIsContained = this->directlyContains(object);&#xA;&#x9;// if object is not directly contained, restart the research&#xA;&#x9;// recursively on the objects owned by this CS_Object&#xA;&#x9;for(unsigned int i = 0; (i &lt; this->retrieveFeatureValues()->size()) &amp;&amp; (!objectIsContained); i++) {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::FeatureValue> featureValue = this->retrieveFeatureValues()->at(i);&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> values = featureValue->getValues();&#xA;&#x9;&#x9;for(unsigned int j = 0; (j &lt; values->size()) &amp;&amp; !objectIsContained; j++) {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::Values::Value> value = values->at(j);&#xA;&#x9;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(value) != nullptr) {&#xA;&#x9;&#x9;&#x9;&#x9;objectIsContained = (std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(value))->contains(object);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(value)) {&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Object> referent = (std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(value))->getCompositeReferent();&#xA;&#x9;&#x9;&#x9;&#x9;objectIsContained = referent->contains(object);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return objectIsContained;"/>
          </eAnnotations>
          <eParameters name="object" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/StructuredClassifiers/Object"/>
        </eOperations>
        <eOperations name="directlyContains" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EBoolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Determines if the object given as a parameter is directly&#xA;&#x9;// contained by this CS_Object&#xA;&#xA;&#x9;bool objectIsContained = false;&#xA;&#x9;for(unsigned int i = 0; (i &lt; this->retrieveFeatureValues()->size()) &amp;&amp; (!objectIsContained); i++) {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::FeatureValue> featureValue = this->retrieveFeatureValues()->at(i);&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> values = featureValue->getValues();&#xA;&#x9;&#x9;for(unsigned int j = 0; (j &lt; values->size()) &amp;&amp; (!objectIsContained); j++) {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::Values::Value> value = values->at(j);&#xA;&#x9;&#x9;&#x9;if(value == object) {&#xA;&#x9;&#x9;&#x9;&#x9;objectIsContained = true;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(value)) {&#xA;&#x9;&#x9;&#x9;&#x9;objectIsContained = (((std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(value))->getReferent()) == object);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return objectIsContained;"/>
          </eAnnotations>
          <eParameters name="object" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/StructuredClassifiers/Object"/>
        </eOperations>
        <eOperations name="getDirectContainers" ordered="false" upperBound="-1" eType="#//Semantics/StructuredClassifiers/CS_Object">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Retrieves all the extensional values at this locus which are direct&#xA;&#x9;// containers for this CS_Object&#xA;&#x9;// An extensional value is a direct container for an object if:&#xA;&#x9;// - it is a CS_Object&#xA;&#x9;// - it directly contains this object (i.e. CS_Object.directlyContains(Object)==true)&#xA;&#xA;&#x9;std::shared_ptr&lt;Bag&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>> containers(new Bag&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>());&#xA;&#x9;for(unsigned int i = 0; i &lt; this->getLocus()->getExtensionalValues()->size(); i++) {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::ExtensionalValue> extensionalValue = this->getLocus()->getExtensionalValues()->at(i);&#xA;&#x9;&#x9;if((extensionalValue != this->getThisCS_ObjectPtr()) &amp;&amp; (std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(extensionalValue) != nullptr)) {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Object> cddContainer = std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(extensionalValue);&#xA;&#x9;&#x9;&#x9;if(cddContainer->directlyContains(this->getThisCS_ObjectPtr())) {&#xA;&#x9;&#x9;&#x9;&#x9;containers->add(cddContainer);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return containers;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="isOperationProvided" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EBoolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Determines if the given reference provides the operation&#xA;&#x9;// If the reference is an interaction point, it provides the operation if this operation&#xA;&#x9;// is a member of one of its provided interfaces&#xA;&#x9;// If the reference is NOT an interactionPoint, it provides this operation if this operation is&#xA;&#x9;// an operation of one of its type, or one of its type provides a realization for this operation (in the case&#xA;&#x9;// where the namespace of this Operation is an interface)&#xA;&#xA;&#x9;bool isProvided = false;&#xA;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_InteractionPoint>(reference) != nullptr) {&#xA;&#x9;&#x9;/*Maximilian Hammer: The following if-Statement is bypassed, because it would prohibit operation delegation&#xA;&#x9;&#x9;for operations that are not owned by an Interface (i.e. are owned by a class) (since there is no else-Statement for this if-Statement)&#xA;&#x9;&#x9;--> this does not match the test models of the PSCS Test Suite.&#xA;&#x9;&#x9;Might be an error in the specification&#xA;&#x9;&#x9;*/&#xA;&#xA;&#x9;&#x9;//if(std::dynamic_pointer_cast&lt;uml::Interface>(operation->getOwner().lock()) != nullptr) {&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// We have to look in provided interfaces of the port if&#xA;&#x9;&#x9;&#x9;// they define directly or indirectly the Operation&#xA;&#x9;&#x9;&#x9;unsigned int interfaceIndex = 1;&#xA;&#x9;&#x9;&#x9;// Iterates on provided interfaces of the port&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;uml::Interface>> providedInterfaces = (std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_InteractionPoint>(reference))->getDefiningPort()->getProvideds();&#xA;&#x9;&#x9;&#x9;while((interfaceIndex &lt;= providedInterfaces->size()) &amp;&amp; (!isProvided)) {&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::Interface> interface_ = providedInterfaces->at(interfaceIndex-1);&#xA;&#x9;&#x9;&#x9;&#x9;// Iterates on members of the current Interface&#xA;&#x9;&#x9;&#x9;&#x9;unsigned int memberIndex = 1;&#xA;&#x9;&#x9;&#x9;&#x9;while((memberIndex &lt;= interface_->getMember()->size()) &amp;&amp; (!isProvided)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::NamedElement> cddOperation = interface_->getMember()->at(memberIndex-1);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;uml::Operation>(cddOperation)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;isProvided = operation->matches(std::dynamic_pointer_cast&lt;uml::Operation>(cddOperation));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;memberIndex += 1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;interfaceIndex += 1;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;//}&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;// We have to look if one of the Classifiers typing this reference&#xA;&#x9;&#x9;// directly or indirectly provides this operation&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;uml::Classifier>> types = reference->getTypes();&#xA;&#x9;&#x9;unsigned int typeIndex = 1;&#xA;&#x9;&#x9;while((typeIndex &lt;= types->size()) &amp;&amp; (!isProvided)) {&#xA;&#x9;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;uml::Class>(types->at(typeIndex-1))) {&#xA;&#x9;&#x9;&#x9;&#x9;unsigned int memberIndex = 1;&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;uml::NamedElement>> members = (std::dynamic_pointer_cast&lt;uml::Class>(types->at(typeIndex-1)))->getMember();&#xA;&#x9;&#x9;&#x9;&#x9;while((memberIndex &lt;= members->size()) &amp;&amp; (!isProvided)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::NamedElement> cddOperation = members->at(memberIndex-1);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;uml::Operation>(cddOperation)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_DispatchOperationOfInterfaceStrategy> strategy = PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_DispatchOperationOfInterfaceStrategy();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;isProvided = strategy->operationsMatch(std::dynamic_pointer_cast&lt;uml::Operation>(cddOperation), operation);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;memberIndex += 1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;typeIndex += 1;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return isProvided;"/>
          </eAnnotations>
          <eParameters name="reference" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/StructuredClassifiers/Reference"/>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
        </eOperations>
        <eOperations name="isOperationRequired" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EBoolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Determines if the given reference requires the operation&#xA;&#x9;// If the reference is an interaction point, it requires the operation if this operation&#xA;&#x9;// is a member of one of its required interfaces&#xA;&#x9;// If the reference is not a interaction point, it cannot require an operation&#xA;&#xA;&#x9;bool matches = false;&#xA;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_InteractionPoint>(reference) != nullptr) {&#xA;&#x9;&#x9;unsigned int interfaceIndex = 1;&#xA;&#x9;&#x9;// Iterates on provided interfaces of the port&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;uml::Interface>> requiredInterfaces = (std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_InteractionPoint>(reference))->getDefiningPort()->getRequireds();&#xA;&#x9;&#x9;while ((interfaceIndex &lt;= requiredInterfaces->size()) &amp;&amp; (!matches)) {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::Interface> interface_ = requiredInterfaces->at(interfaceIndex-1);&#xA;&#x9;&#x9;&#x9;//Iterates on members of the current Interface&#xA;&#x9;&#x9;&#x9;unsigned int memberIndex = 1;&#xA;&#x9;&#x9;&#x9;while((memberIndex &lt;= interface_->getMember()->size()) &amp;&amp; (!matches)) {&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::NamedElement> cddOperation = interface_->getMember()->at(memberIndex-1);&#xA;&#x9;&#x9;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;uml::Operation>(cddOperation) != nullptr) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;matches = operation->matches(std::dynamic_pointer_cast&lt;uml::Operation>(cddOperation));&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;memberIndex += 1;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;interfaceIndex += 1;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return matches;"/>
          </eAnnotations>
          <eParameters name="reference" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/StructuredClassifiers/Reference"/>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
        </eOperations>
        <eOperations name="getLinkKind" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_LinkKind">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// If the given interaction point belongs to the given object, and if the given interaction point is used as an end of the link, &#xA;&#x9;// then the links targets the environment of the object (enumeration literal ToEnvironment) if all the feature values of the link &#xA;&#x9;// (but one for the interaction point) refer to values which are not themselves values for features of the interaction point. &#xA;&#x9;// If all the feature values of the link refer to values which are themselves values for features of the interaction point, &#xA;&#x9;// the link targets the internals of the object (enumeration literal ToInternal). Otherwise, the link has no particular meaning &#xA;&#x9;// in the context defined by the object and the interaction point (enumeration literal None).&#xA;&#xA;&#x9;if(!link->hasValueForAFeature(interactionPoint)) {&#xA;&#x9;&#x9;return PSCS::Semantics::StructuredClassifiers::CS_LinkKind::NONE;&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;PSCS::Semantics::StructuredClassifiers::CS_LinkKind kind = PSCS::Semantics::StructuredClassifiers::CS_LinkKind::TOINTERNAL;&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::SimpleClassifiers::FeatureValue>> featureValues = link->retrieveFeatureValues();&#xA;&#x9;unsigned int i = 1;&#xA;&#xA;&#x9;while((i &lt;= featureValues->size()) &amp;&amp; (kind != PSCS::Semantics::StructuredClassifiers::CS_LinkKind::NONE)) {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::FeatureValue> value = featureValues->at(i-1);&#xA;&#x9;&#x9;if(value->getValues()->empty()){&#xA;&#x9;&#x9;&#x9;kind = PSCS::Semantics::StructuredClassifiers::CS_LinkKind::NONE;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::Values::Value> v = value->getValues()->at(0);&#xA;&#x9;&#x9;&#x9;bool vIsAValueForAFeatureOfContext = false;&#xA;&#x9;&#x9;&#x9;if(v->equals(interactionPoint)) {&#xA;&#x9;&#x9;&#x9;&#x9;vIsAValueForAFeatureOfContext = true;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if (std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_InteractionPoint>(v)) {&#xA;&#x9;&#x9;&#x9;&#x9;v = (std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_InteractionPoint>(v))->getOwner();&#xA;&#x9;&#x9;&#x9;&#x9;vIsAValueForAFeatureOfContext = this->hasValueForAFeature(v);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;vIsAValueForAFeatureOfContext = this->hasValueForAFeature(v);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;if(!vIsAValueForAFeatureOfContext) {&#xA;&#x9;&#x9;&#x9;&#x9;kind = PSCS::Semantics::StructuredClassifiers::CS_LinkKind::TOENVIRONMENT;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;i += 1;&#xA;&#x9;}&#xA;&#x9;return kind;"/>
          </eAnnotations>
          <eParameters name="link" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Link"/>
          <eParameters name="interactionPoint" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
        </eOperations>
        <eOperations name="getLinks" ordered="false" upperBound="-1" eType="#//Semantics/StructuredClassifiers/CS_Link">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Get all links (available at the locus of this object) where the given interaction point is used as a feature value&#xA;&#x9;// (i.e. the interaction is an end such links)&#xA;&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::ExtensionalValue>> extensionalValues = this->getLocus()->getExtensionalValues();&#xA;&#x9;unsigned int i = 1;&#xA;&#x9;std::shared_ptr&lt;Bag&lt;PSCS::Semantics::StructuredClassifiers::CS_Link>> connectorInstances(new Bag&lt;PSCS::Semantics::StructuredClassifiers::CS_Link>());&#xA;&#x9;while(i &lt;= extensionalValues->size()) {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::ExtensionalValue> value = extensionalValues->at(i-1);&#xA;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Link>(value) != nullptr) {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Link> link = std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Link>(value);&#xA;&#x9;&#x9;&#x9;if(this->getLinkKind(link, interactionPoint) != PSCS::Semantics::StructuredClassifiers::CS_LinkKind::NONE) {&#xA;&#x9;&#x9;&#x9;&#x9;connectorInstances->add(link);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;i += 1;&#xA;&#x9;}&#xA;&#x9;return connectorInstances;"/>
          </eAnnotations>
          <eParameters name="interactionPoint" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
        </eOperations>
        <eOperations name="hasValueForAFeature" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EBoolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Returns true if the given value object is used as a value for a feature value of this object&#xA;&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::SimpleClassifiers::FeatureValue>> allFeatureValues = this->retrieveFeatureValues();&#xA;&#x9;unsigned int i = 1;&#xA;&#x9;bool isAValue = false;&#xA;&#x9;while((i &lt;= allFeatureValues->size()) &amp;&amp; (!isAValue)) {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::FeatureValue> featureValue = allFeatureValues->at(i-1);&#xA;&#x9;&#x9;if(!featureValue->getValues()->empty()) {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> valuesForCurrentFeature = featureValue->getValues();&#xA;&#x9;&#x9;&#x9;unsigned int j = 1;&#xA;&#x9;&#x9;&#x9;while ((j &lt;= valuesForCurrentFeature->size()) &amp;&amp; (!isAValue)) {&#xA;&#x9;&#x9;&#x9;&#x9;isAValue = featureValue->getValues()->at(j-1)->equals(value);&#xA;&#x9;&#x9;&#x9;&#x9;j += 1;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;i += 1;&#xA;&#x9;}&#xA;&#x9;return isAValue;"/>
          </eAnnotations>
          <eParameters name="value" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Values/Value"/>
        </eOperations>
        <eOperations name="dispatchOut" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/Execution">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;std::shared_ptr&lt;fUML::Semantics::CommonBehavior::Execution> execution = nullptr;&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::FeatureValue> featureValue = this->retrieveFeatureValue(onPort);&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> values = featureValue->getValues();&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>> potentialTargets(new Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>());&#xA;&#x9;for(unsigned int i = 0; i &lt; values->size(); i++) {&#xA;&#x9;&#x9;potentialTargets->add(std::dynamic_pointer_cast&lt;fUML::Semantics::StructuredClassifiers::Reference>(values->at(i)));&#xA;&#x9;}&#xA;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_RequestPropagationStrategy> strategy = std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_RequestPropagationStrategy>(this->getLocus()->getFactory()->getStrategy(&quot;requestPropagation&quot;));&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>> targets = strategy->select(potentialTargets, fUML::Semantics::Actions::ActionsFactory::eInstance()->createCallOperationActionActivation());&#xA;&#x9;// if targets is empty, no dispatch target has been found,&#xA;&#x9;// and the operation call is lost&#xA;&#x9;if(targets->size() >= 1) {&#xA;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_InteractionPoint> target = std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_InteractionPoint>(targets->at(0));&#xA;&#x9;&#x9;execution = this->dispatchOut(operation, target);&#xA;&#x9;}&#xA;&#x9;return execution;"/>
          </eAnnotations>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
          <eParameters name="onPort" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
        </eOperations>
        <eOperations name="sendOut" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Select a CS_InteractionPoint value playing onPort,&#xA;&#x9;// and send the event occurrence to this interaction point&#xA;&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::FeatureValue> featureValue = this->getFeatureValue(onPort);&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> values = featureValue->getValues();&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>> potentialTargets(new Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>());&#xA;&#x9;for(unsigned int i = 0; i &lt; values->size(); i++) {&#xA;&#x9;&#x9;potentialTargets->add(std::dynamic_pointer_cast&lt;fUML::Semantics::StructuredClassifiers::Reference>(values->at(i)));&#xA;&#x9;}&#xA;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_RequestPropagationStrategy> strategy = std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_RequestPropagationStrategy>(this->getLocus()->getFactory()->getStrategy(&quot;requestPropagation&quot;));&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>> targets = strategy->select(potentialTargets, fUML::Semantics::Actions::ActionsFactory::eInstance()->createSendSignalActionActivation());&#xA;&#x9;for(unsigned int i = 0; i &lt; targets->size(); i++) {&#xA;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_InteractionPoint> target = std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_InteractionPoint>(targets->at(i));&#xA;&#x9;&#x9;this->sendOut(eventOccurrence, target);&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="onPort" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
        </eOperations>
        <eOperations name="dispatchIn" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/Execution">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// delegates dispatching to composite referent&#xA;&#x9;// Select a CS_InteractionPoint value playing onPort,&#xA;&#x9;// and dispatches the operation call to this interaction point&#xA;&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::FeatureValue> featureValue = this->retrieveFeatureValue(onPort);&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> values = featureValue->getValues();&#xA;&#x9;int choice = (std::dynamic_pointer_cast&lt;fUML::Semantics::Loci::ChoiceStrategy>(this->getLocus()->getFactory()->getStrategy(&quot;choice&quot;)))->choose(featureValue->getValues()->size()) - 1;&#xA;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_InteractionPoint> interactionPoint = std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_InteractionPoint>(values->at(choice));&#xA;&#x9;&#xA;&#x9;return interactionPoint->dispatch(operation);"/>
          </eAnnotations>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
          <eParameters name="onPort" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
        </eOperations>
        <eOperations name="sendIn" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Select a Reference value playing onPort,&#xA;&#x9;// and send the event occurrence to this interaction point&#xA;&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::FeatureValue> featureValue = this->getFeatureValue(onPort);&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> values = featureValue->getValues();&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>> potentialTargets(new Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>());&#xA;&#x9;for(unsigned int i = 0; i &lt; values->size(); i++) {&#xA;&#x9;&#x9;potentialTargets->add(std::dynamic_pointer_cast&lt;fUML::Semantics::StructuredClassifiers::Reference>(values->at(i)));&#xA;&#x9;}&#xA;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_RequestPropagationStrategy> strategy = std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_RequestPropagationStrategy>(this->getLocus()->getFactory()->getStrategy(&quot;requestPropagation&quot;));&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>> targets = strategy->select(potentialTargets, fUML::Semantics::Actions::ActionsFactory::eInstance()->createSendSignalActionActivation());&#xA;&#x9;for(unsigned int i = 0; i &lt; targets->size(); i++) {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Reference> target = targets->at(i);&#xA;&#x9;&#x9;target->send(eventOccurrence);&#xA;&#x9;}"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="onPort" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
        </eOperations>
        <eOperations name="checkAllParents" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EBoolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// If the given classifier is not an Interface, behaves like in fUML.&#xA;&#x9;// Otherwise, check if the given type (or one of its direct or indirect ancestors)&#xA;&#x9;// has an InterfaceRealization relationships with the given classifier.&#xA;&#xA;&#x9;bool matched = false;&#xA;&#x9;if (std::dynamic_pointer_cast&lt;uml::Interface>(classifier) == nullptr) {&#xA;&#x9;&#x9;matched = fUML::Semantics::StructuredClassifiers::ObjectImpl::checkAllParents(type, classifier);&#xA;&#x9;}&#xA;&#x9;else if (std::dynamic_pointer_cast&lt;uml::Class>(type) == nullptr) {&#xA;&#x9;&#x9;matched = false;&#xA;&#x9;}&#xA;&#x9;else if (this->realizesInterface(std::dynamic_pointer_cast&lt;uml::Class>(type), std::dynamic_pointer_cast&lt;uml::Interface>(classifier))) {&#xA;&#x9;&#x9;matched = true;&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;uml::Classifier>> directParents = type->getGeneral();&#xA;&#x9;&#x9;unsigned int i = 1;&#xA;&#x9;&#x9;while ((!matched) &amp;&amp; (i &lt;= directParents->size())) {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::Classifier> directParent = directParents->at(i-1);&#xA;&#x9;&#x9;&#x9;matched = this->checkAllParents(directParent, classifier);&#xA;&#x9;&#x9;&#x9;i += 1;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return matched;"/>
          </eAnnotations>
          <eParameters name="type" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Classifier"/>
          <eParameters name="classifier" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Classifier"/>
        </eOperations>
        <eOperations name="isDescendant" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EBoolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Checks if the given contract is a descendant of the given interface_&#xA;&#xA;&#x9;bool matched = false;&#xA;&#x9;std::shared_ptr&lt;Bag&lt;uml::Classifier>> descendants = contract->getGeneral();&#xA;&#x9;unsigned int i = 1;&#xA;&#x9;while((i &lt;= descendants->size()) &amp;&amp; (!matched)) {&#xA;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;uml::Interface>(descendants->at(i-1)) != nullptr) {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::Interface> descendant = std::dynamic_pointer_cast&lt;uml::Interface>(descendants->at(i-1));&#xA;&#x9;&#x9;&#x9;if(descendant == interface_) {&#xA;&#x9;&#x9;&#x9;&#x9;matched = true;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;matched = this->isDescendant(descendant, interface_);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;i += 1;&#xA;&#x9;}&#xA;&#x9;return matched;"/>
          </eAnnotations>
          <eParameters name="contract" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Interface"/>
          <eParameters name="interface_" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Interface"/>
        </eOperations>
        <eOperations name="realizesInterface" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EBoolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Checks if the given type has an InterfaceRealization relationship&#xA;&#x9;// with the given interface or a descendant of the interfac&#xA;&#xA;&#x9;std::shared_ptr&lt;Bag&lt;uml::InterfaceRealization>> realizations = type->getInterfaceRealization();&#xA;&#x9;bool realized = false;&#xA;&#x9;unsigned int i = 1;&#xA;&#x9;while((i &lt;= realizations->size()) &amp;&amp; (!realized)) {&#xA;&#x9;&#x9;std::shared_ptr&lt;uml::InterfaceRealization> realization = realizations->at(i-1);&#xA;&#x9;&#x9;std::shared_ptr&lt;uml::Interface> contract = realization->getContract();&#xA;&#x9;&#x9;if(contract == interface_) {&#xA;&#x9;&#x9;&#x9;realized = true;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else if (this->isDescendant(contract, interface_)) {&#xA;&#x9;&#x9;&#x9;realized = true;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;i += 1;&#xA;&#x9;}&#xA;&#x9;return realized;"/>
          </eAnnotations>
          <eParameters name="type" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class"/>
          <eParameters name="interface_" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Interface"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_InteractionPoint" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/StructuredClassifiers/Reference">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;PSCS/Semantics/CommonBehavior/CS_EventOccurrence.hpp&quot;&#xA;#include &quot;PSCS/Semantics/CommonBehavior/CommonBehaviorFactory.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="startBehavior" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Overriden to do nothing"/>
          </eAnnotations>
          <eParameters name="classifier" ordered="false" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class"/>
          <eParameters name="inputs" ordered="false" upperBound="-1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/ParameterValue"/>
        </eOperations>
        <eOperations name="dispatch" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/Execution">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Delegates dispatching to the owning object&#xA;&#x9;return this->getOwner()->dispatchIn(operation, getThisCS_InteractionPointPtr());"/>
          </eAnnotations>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
        </eOperations>
        <eOperations name="send" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// An event occurrence that passes through a CS_InteractionPoint is&#xA;&#x9;// (if necessary) wrapped in a CS_EventOccurrence. This event occurrence&#xA;&#x9;// is then sent to the owning object.&#xA;&#xA;&#x9;std::shared_ptr&lt;PSCS::Semantics::CommonBehavior::CS_EventOccurrence> wrappingEventOccurrence = nullptr;&#xA;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::CommonBehavior::CS_EventOccurrence>(eventOccurrence) != nullptr) {&#xA;&#x9;&#x9;wrappingEventOccurrence = std::dynamic_pointer_cast&lt;PSCS::Semantics::CommonBehavior::CS_EventOccurrence>(eventOccurrence);&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;wrappingEventOccurrence = PSCS::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createCS_EventOccurrence();&#xA;&#x9;&#x9;wrappingEventOccurrence->setWrappedEventOccurrence(eventOccurrence);&#xA;&#x9;}&#xA;&#x9;wrappingEventOccurrence->setInteractionPoint(getThisCS_InteractionPointPtr());&#xA;&#x9;this->getOwner()->sendIn(wrappingEventOccurrence, getThisCS_InteractionPointPtr());"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        </eOperations>
        <eOperations name="checkAllParents" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EBoolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Delegates the type checking to the reference&#xA;&#x9;return std::dynamic_pointer_cast&lt;CS_InteractionPoint>(this->getReferent())->checkAllParents(type, classifier);"/>
          </eAnnotations>
          <eParameters name="type" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Classifier"/>
          <eParameters name="classifier" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Classifier"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="owner" ordered="false"
            lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Reference"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="definingPort" ordered="false"
            lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_Reference" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/StructuredClassifiers/Reference">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;fUML/fUMLFactory.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="copy" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Values/Value">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="doNotGenerate"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="dispatchIn" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/Execution">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;//Delegates dispatching to composite referent&#xA;&#x9;return this->getCompositeReferent()->dispatchIn(operation, interactionPoint);"/>
          </eAnnotations>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
          <eParameters name="interactionPoint" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
        </eOperations>
        <eOperations name="sendIn" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// delegates sending to composite referent&#xA;&#x9;this->getCompositeReferent()->sendIn(eventOccurrence, interactionPoint);"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="interactionPoint" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
        </eOperations>
        <eOperations name="sendOut" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// delegates sending to composite referent&#xA;&#x9;this->getCompositeReferent()->sendOut(eventOccurrence, onPort);"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="onPort" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
        </eOperations>
        <eOperations name="dispatchOut" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/Execution">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// delegates dispatching to composite referent&#xA;&#x9;return this->getCompositeReferent()->dispatchOut(operation, onPort);"/>
          </eAnnotations>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
          <eParameters name="onPort" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
        </eOperations>
        <eOperations name="dispatchIn" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/Execution">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// delegates dispatching to composite referent&#xA;&#x9;return this->getCompositeReferent()->dispatchIn(operation, onPort);"/>
          </eAnnotations>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
          <eParameters name="onPort" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
        </eOperations>
        <eOperations name="sendIn" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// delegates sending to composite referent&#xA;&#x9;this->getCompositeReferent()->sendIn(eventOccurrence, onPort);"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="onPort" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
        </eOperations>
        <eOperations name="dispatchOut" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/Execution">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Delegates dispatching (through the interaction point, to the environment) &#xA;&#x9;// to compositeReferent&#xA;&#x9;return this->getCompositeReferent()->dispatchOut(operation, interactionPoint);"/>
          </eAnnotations>
          <eParameters name="operation" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Operation"/>
          <eParameters name="interactionPoint" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
        </eOperations>
        <eOperations name="sendOut" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Delegates sending (through the interaction point, to the environment)&#xA;&#x9;// to compositeReferent&#xA;&#x9;this->getCompositeReferent()->sendOut(eventOccurrence, interactionPoint);"/>
          </eAnnotations>
          <eParameters name="eventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
          <eParameters name="interactionPoint" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
        </eOperations>
        <eOperations name="_copy" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Values/Value">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Create a new reference with the same referent and composite referent&#xA;// as this reference.&#xA;&#xA;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference> newValue = PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_Reference();&#xA;newValue->setReferent(this->getReferent());&#xA;newValue->setCompositeReferent(this->getCompositeReferent());&#xA;&#xA;return newValue;"/>
          </eAnnotations>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="compositeReferent"
            ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Object"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EEnum" name="CS_LinkKind">
        <eLiterals name="ToEnvironment"/>
        <eLiterals name="ToInternal" value="1"/>
        <eLiterals name="None" value="2"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_RequestPropagationStrategy" abstract="true"
          eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/Loci/SemanticStrategy">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value=""/>
        </eAnnotations>
        <eOperations name="getName" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EString">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// a CS_RequestPropagationStrategy are always named &quot;requestPropagation&quot;&#xA;&#x9;return &quot;requestPropagation&quot;;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="select" ordered="false" upperBound="-1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/StructuredClassifiers/Reference">
          <eParameters name="potentialTargets" ordered="false" upperBound="-1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/StructuredClassifiers/Reference"/>
          <eParameters name="context" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Loci/SemanticVisitor"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_DefaultRequestPropagationStrategy"
          eSuperTypes="#//Semantics/StructuredClassifiers/CS_RequestPropagationStrategy">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;fUML/Semantics/Actions/SendSignalActionActivation.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="select" upperBound="-1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/StructuredClassifiers/Reference">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;&#x9;// returns all potential targets in the case where the context is a SendSignalActionActivation&#xA;&#x9;// returns the first potential target in the case where the context is anything else&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>> selectedTargets(new Bag&lt;fUML::Semantics::StructuredClassifiers::Reference>());&#xA;&#x9;if(std::dynamic_pointer_cast&lt;fUML::Semantics::Actions::SendSignalActionActivation>(context) != nullptr) {&#xA;&#x9;&#x9;for(unsigned int i = 0; i &lt; potentialTargets->size(); i++) {&#xA;&#x9;&#x9;&#x9;selectedTargets->add(potentialTargets->at(i));&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;if(potentialTargets->size() >= 1) {&#xA;&#x9;&#x9;&#x9;selectedTargets->add(potentialTargets->at(0));&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return selectedTargets;"/>
          </eAnnotations>
          <eParameters name="potentialTargets" upperBound="-1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/StructuredClassifiers/Reference"/>
          <eParameters name="context" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Loci/SemanticVisitor"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_Link" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/StructuredClassifiers/Link">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;fUML/fUMLFactory.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="hasValueForAFeature" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EBoolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;&#x9;// Returns true if the given value object is used as a value for a FeatureValue of this link&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::SimpleClassifiers::FeatureValue>> allFeatureValues = this->getFeatureValues();&#xA;&#x9;unsigned int i = 1;&#xA;&#x9;bool isAValue = false;&#xA;&#x9;while((i &lt;= allFeatureValues->size()) &amp;&amp; (!isAValue)) {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::FeatureValue> featureValue = allFeatureValues->at(i-1);&#xA;&#x9;&#x9;isAValue = (!(featureValue->getValues()->empty())) &amp;&amp; (featureValue->getValues()->at(0)->equals(value));&#xA;&#x9;&#x9;i += 1;&#xA;&#x9;}&#xA;&#x9;return isAValue;"/>
          </eAnnotations>
          <eParameters name="value" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Values/Value"/>
        </eOperations>
        <eOperations name="getFeature" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//StructuralFeature">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::SimpleClassifiers::FeatureValue>> allFeatureValues = this->getFeatureValues();&#xA;&#x9;unsigned int i = 1;&#xA;&#x9;std::shared_ptr&lt;uml::StructuralFeature> feature = nullptr;&#xA;&#x9;while((i &lt;= allFeatureValues->size()) &amp;&amp; (feature == nullptr)) {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::FeatureValue> featureValue = allFeatureValues->at(i-1);&#xA;&#x9;&#x9;if((!(featureValue->getValues()->empty())) &amp;&amp; (featureValue->getValues()->at(0)->equals(value))) {&#xA;&#x9;&#x9;&#x9;feature = featureValue->getFeature();&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;i += 1;&#xA;&#x9;}&#xA;&#x9;return feature;"/>
          </eAnnotations>
          <eParameters name="value" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Values/Value"/>
        </eOperations>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="Loci" nsURI="http:///PSCS_Semantics/Semantics/Loci.ecore"
        nsPrefix="PSCS_Semantics.Semantics.Loci">
      <eClassifiers xsi:type="ecore:EClass" name="CS_Locus" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/Loci/Locus">
        <eOperations name="instantiate" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//MDE4CPP_Extensions/FUML_Object">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Extends fUML semantics by instantiating a CS_Object&#xA;&#x9;// in the case where type is not a Behavior.&#xA;&#x9;// Otherwise behaves like in fUML&#xA;&#x9;/*std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Object> object = nullptr;&#xA;&#x9;if(std::dynamic_pointer_cast&lt;uml::Behavior>(type) != nullptr) {&#xA;&#x9;&#x9;object = fUML::Semantics::Loci::LocusImpl::instantiate(type);&#xA;&#x9;}&#xA;&#x9;else  {&#xA;&#x9;&#x9;object = PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_Object();&#xA;&#x9;&#x9;object->getTypes()->add(type);&#xA;&#x9;&#x9;object->createFeatureValues();&#xA;&#x9;&#x9;this->add(object);&#xA;&#x9;}&#xA;&#x9;return object;*/&#xA;&#xA;/*&#xA; * This method is implemented in every model-specific locus&#xA; */&#xA;&#xA;return nullptr;"/>
          </eAnnotations>
          <eParameters name="type" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class"/>
        </eOperations>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_ExecutionFactory" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/Loci/ExecutionFactory">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;uml/umlPackage.hpp&quot;&#xA;&#xA;#include &quot;uml/ReadExtentAction.hpp&quot;&#xA;#include &quot;uml/AddStructuralFeatureValueAction.hpp&quot;&#xA;#include &quot;uml/ClearStructuralFeatureAction.hpp&quot;&#xA;#include &quot;uml/CreateLinkAction.hpp&quot;&#xA;#include &quot;uml/CreateObjectAction.hpp&quot;&#xA;#include &quot;uml/ReadSelfAction.hpp&quot;&#xA;#include &quot;uml/AcceptCallAction.hpp&quot;&#xA;#include &quot;uml/InstanceValue.hpp&quot;&#xA;#include &quot;uml/AcceptEventAction.hpp&quot;&#xA;#include &quot;uml/CallOperationAction.hpp&quot;&#xA;#include &quot;uml/SendSignalAction.hpp&quot;&#xA;#include &quot;uml/OpaqueExpression.hpp&quot;&#xA;#include &quot;uml/RemoveStructuralFeatureValueAction.hpp&quot;&#xA;#include &quot;uml/Classifier.hpp&quot;&#xA;//#include &quot;fUML/Semantics/CommonBehavior/CallEventBehavior.hpp&quot;&#xA;&#xA;&#xA;#include &quot;PSCS/Semantics/Actions/CS_ReadExtentActionActivation.hpp&quot;&#xA;#include &quot;PSCS/Semantics/Actions/CS_AddStructuralFeatureValueActionActivation.hpp&quot;&#xA;#include &quot;PSCS/Semantics/Actions/CS_ClearStructuralFeatureActionActivation.hpp&quot;&#xA;#include &quot;PSCS/Semantics/Actions/CS_CreateLinkActionActivation.hpp&quot;&#xA;#include &quot;PSCS/Semantics/Actions/CS_CreateObjectActionActivation.hpp&quot;&#xA;#include &quot;PSCS/Semantics/Actions/CS_ReadSelfActionActivation.hpp&quot;&#xA;//#include &quot;PSCS/Semantics/Actions/CS_AcceptCallActionActivation.hpp&quot;&#xA;//#include &quot;PSCS/Semantics/Classification/CS_InstanceValueEvaluation.hpp&quot;&#xA;#include &quot;PSCS/Semantics/Actions/CS_AcceptEventActionActivation.hpp&quot;&#xA;#include &quot;PSCS/Semantics/Actions/CS_CallOperationActionActivation.hpp&quot;&#xA;#include &quot;PSCS/Semantics/Actions/CS_SendSignalActionActivation.hpp&quot;&#xA;#include &quot;PSCS/Semantics/Actions/CS_RemoveStructuralFeatureValueActionActivation.hpp&quot;&#xA;//#include &quot;PSCS/Semantics/Values/CS_OpaqueExpressionEvaluation.hpp&quot;&#xA;//#include &quot;PSCS/Semantics/CommonBehavior/CS_CallEventExecution.hpp&quot;&#xA;//#include &quot;PSCS/Semantics/CommonBehavior/CommonBehaviorFactory.hpp&quot;&#xA;#include &quot;PSCS/Semantics/Actions/ActionsFactory.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="instantiateVisitor" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/Loci/SemanticVisitor">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Extends fUML semantics in the sense that newly introduced &#xA;&#x9;// semantic visitors are instantiated instead of fUML visitors&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::Loci::SemanticVisitor> visitor = nullptr;&#xA;&#x9;&#xA;&#x9;switch(element->eClass()->getClassifierID())&#xA;&#x9;{&#xA;&#x9;&#x9;case uml::umlPackage::READEXTENTACTION_CLASS: &#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;visitor = PSCS::Semantics::Actions::ActionsFactory::eInstance()->createCS_ReadExtentActionActivation();&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;case uml::umlPackage::ADDSTRUCTURALFEATUREVALUEACTION_CLASS:&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;visitor = PSCS::Semantics::Actions::ActionsFactory::eInstance()->createCS_AddStructuralFeatureValueActionActivation();&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;case uml::umlPackage::CLEARSTRUCTURALFEATUREACTION_CLASS:&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;visitor = PSCS::Semantics::Actions::ActionsFactory::eInstance()->createCS_ClearStructuralFeatureActionActivation();&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;case uml::umlPackage::CREATELINKACTION_CLASS:&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;visitor = PSCS::Semantics::Actions::ActionsFactory::eInstance()->createCS_CreateLinkActionActivation();&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;case uml::umlPackage::CREATEOBJECTACTION_CLASS:&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;visitor = PSCS::Semantics::Actions::ActionsFactory::eInstance()->createCS_CreateObjectActionActivation();&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;case uml::umlPackage::READSELFACTION_CLASS:&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;visitor = PSCS::Semantics::Actions::ActionsFactory::eInstance()->createCS_ReadSelfActionActivation();&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;case uml::umlPackage::ACCEPTCALLACTION_CLASS:&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;//visitor = PSCS::Semantics::Actions::ActionsFactory::eInstance()->createCS_AcceptCallActionActivation();&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;case uml::umlPackage::INSTANCEVALUE_CLASS:&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;//visitor = PSCS::Semantics::Classification::ClassificationFactory::eInstance()->createCS_InstanceValueEvaluation();&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;case uml::umlPackage::ACCEPTEVENTACTION_CLASS: &#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;visitor = PSCS::Semantics::Actions::ActionsFactory::eInstance()->createCS_AcceptEventActionActivation();&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;case uml::umlPackage::CALLOPERATIONACTION_CLASS:&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;visitor = PSCS::Semantics::Actions::ActionsFactory::eInstance()->createCS_CallOperationActionActivation();&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;case uml::umlPackage::SENDSIGNALACTION_CLASS:&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;visitor = PSCS::Semantics::Actions::ActionsFactory::eInstance()->createCS_SendSignalActionActivation();&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;case uml::umlPackage::OPAQUEEXPRESSION_CLASS:&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;//visitor = PSCS::Semantics::Values::ValuesFactory::eInstance()->createCS_OpaqueExpressionEvaluation();&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;case uml::umlPackage::REMOVESTRUCTURALFEATUREVALUEACTION_CLASS:&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;visitor = PSCS::Semantics::Actions::ActionsFactory::eInstance()->createCS_RemoveStructuralFeatureValueActionActivation();&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;/*case fUML::Semantics::CommonBehavior::CommonBehaviorPackage::CALLEVENTBEHAVIOR_CLASS:&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;visitor = PSCS::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createCS_CallEventExecution();&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}*/&#xA;&#x9;&#x9;default:&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;visitor = fUML::Semantics::Loci::ExecutionFactoryImpl::instantiateVisitor(element);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return visitor;"/>
          </eAnnotations>
          <eParameters name="element" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Element"/>
        </eOperations>
        <eOperations name="getStereotypeClass" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Classifier">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="return nullptr;"/>
          </eAnnotations>
          <eParameters name="profileName" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EString"/>
          <eParameters name="stereotypeName" ordered="false" lowerBound="1" eType="ecore:EDataType platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EString"/>
        </eOperations>
        <eOperations name="getStereotypeApplication" ordered="false" lowerBound="1"
            eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Element">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;/*std::shared_ptr&lt;Bag&lt;fUML::Semantics::StructuredClassifiers::ExtensionalValue>> extent = this->getLocus().lock()->retrieveExtent(stereotype);&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Object> extensionObject = nullptr;&#xA;&#x9;unsigned int i = 1;&#xA;&#x9;while((i &lt;= extent->size()) &amp;&amp; (extensionObject == nullptr)) {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::ExtensionalValue> object = extent->at(i-1);&#xA;&#x9;&#x9;&#xA;&#x9;//Aktuell nicht funktionfhig, unbekannte Variable &quot;baseEnd&quot;&#xA;&#x9;&#x9;if(object->retrieveFeatureValue(baseEnd)->getValues()->at(0)->equals(element)) {&#xA;&#x9;&#x9;&#x9;extensionObject = dynamic_pointer_cast&lt;fUML::Object>(object);&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;i++;&#xA;&#x9;}&#xA;&#x9;return extensionObject;*/&#xA;&#xA;&#x9;return nullptr;"/>
          </eAnnotations>
          <eParameters name="stereotype" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class"/>
          <eParameters name="element" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Element"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="appliedProfiles" ordered="false"
            upperBound="-1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Package"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_Executor" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/Loci/Executor">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="//#include &quot;PSCS/Semantics/StructuredClassifiers/CS_Object.hpp&quot;&#xA;//#include &quot;PSCS/Semantics/StructuredClassifiers/CS_Reference.hpp&quot;&#xA;//#include &quot;PSCS/Semantics/StructuredClassifiers/StructuredClassifiersFactory.hpp&quot;&#xA;//#include &quot;fUML/Semantics/StructuredClassifiers/Object.hpp&quot;&#xA;#include &quot;fUML/Semantics/StructuredClassifiers/StructuredClassifiersFactory.hpp&quot;&#xA;#include &quot;fUML/fUMLFactory.hpp&quot;&#xA;#include &quot;fUML/MDE4CPP_Extensions/FUML_Object.hpp&quot;"/>
        </eAnnotations>
        <eOperations name="start" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Element">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Instantiate the given class and start any behavior of the resulting&#xA;&#x9;// object.&#xA;&#x9;// (The behavior of an object implIncludes any classifier behaviors for an&#xA;&#x9;// active object or the class of the object itself, if that is a&#xA;&#x9;// behavior.)&#xA;&#x9;// fUML semantics is extended in the sense that when the instantiated object&#xA;&#x9;// is a CS_Object, a CS_Reference is returned (instead of a Reference)&#xA;&#x9;DEBUG_INFO(&quot;[start] Starting &quot; &lt;&lt; type->getName() &lt;&lt; &quot;...&quot;)&#xA;&#x9;&#xA;&#x9;std::shared_ptr&lt;uml::Element> object = this->getLocus().lock()->instantiate(type);&#xA;&#x9;&#xA;&#x9;/* Currently not supported&#xA;&#x9;DEBUG_MESSAGE(std::cout &lt;&lt; &quot;[start] Object = &quot; &lt;&lt; object->toString() &lt;&lt; std::endl;)&#xA;&#x9;object->startBehavior(type, inputs);&#xA;&#x9;&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Reference> reference;&#xA;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(object) != nullptr) {&#xA;&#x9;&#x9;reference = PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_Reference();&#xA;&#x9;&#x9;(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(reference))->setCompositeReferent(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(object));&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;reference = fUML::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createReference();&#xA;&#x9;}&#xA;&#x9;reference->setReferent(object);&#xA;&#x9;&#xA;&#x9;return reference;*/&#xA;&#xA;&#x9;return nullptr;"/>
          </eAnnotations>
          <eParameters name="type" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Class"/>
          <eParameters name="inputs" upperBound="-1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/ParameterValue"/>
        </eOperations>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="CommonBehavior" nsURI="http:///PSCS_Semantics/Semantics/CommonBehavior.ecore"
        nsPrefix="PSCS_Semantics.Semantics.CommonBehavior">
      <eAnnotations source="http://tu-ilmenau.de/see/codegen">
        <details key="doNotGenerate"/>
      </eAnnotations>
      <eClassifiers xsi:type="ecore:EClass" name="CS_CallEventExecution" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/CallEventExecution">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;PSCS/Semantics/CommonBehavior/CS_EventOccurrence.hpp&quot;&#xA;#include &quot;fUML/fUMLFactory.hpp&quot;"/>
          <details key="doNotGenerate" value="Class 'CS_CallEventExecution' is excluded from generation because base class &quot;CallEventExecution&quot; is currently not supported."/>
        </eAnnotations>
        <eOperations name="createEventOccurrence" ordered="false" lowerBound="1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Wrap the created event occurrence within a CS_EventOccurrence which&#xA;&#x9;// references the behavior port on which the call was dispatched.&#xA;&#x9;std::shared_ptr&lt;PSCS::Semantics::CommonBehavior::CS_EventOccurrence> wrappingEventOccurrence = PSCS::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createCS_EventOccurrence();&#xA;&#x9;wrappingEventOccurrence->setInteractionPoint(this->getInteractionPoint());&#xA;&#x9;wrappingEventOccurrence->setWrappedEventOccurrence(fUML::Semantics::CommonBehavior::CallEventExecutionImpl::createEventOccurrence());&#xA;&#x9;return wrappingEventOccurrence;"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="new_" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Create a new call event execution.&#xA;&#xA;return PSCS::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createCS_CallEventExecution();"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="_copy" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Create a new call event execution that is a copy of this execution&#xA;// with no referenced interaction point.&#xA;&#xA;std::shared_ptr&lt;PSCS::Semantics::CommonBehavior::CS_CallEventExecution> newValue = std::dynamic_pointer_cast&lt;PSCS::Semantics::CommonBehavior::CS_CallEventExecution>(fUML::Semantics::CommonBehavior::CallEventExecutionImpl::_copy());&#xA;newValue->setInteractionPoint(nullptr);&#xA;return newValue;"/>
          </eAnnotations>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="interactionPoint" ordered="false"
            eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
      </eClassifiers>
      <eClassifiers xsi:type="ecore:EClass" name="CS_EventOccurrence" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;fUML/fUMLFactory.hpp&quot;"/>
        </eAnnotations>
        <eAnnotations source="TODO"/>
        <eOperations name="getParameterValues" ordered="false" upperBound="-1" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/ParameterValue">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="// Return the parametric data of the referenced event occurrence&#xA;return this->getWrappedEventOccurrence()->getParameterValues();"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="match" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// If the trigger references ports then to match this latter it is required that &#xA;&#x9;// 1] the interaction point is instance of port referenced by the trigger&#xA;&#x9;// 2] the referenced event occurrence match operation returns true.&#xA;&#x9;// If the trigger does not reference ports then the behavior is the same than for fUML.&#xA;&#xA;&#x9;bool matches = false;&#xA;&#x9;if(trigger->getPort()->size() > 0) {&#xA;&#x9;&#x9;unsigned int i = 1;&#xA;&#x9;&#x9;while((!matches) &amp;&amp; (i &lt;= trigger->getPort()->size())) {&#xA;&#x9;&#x9;&#x9;if(this->getInteractionPoint()->getDefiningPort() == trigger->getPort()->at(i-1)){&#xA;&#x9;&#x9;&#x9;&#x9;matches = true;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;i++;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if(matches)&#x9;{&#xA;&#x9;&#x9;&#x9;matches = this->getWrappedEventOccurrence()->match(trigger);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;matches = this->getWrappedEventOccurrence()->match(trigger);&#xA;&#x9;}&#xA;&#x9;return matches;"/>
          </eAnnotations>
          <eParameters name="trigger" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Trigger"/>
        </eOperations>
        <eOperations name="doSend" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// If the specified target is a CS_Reference and the propagation must be done&#xA;&#x9;// to the environment, then the operation sendOut(EventOccurrence, Port) is called&#xA;&#x9;// and make the propagation to continue.&#xA;&#x9;// If the specified target is a CS_Reference but the propagation must be done to&#xA;&#x9;// the internals then the operation sendIn(EventOccurrence, Port) is called.&#xA;&#x9;// In the case were the target is not a CS_EventOccurrence then send(EventOccurence)&#xA;&#x9;// is called.&#xA;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(this->getTarget()) != nullptr) {&#xA;&#x9;&#x9;if(this->isPropagationInward()) {&#xA;&#x9;&#x9;&#x9;std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(this->getTarget())->sendIn(this->getThisCS_EventOccurrencePtr(), this->getOnPort());&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(this->getTarget())->sendOut(this->getThisCS_EventOccurrencePtr(), this->getOnPort());&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;fUML::Semantics::CommonBehavior::EventOccurrenceImpl::doSend();&#xA;&#x9;}"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="sendInTo" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Propagate the sending of the event occurrence to the internals&#xA;&#x9;this->setOnPort(port);&#xA;&#x9;this->setPropagationInward(true);&#xA;&#x9;this->sendTo(std::dynamic_pointer_cast&lt;fUML::Semantics::StructuredClassifiers::Reference>(target));"/>
          </eAnnotations>
          <eParameters name="target" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Reference"/>
          <eParameters name="port" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
        </eOperations>
        <eOperations name="sendOutTo" ordered="false" lowerBound="1">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Propagate the sending of the event occurrence to the environment&#xA;&#x9;this->setOnPort(port);&#xA;&#x9;this->setPropagationInward(false);&#xA;&#x9;this->sendTo(std::dynamic_pointer_cast&lt;fUML::Semantics::StructuredClassifiers::Reference>(target));"/>
          </eAnnotations>
          <eParameters name="target" ordered="false" lowerBound="1" eType="#//Semantics/StructuredClassifiers/CS_Reference"/>
          <eParameters name="port" ordered="false" lowerBound="1" eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
        </eOperations>
        <eStructuralFeatures xsi:type="ecore:EReference" name="interactionPoint" ordered="false"
            eType="#//Semantics/StructuredClassifiers/CS_InteractionPoint"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="wrappedEventOccurrence"
            ordered="false" eType="ecore:EClass ../../fuml/model/fUML.ecore#//Semantics/CommonBehavior/EventOccurrence"/>
        <eStructuralFeatures xsi:type="ecore:EAttribute" name="propagationInward"
            ordered="false" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"/>
        <eStructuralFeatures xsi:type="ecore:EReference" name="onPort" ordered="false"
            eType="ecore:EClass http://www.eclipse.org/uml2/5.0.0/UML#//Port"/>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="Values" nsURI="http:///PSCS_Semantics/Semantics/Values.ecore"
        nsPrefix="PSCS_Semantics.Semantics.Values">
      <eAnnotations source="obsolete"/>
      <eAnnotations source="http://tu-ilmenau.de/see/codegen">
        <details key="doNotGenerate" value="Package 'Values' is excluded from generation because it is obsolete."/>
      </eAnnotations>
      <eClassifiers xsi:type="ecore:EClass" name="CS_OpaqueExpressionEvaluation" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/Values/Evaluation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;abstractDataTypes/Subset.hpp&quot;&#xA;#include &quot;fUML/fUMLFactory.hpp&quot;&#xA;#include &quot;fUML/Semantics/Loci/Locus.hpp&quot;&#xA;#include &quot;fUML/Semantics/Loci/Executor.hpp&quot;&#xA;#include &quot;fUML/Semantics/CommonBehavior/ParameterValue.hpp&quot;&#xA;#include &quot;uml/OpaqueExpression.hpp&quot;&#xA;#include &quot;uml/Behavior.hpp&quot;"/>
          <details key="doNotGenerate" value="Class 'CS_OpaqueExpressionEvaluation' is currently not supported."/>
        </eAnnotations>
        <eOperations name="evaluate" ordered="false" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// Execute the behavior associated with the context OpaqueExpression, if any.&#xA;&#x9;// If multiple return values are computed, then return the first one.&#xA;&#x9;// If no values are computed, return null&#xA;&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> evaluation = this->executeExpressionBehavior();&#xA;&#xA;&#x9;if(evaluation->size() > 0) {&#xA;&#x9;&#x9;return evaluation->at(0);&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;return nullptr;&#xA;&#x9;}"/>
          </eAnnotations>
        </eOperations>
        <eOperations name="executeExpressionBehavior" ordered="false" upperBound="-1"
            eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// If a behavior is associated with the context OpaqueExpression,&#xA;&#x9;// then execute this behavior, and return computed values.&#xA;&#x9;// Otherwise, return an empty list of values.&#xA;&#xA;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> evaluation(new Bag&lt;fUML::Semantics::Values::Value>());&#xA;&#x9;std::shared_ptr&lt;uml::OpaqueExpression> expression = std::dynamic_pointer_cast&lt;uml::OpaqueExpression>(this->getSpecification());&#xA;&#x9;std::shared_ptr&lt;uml::Behavior> behavior = expression->getBehavior();&#xA;&#xA;&#x9;if(behavior != nullptr) {&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::CommonBehavior::ParameterValue>> inputs (new Bag&lt;fUML::Semantics::CommonBehavior::ParameterValue>());&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::CommonBehavior::ParameterValue>> results = this->getLocus()->getExecutor()->execute(behavior, nullptr, inputs);&#xA;&#xA;&#x9;&#x9;Bag&lt;fUML::Semantics::CommonBehavior::ParameterValue>::const_iterator resultsIter;&#xA;&#xA;&#x9;&#x9;for(resultsIter = results->begin(); resultsIter != results->end(); resultsIter++) {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::CommonBehavior::ParameterValue> parameterValue = (*resultsIter);&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> values = parameterValue->getValues();&#xA;&#xA;&#x9;&#x9;&#x9;Bag&lt;fUML::Semantics::Values::Value>::const_iterator valuesIter;&#xA;&#xA;&#x9;&#x9;&#x9;for(valuesIter = values->begin(); valuesIter != values->end(); valuesIter++) {&#xA;&#x9;&#x9;&#x9;&#x9;evaluation->add((*valuesIter));&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;return evaluation;"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
    </eSubpackages>
    <eSubpackages name="Classification" nsURI="http:///PSCS_Semantics/Semantics/Classification.ecore"
        nsPrefix="PSCS_Semantics.Semantics.Classification">
      <eAnnotations source="obsolete"/>
      <eAnnotations source="http://tu-ilmenau.de/see/codegen">
        <details key="doNotGenerate" value="Package 'Classification' is excluded from generation because it is obsolete."/>
      </eAnnotations>
      <eClassifiers xsi:type="ecore:EClass" name="CS_InstanceValueEvaluation" eSuperTypes="../../fuml/model/fUML.ecore#//Semantics/Classification/InstanceValueEvaluation">
        <eAnnotations source="http://tu-ilmenau.de/see/codegen">
          <details key="implIncludes" value="#include &quot;PSCS/Semantics/StructuredClassifiers/CS_Object.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/CS_Reference.hpp&quot;&#xA;#include &quot;PSCS/Semantics/StructuredClassifiers/StructuredClassifiersFactory.hpp&quot;&#xA;#include &quot;fUML/fUMLFactory.hpp&quot;&#xA;#include &quot;fUML/Semantics/SimpleClassifiers/EnumerationValue.hpp&quot;&#xA;#include &quot;fUML/Semantics/SimpleClassifiers/DataValue.hpp&quot;&#xA;#include &quot;fUML/Semantics/SimpleClassifiers/SimpleClassifiersFactory.hpp&quot;&#xA;#include &quot;fUML/Semantics/Loci/ExecutionFactory.hpp&quot;&#xA;#include &quot;fUML/Semantics/StructuredClassifiers/Object.hpp&quot;&#xA;#include &quot;fUML/Semantics/StructuredClassifiers/StructuredClassifiersFactory.hpp&quot;&#xA;#include &quot;fUML/Semantics/CommonBehavior/Execution.hpp&quot;&#xA;#include &quot;fUML/Semantics/Loci/Executor.hpp&quot;&#xA;#include &quot;fUML/Semantics/StructuredClassifiers/Reference.hpp&quot;&#xA;#include &quot;uml/InstanceValue.hpp&quot;&#xA;#include &quot;uml/InstanceSpecification.hpp&quot;&#xA;#include &quot;uml/EnumerationLiteral.hpp&quot;&#xA;#include &quot;uml/Enumeration.hpp&quot;&#xA;#include &quot;uml/Behavior.hpp&quot;&#xA;#include &quot;uml/Slot.hpp&quot;&#xA;"/>
          <details key="doNotGenerate" value="Class 'CS_InstanceValueEvaluation' is currently not supported."/>
        </eAnnotations>
        <eOperations name="evaluate" ordered="false" lowerBound="1" eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EJavaObject">
          <eAnnotations source="http://tu-ilmenau.de/see/codegen">
            <details key="body" value="&#x9;// If the instance specification is for an enumeration, then return the&#xA;&#x9;// identified enumeration literal.&#xA;&#x9;// If the instance specification is for a data type (but not a primitive&#xA;&#x9;// value or an enumeration), then create a data value of the given data&#xA;&#x9;// type.&#xA;&#x9;// If the instance specification is for an object, then create an object&#xA;&#x9;// at the current locus with the specified types.&#xA;&#x9;// Set each feature of the created value to the result of evaluating the&#xA;&#x9;// value specifications for the specified slot for the feature.&#xA;&#x9;// Extends fUML semantics in the sense that when the instance specification&#xA;&#x9;// is for an object which is not typed by a Behaviore, A CS_Reference (to a&#xA;&#x9;// CS_Object) is produced instead of a Reference (to an Object)&#xA;&#xA;&#x9;DEBUG_MESSAGE(std::cout &lt;&lt; &quot;[evaluate] InstanceValueEvaluation...&quot; &lt;&lt; std::endl;)&#xA;&#xA;&#x9;std::shared_ptr&lt;uml::InstanceValue> instanceValue = std::dynamic_pointer_cast&lt;uml::InstanceValue>(this->getSpecification());&#xA;&#x9;std::shared_ptr&lt;uml::InstanceSpecification> instance = instanceValue->getInstance();&#xA;&#xA;&#x9;std::shared_ptr&lt;Bag&lt;uml::Classifier>> types = instance->getClassifier();&#xA;&#x9;std::shared_ptr&lt;uml::Classifier> myType = types->at(0);&#xA;&#xA;&#x9;DEBUG_MESSAGE(std::cout &lt;&lt; &quot;[evaluate] type = &quot; &lt;&lt; myType->getName() &lt;&lt; std::endl;)&#xA;&#xA;&#x9;std::shared_ptr&lt;fUML::Semantics::Values::Value> value;&#xA;&#x9;&#xA;&#x9;if(std::dynamic_pointer_cast&lt;uml::EnumerationLiteral>(instance) != nullptr) {&#xA;&#x9;&#x9;DEBUG_MESSAGE(std::cout &lt;&lt; &quot;[evaluate] Type is an enumeration.&quot; &lt;&lt; std::endl;)&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::EnumerationValue> enumerationValue(fUML::Semantics::SimpleClassifiers::SimpleClassifiersFactory::eInstance()->createEnumerationValue());&#xA;&#xA;&#x9;&#x9;enumerationValue->setType(std::dynamic_pointer_cast&lt;uml::Enumeration>(myType));&#xA;&#x9;&#x9;enumerationValue->setLiteral(std::dynamic_pointer_cast&lt;uml::EnumerationLiteral>(instance));&#xA;&#xA;&#x9;&#x9;value = enumerationValue;&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::StructuredValue> structuredValue = nullptr;&#xA;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;uml::DataType>(myType) != nullptr){&#xA;&#x9;&#x9;&#x9;DEBUG_MESSAGE(std::cout &lt;&lt; &quot;[evaluate] Type is a data type.&quot; &lt;&lt; std::endl;)&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::SimpleClassifiers::DataValue> dataValue(fUML::Semantics::SimpleClassifiers::SimpleClassifiersFactory::eInstance()->createDataValue());&#xA;&#x9;&#x9;&#x9;dataValue->setType(std::dynamic_pointer_cast&lt;uml::DataType>(myType));&#xA;&#x9;&#x9;&#x9;structuredValue = dataValue;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Object> object = nullptr;&#xA;&#x9;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;uml::Behavior>(myType) != nullptr){&#xA;&#x9;&#x9;&#x9;&#x9;DEBUG_MESSAGE(std::cout &lt;&lt; &quot;[evaluate] Type is a behavior.&quot; &lt;&lt; std::endl;)&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::CommonBehavior::Execution> execution = this->getLocus()->getFactory()->createExecution(std::dynamic_pointer_cast&lt;uml::Behavior>(myType), nullptr);&#xA;&#x9;&#x9;&#x9;&#x9;object = std::dynamic_pointer_cast&lt;fUML::Semantics::StructuredClassifiers::Object>(execution);&#x9;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;DEBUG_MESSAGE(std::cout &lt;&lt; &quot;[evaluate] Type is a class.&quot; &lt;&lt; std::endl;)&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;PSCS::Semantics::StructuredClassifiers::CS_Object> csObject(PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_Object());&#xA;&#x9;&#x9;&#x9;&#x9;object = std::dynamic_pointer_cast&lt;fUML::Semantics::StructuredClassifiers::Object>(csObject);&#xA;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;for(Bag&lt;uml::Classifier>::const_iterator itClass = types->begin(); itClass != types->end(); itClass++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::Classifier> type = (*itClass);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;object->getTypes()->add(std::dynamic_pointer_cast&lt;uml::Class>(type));&#xA;&#x9;&#x9;&#x9;&#x9;}&#x9;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;this->getLocus()->add(object);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;fUML::Semantics::StructuredClassifiers::Reference> reference;&#xA;&#x9;&#x9;&#x9;if(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(object) != nullptr){&#xA;&#x9;&#x9;&#x9;&#x9;reference = fUML::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createReference();&#xA;&#x9;&#x9;&#x9;&#x9;(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Reference>(reference))->setCompositeReferent(std::dynamic_pointer_cast&lt;PSCS::Semantics::StructuredClassifiers::CS_Object>(object));&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else{&#xA;&#x9;&#x9;&#x9;&#x9;reference = fUML::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createReference();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;reference->setReferent(object);&#xA;&#x9;&#x9;&#x9;structuredValue = reference;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;structuredValue->createFeatureValues();&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;DEBUG_MESSAGE(std::cout &lt;&lt; &quot;[evaluate] &quot; &lt;&lt; instance->getSlot->size() &lt;&lt; &quot; slot(s).&quot; &lt;&lt; std::endl;)&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;uml::Slot>> instanceSlots = instance->getSlot(); &#xA;&#x9;&#x9;for(Bag&lt;uml::Slot>::const_iterator itSlot = instanceSlots->begin(); itSlot != instanceSlots->end(); itSlot++){&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::Slot> slot = (*itSlot);&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;fUML::Semantics::Values::Value>> values(new Bag&lt;fUML::Semantics::Values::Value>());&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;DEBUG_MESSAGE(std::cout &lt;&lt; &quot;[evaluate] feature&quot; &lt;&lt; slot->getDefiningFeature->getName() &lt;&lt; &quot;, &quot; &lt;&lt; slot->getValue->size() &lt;&lt; &quot; value(s).&quot; &lt;&lt; std::endl;)&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;std::shared_ptr&lt;Bag&lt;uml::ValueSpecification>> slotValues = slot->getValue();&#xA;&#x9;&#x9;&#x9;for(Bag&lt;uml::ValueSpecification>::const_iterator itValSpec = slotValues->begin(); itValSpec != slotValues->end(); itValSpec++){&#xA;&#x9;&#x9;&#x9;&#x9;std::shared_ptr&lt;uml::ValueSpecification> slotValue = (*itValSpec);&#xA;&#x9;&#x9;&#x9;&#x9;DEBUG_MESSAGE(std::cout &lt;&lt; &quot;[evaluate] Value &quot; &lt;&lt; slotValue->getClass()->getName() &lt;&lt; std::endl;)&#xA;&#x9;&#x9;&#x9;&#x9;values->add(this->getLocus()->getExecutor()->evaluate(slotValue));&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;structuredValue->assignFeatureValue(slot->getDefiningFeature(), values, 0);&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;value = structuredValue;&#xA;&#x9;}&#xA;&#xA;return value;"/>
          </eAnnotations>
        </eOperations>
      </eClassifiers>
    </eSubpackages>
  </eSubpackages>
</ecore:EPackage>
