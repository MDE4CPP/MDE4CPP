[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */]
[module generateStructuralFeatureSetGet('http://www.eclipse.org/emf/2002/Ecore')]

[import ecore4CPP::generator::main::helper /]
[import ecore4CPP::generator::main::generateAttribute /]
[import ecore4CPP::generator::main::generateType /]
[import ecore4CPP::generator::main::generateReference /]
[import ecore4CPP::generator::main::helpers::IDHelper /]


[**
 * eGet Function
*/]
[template public generateeGetDeclaration(aClass : EClass,impl : Boolean) post(trim())]
virtual std::shared_ptr<Any> eGet(int featureID, bool resolve, bool coreType) const [abstractSufix(impl)/];
[/template]

[template public generateeIsSetDeclaration(aClass : EClass,impl : Boolean) post(trim())]
virtual bool internalEIsSet(int featureID) const [abstractSufix(impl)/];
[/template]

[template public generateeSetDeclaration(aClass : EClass,impl : Boolean) post(trim())]
virtual bool eSet(int featureID, const std::shared_ptr<Any>& newValue) [abstractSufix(impl)/];
[/template]

[template public generateeGetImplementation(aClass : EClass) post(trim())]
std::shared_ptr<Any> [aClass.name.toUpperFirst().concat('Impl')/]::eGet(int featureID, bool resolve, bool coreType) const
{
	switch(featureID)
	{
	[for (struct : EStructuralFeature | aClass.eStructuralFeatures->reject(doNotGenerateEStructuralFeature())->asOrderedSet()->sortedBy(name))]
		case [struct.metamodelPackageNameForEstructuralFeture(aClass)/]::[struct.getStaticAttributeIDName()/]:
		[if (struct.eType.oclIsKindOf(EDataType))] [comment no primitive type but can be TemplateType EMap /]
			[if struct.upperBound = 1]
			return eAny([struct.GetterName()/](),[struct.eType.getMetaElementIDName()/],false); //[aClass.getMyClassifierID()/][struct.getFeatureID()/]
			[else]
			return eAny([struct.GetterName()/](),[struct.eType.getMetaElementIDName()/],true); //[aClass.getMyClassifierID()/][struct.getFeatureID()/]
			[/if]
		[else] [comment no primitive Type/]
			[if (struct.upperBound = 1)]
				[if (( (struct.oclAsType(EReference).isBackReference()) and (not struct.hasGetterName()) ))]
		{
			std::shared_ptr<ecore::EObject> returnValue=[struct.GetterName()/]().lock();
			return eEcoreAny(returnValue,[struct.eType.getMetaElementIDName()/]); //[aClass.getMyClassifierID()/][struct.getFeatureID()/]
		}
				[else]
			return eAny([struct.GetterName()/](),[struct.eType.getMetaElementIDName()/],false); //[aClass.getMyClassifierID()/][struct.getFeatureID()/]
				[/if]
			[else]
			return eEcoreContainerAny([struct.GetterName()/](),[struct.eType.getMetaElementIDName()/]); //[aClass.getMyClassifierID()/][struct.getFeatureID()/]
			[/if]
		[/if]
	[/for]
	}
[if (aClass.eSuperTypes->reject(doNotGenerateEClassifier())->isEmpty() and not (aClass.name ='EObject'))]
	return ecore::EObjectImpl::eGet(featureID, resolve, coreType);
[elseif (aClass.eSuperTypes->reject(doNotGenerateEClassifier())->size() = 1)]
	return [ClassWithNamespace(aClass, aClass.eSuperTypes->first())/]Impl::eGet(featureID, resolve, coreType);
[else]
	std::shared_ptr<Any> result;
	[let eClasses : OrderedSet(EClass) = aClass.eSuperTypes->reject(doNotGenerateEClassifier())->asOrderedSet()->sortedBy(name)]		
		[for (sClass : EClass | eClasses)]
	result = [ClassWithNamespace(aClass,sClass)/]Impl::eGet(featureID, resolve, coreType);
			[if (sClass <> eClasses->last())]
	if (result != nullptr && !result->isEmpty())
	{
		return result;
	}
			[/if]
		[/for]
	return result;
	[/let]
[/if]
}
[/template]

[template public generateeIsSetImplementation(aClass : EClass) post(trim())]
bool [aClass.name.toUpperFirst().concat('Impl')/]::internalEIsSet(int featureID) const
{
	switch(featureID)
	{
	[for (struct : EStructuralFeature | aClass.eStructuralFeatures->reject(doNotGenerateEStructuralFeature())->asOrderedSet()->sortedBy(name))]
		case [struct.metamodelPackageNameForEstructuralFeture(aClass)/]::[struct.getStaticAttributeIDName()/]:
			return [struct._generateComparison()/]; //[aClass.getMyClassifierID()/][struct.getFeatureID()/]
	[/for]
	}
	[if (aClass.eSuperTypes->reject(doNotGenerateEClassifier())->isEmpty() and not (aClass.name ='EObject'))]
	return ecore::EObjectImpl::internalEIsSet(featureID);
	[elseif (aClass.eSuperTypes->reject(doNotGenerateEClassifier())->size() = 1)]
	return [ClassWithNamespace(aClass, aClass.eSuperTypes->first())/]Impl::internalEIsSet(featureID);
	[else]
	bool result = false;
		[let eClasses : OrderedSet(EClass) = aClass.eSuperTypes->reject(doNotGenerateEClassifier())->asOrderedSet()->sortedBy(name)]		
			[for (sClass : EClass | eClasses)]
	result = [ClassWithNamespace(aClass,sClass)/]Impl::internalEIsSet(featureID);
				[if (sClass <> eClasses->last())]
	if (result)
	{
		return result;
	}
				[/if]
			[/for]
	return result;
		[/let]
	[/if]
}
[/template]

[template public generateeSetImplementation(aClass : EClass) post(trim())]
bool [aClass.name.toUpperFirst().concat('Impl')/]::eSet(int featureID,  const std::shared_ptr<Any>& newValue)
{
	switch(featureID)
	{
	[for (anEStructuralFeature : EStructuralFeature | aClass.eStructuralFeatures->select(changeable)->reject(doNotGenerateEStructuralFeature())->asOrderedSet()->sortedBy(name))]
		case [anEStructuralFeature.metamodelPackageNameForEstructuralFeture(aClass)/]::[anEStructuralFeature.getStaticAttributeIDName()/]:
		{
		[comment anEStructuralFeature is typed by an EDataType /]
		[if (anEStructuralFeature.eType.oclIsKindOf(EDataType))]
			[comment anEStructuralFeature is a single-instanced value /]
			[if (anEStructuralFeature.upperBound = 1)]
			try
			{
				[anEStructuralFeature.generateStructuralFeatureType(true)/] _[anEStructuralFeature.name/] = newValue->get<[anEStructuralFeature.generateStructuralFeatureType(true)/]>();
				[anEStructuralFeature.SetterName()/](_[anEStructuralFeature.name/]); //[aClass.getMyClassifierID()/][anEStructuralFeature.getFeatureID()/]
			}
			catch(...)
			{
				DEBUG_ERROR("Invalid type stored in 'Any' for feature '[anEStructuralFeature.name/]'. Failed to set feature!")
				return false;
			}
			[comment anEStructuralFeature is a bag value /]
			[else]
			try
			{
				[anEStructuralFeature.generateStructuralFeatureType(true)/] _[anEStructuralFeature.name/]List = newValue->get<[anEStructuralFeature.generateStructuralFeatureType(true)/]>();
				[anEStructuralFeature.generateStructuralFeatureType(true)/] _[anEStructuralFeature.name.toLowerFirst()/] = [anEStructuralFeature.GetterName()/]();
				
				for(const std::shared_ptr<[anEStructuralFeature.eGenericType.generateCppType(false)/]> valueToAdd: *_[anEStructuralFeature.name/]List)
				{
					if (valueToAdd)
					{
						if(!(_[anEStructuralFeature.name.toLowerFirst()/]->includes(valueToAdd)))
						{
							_[anEStructuralFeature.name.toLowerFirst()/]->add(valueToAdd);
						}
						//else, valueToAdd is already present so it won't be added again
					}
					else
					{
						throw "Invalid argument";
					}
				}
			}
			catch(...)
			{
				DEBUG_ERROR("Invalid type stored in 'Any' for feature '[anEStructuralFeature.name/]'. Failed to set feature!")
				return false;
			}
			[/if]
		[comment anEStructuralFeature is typed by an EClass /]
		[else]
			[comment anEStructuralFeature is a single-instanced value /]
			[if (anEStructuralFeature.upperBound = 1)]
			std::shared_ptr<ecore::EcoreAny> ecoreAny = std::dynamic_pointer_cast<ecore::EcoreAny>(newValue);
			if(ecoreAny)
			{
				try
				{
					std::shared_ptr<ecore::EObject> eObject = ecoreAny->getAsEObject();
					std::shared_ptr<[anEStructuralFeature.generateStructuralFeatureType(false)/]> _[anEStructuralFeature.name/] = std::dynamic_pointer_cast<[anEStructuralFeature.generateStructuralFeatureType(false)/]>(eObject);
					if(_[anEStructuralFeature.name/])
					{
						[anEStructuralFeature.SetterName()/](_[anEStructuralFeature.name/]); //[aClass.getMyClassifierID()/][anEStructuralFeature.getFeatureID()/]
					}
					else
					{
						throw "Invalid argument";
					}
				}
				catch(...)
				{
					DEBUG_ERROR("Invalid type stored in 'ecore::ecoreAny' for feature '[anEStructuralFeature.name/]'. Failed to set feature!")
					return false;
				}
			}
			else
			{
				DEBUG_ERROR("Invalid instance of 'ecore::ecoreAny' for feature '[anEStructuralFeature.name/]'. Failed to set feature!")
				return false;
			}
			[comment anEStructuralFeature is a bag value /]
			[else]
			std::shared_ptr<ecore::EcoreContainerAny> ecoreContainerAny = std::dynamic_pointer_cast<ecore::EcoreContainerAny>(newValue);
			if(ecoreContainerAny)
			{
				try
				{
					std::shared_ptr<Bag<ecore::EObject>> eObjectList = ecoreContainerAny->getAsEObjectContainer();
	
					if(eObjectList)
					{
						std::shared_ptr<[anEStructuralFeature.generateStructuralFeatureType(false)/]> _[anEStructuralFeature.name.toLowerFirst()/] = [anEStructuralFeature.GetterName()/]();
	
						for(const std::shared_ptr<ecore::EObject> anEObject: *eObjectList)
						{
							std::shared_ptr<[anEStructuralFeature.eGenericType.generateCppType(false)/]> valueToAdd = std::dynamic_pointer_cast<[anEStructuralFeature.eGenericType.generateCppType(false)/]>(anEObject);
	
							if (valueToAdd)
							{
								if(!(_[anEStructuralFeature.name.toLowerFirst()/]->includes(valueToAdd)))
								{
									_[anEStructuralFeature.name.toLowerFirst()/]->add(valueToAdd);
								}
								//else, valueToAdd is already present so it won't be added again
							}
							else
							{
								throw "Invalid argument";
							}
						}
					}
				}
				catch(...)
				{
					DEBUG_ERROR("Invalid type stored in 'ecore::ecoreContainerAny' for feature '[anEStructuralFeature.name/]'. Failed to set feature!")
					return false;
				}
			}
			else
			{
				DEBUG_ERROR("Invalid instance of 'ecore::ecoreContainerAny' for feature '[anEStructuralFeature.name/]'. Failed to set feature!")
				return false;
			}
			[/if]
		[/if]
		return true;
		}
	[/for]
	}

	[if (aClass.eSuperTypes->reject(doNotGenerateEClassifier())->isEmpty() and not (aClass.name ='EObject'))]
	return ecore::EObjectImpl::eSet(featureID, newValue);
	[elseif (aClass.eSuperTypes->reject(doNotGenerateEClassifier())->size() = 1)]
	return [ClassWithNamespace(aClass, aClass.eSuperTypes->first())/]Impl::eSet(featureID, newValue);
	[else]
	bool result = false;
		[let eClasses : OrderedSet(EClass) = aClass.eSuperTypes->reject(doNotGenerateEClassifier())->asOrderedSet()->sortedBy(name)]		
		[for (sClass : EClass | eClasses)]
	result = [ClassWithNamespace(aClass,sClass)/]Impl::eSet(featureID, newValue);
			[if (sClass <> eClasses->last())]
	if (result)
	{
		return result;
	}
			[/if]
		[/for]
	return result;
		[/let]
	[/if]
}
[/template]

[template private _generateComparison(anStructFeature : EStructuralFeature) ? (oclIsKindOf(EAttribute) and not eType.requiresAny()) post (trim())]
[if (anStructFeature.upperBound <> 1)]
![anStructFeature.GetterName()/]()->empty()
[elseif (eType.oclIsKindOf(EEnum))]
m_[anStructFeature.name/] ![anStructFeature.oclAsType(EAttribute).generateDefaultValue()/];
[else]
[anStructFeature.GetterName()/]() != [anStructFeature.oclAsType(EAttribute).getDefaultValue()/]
[/if]
[/template]

[template private _generateComparison(anStructFeature : EStructuralFeature) ? (not oclIsKindOf(EAttribute) and not eType.requiresAny())]
[anStructFeature.GetterName()/]()[if (anStructFeature.oclIsKindOf(EReference))][if((anStructFeature.oclAsType(EReference).isBackReference()) and (not anStructFeature.hasGetterName()) ) ].lock()[/if][/if] != [anStructFeature.eType.getDefaultValue()/]
[/template]

[template private _generateComparison(anStructFeature : EStructuralFeature) ? (eType.requiresAny())]
[anStructFeature.GetterName()/]() != nullptr[comment TODO what is the default value of Any?/]
[/template]