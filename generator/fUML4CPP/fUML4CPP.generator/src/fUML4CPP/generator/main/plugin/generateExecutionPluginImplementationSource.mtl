[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */]
[module generateExecutionPluginImplementationSource('http://www.eclipse.org/uml2/5.0.0/UML')]

[import fUML4CPP::generator::main::parameterHelper /]
[import fUML4CPP::generator::main::fUMLCollectionHelper /]
[import fUML4CPP::generator::main::fUMLKeywords /]
[import UML4CPP::generator::main::components::generateType /]
[import UML4CPP::generator::main::helpers::generalHelper /]
[import UML4CPP::generator::main::helpers::nameHelper /]
[import UML4CPP::generator::main::helpers::keywords /]
[import UML4CPP::generator::main::profiles::profileHelper /]
[import UML4CPP::generator::main::profiles::uml4CPPProfileHelper /]
[import UML4CPP::generator::main::profiles::strategyHelper /]

[template public generateExecutionPluginImplSource(aPackage : Package) { packageName : String = aPackage.name.concat('ExecPluginImpl'); }]
[file (aPackage.generateNamespacePath(false).concat('Exec/impl/').concat(packageName).concat('.cpp'), false, 'UTF-8')]
#include "[aPackage.generateNamespacePath(false)/]Exec/impl/[packageName/].hpp"

[defineDebugMacro()/]

#include <iostream>
#include "abstractDataTypes/Any.hpp"
#include "abstractDataTypes/Bag.hpp"

[if (aPackage.collectActivitiesOwnedByPackage()->size() > 0)]
[generateMainIncludes()/]
[/if]

using namespace [aPackage.generateNamespace(false)/];

//*********************************
// Constructor / Destructor
//*********************************
[packageName/]::[packageName/]()
{
	initialize();
}

[packageName/]::~[packageName/]()
{
}

std::string [packageName/]::eclipseURI()
{
	return "";
}

std::string [packageName/]::eNAME()
{
	return "[aPackage.name/]Exec";
}

std::string [packageName/]::eNS_URI()
{
	return "[aPackage.URI/]";
}

std::string [packageName/]::eNS_PREFIX()
{
	return "[if(not (aPackage.namespace.oclIsUndefined()))][aPackage.namespace.name/][/if]";
}

std::shared_ptr<ecore::EObject> [packageName/]::create(const std::string& name) const
{		
	return nullptr;
}

std::shared_ptr<ecore::EObject> [packageName/]::create(const std::string& name, std::shared_ptr<ecore::EObject> container, const unsigned int referenceID) const
{
	return nullptr;
}

void [packageName/]::initialize()
{
	[comment initialization of execution locus, factory, executer/]
	[if (collectActivitiesOwnedByPackage()->size() > 0)]
	[generateExecutionPluginInitialization()/]
	[/if]

	m_IsInitialized = true;
}

std::shared_ptr<Any> [packageName/]::executeActivity(std::shared_ptr<uml::Activity> activity, std::shared_ptr<Bag<Any>> parameterList, std::shared_ptr<uml::Element> element)
{
	if(!m_IsInitialized)
	{
		initialize();
	}
[for (act : Activity | aPackage.collectActivitiesOwnedByPackage()->sortedBy(myQualifiedName()))]
	if (activity == [act.generatePackageGetterCall()/])
	{
		[act.generateActivityExecution()/]
	}
[/for]
	return nullptr;
}

[for (anActivity : Activity | aPackage.collectActivitiesOwnedByPackage())]
std::shared_ptr<fUML::Semantics::Activities::ActivityExecution> [packageName/]::get[anActivity.memberName().toUpperFirst()/]ExecutionPrototype()
{
	if(!m_[anActivity.memberName()/]ExecutionPrototype)
	{
		this->create[anActivity.memberName().toUpperFirst()/]ExecutionPrototype();
	}

	return m_[anActivity.memberName()/]ExecutionPrototype;
}

void [packageName/]::create[anActivity.memberName().toUpperFirst()/]ExecutionPrototype()
{
	[anActivity.generateActivityExecutionPrototypeCreatorBody()/]
}
[/for]

[/file]
[/template]

[template private generateMainIncludes(aPackage : Package)]
//fUML includes
#include "fUML/Semantics/Loci/LociFactory.hpp"
#include "fUML/Semantics/Loci/ExecutionFactory.hpp"
#include "fUML/Semantics/CommonBehavior/CommonBehaviorFactory.hpp"
#include "fUML/Semantics/CommonBehavior/ParameterValue.hpp"
#include "fUML/Semantics/Activities/ActivitiesFactory.hpp"
#include "fUML/Semantics/Activities/ActivityExecution.hpp"
#include "fUML/Semantics/Activities/ActivityNodeActivationGroup.hpp"
#include "fUML/Semantics/Actions/ActionsFactory.hpp"
//Test
[for (anIncludeString : String | aPackage.collectActivitiesOwnedByPackage().node->addAll(aPackage.collectActivitiesOwnedByPackage().node->filter(Action).input)->addAll(aPackage.collectActivitiesOwnedByPackage().node->filter(Action).output).generateCorrespondingActivityNodeActivationInclude()->asSet())]
[anIncludeString/]
[/for]
[if (aPackage.getRootPackage().allOwnedElements()->filter(ActivityEdge)->size() > 0)]
#include "fUML/Semantics/Activities/ActivityEdgeInstance.hpp"
[/if]

//Semantic Strategy Includes
[if (aPackage.hasChoiceStrategy())][let choiceStrategy : Class = aPackage.getChoiceStrategy()]
#include "[choiceStrategy.getNearestPackage().generateNamespacePath(true)/]Exec/[choiceStrategy.name.toUpperFirst()/].hpp"
[/let][else]
#include "fUML/Semantics/Loci/FirstChoiceStrategy.hpp"
[/if]
[comment] TODO later
[if (aPackage.hasDispatchStrategy())][let dispatchStrategy : Class = aPackage.getDispatchStrategy()]
#include "[dispatchStrategy.getNearestPackage().generateNamespacePath(true)/]Exec/[dispatchStrategy.name.toUpperFirst()/].hpp"
[/let][else]
#include "PSCS/Semantics/StructuredClassifiers/CS_DispatchOperationOfInterfaceStrategy.hpp"
[/if]
[if (aPackage.hasGetNextEventStrategy())][let getNextEventStrategy : Class = aPackage.getGetNextEventStrategy()]
#include "[getNextEventStrategy.getNearestPackage().generateNamespacePath(true)/]Exec/[getNextEventStrategy.name.toUpperFirst()/].hpp"
[/let][else]
#include "fUML/Semantics/CommonBehavior/FIFOGetNextEventStrategy.hpp"
[/if]
[if (aPackage.hasCS_RequestPropagationStrategy())][let cS_RequestPropagationStrategy : Class = aPackage.getCS_RequestPropagationStrategy()]
#include "[cS_RequestPropagationStrategy.getNearestPackage().generateNamespacePath(true)/]Exec/[cS_RequestPropagationStrategy.name.toUpperFirst()/].hpp"
[/let][else]
#include "PSCS/Semantics/StructuredClassifiers/CS_DefaultRequestPropagationStrategy.hpp"
[/if]
[if (aPackage.hasCS_StructuralFeatureOfInterfaceAccessStrategy())][let cS_StructuralFeatureOfInterfaceAccessStrategy : Class = aPackage.getCS_StructuralFeatureOfInterfaceAccessStrategy()]
#include "[cS_StructuralFeatureOfInterfaceAccessStrategy.getNearestPackage().generateNamespacePath(true)/]Exec/[cS_StructuralFeatureOfInterfaceAccessStrategy.name.toUpperFirst()/].hpp"
[/let][else]
#include "PSCS/Semantics/StructuredClassifiers/CS_NameBased_StructuralFeatureOfInterfaceAccessStrategy.hpp"
[/if]
[if (aPackage.hasCS_ConstructStrategy())][let cS_ConstructStrategy : Class = aPackage.getCS_ConstructStrategy()]
#include "[cS_ConstructStrategy.getNearestPackage().generateNamespacePath(true)/]Exec/[cS_ConstructStrategy.name.toUpperFirst()/].hpp"
[/let][else]
#include "PSCS/Semantics/Actions/CS_DefaultConstructStrategy.hpp"
[/if]
[/comment]

//UML includes
#include "uml/Element.hpp"
#include "uml/Activity.hpp"
#include "uml/Parameter.hpp"
//Test
[for (anIncludeString : String | aPackage.collectActivitiesOwnedByPackage().node->addAll(aPackage.collectActivitiesOwnedByPackage().node->filter(Action).input)->addAll(aPackage.collectActivitiesOwnedByPackage().node->filter(Action).output).generateCorrespondingActivityNodeInclude()->asSet())]
[anIncludeString/]
[/for]
[for (anIncludeString : String | aPackage.collectActivitiesOwnedByPackage().edge.generateCorrespondingActivityEdgeInclude()->asSet())]
[anIncludeString/]
[/for]

//Includes of model-specific Locus, Executor and model package
#include "[aPackage.generateNamespacePath(false)/]/[aPackage.getPackageName()/]Package.hpp"
#include "[aPackage.generateNamespacePath(false)/]Exec/impl/[aPackage.getPackageName()/]LocusImpl.hpp"
#include "[aPackage.generateNamespacePath(false)/]Exec/impl/[aPackage.getPackageName()/]ExecutorImpl.hpp"
[/template]



[template private generateExecutionPluginInitialization(aPackage : Package) {locusName : String = aPackage.generateNamespace(false).sanitize() + 'Locus' ; executorName : String = aPackage.generateNamespace(false).sanitize() + 'Executor' ;}]
//Initialize Locus
std::shared_ptr<[locusName/]Impl> locusImpl(new [locusName/]Impl());
locusImpl->setThisLocusPtr(locusImpl);
m_locus = locusImpl;

//Initialize Executor
std::shared_ptr<[executorName/]Impl> executorImpl(new [executorName/]Impl());
executorImpl->setThisExecutorPtr(executorImpl);
m_executor = executorImpl;

m_locus->setExecutor(m_executor);
m_executor->setLocus(m_locus);

//Initialize ExecutionFactory
std::shared_ptr<fUML::Semantics::Loci::ExecutionFactory> m_factory = fUML::Semantics::Loci::LociFactory::eInstance()->createExecutionFactory_as_factory_in_Locus(m_locus);

[if (aPackage.hasChoiceStrategy())]
[aPackage.getChoiceStrategy().generateStrategyAssignment()/]
[else]
//Assign FirstChoiceStrategy to execution factory
m_factory->assignStrategy(fUML::Semantics::Loci::LociFactory::eInstance()->createFirstChoiceStrategy());
[/if]
[comment] TODO: later
[if (aPackage.hasDispatchStrategy())]
[aPackage.getDispatchStrategy().generateStrategyAssignment()/]
[else]
//assign CS_DispatchOperationOfInterfaceStrategy to execution factory
m_factory->assignStrategy(PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_DispatchOperationOfInterfaceStrategy());
[/if]
[if (aPackage.hasGetNextEventStrategy())]
[aPackage.getGetNextEventStrategy().generateStrategyAssignment()/]
[else]
//assign FIFOGetNextEventStrategy to execution factory
m_factory->assignStrategy(fUML::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createFIFOGetNextEventStrategy());
[/if]
[if (aPackage.hasCS_RequestPropagationStrategy())]
[aPackage.getCS_RequestPropagationStrategy().generateStrategyAssignment()/]
[else]
//assign CS_DefaultRequestPropagationStrategy to execution factory
m_factory->assignStrategy(PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_DefaultRequestPropagationStrategy());
[/if]
[if (aPackage.hasCS_StructuralFeatureOfInterfaceAccessStrategy())]
[aPackage.getCS_StructuralFeatureOfInterfaceAccessStrategy().generateStrategyAssignment()/]
[else]
//assign CS_NameBased_StructuralFeatureOfInterfaceAccessStrategy to execution factory
m_factory->assignStrategy(PSCS::Semantics::StructuredClassifiers::StructuredClassifiersFactory::eInstance()->createCS_NameBased_StructuralFeatureOfInterfaceAccessStrategy());
[/if]
[if (aPackage.hasCS_ConstructStrategy())]
[aPackage.getCS_ConstructStrategy().generateStrategyAssignment()/]
[else]
//assign CS_DefaultConstructStrategy to execution factory
m_factory->assignStrategy(PSCS::Semantics::Actions::ActionsFactory::eInstance()->createCS_DefaultConstructStrategy());
[/if]
[/comment]
[/template]

[template private generateStrategyAssignment(aStrategyClass : Class)]
//assign [aStrategyClass.name.toUpperFirst()/] to execution factory
std::shared_ptr<[aStrategyClass.generateNamespaceName(true)/]> [aStrategyClass.name.toLowerFirst()/](new [aStrategyClass.generateNamespaceName(true)/]());
[aStrategyClass.name.toLowerFirst()/]->setThis[aStrategyClass.name.toUpperFirst()/]Ptr([aStrategyClass.name.toLowerFirst()/]);
m_factory->assignStrategy([aStrategyClass.name.toLowerFirst()/]);
[/template]

[template private generateActivityExecution(anActivity : Activity)]
std::shared_ptr<Bag<fUML::Semantics::CommonBehavior::ParameterValue> > pList(new Bag<fUML::Semantics::CommonBehavior::ParameterValue>());
[for (par : Parameter | anActivity.ownedParameter->select((direction = ParameterDirectionKind::inout) or (direction = ParameterDirectionKind::_in)))]
//Creating ParameterValue for input parameter [anActivity.name/]::[par.name/]
std::shared_ptr<fUML::Semantics::CommonBehavior::ParameterValue> [par.name/]_parameterValue = fUML::Semantics::CommonBehavior::CommonBehaviorFactory::eInstance()->createParameterValue();
[par.name/]_parameterValue->setParameter([par.generatePackageGetterCall()/]); 
[par.name/]_parameterValue->getValues()->add(parameterList->at([par.listNumber(anActivity)/]));
[/for]

//Executing Activity [anActivity.name/]
std::shared_ptr<Bag<fUML::Semantics::CommonBehavior::ParameterValue>> outputParameterValues = m_locus->getExecutor()->execute([anActivity.generatePackageGetterCall()/], [if (anActivity.owner.oclIsKindOf(Class))]element[else]nullptr[/if], pList);

[if (anActivity.ownedParameter->select(p :Parameter | p.direction = ParameterDirectionKind::return)->notEmpty())]
//The activity has a return parameter
[let par : Parameter = anActivity.ownedParameter->select(p :Parameter | p.direction = ParameterDirectionKind::return)->first()]
std::shared_ptr<Any> returnValue;
std::shared_ptr<uml::Parameter> returnParameter = [par.generatePackageGetterCall()/];

for(std::shared_ptr<fUML::Semantics::CommonBehavior::ParameterValue> parameterValue : *outputParameterValues)
{
	if(returnParameter == parameterValue->getParameter())
	{
		returnValue = parameterValue->getValues()->at(0);
		break;
	}
}

return returnValue;
[/let]
[else]
DEBUG_INFO("Activity [anActivity.myQualifiedName()/] does not have any return parameter.")
return nullptr;
[/if]
[/template]

[template private generateExecutionPluginDeinitialization(aPackage : Package)]
//uninitialize execution factory
m_factory->getPrimitiveBehaviorPrototypes()->clear();
m_factory->setLocus(nullptr);

//uninitialize executor
m_executor->setLocus(nullptr);

//uninitialize execution locus
m_locus->setExecutor(nullptr);
m_locus->setFactory(nullptr);
[/template]

[template private generateActivityExecutionPrototypeCreatorBody(anActivity : Activity) {activityExecutionPrototypeMemberName : String = 'm_' + anActivity.memberName() + 'ExecutionPrototype';}]
std::shared_ptr<uml::Activity> activity = [anActivity.generatePackageGetterCall()/];
[activityExecutionPrototypeMemberName/] = fUML::Semantics::Activities::ActivitiesFactory::eInstance()->createActivityExecution();
[activityExecutionPrototypeMemberName/]->getTypes()->push_back(activity);

m_locus->add([activityExecutionPrototypeMemberName/]);
[activityExecutionPrototypeMemberName/]->setLocus(m_locus);

std::shared_ptr<fUML::Semantics::Activities::ActivityNodeActivationGroup> newActivationGroup=fUML::Semantics::Activities::ActivitiesFactory::eInstance()->createActivityNodeActivationGroup_as_activationGroup_in_ActivityExecution([activityExecutionPrototypeMemberName/]);

[for (anActivityNode : ActivityNode | anActivity.node) before('//Create ActivityNodeActivations\n') separator('\n') after('\n')]
	//Create ActivityNodeActivation for [anActivityNode.eClass().name/] '[anActivityNode.metamodelElementName()/]'
	DEBUG_INFO("Creating [anActivityNode.eClass().name/]Activation for [anActivityNode.eClass().name/] '[anActivityNode.metamodelElementName()/]'.")
	std::shared_ptr<[anActivityNode.generateCorrespondingActivityNodeActivationCPPType()/]> [anActivityNode.getActivityNodeActivationVariableName()/] = fUML::Semantics::[if(anActivityNode.oclIsKindOf(Action))]Actions::Actions[else]Activities::Activities[/if]Factory::eInstance()->create[anActivityNode.eClass().name/]Activation();
	[anActivityNode.getActivityNodeActivationVariableName()/]->setNode([anActivityNode.generatePackageGetterCall()/]);
	[anActivityNode.getActivityNodeActivationVariableName()/]->setRunning(false);
	newActivationGroup->addNodeActivation([anActivityNode.getActivityNodeActivationVariableName()/]);
	[if (anActivityNode.oclIsKindOf(Action))]
	[let anAction : Action = anActivityNode.oclAsType(Action)]
		[for (aPin : Pin | anAction.input->addAll(anAction.output))]
		//Create PinActivation for [aPin.eClass().name/] '[anAction.name/]::[aPin.name/]'
		std::shared_ptr<[aPin.generateCorrespondingActivityNodeActivationCPPType()/]> [aPin.getActivityNodeActivationVariableName()/] = fUML::Semantics::Actions::ActionsFactory::eInstance()->create[aPin.eClass().name/]Activation();
		[aPin.getActivityNodeActivationVariableName()/]->setNode([aPin.generatePackageGetterCall()/]);
		[aPin.getActivityNodeActivationVariableName()/]->setRunning(false);
		[anActivityNode.getActivityNodeActivationVariableName()/]->addPinActivation([aPin.getActivityNodeActivationVariableName()/]);
		newActivationGroup->addNodeActivation([aPin.getActivityNodeActivationVariableName()/]);
		[/for]
	[/let]
	[comment TODO /]
	[elseif(anActivityNode.oclIsKindOf(StructuredActivityNode))]
	[comment TODO /]
	[/if]
[/for]
[for (anActivityEdge : ActivityEdge | anActivity.edge) before('//Create ActivityEdgeInstances\n') separator('\n')]
	//Create ActivityEdgeInstance for [anActivityEdge.eClass().name/] '[anActivityEdge.metamodelElementName()/]'
	DEBUG_INFO("Creating EdgeInstance for [anActivityEdge.eClass().name/] '[anActivityEdge.metamodelElementName()/]'.")
	std::shared_ptr<[anActivityEdge.generateCorrespondingActivityEdgeInstanceCPPType()/]> [anActivityEdge.getEdgeInstanceVariableName()/] = fUML::Semantics::Activities::ActivitiesFactory::eInstance()->createActivityEdgeInstance();
	[anActivityEdge.getEdgeInstanceVariableName()/]->setEdge([anActivityEdge.generatePackageGetterCall()/]);
	newActivationGroup->addEdgeInstance([anActivityEdge.getEdgeInstanceVariableName()/]);
	[anActivityEdge.source.getActivityNodeActivationVariableName()/]->addOutgoingEdge([anActivityEdge.getEdgeInstanceVariableName()/]);
	[anActivityEdge.target.getActivityNodeActivationVariableName()/]->addIncomingEdge([anActivityEdge.getEdgeInstanceVariableName()/]);
[/for]
[/template]

[comment]
The following templates return the C++ type of the corresponding ActivityNodeActivation class for a given ActivityNode
[/comment]
[comment ControlNodes /]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(InitialNode))]
fUML::Semantics::Activities::InitialNodeActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(FlowFinalNode))]
fUML::Semantics::Activities::FlowFinalNodeActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(ActivityFinalNode))]
fUML::Semantics::Activities::ActivityFinalNodeActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(ForkNode))]
fUML::Semantics::Activities::ForkNodeActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(JoinNode))]
fUML::Semantics::Activities::JoinNodeActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(MergeNode))]
fUML::Semantics::Activities::MergeNodeActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(DecisionNode))]
fUML::Semantics::Activities::DecisionNodeActivation
[/template]

[comment ObjectNodes /]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(ActivityParameterNode))]
fUML::Semantics::Activities::ActivityParameterNodeActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(CentralBufferNode))]
fUML::Semantics::Activities::CentralBufferNodeActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(DataStoreNode))]
fUML::Semantics::Activities::DataStoreNodeActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(InputPin))]
fUML::Semantics::Actions::InputPinActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(OutputPin))]
fUML::Semantics::Actions::OutputPinActivation
[/template]

[comment Actions /]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(CallOperationAction))]
fUML::Semantics::Actions::CallOperationActionActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(CallBehaviorAction))]
fUML::Semantics::Actions::CallBehaviorActionActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(CreateObjectAction))]
fUML::Semantics::Actions::CreateObjectActionActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(DestroyObjectAction))]
fUML::Semantics::Actions::DestroyObjectActionActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(ReadSelfAction))]
fUML::Semantics::Actions::ReadSelfActionActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(ValueSpecificationAction))]
fUML::Semantics::Actions::ValueSpecificationActionActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(ReadStructuralFeatureAction))]
fUML::Semantics::Actions::ReadStructuralFeatureActionActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(AddStructuralFeatureValueAction))]
fUML::Semantics::Actions::AddStructuralFeatureValueActionActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(RemoveStructuralFeatureValueAction))]
fUML::Semantics::Actions::RemoveStructuralFeatureValueActionActivation
[/template]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(ClearStructuralFeatureAction))]
fUML::Semantics::Actions::ClearStructuralFeatureActionActivation
[/template]

[comment Structured Activity Nodes /]
[template private generateCorrespondingActivityNodeActivationCPPType(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(ExpansionRegion))]
fUML::Semantics::Activities::ExpansionRegionActivation
[/template]

[comment]
The following templates return the include path of the corresponding ActivityNode as well as ActivityNodeActivation class for a given ActivityNode
[/comment]
[template private generateCorrespondingActivityNodeActivationInclude(anActivityNode : ActivityNode)]
#include "[anActivityNode.generateCorrespondingActivityNodeActivationCPPType().substituteAll('::', '/')/].hpp"
[/template]
[template private generateCorrespondingActivityNodeInclude(anActivityNode : ActivityNode)]
#include "uml/[anActivityNode.eClass().name/].hpp"
[/template]

[comment]
The following template returns the C++ type of the corresponding ActivityEdgeInstance class for a given ActivityEdge
[/comment]
[template private generateCorrespondingActivityEdgeInstanceCPPType(anActivityEdge : ActivityEdge)]
fUML::Semantics::Activities::ActivityEdgeInstance
[/template]

[comment]
The following templates return the include path of the corresponding ActivityEdge as well as ActivityEdgeInstance class for a given ActivityEdge
[/comment]
[template private generateCorrespondingActivityEdgeInstanceInclude(anActivityEdge : ActivityEdge)]
#include "[anActivityEdge.generateCorrespondingActivityEdgeInstanceCPPType().substitute('::', '/')/].hpp"
[/template]
[template private generateCorrespondingActivityEdgeInclude(anActivityEdge : ActivityEdge)]
#include "uml/[anActivityEdge.eClass().name/].hpp"
[/template]


[template private getActivityNodeActivationVariableName(anActivityNode : ActivityNode) ? (anActivityNode.oclIsKindOf(Pin))]
[anActivityNode.memberName()/]_[anActivityNode.eClass().name/]Activation
[/template]

[template private getActivityNodeActivationVariableName(anActivityNode : ActivityNode)]
[anActivityNode.memberName()/]_[anActivityNode.eClass().name/]Activation
[/template]

[comment]
[query private getEdgeInstanceVariableName(anActivityEdge : ActivityEdge) : String = ('from_' + anActivityEdge.source.name + '_to_' + anActivityEdge.target.name + '_EdgeInstance').sanitize() /]
[/comment]

[query private getEdgeInstanceVariableName(anActivityEdge : ActivityEdge) : String = anActivityEdge.memberName() + '_EdgeInstance' /]

[query public listNumber(aParameter : Parameter, anActivity : Activity) : Integer =  
	anActivity.ownedParameter->select((direction = ParameterDirectionKind::_out) or (direction = ParameterDirectionKind::_in))->indexOf(aParameter)-1 /]

[query private rejectClassOperationWithoutMethod(anOperation : Operation) : Boolean = (not owner.oclIsKindOf(Interface)) and (method->isEmpty()) and (not isAbstract)/]