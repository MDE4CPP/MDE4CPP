//********************************************************************
//*    
//* Warning: This file was generated by ecore4CPP Generator
//*
//********************************************************************

#ifndef UML_GATE_HPP
#define UML_GATE_HPP


#include <memory>
#include <string>
// forward declarations


//*********************************
// generated Includes
#include <map> // used for Persistence
#include <vector> // used for Persistence
namespace persistence
{
	namespace interfaces
	{
		class XLoadHandler; // used for Persistence
		class XSaveHandler; // used for Persistence
	}
}

namespace uml
{
	class umlFactory;
}

//Forward Declaration for used types 
namespace uml 
{
	class Comment;
	class Dependency;
	class InteractionOperand;
	class Message;
	class Namespace;
	class StringExpression;
}

// namespace macro header include
#include "uml/uml.hpp"

// base class includes
#include "uml/MessageEnd.hpp"

// enum includes
#include "uml/VisibilityKind.hpp"



//*********************************
namespace uml 
{
	/*!
	A Gate is a MessageEnd which serves as a connection point for relating a Message which has a MessageEnd (sendEvent / receiveEvent) outside an InteractionFragment with another Message which has a MessageEnd (receiveEvent / sendEvent)  inside that InteractionFragment.
	<p>From package UML::Interactions.</p>
	*/
	
	class UML_API Gate : virtual public MessageEnd
	{
		public:
 			Gate(const Gate &) {}

		protected:
			Gate(){}

		public:
			virtual std::shared_ptr<ecore::EObject> copy() const = 0;

			//destructor
			virtual ~Gate() {}

			//*********************************
			// Operations
			//*********************************
			/*!
			This query returns the name of the gate, either the explicit name (.name) or the constructed name ('out_" or 'in_' concatenated in front of .message.name) if the explicit name is not present.
			result = (if name->notEmpty() then name->asOrderedSet()->first()
			else  if isActual() or isOutsideCF() 
			  then if isSend() 
			    then 'out_'.concat(self.message.name->asOrderedSet()->first())
			    else 'in_'.concat(self.message.name->asOrderedSet()->first())
			    endif
			  else if isSend()
			    then 'in_'.concat(self.message.name->asOrderedSet()->first())
			    else 'out_'.concat(self.message.name->asOrderedSet()->first())
			    endif
			  endif
			endif)
			<p>From package UML::Interactions.</p>
			*/
			 
			virtual std::string getName() const = 0;
			/*!
			If the Gate is an inside Combined Fragment Gate, this operation returns the InteractionOperand that the opposite end of this Gate is included within.
			result = (if isInsideCF() then
			  let oppEnd : MessageEnd = self.oppositeEnd()->asOrderedSet()->first() in
			    if oppEnd.oclIsKindOf(MessageOccurrenceSpecification)
			    then let oppMOS : MessageOccurrenceSpecification = oppEnd.oclAsType(MessageOccurrenceSpecification)
			        in oppMOS.enclosingOperand->asOrderedSet()->first()
			    else let oppGate : Gate = oppEnd.oclAsType(Gate)
			        in oppGate.combinedFragment.enclosingOperand->asOrderedSet()->first()
			    endif
			  else null
			endif)
			<p>From package UML::Interactions.</p>
			*/
			 
			virtual std::shared_ptr<uml::InteractionOperand> getOperand() = 0;
			/*!
			This query returns true value if this Gate is an actualGate of an InteractionUse.
			result = (interactionUse->notEmpty())
			<p>From package UML::Interactions.</p>
			*/
			 
			virtual bool isActual() = 0;
			/*!
			This query returns true if this Gate is a formalGate of an Interaction.
			result = (interaction->notEmpty())
			<p>From package UML::Interactions.</p>
			*/
			 
			virtual bool isFormal() = 0;
			/*!
			This query returns true if this Gate is attached to the boundary of a CombinedFragment, and its other end (if present) is inside of an InteractionOperator of the same CombinedFragment.
			result = (self.oppositeEnd()-> notEmpty() and combinedFragment->notEmpty() implies
			let oppEnd : MessageEnd = self.oppositeEnd()->asOrderedSet()->first() in
			if oppEnd.oclIsKindOf(MessageOccurrenceSpecification)
			then let oppMOS : MessageOccurrenceSpecification
			= oppEnd.oclAsType(MessageOccurrenceSpecification)
			in combinedFragment = oppMOS.enclosingOperand.combinedFragment
			else let oppGate : Gate = oppEnd.oclAsType(Gate)
			in combinedFragment = oppGate.combinedFragment.enclosingOperand.combinedFragment
			endif)
			<p>From package UML::Interactions.</p>
			*/
			 
			virtual bool isInsideCF() = 0;
			/*!
			This query returns true if this Gate is attached to the boundary of a CombinedFragment, and its other end (if present)  is outside of the same CombinedFragment.
			result = (self.oppositeEnd()-> notEmpty() and combinedFragment->notEmpty() implies
			let oppEnd : MessageEnd = self.oppositeEnd()->asOrderedSet()->first() in
			if oppEnd.oclIsKindOf(MessageOccurrenceSpecification) 
			then let oppMOS : MessageOccurrenceSpecification = oppEnd.oclAsType(MessageOccurrenceSpecification)
			in  self.combinedFragment.enclosingInteraction.oclAsType(InteractionFragment)->asSet()->
			     union(self.combinedFragment.enclosingOperand.oclAsType(InteractionFragment)->asSet()) =
			     oppMOS.enclosingInteraction.oclAsType(InteractionFragment)->asSet()->
			     union(oppMOS.enclosingOperand.oclAsType(InteractionFragment)->asSet())
			else let oppGate : Gate = oppEnd.oclAsType(Gate) 
			in self.combinedFragment.enclosingInteraction.oclAsType(InteractionFragment)->asSet()->
			     union(self.combinedFragment.enclosingOperand.oclAsType(InteractionFragment)->asSet()) =
			     oppGate.combinedFragment.enclosingInteraction.oclAsType(InteractionFragment)->asSet()->
			     union(oppGate.combinedFragment.enclosingOperand.oclAsType(InteractionFragment)->asSet())
			endif)
			<p>From package UML::Interactions.</p>
			*/
			 
			virtual bool isOutsideCF() = 0;
			/*!
			This query returns true if the name of this Gate matches the name of the in parameter Gate, and the messages for the two Gates correspond. The Message for one Gate (say A) corresponds to the Message for another Gate (say B) if (A and B have the same name value) and (if A is a sendEvent then B is a receiveEvent) and (if A is a receiveEvent then B is a sendEvent) and (A and B have the same messageSort value) and (A and B have the same signature value).
			result = (self.getName() = gateToMatch.getName() and 
			self.message.messageSort = gateToMatch.message.messageSort and
			self.message.name = gateToMatch.message.name and
			self.message.sendEvent->includes(self) implies gateToMatch.message.receiveEvent->includes(gateToMatch)  and
			self.message.receiveEvent->includes(self) implies gateToMatch.message.sendEvent->includes(gateToMatch) and
			self.message.signature = gateToMatch.message.signature)
			<p>From package UML::Interactions.</p>
			*/
			 
			virtual bool matches(std::shared_ptr<uml::Gate> gateToMatch) = 0;

			//*********************************
			// Attribute Getters & Setters
			//*********************************

			//*********************************
			// Reference Getters & Setters
			//*********************************

			//*********************************
			// Union Reference Getters
			//*********************************

			//*********************************
			// Container Getter
			//*********************************
			virtual std::shared_ptr<ecore::EObject> eContainer() const = 0; 

			//*********************************
			// Persistence Functions
			//*********************************
			virtual void load(std::shared_ptr<persistence::interfaces::XLoadHandler> loadHandler) = 0;
			virtual void resolveReferences(const int featureID, std::vector<std::shared_ptr<ecore::EObject> > references) = 0;
			virtual void save(std::shared_ptr<persistence::interfaces::XSaveHandler> saveHandler) const = 0;

		protected:
			//*********************************
			// Attribute Members
			//*********************************
			
			//*********************************
			// Reference Members
			//*********************************
	};
}
#endif /* end of include guard: UML_GATE_HPP */
