[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */]
[module generateBuildFile('http://www.eclipse.org/emf/2002/Ecore')]

[import ecore4CPP::generator::main::helper /]

[query public metaModelLibraries(anEPackage : EPackage) : Set(EPackage) = OrderedSet{anEPackage.eAllContents().eClass().ePackage,anEPackage.eAllContents(EClass).eAllSuperTypes.ePackage,anEPackage.eAllContents(EStructuralFeature).eType.ePackage,anEPackage.eAllContents(EParameter).eType.ePackage}->flatten()->sortedBy(name) /]

[template public generateBuildFile(aPackage : EPackage) { packageName : String = aPackage.name; }]
[comment	generate CMakeLists.txt for model libary/]
[file (packageName.concat('/').concat('CMakeLists.txt'), false, 'UTF-8')]
#############################################################################
#																	      #
#		 			CMakeList created by ecore4CPP Generator				  # 
#																	      #
#############################################################################

# C++ project of model [packageName/].ecore, generated by Ecore4CPP

CMAKE_MINIMUM_REQUIRED(VERSION 3.9)

PROJECT([packageName/])

IF(NOT CMAKE_BUILD_TYPE) 
    SET(CMAKE_BUILD_TYPE Debug)
ENDIF(NOT CMAKE_BUILD_TYPE)
SET(CMAKE_DEBUG_POSTFIX d)

SET(CMAKE_CXX_STANDARD 14)

[comment IF("${CMAKE_CXX_COMPILER_ID}" STREQUAL "AppleClang") -> not necessary after removing openmp/]
SET(CMAKE_CXX_FLAGS "-Wall -Wno-overloaded-virtual -Wdeprecated-declarations -fmax-errors=5")
SET(CMAKE_CXX_FLAGS_DEBUG " -Og -ggdb -DNDEBUG -DACTIVITY_DEBUG_ON")
SET(CMAKE_CXX_FLAGS_RELEASE " -O3")

string(REPLACE "\\" "/" MDE4CPP_HOME $ENV{MDE4CPP_HOME})

SET(SOURCE_FILES
	impl/[packageName.toUpperFirst()/]FactoryImpl.cpp
	[packageName.toUpperFirst()/]Factory.cpp
	impl/[packageName.toUpperFirst()/]PackageImpl.cpp
	impl/[packageName.toUpperFirst()/]PackageImpl_Creation.cpp
	impl/[packageName.toUpperFirst()/]PackageImpl_Initialization.cpp
	[packageName.toUpperFirst()/]Package.cpp
	impl/[packageName.toUpperFirst()/]PluginImpl.cpp
	[packageName.toUpperFirst()/]Plugin.cpp
[for (aClass : EClass | aPackage.eAllContents(EClass)->asOrderedSet()->sortedBy(name))]
	impl/[aClass.name.toUpperFirst()/]Impl.cpp
[/for]
[if (packageName='uml')]
	${MDE4CPP_HOME}/application/include/util/util.cpp
	${MDE4CPP_HOME}/application/include/util/registry.cpp
	${MDE4CPP_HOME}/application/include/util/stereotypestorage.cpp
[/if]
	#${MDE4CPP_HOME}/application/include/util/ProfileCallCount.cpp
)

INCLUDE_DIRECTORIES(
	../
	${MDE4CPP_HOME}/application/include
)

# Apple specific stuff
if(APPLE)
  set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -undefined dynamic_lookup")
  set(CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS} -undefined dynamic_lookup")
endif(APPLE)

IF(UNIX AND NOT APPLE)
    # for Linux, BSD, Solaris, Minix
	[generateCMakeFindLibraryCommands('.so', 'bin')/]
ELSEIF(APPLE)
	[generateCMakeFindLibraryCommands('.dylib', 'bin')/]
ELSE()
	[generateCMakeFindLibraryCommands('', 'lib')/]
ENDIF()

ADD_LIBRARY(${PROJECT_NAME} SHARED ${SOURCE_FILES})
SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES PREFIX "")

IF (CMAKE_BUILD_TYPE STREQUAL "Debug")
	[generateLibraryLinking(true)/]
ELSE()
	[generateLibraryLinking(false)/]
ENDIF()

#-----------------------------------------------------
# DELIVERING binaries and header to ${MDE4CPP_HOME}
#-----------------------------------------------------

INSTALL(TARGETS ${PROJECT_NAME}
	RUNTIME DESTINATION ${MDE4CPP_HOME}/application/bin
    LIBRARY DESTINATION ${MDE4CPP_HOME}/application/bin
    ARCHIVE DESTINATION ${MDE4CPP_HOME}/application/lib
)

INSTALL(DIRECTORY . DESTINATION ${MDE4CPP_HOME}/application/include/${PROJECT_NAME}
	FILES_MATCHING PATTERN "*.hpp"
	PATTERN ".cmake" EXCLUDE
)
[/file]

[comment gradle file for build command /]
[file ('../build.gradle', false, 'UTF-8')]
description 'Build task for project: [packageName/]'

task build[packageName.toUpperFirst()/]() {
	group '[packageName/]'
	description 'build [packageName/]'

	dependsOn 'model:generate[packageName.toUpperFirst()/]'
	dependsOn 'src_gen:compile[packageName.toUpperFirst()/]'
[if(aPackage.prepareApplication())]
	dependsOn 'application:compileApplicationFor[packageName.toUpperFirst()/]'
[/if]
[for (pack : EPackage | aPackage.metaModelLibraries()) before ('\n') ? (not(pack.name = aPackage.name))]
	dependsOn getRootProject().getTasksByName('build[pack.name.toUpperFirst()/]', true)
[/for]
}

tasks.getByPath('src_gen:compile[packageName.toUpperFirst()/]').mustRunAfter tasks.getByPath('model:generate[packageName.toUpperFirst()/]')
[/file]

[comment gradle file for generate command /]
[file ('../model/build.gradle', false, 'UTF-8')]
plugins {
	id "tui.sse.mde4cpp.mde4cpp-generate-plugin" version "0.4"
}

description 'Generate task for project: [packageName/]'

task generate[packageName.toUpperFirst()/](type: tui.sse.mde4cpp.MDE4CPPGenerate) {
	group '[packageName/]'
	description 'generate C++ code of [packageName/].ecore model'
	
	modelFilePath = file('.' + File.separator + '[packageName/].ecore')

	relatedModels = ['['/][aPackage.generateRelatedModelNameList()/][']'/]
}
[/file]

[comment gradle file for compile command of model /]
[file ('build.gradle', false, 'UTF-8')]
plugins {
	id "tui.sse.mde4cpp.mde4cpp-compile-plugin" version "0.4"
}

description 'Compile task for project: [packageName/]'

task compile[packageName.toUpperFirst()/](type: tui.sse.mde4cpp.MDE4CPPCompile) {
	group '[packageName/]'
	description 'compile [packageName/]'

	projectFolder = file('.' + File.separator + '[packageName/]')

	inputs.files(fileTree('.') {
        exclude '[packageName/]/.cmake/**'
    })
	if(!file('.' + File.separator + '[packageName/]' + File.separator + '.cmake' + File.separator).exists()) {
		outputs.upToDateWhen { false }
	}
	outputs.file file(System.getenv('MDE4CPP_HOME') + File.separator + 'application' + File.separator + 'bin' + File.separator + '[packageName/].dll')
	outputs.file file(System.getenv('MDE4CPP_HOME') + File.separator + 'application' + File.separator + 'bin' + File.separator + '[packageName/]d.dll')
	outputs.dir file(System.getenv('MDE4CPP_HOME') + File.separator + 'application' + File.separator + 'include' + File.separator + '[packageName/]')

	// dependency to basic interfaces
	dependsOn getRootProject().getTasksByName('deliverBasicInterfaces', true) 
	outputs.dir file(System.getenv('MDE4CPP_HOME') + File.separator + 'application' + File.separator + 'include' + File.separator + 'abstractDataTypes')
	outputs.dir file(System.getenv('MDE4CPP_HOME') + File.separator + 'application' + File.separator + 'include' + File.separator + 'persistence' + File.separator + 'interfaces')
	outputs.dir file(System.getenv('MDE4CPP_HOME') + File.separator + 'application' + File.separator + 'include' + File.separator + 'pluginFramework')
	outputs.dir file(System.getenv('MDE4CPP_HOME') + File.separator + 'application' + File.separator + 'include' + File.separator + 'util')
[for (pack : EPackage | aPackage.metaModelLibraries()) ? (not(pack.name = aPackage.name))]

	// dependency to model '[pack.name/]'
	def [pack.name/] = getRootProject().getTasksByName('compile[pack.name.toUpperFirst()/]', true)
	dependsOn [pack.name/]
	inputs.files([pack.name/].outputs)
[/for]
}

task clean {
	doFirst {
		def cmakeFolder = file('.' + File.separator + '[packageName/]' + File.separator + '.cmake' + File.separator)
		if(cmakeFolder.exists()) {
    		delete cmakeFolder.absolutePath
   			println 'deleting folder ' + cmakeFolder.absolutePath
		}
	}
}
[/file]
[/template]

[template private generateCMakeFindLibraryCommands(aPackage : EPackage, ending : String, folderName : String)]
IF (CMAKE_BUILD_TYPE STREQUAL "Debug")
	[generateCMakeFindLibraryCommand(aPackage, ending, folderName, true)/]
ELSE()
	[generateCMakeFindLibraryCommand(aPackage, ending, folderName, false)/]
ENDIF()
[/template]

[query private libraryVariableNameSuffix(debugMode : Boolean) : String = if (debugMode) then 'DEBUG' else 'RELEASE' endif/]
[query private libraryNameSuffix(debugMode : Boolean) : String = if (debugMode) then 'd' else '' endif/]
[query private buildModeCMakeProperty(debugMode : Boolean) : String = if (debugMode) then 'debug' else 'optimized' endif/]

[template private generateCMakeFindLibraryCommand(aPackage : EPackage, ending : String, folderName : String, debugMode : Boolean)]
[for (pack : EPackage | aPackage.metaModelLibraries()) ? (not(pack.name = aPackage.name))]
FIND_LIBRARY([pack.name.toUpperCase()/]_[libraryVariableNameSuffix(debugMode)/] [pack.name/][libraryNameSuffix(debugMode)/][ending/] ${MDE4CPP_HOME}/application/[folderName/])
[/for]
[/template]

[template private generateLibraryLinking(aPackage : EPackage, debugMode : Boolean)]
TARGET_LINK_LIBRARIES(${PROJECT_NAME}
[for (pack : EPackage | aPackage.metaModelLibraries()) ? (not(pack.name = aPackage.name))]
	[buildModeCMakeProperty(debugMode)/] ${[pack.name.toUpperCase()/]_[libraryVariableNameSuffix(debugMode)/]}
[/for]
)
[/template]

[template private generateRelatedModelNameList(aPackage : EPackage) post (trim())]
[for (pack : EPackage | aPackage.metaModelLibraries()) separator (', ') ? (not(pack.name = aPackage.name))]
'[pack.name/]'[/for]
[/template]