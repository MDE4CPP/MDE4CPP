[comment encoding = UTF-8 /]
[module generatePackageGlobalFunctionsSource('http://www.eclipse.org/uml2/5.0.0/UML')]

[import UML4CPP::generator::main::helpers::nameHelper /]
[import UML4CPP::generator::main::helpers::generalHelper /]
[import UML4CPP::generator::main::helpers::collectionHelper /]
[import UML4CPP::generator::main::components::generateType /]
[import UML4CPP::generator::main::components::generateParameter /]
[import UML4CPP::generator::main::components::generateOpaqueBehavior /]
[import UML4CPP::generator::main::helpers::keywords /]

[template public generatePackageGlobalFunctionsSource(aPackage : Package)]
[file (aPackage.generateNamespacePath(false) + '/_GlobalFunctions.cpp', false, 'UTF-8')]
#include "_GlobalFunctions.hpp"
#include <iostream>

[aPackage.generatePackageGlobalFunctionsIncludeStatements()/]

[let opaqueBehaviorsForGlobalFunctions : Set(OpaqueBehavior) = aPackage.collectOpaqueBehaviorsForGlobalFunctionsOfPackage()]
[for (aNamespace : Namespace | opaqueBehaviorsForGlobalFunctions.namespace->asSet()->sortedBy(name)) separator('\n') after('\n')]
	[for (anOpaqueBehavior : OpaqueBehavior | opaqueBehaviorsForGlobalFunctions->select(oB : OpaqueBehavior | oB.namespace = aNamespace))]
[anOpaqueBehavior.generateCppType()/] [if (aNamespace.oclIsKindOf(Classifier))][aNamespace.oclAsType(Classifier).generateNamespaceName(true)/]::[elseif(aNamespace.oclIsKindOf(Package))][aNamespace.oclAsType(Package).generateNamespace(true)/]::[else]/*ERROR: Invalid namespace for OpaqueBehavior: [aNamespace.myNamespaceName()/]*/ [/if][anOpaqueBehavior.name/]([for (passedParameter : Parameter | anOpaqueBehavior.ownedParameter->select(p :Parameter | not (p.direction = ParameterDirectionKind::return))) separator (',')][passedParameter.generateCppType(true)/] [passedParameter.name/][/for])
{
		[if (anOpaqueBehavior.ownedParameter->select(p : Parameter | p.direction = ParameterDirectionKind::return)->notEmpty())]
		[let returnParameter : Parameter = anOpaqueBehavior.ownedParameter->select(p : Parameter | p.direction = ParameterDirectionKind::return)->first()]
	[anOpaqueBehavior.generateCppType()/] [if(returnParameter.name.oclIsUndefined())][returnParameter.myQualifiedName()/][else][returnParameter.name/][/if][if (returnParameter.upper <> 1)](new Bag<[returnParameter.type.generateCppRawType(true)/]>())[/if][if(returnParameter.type.isPrimitive())] = [returnParameter.genDefault()/][/if];
		[/let]
		[/if]

	[anOpaqueBehavior.generateMethodImplementationFromOpaqueBehavior()/]

		[if (anOpaqueBehavior.ownedParameter->select(p :Parameter | p.direction = ParameterDirectionKind::return)->notEmpty())]
		[let returnParameter : Parameter = anOpaqueBehavior.ownedParameter->select(p : Parameter | p.direction = ParameterDirectionKind::return)->first()]
	return [if(returnParameter.name.oclIsUndefined())][returnParameter.myQualifiedName()/][else][returnParameter.name/][/if];
		[/let]
		[/if]
}
	[/for]
[/for]

std::shared_ptr<Any> [aPackage.generateNamespace(true)/]::invoke(std::shared_ptr<uml::OpaqueBehavior> _opaqueBehavior, std::shared_ptr<Bag<Any>> inputArguments, std::shared_ptr<Bag<Any>> outputArguments)
{
[if (not aPackage.collectOpaqueBehaviorsForGlobalFunctionsOfPackage()->isEmpty())]
	unsigned long uID = _opaqueBehavior->_getID();

	switch(uID)
	{
	[for (anOpaqueBehavior : OpaqueBehavior | aPackage.collectOpaqueBehaviorsForGlobalFunctionsOfPackage())]
		case [anOpaqueBehavior.getNearestPackage().generateNamespace(true)/]::[anOpaqueBehavior.getNearestPackage().getPackageName()/]Package::[anOpaqueBehavior.getMemberName().toUpperCase()/]:
		{
		[comment Retrieve all parameter values for parameters with in or inout direction /]
		[let inputParameterList : OrderedSet(Parameter) = anOpaqueBehavior.ownedParameter->select((direction = ParameterDirectionKind::_in) or (direction = ParameterDirectionKind::inout))]
		[for (anInputParameter : Parameter | inputParameterList) before('\t\t//Retrieve input parameters\n') after('\n')]
			//Retrieve [anInputParameter.direction/] parameter '[anInputParameter.name/]'
			std::shared_ptr<Any> any[anInputParameter.name.toUpperFirst()/] =  inputArguments->at([inputParameterList->indexOf(anInputParameter) - 1/]);
			[anInputParameter.generateCppType(false)/] [anInputParameter.name/];
			[comment anInputParameter has no type. i.e. is of any type, ergo no transformation required /]
			[if (anInputParameter.type.oclIsUndefined())]
			[anInputParameter.name/] = any[anInputParameter.name.toUpperFirst()/];
			[comment anInputParameter is typed by a PrimitiveType or Enumeration /]
			[elseif (anInputParameter.type.oclIsKindOf(PrimitiveType) or anInputParameter.type.oclIsKindOf(Enumeration))]
			try
			{
				[anInputParameter.name/] = any[anInputParameter.name.toUpperFirst()/]->get<[anInputParameter.generateCppType(false)/]>();
			}
			catch(...)
			{
				DEBUG_ERROR("Invalid type stored in 'Any' for parameter '[anInputParameter.name/]'. Failed to invoke operation '[anInputParameter.operation.name/]'!")
				return nullptr;
			}
			[comment anInputParameter is typed by a Class or Interface /]
			[else]
				[comment anInputParameter is a single-instanced value /]
				[if (anInputParameter.upper = 1)]
			{
				std::shared_ptr<uml::UMLAny> umlAny = std::dynamic_pointer_cast<uml::UMLAny>(any[anInputParameter.name.toUpperFirst()/]);
				if(umlAny)
				{
					try
					{
						std::shared_ptr<uml::Element> _temp = umlAny->getAsElement();
						[anInputParameter.name/] = std::dynamic_pointer_cast<[anInputParameter.type.generateCppRawType(true)/]>(_temp);
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'uml::UMLAny' for parameter '[anInputParameter.name/]'. Failed to invoke operation '[anInputParameter.operation.name/]'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'uml::UMLAny' for parameter '[anInputParameter.name/]'. Failed to invoke operation '[anInputParameter.operation.name/]'!")
					return nullptr;
				}
			}
				[comment anInputParameter is a bag value /]
				[else]
			{
				std::shared_ptr<uml::UMLContainerAny> umlContainerAny = std::dynamic_pointer_cast<uml::UMLContainerAny>(any[anInputParameter.name.toUpperFirst()/]);
				if(umlContainerAny)
				{
					try
					{
						std::shared_ptr<Bag<uml::Element>> elementList = umlContainerAny->getAsElementContainer();
					
						if(elementList)
						{
							[anInputParameter.name/] = std::make_shared<Bag<[anInputParameter.type.generateCppRawType(true)/]>>();
							for(const std::shared_ptr<uml::Element> anElement: *elementList)
							{
								std::shared_ptr<[anInputParameter.type.generateCppRawType(true)/]> _temp = std::dynamic_pointer_cast<[anInputParameter.type.generateCppRawType(true)/]>(anElement);
								[anInputParameter.name/]->add(_temp);
							}
						}
					}
					catch(...)
					{
						DEBUG_ERROR("Invalid type stored in 'uml::UMLContainerAny' for parameter '[anInputParameter.name/]'. Failed to invoke operation '[anInputParameter.operation.name/]'!")
						return nullptr;
					}
				}
				else
				{
					DEBUG_ERROR("Invalid instance of 'uml::UMLContainerAny' for parameter '[anInputParameter.name/]'. Failed to invoke operation '[anInputParameter.operation.name/]'!")
					return nullptr;
				}
			}
				[/if]
			[/if]
		[/for]
		[/let]
		[comment Create all parameter values for parameters with out direction /]
		[let outputParameterList : OrderedSet(Parameter) = anOpaqueBehavior.ownedParameter->select(direction = ParameterDirectionKind::out)]
		[for (anOutputParameter : Parameter | outputParameterList) before('\t\t//Create output parameters\n') after('\n')]
			//Create [anOutputParameter.direction/] parameter '[anOutputParameter.name/]'
			[anOutputParameter.generateCppType(false)/] [anOutputParameter.name/];
		[/for]
		[/let]
		[comment Create return parameter (if there is any) and invoke the operation /]
			//Invoke method
		[let returnParameterList : OrderedSet(Parameter) = anOpaqueBehavior.ownedParameter->select(p :Parameter | (p.direction = ParameterDirectionKind::return))]
			[comment anOpaqueBehavior has a return parameter /]
			[if(not returnParameterList->isEmpty() and not returnParameterList->first().oclIsInvalid())]
			[let returnParameter : Parameter = returnParameterList->first()]
			[returnParameter.generateCppType(false)/] [returnParameter.name/] = [if (anOpaqueBehavior.namespace.oclIsKindOf(Classifier))][anOpaqueBehavior.namespace.oclAsType(Classifier).generateNamespaceName(true)/]::[elseif(anOpaqueBehavior.namespace.oclIsKindOf(Package))][anOpaqueBehavior.namespace.oclAsType(Package).generateNamespace(true)/]::[else]/*ERROR: Invalid namespace for OpaqueBehavior: [anOpaqueBehavior.namespace.myNamespaceName()/]*/ [/if][anOpaqueBehavior.name/]([for (inputParameter : Parameter | anOpaqueBehavior.ownedParameter->select(direction = ParameterDirectionKind::_in or direction = ParameterDirectionKind::inout)) separator (', ')][inputParameter.name/][/for]);
				[comment returnParameter has no type, i.e. is of any type, ergo can be passed right away /]
				[if (returnParameter.type.oclIsUndefined())]
			std::shared_ptr<Any> returnArgument = [returnParameter.name/];
				[comment returnParameter is typed by a PrimitiveType or Enumeration /]
				[elseif (returnParameter.type.oclIsKindOf(PrimitiveType) or returnParameter.type.oclIsKindOf(Enumeration))]
			std::shared_ptr<Any> returnArgument = eAny([returnParameter.name/], [returnParameter.type.oclAsType(Classifier).generateStaticClassifierIDAccess()/], [if(returnParameter.upper = 1)]false[else]true[/if]);
				[comment returnParameter is typed by a Class or Interface /]
				[else]
			std::shared_ptr<Any> returnArgument = [if(returnParameter.upper = 1)]eUMLAny[else]eUMLContainerAny[/if]([returnParameter.name/], [returnParameter.type.oclAsType(Classifier).generateStaticClassifierIDAccess()/]);
				[/if]
			[/let]
			[comment anOpaqueBehavior has no return parameter /]
			[else]
		[if (anOpaqueBehavior.namespace.oclIsKindOf(Classifier))][anOpaqueBehavior.namespace.oclAsType(Classifier).generateNamespaceName(true)/]::[elseif(anOpaqueBehavior.namespace.oclIsKindOf(Package))][anOpaqueBehavior.namespace.oclAsType(Package).generateNamespace(true)/]::[else]/*ERROR: Invalid namespace for OpaqueBehavior: [anOpaqueBehavior.namespace.myNamespaceName()/]*/ [/if][anOpaqueBehavior.name/]([for (inputParameter : Parameter | anOpaqueBehavior.ownedParameter->select(not (direction = ParameterDirectionKind::return))) separator (', ')][inputParameter.name/][/for]);
			std::shared_ptr<Any> returnArgument = eAny(nullptr, -1, false);
			[/if]
		[/let]
	
		[comment Add all parameter values for parameters with inout or out direction the outputArguments /]
		[let outputParameterList : OrderedSet(Parameter) = anOpaqueBehavior.ownedParameter->select((direction = ParameterDirectionKind::inout) or (direction = ParameterDirectionKind::out))]
		[for (anOutputParameter : Parameter | outputParameterList) before('\t\t//Store output parameters\n') after('\n')]
			[comment For inout parameters, we can reuse the previously retrieved Any-object IF the stored value is of non-primitive type (i.e. stored as a shared pointer /]
			//Store [anOutputParameter.direction/] parameter '[anOutputParameter.name/]'
			[if (anOutputParameter.direction = ParameterDirectionKind::inout)]
				[comment Only IF the inout parameter is primitive-typed, the new value (i.e. after operation invocation) has to be re-stored /]
				[if (anOutputParameter.type.oclIsKindOf(PrimitiveType) or anOutputParameter.type.oclIsKindOf(Enumeration))]
			any[anOutputParameter.name.toUpperFirst()/] = eAny([anOutputParameter.name/], [anOutputParameter.type.oclAsType(Classifier).generateStaticClassifierIDAccess()/], [if(anOutputParameter.upper = 1)]false[else]true[/if]); 
				[/if]
			[comment For out parameters, create a new Any-object to store the value /]
			[else]
				[comment anOutputParameter has no type, i.e. is of any type, ergo can be passed right away /]
				[if (anOutputParameter.type.oclIsUndefined())]
			std::shared_ptr<Any> any[anOutputParameter.name.toUpperFirst()/] = [anOutputParameter.name/];
				[comment anOutputParameter is typed by a PrimitiveType or Enumeration /]
				[elseif (anOutputParameter.type.oclIsKindOf(PrimitiveType) or anOutputParameter.type.oclIsKindOf(Enumeration))]
			std::shared_ptr<Any> any[anOutputParameter.name.toUpperFirst()/] = eAny([anOutputParameter.name/], [anOutputParameter.type.oclAsType(Classifier).generateStaticClassifierIDAccess()/], [if(anOutputParameter.upper = 1)]false[else]true[/if]);
				[comment anOutputParameter is typed by a Class or Interface /]
				[else]
			std::shared_ptr<Any> any[anOutputParameter.name.toUpperFirst()/] = [if(anOutputParameter.upper = 1)]eUMLAny[else]eUMLContainerAny[/if]([anOutputParameter.name/], [anOutputParameter.type.oclAsType(Classifier).generateStaticClassifierIDAccess()/]);
				[/if]
			[/if]
			outputArguments->add(any[anOutputParameter.name.toUpperFirst()/]);
		[/for]
		[/let]
			return returnArgument;
		}
	[/for]
	}
[/if]
	return nullptr;
}
[/let]
[/file]
[/template]

[template private generatePackageGlobalFunctionsIncludeStatements(aPackage : Package) post(trim())]
[let opaqueBehaviorsForGlobalFunctionsOfPackage : Set(OpaqueBehavior) = aPackage.collectOpaqueBehaviorsForGlobalFunctionsOfPackage()]
[let includeStatements : Bag(String) = aPackage.collectOpaqueBehaviorsForGlobalFunctionsOfPackage().collectOpaqueBehaviorIncludeStrings()->flatten()]
[comment Output all include statements /]
[collectAbstractDataTypes_Any_IncludeString()/]
[collectAbstractDataTypes_Bag_IncludeString()/]
[collectUML_OpaqueBehavior_IncludeString()/]
[collectPackageInterface_IncludeString(aPackage)/]
[opaqueBehaviorsForGlobalFunctionsOfPackage.ownedParameter.type._package->excluding(aPackage)->asOrderedSet().collectPackageInterface_IncludeString()/]
[for (includeStatement : String | includeStatements->asOrderedSet())]
[includeStatement/]
[/for]
[/let]
[/let]
[/template]

[query private collectAbstractDataTypes_Any_IncludeString(arg : OclAny) : String = '#include "uml/UMLAny.hpp"\n#include"uml/UMLContainerAny.hpp"' /]
[query private collectAbstractDataTypes_Bag_IncludeString(arg : OclAny) : String = '#include "abstractDataTypes/Bag.hpp"' /]
[query private collectUML_OpaqueBehavior_IncludeString(arg : OclAny) : String = '#include "uml/OpaqueBehavior.hpp"\n#include "uml/FunctionBehavior.hpp"' /]
[query private collectPackageInterface_IncludeString(aPackage : Package) : String = '#include "' + (if(aPackage.name = 'PrimitiveTypes') then ('types/typesPackage.hpp"') else (aPackage.generateNamespacePath(false) + '/' + aPackage.name + 'Package.hpp"') endif) /]